<!DOCTYPE HTML>
<html lang="en" class="ayu" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Foundry Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
                <meta name="twitter:card" content="summary">
                <meta property="og:title" content="Foundry Book" />
                <meta property="og:description" content="A book on all things Foundry" />
                <meta name="twitter:image:src" content="https://raw.githubusercontent.com/foundry-rs/book/master/theme/card.png" />

        <meta name="description" content="A book on all things Foundry">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="src/static/custom.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('ayu')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">介绍</a></li><li class="chapter-item expanded affix "><li class="part-title">入门</li><li class="chapter-item expanded "><a href="getting-started/installation.html"><strong aria-hidden="true">1.</strong> 安装</a></li><li class="chapter-item expanded "><a href="getting-started/first-steps.html"><strong aria-hidden="true">2.</strong> Foundry 的第一步</a></li><li class="chapter-item expanded affix "><li class="part-title">项目</li><li class="chapter-item expanded "><a href="projects/creating-a-new-project.html"><strong aria-hidden="true">3.</strong> 创建一个新项目</a></li><li class="chapter-item expanded "><a href="projects/working-on-an-existing-project.html"><strong aria-hidden="true">4.</strong> 在现有项目上工作</a></li><li class="chapter-item expanded "><a href="projects/clone-a-verified-contract.html"><strong aria-hidden="true">5.</strong> 在链上克隆已验证的合约</a></li><li class="chapter-item expanded "><a href="projects/dependencies.html"><strong aria-hidden="true">6.</strong> 依赖项</a></li><li class="chapter-item expanded "><a href="projects/soldeer.html"><strong aria-hidden="true">7.</strong> Soldeer</a></li><li class="chapter-item expanded "><a href="projects/project-layout.html"><strong aria-hidden="true">8.</strong> 项目布局</a></li><li class="chapter-item expanded affix "><li class="part-title">Forge 概述</li><li class="chapter-item expanded "><a href="forge/index.html"><strong aria-hidden="true">9.</strong> Forge 概述</a></li><li class="chapter-item expanded "><a href="forge/tests.html"><strong aria-hidden="true">10.</strong> 测试</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="forge/writing-tests.html"><strong aria-hidden="true">10.1.</strong> 编写测试</a></li><li class="chapter-item "><a href="forge/cheatcodes.html"><strong aria-hidden="true">10.2.</strong> 作弊码</a></li><li class="chapter-item "><a href="forge/forge-std.html"><strong aria-hidden="true">10.3.</strong> Forge 标准库概述</a></li><li class="chapter-item "><a href="forge/traces.html"><strong aria-hidden="true">10.4.</strong> 理解追踪</a></li><li class="chapter-item "><a href="forge/fork-testing.html"><strong aria-hidden="true">10.5.</strong> 分叉测试</a></li></ol></li><li class="chapter-item expanded "><a href="forge/advanced-testing.html"><strong aria-hidden="true">11.</strong> 高级测试</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="forge/fuzz-testing.html"><strong aria-hidden="true">11.1.</strong> 模糊测试</a></li><li class="chapter-item "><a href="forge/invariant-testing.html"><strong aria-hidden="true">11.2.</strong> 不变性测试</a></li><li class="chapter-item "><a href="forge/differential-ffi-testing.html"><strong aria-hidden="true">11.3.</strong> 差异测试</a></li></ol></li><li class="chapter-item expanded "><a href="forge/deploying.html"><strong aria-hidden="true">12.</strong> 部署和验证</a></li><li class="chapter-item expanded "><a href="forge/gas-tracking.html"><strong aria-hidden="true">13.</strong> Gas 跟踪</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="forge/gas-reports.html"><strong aria-hidden="true">13.1.</strong> Gas 报告</a></li><li class="chapter-item "><a href="forge/gas-snapshots.html"><strong aria-hidden="true">13.2.</strong> Gas 快照</a></li></ol></li><li class="chapter-item expanded "><a href="forge/debugger.html"><strong aria-hidden="true">14.</strong> 调试器</a></li><li class="chapter-item expanded affix "><li class="part-title">Cast 概述</li><li class="chapter-item expanded "><a href="cast/index.html"><strong aria-hidden="true">15.</strong> Cast 概述</a></li><li class="chapter-item expanded affix "><li class="part-title">Anvil 概述</li><li class="chapter-item expanded "><a href="anvil/index.html"><strong aria-hidden="true">16.</strong> Anvil 概述</a></li><li class="chapter-item expanded affix "><li class="part-title">Chisel 概述</li><li class="chapter-item expanded "><a href="chisel/index.html"><strong aria-hidden="true">17.</strong> Chisel 概述</a></li><li class="chapter-item expanded affix "><li class="part-title">配置</li><li class="chapter-item expanded "><a href="config/index.html"><strong aria-hidden="true">18.</strong> 使用 foundry.toml 配置</a></li><li class="chapter-item expanded "><a href="config/continuous-integration.html"><strong aria-hidden="true">19.</strong> 持续集成</a></li><li class="chapter-item expanded "><a href="config/vscode.html"><strong aria-hidden="true">20.</strong> 与 VSCode 集成</a></li><li class="chapter-item expanded "><a href="config/shell-autocompletion.html"><strong aria-hidden="true">21.</strong> Shell 自动补全</a></li><li class="chapter-item expanded "><a href="config/static-analyzers.html"><strong aria-hidden="true">22.</strong> 静态分析器</a></li><li class="chapter-item expanded "><a href="config/hardhat.html"><strong aria-hidden="true">23.</strong> 与 Hardhat 集成</a></li><li class="chapter-item expanded "><a href="config/vyper.html"><strong aria-hidden="true">24.</strong> Vyper 支持</a></li><li class="chapter-item expanded affix "><li class="part-title">教程</li><li class="chapter-item expanded "><a href="tutorials/best-practices.html"><strong aria-hidden="true">25.</strong> 最佳实践</a></li><li class="chapter-item expanded "><a href="tutorials/solmate-nft.html"><strong aria-hidden="true">26.</strong> 使用 Solmate 创建 NFT</a></li><li class="chapter-item expanded "><a href="tutorials/foundry-docker.html"><strong aria-hidden="true">27.</strong> Docker 和 Foundry</a></li><li class="chapter-item expanded "><a href="tutorials/testing-eip712.html"><strong aria-hidden="true">28.</strong> 测试 EIP-712 签名</a></li><li class="chapter-item expanded "><a href="tutorials/solidity-scripting.html"><strong aria-hidden="true">29.</strong> Solidity 脚本</a></li><li class="chapter-item expanded "><a href="tutorials/create2-tutorial.html"><strong aria-hidden="true">30.</strong> 使用 CREATE2 进行确定性部署</a></li><li class="chapter-item expanded "><a href="tutorials/forking-mainnet-with-cast-anvil.html"><strong aria-hidden="true">31.</strong> 使用 Cast 和 Anvil 分叉主网</a></li><li class="chapter-item expanded "><a href="tutorials/learn-foundry.html"><strong aria-hidden="true">32.</strong> 学习 Foundry 视频</a></li><li class="chapter-item expanded affix "><li class="part-title">附录</li><li class="chapter-item expanded "><a href="faq.html"><strong aria-hidden="true">33.</strong> 常见问题</a></li><li class="chapter-item expanded "><a href="contributing.html"><strong aria-hidden="true">34.</strong> 帮助我们改进 Foundry</a></li><li class="chapter-item expanded "><a href="reference/index.html"><strong aria-hidden="true">35.</strong> 参考</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="reference/cli/index.html"><strong aria-hidden="true">35.1.</strong> CLI 参考</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="reference/cli/forge.html"><strong aria-hidden="true">35.1.1.</strong> forge</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="reference/cli/forge/bind.html"><strong aria-hidden="true">35.1.1.1.</strong> forge bind</a></li><li class="chapter-item "><a href="reference/cli/forge/build.html"><strong aria-hidden="true">35.1.1.2.</strong> forge build</a></li><li class="chapter-item "><a href="reference/cli/forge/cache.html"><strong aria-hidden="true">35.1.1.3.</strong> forge cache</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="reference/cli/forge/cache/clean.html"><strong aria-hidden="true">35.1.1.3.1.</strong> forge cache clean</a></li><li class="chapter-item "><a href="reference/cli/forge/cache/ls.html"><strong aria-hidden="true">35.1.1.3.2.</strong> forge cache ls</a></li></ol></li><li class="chapter-item "><a href="reference/cli/forge/clean.html"><strong aria-hidden="true">35.1.1.4.</strong> forge clean</a></li><li class="chapter-item "><a href="reference/cli/forge/clone.html"><strong aria-hidden="true">35.1.1.5.</strong> forge clone</a></li><li class="chapter-item "><a href="reference/cli/forge/completions.html"><strong aria-hidden="true">35.1.1.6.</strong> forge completions</a></li><li class="chapter-item "><a href="reference/cli/forge/config.html"><strong aria-hidden="true">35.1.1.7.</strong> forge config</a></li><li class="chapter-item "><a href="reference/cli/forge/coverage.html"><strong aria-hidden="true">35.1.1.8.</strong> forge coverage</a></li><li class="chapter-item "><a href="reference/cli/forge/create.html"><strong aria-hidden="true">35.1.1.9.</strong> forge create</a></li><li class="chapter-item "><a href="reference/cli/forge/debug.html"><strong aria-hidden="true">35.1.1.10.</strong> forge debug</a></li><li class="chapter-item "><a href="reference/cli/forge/doc.html"><strong aria-hidden="true">35.1.1.11.</strong> forge doc</a></li><li class="chapter-item "><a href="reference/cli/forge/flatten.html"><strong aria-hidden="true">35.1.1.12.</strong> forge flatten</a></li><li class="chapter-item "><a href="reference/cli/forge/fmt.html"><strong aria-hidden="true">35.1.1.13.</strong> forge fmt</a></li><li class="chapter-item "><a href="reference/cli/forge/geiger.html"><strong aria-hidden="true">35.1.1.14.</strong> forge geiger</a></li><li class="chapter-item "><a href="reference/cli/forge/generate.html"><strong aria-hidden="true">35.1.1.15.</strong> forge generate</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="reference/cli/forge/generate/test.html"><strong aria-hidden="true">35.1.1.15.1.</strong> forge generate test</a></li></ol></li><li class="chapter-item "><a href="reference/cli/forge/generate-fig-spec.html"><strong aria-hidden="true">35.1.1.16.</strong> forge generate-fig-spec</a></li><li class="chapter-item "><a href="reference/cli/forge/init.html"><strong aria-hidden="true">35.1.1.17.</strong> forge init</a></li><li class="chapter-item "><a href="reference/cli/forge/inspect.html"><strong aria-hidden="true">35.1.1.18.</strong> forge inspect</a></li><li class="chapter-item "><a href="reference/cli/forge/install.html"><strong aria-hidden="true">35.1.1.19.</strong> forge install</a></li><li class="chapter-item "><a href="reference/cli/forge/remappings.html"><strong aria-hidden="true">35.1.1.20.</strong> forge remappings</a></li><li class="chapter-item "><a href="reference/cli/forge/remove.html"><strong aria-hidden="true">35.1.1.21.</strong> forge remove</a></li><li class="chapter-item "><a href="reference/cli/forge/script.html"><strong aria-hidden="true">35.1.1.22.</strong> forge script</a></li><li class="chapter-item "><a href="reference/cli/forge/selectors.html"><strong aria-hidden="true">35.1.1.23.</strong> forge selectors</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="reference/cli/forge/selectors/collision.html"><strong aria-hidden="true">35.1.1.23.1.</strong> forge selectors collision</a></li><li class="chapter-item "><a href="reference/cli/forge/selectors/upload.html"><strong aria-hidden="true">35.1.1.23.2.</strong> forge selectors upload</a></li><li class="chapter-item "><a href="reference/cli/forge/selectors/list.html"><strong aria-hidden="true">35.1.1.23.3.</strong> forge selectors list</a></li></ol></li><li class="chapter-item "><a href="reference/cli/forge/snapshot.html"><strong aria-hidden="true">35.1.1.24.</strong> forge snapshot</a></li><li class="chapter-item "><a href="reference/cli/forge/soldeer.html"><strong aria-hidden="true">35.1.1.25.</strong> forge soldeer</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="reference/cli/forge/soldeer/install.html"><strong aria-hidden="true">35.1.1.25.1.</strong> forge soldeer install</a></li><li class="chapter-item "><a href="reference/cli/forge/soldeer/update.html"><strong aria-hidden="true">35.1.1.25.2.</strong> forge soldeer update</a></li><li class="chapter-item "><a href="reference/cli/forge/soldeer/login.html"><strong aria-hidden="true">35.1.1.25.3.</strong> forge soldeer login</a></li><li class="chapter-item "><a href="reference/cli/forge/soldeer/push.html"><strong aria-hidden="true">35.1.1.25.4.</strong> forge soldeer push</a></li><li class="chapter-item "><a href="reference/cli/forge/soldeer/version-dry-run.html"><strong aria-hidden="true">35.1.1.25.5.</strong> forge soldeer version-dry-run</a></li></ol></li><li class="chapter-item "><a href="reference/cli/forge/test.html"><strong aria-hidden="true">35.1.1.26.</strong> forge test</a></li><li class="chapter-item "><a href="reference/cli/forge/tree.html"><strong aria-hidden="true">35.1.1.27.</strong> forge tree</a></li><li class="chapter-item "><a href="reference/cli/forge/update.html"><strong aria-hidden="true">35.1.1.28.</strong> forge update</a></li><li class="chapter-item "><a href="reference/cli/forge/verify-bytecode.html"><strong aria-hidden="true">35.1.1.29.</strong> forge verify-bytecode</a></li><li class="chapter-item "><a href="reference/cli/forge/verify-check.html"><strong aria-hidden="true">35.1.1.30.</strong> forge verify-check</a></li><li class="chapter-item "><a href="reference/cli/forge/verify-contract.html"><strong aria-hidden="true">35.1.1.31.</strong> forge verify-contract</a></li></ol></li><li class="chapter-item "><a href="reference/cli/cast.html"><strong aria-hidden="true">35.1.2.</strong> cast</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="reference/cli/cast/4byte.html"><strong aria-hidden="true">35.1.2.1.</strong> cast 4byte</a></li><li class="chapter-item "><a href="reference/cli/cast/4byte-decode.html"><strong aria-hidden="true">35.1.2.2.</strong> cast 4byte-decode</a></li><li class="chapter-item "><a href="reference/cli/cast/4byte-event.html"><strong aria-hidden="true">35.1.2.3.</strong> cast 4byte-event</a></li><li class="chapter-item "><a href="reference/cli/cast/abi-decode.html"><strong aria-hidden="true">35.1.2.4.</strong> cast abi-decode</a></li><li class="chapter-item "><a href="reference/cli/cast/abi-encode.html"><strong aria-hidden="true">35.1.2.5.</strong> cast abi-encode</a></li><li class="chapter-item "><a href="reference/cli/cast/access-list.html"><strong aria-hidden="true">35.1.2.6.</strong> cast access-list</a></li><li class="chapter-item "><a href="reference/cli/cast/address-zero.html"><strong aria-hidden="true">35.1.2.7.</strong> cast address-zero</a></li><li class="chapter-item "><a href="reference/cli/cast/admin.html"><strong aria-hidden="true">35.1.2.8.</strong> cast admin</a></li><li class="chapter-item "><a href="reference/cli/cast/age.html"><strong aria-hidden="true">35.1.2.9.</strong> cast age</a></li><li class="chapter-item "><a href="reference/cli/cast/balance.html"><strong aria-hidden="true">35.1.2.10.</strong> cast balance</a></li><li class="chapter-item "><a href="reference/cli/cast/base-fee.html"><strong aria-hidden="true">35.1.2.11.</strong> cast base-fee</a></li><li class="chapter-item "><a href="reference/cli/cast/bind.html"><strong aria-hidden="true">35.1.2.12.</strong> cast bind</a></li><li class="chapter-item "><a href="reference/cli/cast/block.html"><strong aria-hidden="true">35.1.2.13.</strong> cast block</a></li><li class="chapter-item "><a href="reference/cli/cast/block-number.html"><strong aria-hidden="true">35.1.2.14.</strong> cast block-number</a></li><li class="chapter-item "><a href="reference/cli/cast/call.html"><strong aria-hidden="true">35.1.2.15.</strong> cast call</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="reference/cli/cast/call/--create.html"><strong aria-hidden="true">35.1.2.15.1.</strong> cast call --create</a></li></ol></li><li class="chapter-item "><a href="reference/cli/cast/calldata.html"><strong aria-hidden="true">35.1.2.16.</strong> cast calldata</a></li><li class="chapter-item "><a href="reference/cli/cast/calldata-decode.html"><strong aria-hidden="true">35.1.2.17.</strong> cast calldata-decode</a></li><li class="chapter-item "><a href="reference/cli/cast/chain.html"><strong aria-hidden="true">35.1.2.18.</strong> cast chain</a></li><li class="chapter-item "><a href="reference/cli/cast/chain-id.html"><strong aria-hidden="true">35.1.2.19.</strong> cast chain-id</a></li><li class="chapter-item "><a href="reference/cli/cast/client.html"><strong aria-hidden="true">35.1.2.20.</strong> cast client</a></li><li class="chapter-item "><a href="reference/cli/cast/code.html"><strong aria-hidden="true">35.1.2.21.</strong> cast code</a></li><li class="chapter-item "><a href="reference/cli/cast/codesize.html"><strong aria-hidden="true">35.1.2.22.</strong> cast codesize</a></li><li class="chapter-item "><a href="reference/cli/cast/completions.html"><strong aria-hidden="true">35.1.2.23.</strong> cast completions</a></li><li class="chapter-item "><a href="reference/cli/cast/compute-address.html"><strong aria-hidden="true">35.1.2.24.</strong> cast compute-address</a></li><li class="chapter-item "><a href="reference/cli/cast/concat-hex.html"><strong aria-hidden="true">35.1.2.25.</strong> cast concat-hex</a></li><li class="chapter-item "><a href="reference/cli/cast/create2.html"><strong aria-hidden="true">35.1.2.26.</strong> cast create2</a></li><li class="chapter-item "><a href="reference/cli/cast/decode-transaction.html"><strong aria-hidden="true">35.1.2.27.</strong> cast decode-transaction</a></li><li class="chapter-item "><a href="reference/cli/cast/disassemble.html"><strong aria-hidden="true">35.1.2.28.</strong> cast disassemble</a></li><li class="chapter-item "><a href="reference/cli/cast/estimate.html"><strong aria-hidden="true">35.1.2.29.</strong> cast estimate</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="reference/cli/cast/estimate/--create.html"><strong aria-hidden="true">35.1.2.29.1.</strong> cast estimate --create</a></li></ol></li><li class="chapter-item "><a href="reference/cli/cast/etherscan-source.html"><strong aria-hidden="true">35.1.2.30.</strong> cast etherscan-source</a></li><li class="chapter-item "><a href="reference/cli/cast/find-block.html"><strong aria-hidden="true">35.1.2.31.</strong> cast find-block</a></li><li class="chapter-item "><a href="reference/cli/cast/format-bytes32-string.html"><strong aria-hidden="true">35.1.2.32.</strong> cast format-bytes32-string</a></li><li class="chapter-item "><a href="reference/cli/cast/from-bin.html"><strong aria-hidden="true">35.1.2.33.</strong> cast from-bin</a></li><li class="chapter-item "><a href="reference/cli/cast/from-fixed-point.html"><strong aria-hidden="true">35.1.2.34.</strong> cast from-fixed-point</a></li><li class="chapter-item "><a href="reference/cli/cast/from-rlp.html"><strong aria-hidden="true">35.1.2.35.</strong> cast from-rlp</a></li><li class="chapter-item "><a href="reference/cli/cast/from-utf8.html"><strong aria-hidden="true">35.1.2.36.</strong> cast from-utf8</a></li><li class="chapter-item "><a href="reference/cli/cast/from-wei.html"><strong aria-hidden="true">35.1.2.37.</strong> cast from-wei</a></li><li class="chapter-item "><a href="reference/cli/cast/gas-price.html"><strong aria-hidden="true">35.1.2.38.</strong> cast gas-price</a></li><li class="chapter-item "><a href="reference/cli/cast/generate-fig-spec.html"><strong aria-hidden="true">35.1.2.39.</strong> cast generate-fig-spec</a></li><li class="chapter-item "><a href="reference/cli/cast/hash-zero.html"><strong aria-hidden="true">35.1.2.40.</strong> cast hash-zero</a></li><li class="chapter-item "><a href="reference/cli/cast/implementation.html"><strong aria-hidden="true">35.1.2.41.</strong> cast implementation</a></li><li class="chapter-item "><a href="reference/cli/cast/index.html"><strong aria-hidden="true">35.1.2.42.</strong> cast index</a></li><li class="chapter-item "><a href="reference/cli/cast/index-erc7201.html"><strong aria-hidden="true">35.1.2.43.</strong> cast index-erc7201</a></li><li class="chapter-item "><a href="reference/cli/cast/interface.html"><strong aria-hidden="true">35.1.2.44.</strong> cast interface</a></li><li class="chapter-item "><a href="reference/cli/cast/keccak.html"><strong aria-hidden="true">35.1.2.45.</strong> cast keccak</a></li><li class="chapter-item "><a href="reference/cli/cast/logs.html"><strong aria-hidden="true">35.1.2.46.</strong> cast logs</a></li><li class="chapter-item "><a href="reference/cli/cast/lookup-address.html"><strong aria-hidden="true">35.1.2.47.</strong> cast lookup-address</a></li><li class="chapter-item "><a href="reference/cli/cast/max-int.html"><strong aria-hidden="true">35.1.2.48.</strong> cast max-int</a></li><li class="chapter-item "><a href="reference/cli/cast/max-uint.html"><strong aria-hidden="true">35.1.2.49.</strong> cast max-uint</a></li><li class="chapter-item "><a href="reference/cli/cast/min-int.html"><strong aria-hidden="true">35.1.2.50.</strong> cast min-int</a></li><li class="chapter-item "><a href="reference/cli/cast/mktx.html"><strong aria-hidden="true">35.1.2.51.</strong> cast mktx</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="reference/cli/cast/mktx/--create.html"><strong aria-hidden="true">35.1.2.51.1.</strong> cast mktx --create</a></li></ol></li><li class="chapter-item "><a href="reference/cli/cast/namehash.html"><strong aria-hidden="true">35.1.2.52.</strong> cast namehash</a></li><li class="chapter-item "><a href="reference/cli/cast/nonce.html"><strong aria-hidden="true">35.1.2.53.</strong> cast nonce</a></li><li class="chapter-item "><a href="reference/cli/cast/parse-bytes32-address.html"><strong aria-hidden="true">35.1.2.54.</strong> cast parse-bytes32-address</a></li><li class="chapter-item "><a href="reference/cli/cast/parse-bytes32-string.html"><strong aria-hidden="true">35.1.2.55.</strong> cast parse-bytes32-string</a></li><li class="chapter-item "><a href="reference/cli/cast/pretty-calldata.html"><strong aria-hidden="true">35.1.2.56.</strong> cast pretty-calldata</a></li><li class="chapter-item "><a href="reference/cli/cast/proof.html"><strong aria-hidden="true">35.1.2.57.</strong> cast proof</a></li><li class="chapter-item "><a href="reference/cli/cast/publish.html"><strong aria-hidden="true">35.1.2.58.</strong> cast publish</a></li><li class="chapter-item "><a href="reference/cli/cast/receipt.html"><strong aria-hidden="true">35.1.2.59.</strong> cast receipt</a></li><li class="chapter-item "><a href="reference/cli/cast/resolve-name.html"><strong aria-hidden="true">35.1.2.60.</strong> cast resolve-name</a></li><li class="chapter-item "><a href="reference/cli/cast/rpc.html"><strong aria-hidden="true">35.1.2.61.</strong> cast rpc</a></li><li class="chapter-item "><a href="reference/cli/cast/run.html"><strong aria-hidden="true">35.1.2.62.</strong> cast run</a></li><li class="chapter-item "><a href="reference/cli/cast/selectors.html"><strong aria-hidden="true">35.1.2.63.</strong> cast selectors</a></li><li class="chapter-item "><a href="reference/cli/cast/send.html"><strong aria-hidden="true">35.1.2.64.</strong> cast send</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="reference/cli/cast/send/--create.html"><strong aria-hidden="true">35.1.2.64.1.</strong> cast send --create</a></li></ol></li><li class="chapter-item "><a href="reference/cli/cast/shl.html"><strong aria-hidden="true">35.1.2.65.</strong> cast shl</a></li><li class="chapter-item "><a href="reference/cli/cast/shr.html"><strong aria-hidden="true">35.1.2.66.</strong> cast shr</a></li><li class="chapter-item "><a href="reference/cli/cast/sig.html"><strong aria-hidden="true">35.1.2.67.</strong> cast sig</a></li><li class="chapter-item "><a href="reference/cli/cast/sig-event.html"><strong aria-hidden="true">35.1.2.68.</strong> cast sig-event</a></li><li class="chapter-item "><a href="reference/cli/cast/storage.html"><strong aria-hidden="true">35.1.2.69.</strong> cast storage</a></li><li class="chapter-item "><a href="reference/cli/cast/to-ascii.html"><strong aria-hidden="true">35.1.2.70.</strong> cast to-ascii</a></li><li class="chapter-item "><a href="reference/cli/cast/to-base.html"><strong aria-hidden="true">35.1.2.71.</strong> cast to-base</a></li><li class="chapter-item "><a href="reference/cli/cast/to-bytes32.html"><strong aria-hidden="true">35.1.2.72.</strong> cast to-bytes32</a></li><li class="chapter-item "><a href="reference/cli/cast/to-check-sum-address.html"><strong aria-hidden="true">35.1.2.73.</strong> cast to-check-sum-address</a></li><li class="chapter-item "><a href="reference/cli/cast/to-dec.html"><strong aria-hidden="true">35.1.2.74.</strong> cast to-dec</a></li><li class="chapter-item "><a href="reference/cli/cast/to-fixed-point.html"><strong aria-hidden="true">35.1.2.75.</strong> cast to-fixed-point</a></li><li class="chapter-item "><a href="reference/cli/cast/to-hex.html"><strong aria-hidden="true">35.1.2.76.</strong> cast to-hex</a></li><li class="chapter-item "><a href="reference/cli/cast/to-hexdata.html"><strong aria-hidden="true">35.1.2.77.</strong> cast to-hexdata</a></li><li class="chapter-item "><a href="reference/cli/cast/to-int256.html"><strong aria-hidden="true">35.1.2.78.</strong> cast to-int256</a></li><li class="chapter-item "><a href="reference/cli/cast/to-rlp.html"><strong aria-hidden="true">35.1.2.79.</strong> cast to-rlp</a></li><li class="chapter-item "><a href="reference/cli/cast/to-uint256.html"><strong aria-hidden="true">35.1.2.80.</strong> cast to-uint256</a></li><li class="chapter-item "><a href="reference/cli/cast/to-unit.html"><strong aria-hidden="true">35.1.2.81.</strong> cast to-unit</a></li><li class="chapter-item "><a href="reference/cli/cast/to-utf8.html"><strong aria-hidden="true">35.1.2.82.</strong> cast to-utf8</a></li><li class="chapter-item "><a href="reference/cli/cast/to-wei.html"><strong aria-hidden="true">35.1.2.83.</strong> cast to-wei</a></li><li class="chapter-item "><a href="reference/cli/cast/tx.html"><strong aria-hidden="true">35.1.2.84.</strong> cast tx</a></li><li class="chapter-item "><a href="reference/cli/cast/upload-signature.html"><strong aria-hidden="true">35.1.2.85.</strong> cast upload-signature</a></li><li class="chapter-item "><a href="reference/cli/cast/wallet.html"><strong aria-hidden="true">35.1.2.86.</strong> cast wallet</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="reference/cli/cast/wallet/new.html"><strong aria-hidden="true">35.1.2.86.1.</strong> cast wallet new</a></li><li class="chapter-item "><a href="reference/cli/cast/wallet/new-mnemonic.html"><strong aria-hidden="true">35.1.2.86.2.</strong> cast wallet new-mnemonic</a></li><li class="chapter-item "><a href="reference/cli/cast/wallet/vanity.html"><strong aria-hidden="true">35.1.2.86.3.</strong> cast wallet vanity</a></li><li class="chapter-item "><a href="reference/cli/cast/wallet/address.html"><strong aria-hidden="true">35.1.2.86.4.</strong> cast wallet address</a></li><li class="chapter-item "><a href="reference/cli/cast/wallet/sign.html"><strong aria-hidden="true">35.1.2.86.5.</strong> cast wallet sign</a></li><li class="chapter-item "><a href="reference/cli/cast/wallet/verify.html"><strong aria-hidden="true">35.1.2.86.6.</strong> cast wallet verify</a></li><li class="chapter-item "><a href="reference/cli/cast/wallet/import.html"><strong aria-hidden="true">35.1.2.86.7.</strong> cast wallet import</a></li><li class="chapter-item "><a href="reference/cli/cast/wallet/list.html"><strong aria-hidden="true">35.1.2.86.8.</strong> cast wallet list</a></li><li class="chapter-item "><a href="reference/cli/cast/wallet/private-key.html"><strong aria-hidden="true">35.1.2.86.9.</strong> cast wallet private-key</a></li><li class="chapter-item "><a href="reference/cli/cast/wallet/decrypt-keystore.html"><strong aria-hidden="true">35.1.2.86.10.</strong> cast wallet decrypt-keystore</a></li></ol></li></ol></li><li class="chapter-item "><a href="reference/cli/anvil.html"><strong aria-hidden="true">35.1.3.</strong> anvil</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="reference/cli/anvil/completions.html"><strong aria-hidden="true">35.1.3.1.</strong> anvil completions</a></li><li class="chapter-item "><a href="reference/cli/anvil/generate-fig-spec.html"><strong aria-hidden="true">35.1.3.2.</strong> anvil generate-fig-spec</a></li></ol></li><li class="chapter-item "><a href="reference/cli/chisel.html"><strong aria-hidden="true">35.1.4.</strong> chisel</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="reference/cli/chisel/list.html"><strong aria-hidden="true">35.1.4.1.</strong> chisel list</a></li><li class="chapter-item "><a href="reference/cli/chisel/load.html"><strong aria-hidden="true">35.1.4.2.</strong> chisel load</a></li><li class="chapter-item "><a href="reference/cli/chisel/view.html"><strong aria-hidden="true">35.1.4.3.</strong> chisel view</a></li><li class="chapter-item "><a href="reference/cli/chisel/clear-cache.html"><strong aria-hidden="true">35.1.4.4.</strong> chisel clear-cache</a></li></ol></li></ol></li><li class="chapter-item "><a href="reference/forge/index.html"><strong aria-hidden="true">35.2.</strong> forge 命令</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="reference/forge/general-commands.html"><strong aria-hidden="true">35.2.1.</strong> 通用命令</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="reference/forge/forge.html"><strong aria-hidden="true">35.2.1.1.</strong> forge</a></li><li class="chapter-item "><a href="reference/forge/forge-help.html"><strong aria-hidden="true">35.2.1.2.</strong> forge help</a></li><li class="chapter-item "><a href="reference/forge/forge-completions.html"><strong aria-hidden="true">35.2.1.3.</strong> forge completions</a></li></ol></li><li class="chapter-item "><a href="reference/forge/project-commands.html"><strong aria-hidden="true">35.2.2.</strong> 项目命令</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="reference/forge/forge-init.html"><strong aria-hidden="true">35.2.2.1.</strong> forge init</a></li><li class="chapter-item "><a href="reference/forge/forge-clone.html"><strong aria-hidden="true">35.2.2.2.</strong> forge clone</a></li><li class="chapter-item "><a href="reference/forge/forge-install.html"><strong aria-hidden="true">35.2.2.3.</strong> forge install</a></li><li class="chapter-item "><a href="reference/forge/forge-update.html"><strong aria-hidden="true">35.2.2.4.</strong> forge update</a></li><li class="chapter-item "><a href="reference/forge/forge-remove.html"><strong aria-hidden="true">35.2.2.5.</strong> forge remove</a></li><li class="chapter-item "><a href="reference/forge/forge-config.html"><strong aria-hidden="true">35.2.2.6.</strong> forge config</a></li><li class="chapter-item "><a href="reference/forge/forge-remappings.html"><strong aria-hidden="true">35.2.2.7.</strong> forge remappings</a></li><li class="chapter-item "><a href="reference/forge/forge-tree.html"><strong aria-hidden="true">35.2.2.8.</strong> forge tree</a></li><li class="chapter-item "><a href="reference/forge/forge-geiger.html"><strong aria-hidden="true">35.2.2.9.</strong> forge geiger</a></li></ol></li><li class="chapter-item "><a href="reference/forge/build-commands.html"><strong aria-hidden="true">35.2.3.</strong> 构建命令</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="reference/forge/forge-build.html"><strong aria-hidden="true">35.2.3.1.</strong> forge build</a></li><li class="chapter-item "><a href="reference/forge/forge-clean.html"><strong aria-hidden="true">35.2.3.2.</strong> forge clean</a></li><li class="chapter-item "><a href="reference/forge/forge-inspect.html"><strong aria-hidden="true">35.2.3.3.</strong> forge inspect</a></li></ol></li><li class="chapter-item "><a href="reference/forge/test-commands.html"><strong aria-hidden="true">35.2.4.</strong> 测试命令</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="reference/forge/forge-test.html"><strong aria-hidden="true">35.2.4.1.</strong> forge test</a></li><li class="chapter-item "><a href="reference/forge/forge-snapshot.html"><strong aria-hidden="true">35.2.4.2.</strong> forge snapshot</a></li><li class="chapter-item "><a href="reference/forge/forge-coverage.html"><strong aria-hidden="true">35.2.4.3.</strong> forge coverage</a></li></ol></li><li class="chapter-item "><a href="reference/forge/deploy-commands.html"><strong aria-hidden="true">35.2.5.</strong> 部署命令</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="reference/forge/forge-create.html"><strong aria-hidden="true">35.2.5.1.</strong> forge create</a></li><li class="chapter-item "><a href="reference/forge/forge-verify-contract.html"><strong aria-hidden="true">35.2.5.2.</strong> forge verify-contract</a></li><li class="chapter-item "><a href="reference/forge/forge-verify-check.html"><strong aria-hidden="true">35.2.5.3.</strong> forge verify-check</a></li><li class="chapter-item "><a href="reference/forge/forge-flatten.html"><strong aria-hidden="true">35.2.5.4.</strong> forge flatten</a></li></ol></li><li class="chapter-item "><a href="reference/forge/utility-commands.html"><strong aria-hidden="true">35.2.6.</strong> 实用命令</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="reference/forge/forge-debug.html"><strong aria-hidden="true">35.2.6.1.</strong> forge debug</a></li><li class="chapter-item "><a href="reference/forge/forge-bind.html"><strong aria-hidden="true">35.2.6.2.</strong> forge bind</a></li><li class="chapter-item "><a href="reference/forge/forge-cache.html"><strong aria-hidden="true">35.2.6.3.</strong> forge cache</a></li><li class="chapter-item "><a href="reference/forge/forge-cache-clean.html"><strong aria-hidden="true">35.2.6.4.</strong> forge cache clean</a></li><li class="chapter-item "><a href="reference/forge/forge-cache-ls.html"><strong aria-hidden="true">35.2.6.5.</strong> forge cache ls</a></li><li class="chapter-item "><a href="reference/forge/forge-script.html"><strong aria-hidden="true">35.2.6.6.</strong> forge script</a></li><li class="chapter-item "><a href="reference/forge/forge-upload-selectors.html"><strong aria-hidden="true">35.2.6.7.</strong> forge upload-selectors</a></li><li class="chapter-item "><a href="reference/forge/forge-doc.html"><strong aria-hidden="true">35.2.6.8.</strong> forge doc</a></li></ol></li></ol></li><li class="chapter-item "><a href="reference/cast/index.html"><strong aria-hidden="true">35.3.</strong> cast 命令</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="reference/cast/general-commands.html"><strong aria-hidden="true">35.3.1.</strong> 通用命令</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="reference/cast/cast.html"><strong aria-hidden="true">35.3.1.1.</strong> cast</a></li><li class="chapter-item "><a href="reference/cast/cast-help.html"><strong aria-hidden="true">35.3.1.2.</strong> cast help</a></li><li class="chapter-item "><a href="reference/cast/cast-completions.html"><strong aria-hidden="true">35.3.1.3.</strong> cast completions</a></li></ol></li><li class="chapter-item "><a href="reference/cast/chain-commands.html"><strong aria-hidden="true">35.3.2.</strong> 链命令</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="reference/cast/cast-chain-id.html"><strong aria-hidden="true">35.3.2.1.</strong> cast chain-id</a></li><li class="chapter-item "><a href="reference/cast/cast-chain.html"><strong aria-hidden="true">35.3.2.2.</strong> cast chain</a></li><li class="chapter-item "><a href="reference/cast/cast-client.html"><strong aria-hidden="true">35.3.2.3.</strong> cast client</a></li></ol></li><li class="chapter-item "><a href="reference/cast/transaction-commands.html"><strong aria-hidden="true">35.3.3.</strong> 交易命令</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="reference/cast/cast-publish.html"><strong aria-hidden="true">35.3.3.1.</strong> cast publish</a></li><li class="chapter-item "><a href="reference/cast/cast-receipt.html"><strong aria-hidden="true">35.3.3.2.</strong> cast receipt</a></li><li class="chapter-item "><a href="reference/cast/cast-send.html"><strong aria-hidden="true">35.3.3.3.</strong> cast send</a></li><li class="chapter-item "><a href="reference/cast/cast-mktx.html"><strong aria-hidden="true">35.3.3.4.</strong> cast mktx</a></li><li class="chapter-item "><a href="reference/cast/cast-call.html"><strong aria-hidden="true">35.3.3.5.</strong> cast call</a></li><li class="chapter-item "><a href="reference/cast/cast-rpc.html"><strong aria-hidden="true">35.3.3.6.</strong> cast rpc</a></li><li class="chapter-item "><a href="reference/cast/cast-tx.html"><strong aria-hidden="true">35.3.3.7.</strong> cast tx</a></li><li class="chapter-item "><a href="reference/cast/cast-run.html"><strong aria-hidden="true">35.3.3.8.</strong> cast run</a></li><li class="chapter-item "><a href="reference/cast/cast-estimate.html"><strong aria-hidden="true">35.3.3.9.</strong> cast estimate</a></li><li class="chapter-item "><a href="reference/cast/cast-access-list.html"><strong aria-hidden="true">35.3.3.10.</strong> cast access-list</a></li><li class="chapter-item "><a href="reference/cast/cast-logs.html"><strong aria-hidden="true">35.3.3.11.</strong> cast logs</a></li></ol></li><li class="chapter-item "><a href="reference/cast/block-commands.html"><strong aria-hidden="true">35.3.4.</strong> 区块命令</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="reference/cast/cast-find-block.html"><strong aria-hidden="true">35.3.4.1.</strong> cast find-block</a></li><li class="chapter-item "><a href="reference/cast/cast-gas-price.html"><strong aria-hidden="true">35.3.4.2.</strong> cast gas-price</a></li><li class="chapter-item "><a href="reference/cast/cast-block-number.html"><strong aria-hidden="true">35.3.4.3.</strong> cast block-number</a></li><li class="chapter-item "><a href="reference/cast/cast-basefee.html"><strong aria-hidden="true">35.3.4.4.</strong> cast basefee</a></li><li class="chapter-item "><a href="reference/cast/cast-block.html"><strong aria-hidden="true">35.3.4.5.</strong> cast block</a></li><li class="chapter-item "><a href="reference/cast/cast-age.html"><strong aria-hidden="true">35.3.4.6.</strong> cast age</a></li></ol></li><li class="chapter-item "><a href="reference/cast/account-commands.html"><strong aria-hidden="true">35.3.5.</strong> 账户命令</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="reference/cast/cast-balance.html"><strong aria-hidden="true">35.3.5.1.</strong> cast balance</a></li><li class="chapter-item "><a href="reference/cast/cast-storage.html"><strong aria-hidden="true">35.3.5.2.</strong> cast storage</a></li><li class="chapter-item "><a href="reference/cast/cast-proof.html"><strong aria-hidden="true">35.3.5.3.</strong> cast proof</a></li><li class="chapter-item "><a href="reference/cast/cast-nonce.html"><strong aria-hidden="true">35.3.5.4.</strong> cast nonce</a></li><li class="chapter-item "><a href="reference/cast/cast-code.html"><strong aria-hidden="true">35.3.5.5.</strong> cast code</a></li><li class="chapter-item "><a href="reference/cast/cast-codesize.html"><strong aria-hidden="true">35.3.5.6.</strong> cast codesize</a></li></ol></li><li class="chapter-item "><a href="reference/cast/ens-commands.html"><strong aria-hidden="true">35.3.6.</strong> ENS 命令</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="reference/cast/cast-lookup-address.html"><strong aria-hidden="true">35.3.6.1.</strong> cast lookup-address</a></li><li class="chapter-item "><a href="reference/cast/cast-resolve-name.html"><strong aria-hidden="true">35.3.6.2.</strong> cast resolve-name</a></li><li class="chapter-item "><a href="reference/cast/cast-namehash.html"><strong aria-hidden="true">35.3.6.3.</strong> cast namehash</a></li></ol></li><li class="chapter-item "><a href="reference/cast/etherscan-commands.html"><strong aria-hidden="true">35.3.7.</strong> Etherscan 命令</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="reference/cast/cast-etherscan-source.html"><strong aria-hidden="true">35.3.7.1.</strong> cast etherscan-source</a></li></ol></li><li class="chapter-item "><a href="reference/cast/abi-commands.html"><strong aria-hidden="true">35.3.8.</strong> ABI 命令</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="reference/cast/cast-abi-decode.html"><strong aria-hidden="true">35.3.8.1.</strong> cast abi-decode</a></li><li class="chapter-item "><a href="reference/cast/cast-abi-encode.html"><strong aria-hidden="true">35.3.8.2.</strong> cast abi-encode</a></li><li class="chapter-item "><a href="reference/cast/cast-4byte.html"><strong aria-hidden="true">35.3.8.3.</strong> cast 4byte</a></li><li class="chapter-item "><a href="reference/cast/cast-4byte-decode.html"><strong aria-hidden="true">35.3.8.4.</strong> cast 4byte-decode</a></li><li class="chapter-item "><a href="reference/cast/cast-4byte-event.html"><strong aria-hidden="true">35.3.8.5.</strong> cast 4byte-event</a></li><li class="chapter-item "><a href="reference/cast/cast-calldata.html"><strong aria-hidden="true">35.3.8.6.</strong> cast calldata</a></li><li class="chapter-item "><a href="reference/cast/cast-calldata-decode.html"><strong aria-hidden="true">35.3.8.7.</strong> cast calldata-decode</a></li><li class="chapter-item "><a href="reference/cast/cast-pretty-calldata.html"><strong aria-hidden="true">35.3.8.8.</strong> cast pretty-calldata</a></li><li class="chapter-item "><a href="reference/cast/cast-selectors.html"><strong aria-hidden="true">35.3.8.9.</strong> cast selectors</a></li><li class="chapter-item "><a href="reference/cast/cast-upload-signature.html"><strong aria-hidden="true">35.3.8.10.</strong> cast upload-signature</a></li></ol></li><li class="chapter-item "><a href="reference/cast/conversion-commands.html"><strong aria-hidden="true">35.3.9.</strong> 转换命令</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="reference/cast/cast-format-bytes32-string.html"><strong aria-hidden="true">35.3.9.1.</strong> cast format-bytes32-string</a></li><li class="chapter-item "><a href="reference/cast/cast-from-bin.html"><strong aria-hidden="true">35.3.9.2.</strong> cast from-bin</a></li><li class="chapter-item "><a href="reference/cast/cast-from-fixed-point.html"><strong aria-hidden="true">35.3.9.3.</strong> cast from-fixed-point</a></li><li class="chapter-item "><a href="reference/cast/cast-from-rlp.html"><strong aria-hidden="true">35.3.9.4.</strong> cast from-rlp</a></li><li class="chapter-item "><a href="reference/cast/cast-from-utf8.html"><strong aria-hidden="true">35.3.9.5.</strong> cast from-utf8</a></li><li class="chapter-item "><a href="reference/cast/cast-from-wei.html"><strong aria-hidden="true">35.3.9.6.</strong> cast from-wei</a></li><li class="chapter-item "><a href="reference/cast/cast-parse-bytes32-address.html"><strong aria-hidden="true">35.3.9.7.</strong> cast parse-bytes32-address</a></li><li class="chapter-item "><a href="reference/cast/cast-parse-bytes32-string.html"><strong aria-hidden="true">35.3.9.8.</strong> cast parse-bytes32-string</a></li><li class="chapter-item "><a href="reference/cast/cast-to-ascii.html"><strong aria-hidden="true">35.3.9.9.</strong> cast to-ascii</a></li><li class="chapter-item "><a href="reference/cast/cast-to-base.html"><strong aria-hidden="true">35.3.9.10.</strong> cast to-base</a></li><li class="chapter-item "><a href="reference/cast/cast-to-bytes32.html"><strong aria-hidden="true">35.3.9.11.</strong> cast to-bytes32</a></li><li class="chapter-item "><a href="reference/cast/cast-to-dec.html"><strong aria-hidden="true">35.3.9.12.</strong> cast to-dec</a></li><li class="chapter-item "><a href="reference/cast/cast-to-fixed-point.html"><strong aria-hidden="true">35.3.9.13.</strong> cast to-fixed-point</a></li><li class="chapter-item "><a href="reference/cast/cast-to-hex.html"><strong aria-hidden="true">35.3.9.14.</strong> cast to-hex</a></li><li class="chapter-item "><a href="reference/cast/cast-to-hexdata.html"><strong aria-hidden="true">35.3.9.15.</strong> cast to-hexdata</a></li><li class="chapter-item "><a href="reference/cast/cast-to-int256.html"><strong aria-hidden="true">35.3.9.16.</strong> cast to-int256</a></li><li class="chapter-item "><a href="reference/cast/cast-to-rlp.html"><strong aria-hidden="true">35.3.9.17.</strong> cast to-rlp</a></li><li class="chapter-item "><a href="reference/cast/cast-to-uint256.html"><strong aria-hidden="true">35.3.9.18.</strong> cast to-uint256</a></li><li class="chapter-item "><a href="reference/cast/cast-to-unit.html"><strong aria-hidden="true">35.3.9.19.</strong> cast to-unit</a></li><li class="chapter-item "><a href="reference/cast/cast-to-wei.html"><strong aria-hidden="true">35.3.9.20.</strong> cast to-wei</a></li><li class="chapter-item "><a href="reference/cast/cast-shl.html"><strong aria-hidden="true">35.3.9.21.</strong> cast shl</a></li><li class="chapter-item "><a href="reference/cast/cast-shr.html"><strong aria-hidden="true">35.3.9.22.</strong> cast shr</a></li></ol></li><li class="chapter-item "><a href="reference/cast/utility-commands.html"><strong aria-hidden="true">35.3.10.</strong> 实用命令</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="reference/cast/cast-address-zero.html"><strong aria-hidden="true">35.3.10.1.</strong> cast address-zero</a></li><li class="chapter-item "><a href="reference/cast/cast-sig.html"><strong aria-hidden="true">35.3.10.2.</strong> cast sig</a></li><li class="chapter-item "><a href="reference/cast/cast-sig-event.html"><strong aria-hidden="true">35.3.10.3.</strong> cast sig-event</a></li><li class="chapter-item "><a href="reference/cast/cast-keccak.html"><strong aria-hidden="true">35.3.10.4.</strong> cast keccak</a></li><li class="chapter-item "><a href="reference/cast/cast-compute-address.html"><strong aria-hidden="true">35.3.10.5.</strong> cast compute-address</a></li><li class="chapter-item "><a href="reference/cast/cast-create2.html"><strong aria-hidden="true">35.3.10.6.</strong> cast create2</a></li><li class="chapter-item "><a href="reference/cast/cast-interface.html"><strong aria-hidden="true">35.3.10.7.</strong> cast interface</a></li><li class="chapter-item "><a href="reference/cast/cast-index.html"><strong aria-hidden="true">35.3.10.8.</strong> cast index</a></li><li class="chapter-item "><a href="reference/cast/cast-concat-hex.html"><strong aria-hidden="true">35.3.10.9.</strong> cast concat-hex</a></li><li class="chapter-item "><a href="reference/cast/cast-max-int.html"><strong aria-hidden="true">35.3.10.10.</strong> cast max-int</a></li><li class="chapter-item "><a href="reference/cast/cast-min-int.html"><strong aria-hidden="true">35.3.10.11.</strong> cast min-int</a></li><li class="chapter-item "><a href="reference/cast/cast-max-uint.html"><strong aria-hidden="true">35.3.10.12.</strong> cast max-uint</a></li><li class="chapter-item "><a href="reference/cast/cast-to-check-sum-address.html"><strong aria-hidden="true">35.3.10.13.</strong> cast to-check-sum-address</a></li></ol></li><li class="chapter-item "><a href="reference/cast/wallet-commands.html"><strong aria-hidden="true">35.3.11.</strong> 钱包命令</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="reference/cast/cast-wallet.html"><strong aria-hidden="true">35.3.11.1.</strong> cast wallet</a></li><li class="chapter-item "><a href="reference/cast/cast-wallet-new.html"><strong aria-hidden="true">35.3.11.2.</strong> cast wallet new</a></li><li class="chapter-item "><a href="reference/cast/cast-wallet-new-mnemonic.html"><strong aria-hidden="true">35.3.11.3.</strong> cast wallet new-mnemonic</a></li><li class="chapter-item "><a href="reference/cast/cast-wallet-address.html"><strong aria-hidden="true">35.3.11.4.</strong> cast wallet address</a></li><li class="chapter-item "><a href="reference/cast/cast-wallet-sign.html"><strong aria-hidden="true">35.3.11.5.</strong> cast wallet sign</a></li><li class="chapter-item "><a href="reference/cast/cast-wallet-vanity.html"><strong aria-hidden="true">35.3.11.6.</strong> cast wallet vanity</a></li><li class="chapter-item "><a href="reference/cast/cast-wallet-verify.html"><strong aria-hidden="true">35.3.11.7.</strong> cast wallet verify</a></li><li class="chapter-item "><a href="reference/cast/cast-wallet-import.html"><strong aria-hidden="true">35.3.11.8.</strong> cast wallet import</a></li><li class="chapter-item "><a href="reference/cast/cast-wallet-list.html"><strong aria-hidden="true">35.3.11.9.</strong> cast wallet list</a></li></ol></li></ol></li><li class="chapter-item "><a href="reference/anvil/index.html"><strong aria-hidden="true">35.4.</strong> anvil 参考</a></li><li class="chapter-item "><a href="reference/chisel/index.html"><strong aria-hidden="true">35.5.</strong> chisel 参考</a></li><li class="chapter-item "><a href="reference/config/index.html"><strong aria-hidden="true">35.6.</strong> 配置参考</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="reference/config/overview.html"><strong aria-hidden="true">35.6.1.</strong> 概述</a></li><li class="chapter-item "><a href="reference/config/project.html"><strong aria-hidden="true">35.6.2.</strong> 项目</a></li><li class="chapter-item "><a href="reference/config/solidity-compiler.html"><strong aria-hidden="true">35.6.3.</strong> Solidity 编译器</a></li><li class="chapter-item "><a href="reference/config/testing.html"><strong aria-hidden="true">35.6.4.</strong> 测试</a></li><li class="chapter-item "><a href="reference/config/inline-test-config.html"><strong aria-hidden="true">35.6.5.</strong> 内联配置测试</a></li><li class="chapter-item "><a href="reference/config/formatter.html"><strong aria-hidden="true">35.6.6.</strong> 格式化器</a></li><li class="chapter-item "><a href="reference/config/doc-generator.html"><strong aria-hidden="true">35.6.7.</strong> 文档生成器</a></li><li class="chapter-item "><a href="reference/config/etherscan.html"><strong aria-hidden="true">35.6.8.</strong> Etherscan</a></li></ol></li><li class="chapter-item "><a href="cheatcodes/index.html"><strong aria-hidden="true">35.7.</strong> 作弊码参考</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="cheatcodes/environment.html"><strong aria-hidden="true">35.7.1.</strong> 环境</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="cheatcodes/warp.html"><strong aria-hidden="true">35.7.1.1.</strong> warp</a></li><li class="chapter-item "><a href="cheatcodes/roll.html"><strong aria-hidden="true">35.7.1.2.</strong> roll</a></li><li class="chapter-item "><a href="cheatcodes/fee.html"><strong aria-hidden="true">35.7.1.3.</strong> fee</a></li><li class="chapter-item "><a href="cheatcodes/get-block-timestamp.html"><strong aria-hidden="true">35.7.1.4.</strong> getBlockTimestamp</a></li><li class="chapter-item "><a href="cheatcodes/get-block-number.html"><strong aria-hidden="true">35.7.1.5.</strong> getBlockNumber</a></li><li class="chapter-item "><a href="cheatcodes/difficulty.html"><strong aria-hidden="true">35.7.1.6.</strong> difficulty</a></li><li class="chapter-item "><a href="cheatcodes/prevrandao.html"><strong aria-hidden="true">35.7.1.7.</strong> prevrandao</a></li><li class="chapter-item "><a href="cheatcodes/chain-id.html"><strong aria-hidden="true">35.7.1.8.</strong> chainId</a></li><li class="chapter-item "><a href="cheatcodes/store.html"><strong aria-hidden="true">35.7.1.9.</strong> store</a></li><li class="chapter-item "><a href="cheatcodes/load.html"><strong aria-hidden="true">35.7.1.10.</strong> load</a></li><li class="chapter-item "><a href="cheatcodes/etch.html"><strong aria-hidden="true">35.7.1.11.</strong> etch</a></li><li class="chapter-item "><a href="cheatcodes/deal.html"><strong aria-hidden="true">35.7.1.12.</strong> deal</a></li><li class="chapter-item "><a href="cheatcodes/prank.html"><strong aria-hidden="true">35.7.1.13.</strong> prank</a></li><li class="chapter-item "><a href="cheatcodes/start-prank.html"><strong aria-hidden="true">35.7.1.14.</strong> startPrank</a></li><li class="chapter-item "><a href="cheatcodes/stop-prank.html"><strong aria-hidden="true">35.7.1.15.</strong> stopPrank</a></li><li class="chapter-item "><a href="cheatcodes/read-callers.html"><strong aria-hidden="true">35.7.1.16.</strong> readCallers</a></li><li class="chapter-item "><a href="cheatcodes/record.html"><strong aria-hidden="true">35.7.1.17.</strong> record</a></li><li class="chapter-item "><a href="cheatcodes/accesses.html"><strong aria-hidden="true">35.7.1.18.</strong> accesses</a></li><li class="chapter-item "><a href="cheatcodes/record-logs.html"><strong aria-hidden="true">35.7.1.19.</strong> recordLogs</a></li><li class="chapter-item "><a href="cheatcodes/get-recorded-logs.html"><strong aria-hidden="true">35.7.1.20.</strong> getRecordedLogs</a></li><li class="chapter-item "><a href="cheatcodes/set-nonce.html"><strong aria-hidden="true">35.7.1.21.</strong> setNonce</a></li><li class="chapter-item "><a href="cheatcodes/get-nonce.html"><strong aria-hidden="true">35.7.1.22.</strong> getNonce</a></li><li class="chapter-item "><a href="cheatcodes/mock-call.html"><strong aria-hidden="true">35.7.1.23.</strong> mockCall</a></li><li class="chapter-item "><a href="cheatcodes/mock-call-revert.html"><strong aria-hidden="true">35.7.1.24.</strong> mockCallRevert</a></li><li class="chapter-item "><a href="cheatcodes/clear-mocked-calls.html"><strong aria-hidden="true">35.7.1.25.</strong> clearMockedCalls</a></li><li class="chapter-item "><a href="cheatcodes/coinbase.html"><strong aria-hidden="true">35.7.1.26.</strong> coinbase</a></li><li class="chapter-item "><a href="cheatcodes/broadcast.html"><strong aria-hidden="true">35.7.1.27.</strong> broadcast</a></li><li class="chapter-item "><a href="cheatcodes/start-broadcast.html"><strong aria-hidden="true">35.7.1.28.</strong> startBroadcast</a></li><li class="chapter-item "><a href="cheatcodes/stop-broadcast.html"><strong aria-hidden="true">35.7.1.29.</strong> stopBroadcast</a></li><li class="chapter-item "><a href="cheatcodes/pause-gas-metering.html"><strong aria-hidden="true">35.7.1.30.</strong> pauseGasMetering</a></li><li class="chapter-item "><a href="cheatcodes/resume-gas-metering.html"><strong aria-hidden="true">35.7.1.31.</strong> resumeGasMetering</a></li><li class="chapter-item "><a href="cheatcodes/tx-gas-price.html"><strong aria-hidden="true">35.7.1.32.</strong> txGasPrice</a></li><li class="chapter-item "><a href="cheatcodes/start-state-diff-recording.html"><strong aria-hidden="true">35.7.1.33.</strong> startStateDiffRecording</a></li><li class="chapter-item "><a href="cheatcodes/stop-and-return-state-diff.html"><strong aria-hidden="true">35.7.1.34.</strong> stopAndReturnStateDiff</a></li></ol></li><li class="chapter-item "><a href="cheatcodes/assertions.html"><strong aria-hidden="true">35.7.2.</strong> 断言</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="cheatcodes/expect-revert.html"><strong aria-hidden="true">35.7.2.1.</strong> expectRevert</a></li><li class="chapter-item "><a href="cheatcodes/expect-emit.html"><strong aria-hidden="true">35.7.2.2.</strong> expectEmit</a></li><li class="chapter-item "><a href="cheatcodes/expect-call.html"><strong aria-hidden="true">35.7.2.3.</strong> expectCall</a></li></ol></li><li class="chapter-item "><a href="cheatcodes/fuzzer.html"><strong aria-hidden="true">35.7.3.</strong> 模糊器</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="cheatcodes/assume.html"><strong aria-hidden="true">35.7.3.1.</strong> assume</a></li></ol></li><li class="chapter-item "><a href="cheatcodes/forking.html"><strong aria-hidden="true">35.7.4.</strong> 分叉</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="cheatcodes/create-fork.html"><strong aria-hidden="true">35.7.4.1.</strong> createFork</a></li><li class="chapter-item "><a href="cheatcodes/select-fork.html"><strong aria-hidden="true">35.7.4.2.</strong> selectFork</a></li><li class="chapter-item "><a href="cheatcodes/create-select-fork.html"><strong aria-hidden="true">35.7.4.3.</strong> createSelectFork</a></li><li class="chapter-item "><a href="cheatcodes/active-fork.html"><strong aria-hidden="true">35.7.4.4.</strong> activeFork</a></li><li class="chapter-item "><a href="cheatcodes/roll-fork.html"><strong aria-hidden="true">35.7.4.5.</strong> rollFork</a></li><li class="chapter-item "><a href="cheatcodes/make-persistent.html"><strong aria-hidden="true">35.7.4.6.</strong> makePersistent</a></li><li class="chapter-item "><a href="cheatcodes/revoke-persistent.html"><strong aria-hidden="true">35.7.4.7.</strong> revokePersistent</a></li><li class="chapter-item "><a href="cheatcodes/is-persistent.html"><strong aria-hidden="true">35.7.4.8.</strong> isPersistent</a></li><li class="chapter-item "><a href="cheatcodes/allow-cheatcodes.html"><strong aria-hidden="true">35.7.4.9.</strong> allowCheatcodes</a></li><li class="chapter-item "><a href="cheatcodes/transact.html"><strong aria-hidden="true">35.7.4.10.</strong> transact</a></li></ol></li><li class="chapter-item "><a href="cheatcodes/external.html"><strong aria-hidden="true">35.7.5.</strong> 外部</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="cheatcodes/ffi.html"><strong aria-hidden="true">35.7.5.1.</strong> ffi</a></li><li class="chapter-item "><a href="cheatcodes/prompt.html"><strong aria-hidden="true">35.7.5.2.</strong> prompt</a></li><li class="chapter-item "><a href="cheatcodes/project-root.html"><strong aria-hidden="true">35.7.5.3.</strong> projectRoot</a></li><li class="chapter-item "><a href="cheatcodes/get-code.html"><strong aria-hidden="true">35.7.5.4.</strong> getCode</a></li><li class="chapter-item "><a href="cheatcodes/get-deployed-code.html"><strong aria-hidden="true">35.7.5.5.</strong> getDeployedCode</a></li><li class="chapter-item "><a href="cheatcodes/sleep.html"><strong aria-hidden="true">35.7.5.6.</strong> sleep</a></li><li class="chapter-item "><a href="cheatcodes/unix-time.html"><strong aria-hidden="true">35.7.5.7.</strong> unixTime</a></li><li class="chapter-item "><a href="cheatcodes/set-env.html"><strong aria-hidden="true">35.7.5.8.</strong> setEnv</a></li><li class="chapter-item "><a href="cheatcodes/env-or.html"><strong aria-hidden="true">35.7.5.9.</strong> envOr</a></li><li class="chapter-item "><a href="cheatcodes/env-bool.html"><strong aria-hidden="true">35.7.5.10.</strong> envBool</a></li><li class="chapter-item "><a href="cheatcodes/env-uint.html"><strong aria-hidden="true">35.7.5.11.</strong> envUint</a></li><li class="chapter-item "><a href="cheatcodes/env-int.html"><strong aria-hidden="true">35.7.5.12.</strong> envInt</a></li><li class="chapter-item "><a href="cheatcodes/env-address.html"><strong aria-hidden="true">35.7.5.13.</strong> envAddress</a></li><li class="chapter-item "><a href="cheatcodes/env-bytes32.html"><strong aria-hidden="true">35.7.5.14.</strong> envBytes32</a></li><li class="chapter-item "><a href="cheatcodes/env-string.html"><strong aria-hidden="true">35.7.5.15.</strong> envString</a></li><li class="chapter-item "><a href="cheatcodes/env-bytes.html"><strong aria-hidden="true">35.7.5.16.</strong> envBytes</a></li><li class="chapter-item "><a href="cheatcodes/key-exists.html"><strong aria-hidden="true">35.7.5.17.</strong> keyExists</a></li><li class="chapter-item "><a href="cheatcodes/key-exists-json.html"><strong aria-hidden="true">35.7.5.18.</strong> keyExistsJson</a></li><li class="chapter-item "><a href="cheatcodes/key-exists-toml.html"><strong aria-hidden="true">35.7.5.19.</strong> keyExistsToml</a></li><li class="chapter-item "><a href="cheatcodes/parse-json.html"><strong aria-hidden="true">35.7.5.20.</strong> parseJson</a></li><li class="chapter-item "><a href="cheatcodes/parse-toml.html"><strong aria-hidden="true">35.7.5.21.</strong> parseToml</a></li><li class="chapter-item "><a href="cheatcodes/parse-json-keys.html"><strong aria-hidden="true">35.7.5.22.</strong> parseJsonKeys</a></li><li class="chapter-item "><a href="cheatcodes/parse-toml-keys.html"><strong aria-hidden="true">35.7.5.23.</strong> parseTomlKeys</a></li><li class="chapter-item "><a href="cheatcodes/serialize-json.html"><strong aria-hidden="true">35.7.5.24.</strong> serializeJson</a></li><li class="chapter-item "><a href="cheatcodes/write-json.html"><strong aria-hidden="true">35.7.5.25.</strong> writeJson</a></li><li class="chapter-item "><a href="cheatcodes/write-toml.html"><strong aria-hidden="true">35.7.5.26.</strong> writeToml</a></li></ol></li><li class="chapter-item "><a href="cheatcodes/utilities.html"><strong aria-hidden="true">35.7.6.</strong> 实用工具</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="cheatcodes/addr.html"><strong aria-hidden="true">35.7.6.1.</strong> addr</a></li><li class="chapter-item "><a href="cheatcodes/sign.html"><strong aria-hidden="true">35.7.6.2.</strong> sign</a></li><li class="chapter-item "><a href="cheatcodes/skip.html"><strong aria-hidden="true">35.7.6.3.</strong> skip</a></li><li class="chapter-item "><a href="cheatcodes/label.html"><strong aria-hidden="true">35.7.6.4.</strong> label</a></li><li class="chapter-item "><a href="cheatcodes/get-label.html"><strong aria-hidden="true">35.7.6.5.</strong> getLabel</a></li><li class="chapter-item "><a href="cheatcodes/derive-key.html"><strong aria-hidden="true">35.7.6.6.</strong> deriveKey</a></li><li class="chapter-item "><a href="cheatcodes/parse-bytes.html"><strong aria-hidden="true">35.7.6.7.</strong> parseBytes</a></li><li class="chapter-item "><a href="cheatcodes/parse-address.html"><strong aria-hidden="true">35.7.6.8.</strong> parseAddress</a></li><li class="chapter-item "><a href="cheatcodes/parse-uint.html"><strong aria-hidden="true">35.7.6.9.</strong> parseUint</a></li><li class="chapter-item "><a href="cheatcodes/parse-int.html"><strong aria-hidden="true">35.7.6.10.</strong> parseInt</a></li><li class="chapter-item "><a href="cheatcodes/parse-bytes32.html"><strong aria-hidden="true">35.7.6.11.</strong> parseBytes32</a></li><li class="chapter-item "><a href="cheatcodes/parse-bool.html"><strong aria-hidden="true">35.7.6.12.</strong> parseBool</a></li><li class="chapter-item "><a href="cheatcodes/remember-key.html"><strong aria-hidden="true">35.7.6.13.</strong> rememberKey</a></li><li class="chapter-item "><a href="cheatcodes/to-string.html"><strong aria-hidden="true">35.7.6.14.</strong> toString</a></li><li class="chapter-item "><a href="cheatcodes/breakpoint.html"><strong aria-hidden="true">35.7.6.15.</strong> breakpoint</a></li><li class="chapter-item "><a href="cheatcodes/create-wallet.html"><strong aria-hidden="true">35.7.6.16.</strong> createWallet</a></li></ol></li><li class="chapter-item "><a href="cheatcodes/snapshots.html"><strong aria-hidden="true">35.7.7.</strong> 快照</a></li><li class="chapter-item "><a href="cheatcodes/rpc.html"><strong aria-hidden="true">35.7.8.</strong> RPC</a></li><li class="chapter-item "><a href="cheatcodes/fs.html"><strong aria-hidden="true">35.7.9.</strong> 文件</a></li></ol></li><li class="chapter-item "><a href="reference/forge-std/index.html"><strong aria-hidden="true">35.8.</strong> Forge 标准库参考</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="reference/forge-std/std-logs.html"><strong aria-hidden="true">35.8.1.</strong> Std Logs</a></li><li class="chapter-item "><a href="reference/forge-std/std-assertions.html"><strong aria-hidden="true">35.8.2.</strong> Std 断言</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="reference/forge-std/fail.html"><strong aria-hidden="true">35.8.2.1.</strong> fail</a></li><li class="chapter-item "><a href="reference/forge-std/assertTrue.html"><strong aria-hidden="true">35.8.2.2.</strong> assertTrue</a></li><li class="chapter-item "><a href="reference/forge-std/assertFalse.html"><strong aria-hidden="true">35.8.2.3.</strong> assertFalse</a></li><li class="chapter-item "><a href="reference/forge-std/assertEq.html"><strong aria-hidden="true">35.8.2.4.</strong> assertEq</a></li><li class="chapter-item "><a href="reference/forge-std/assertEqDecimal.html"><strong aria-hidden="true">35.8.2.5.</strong> assertEqDecimal</a></li><li class="chapter-item "><a href="reference/forge-std/assertNotEq.html"><strong aria-hidden="true">35.8.2.6.</strong> assertNotEq</a></li><li class="chapter-item "><a href="reference/forge-std/assertNotEqDecimal.html"><strong aria-hidden="true">35.8.2.7.</strong> assertNotEqDecimal</a></li><li class="chapter-item "><a href="reference/forge-std/assertLt.html"><strong aria-hidden="true">35.8.2.8.</strong> assertLt</a></li><li class="chapter-item "><a href="reference/forge-std/assertLtDecimal.html"><strong aria-hidden="true">35.8.2.9.</strong> assertLtDecimal</a></li><li class="chapter-item "><a href="reference/forge-std/assertGt.html"><strong aria-hidden="true">35.8.2.10.</strong> assertGt</a></li><li class="chapter-item "><a href="reference/forge-std/assertGtDecimal.html"><strong aria-hidden="true">35.8.2.11.</strong> assertGtDecimal</a></li><li class="chapter-item "><a href="reference/forge-std/assertLe.html"><strong aria-hidden="true">35.8.2.12.</strong> assertLe</a></li><li class="chapter-item "><a href="reference/forge-std/assertLeDecimal.html"><strong aria-hidden="true">35.8.2.13.</strong> assertLeDecimal</a></li><li class="chapter-item "><a href="reference/forge-std/assertGe.html"><strong aria-hidden="true">35.8.2.14.</strong> assertGe</a></li><li class="chapter-item "><a href="reference/forge-std/assertGeDecimal.html"><strong aria-hidden="true">35.8.2.15.</strong> assertGeDecimal</a></li><li class="chapter-item "><a href="reference/forge-std/assertApproxEqAbs.html"><strong aria-hidden="true">35.8.2.16.</strong> assertApproxEqAbs</a></li><li class="chapter-item "><a href="reference/forge-std/assertApproxEqAbsDecimal.html"><strong aria-hidden="true">35.8.2.17.</strong> assertApproxEqAbsDecimal</a></li><li class="chapter-item "><a href="reference/forge-std/assertApproxEqRel.html"><strong aria-hidden="true">35.8.2.18.</strong> assertApproxEqRel</a></li><li class="chapter-item "><a href="reference/forge-std/assertApproxEqRelDecimal.html"><strong aria-hidden="true">35.8.2.19.</strong> assertApproxEqRelDecimal</a></li></ol></li><li class="chapter-item "><a href="reference/forge-std/std-cheats.html"><strong aria-hidden="true">35.8.3.</strong> Std 作弊</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="reference/forge-std/skip.html"><strong aria-hidden="true">35.8.3.1.</strong> skip</a></li><li class="chapter-item "><a href="reference/forge-std/rewind.html"><strong aria-hidden="true">35.8.3.2.</strong> rewind</a></li><li class="chapter-item "><a href="reference/forge-std/hoax.html"><strong aria-hidden="true">35.8.3.3.</strong> hoax</a></li><li class="chapter-item "><a href="reference/forge-std/startHoax.html"><strong aria-hidden="true">35.8.3.4.</strong> startHoax</a></li><li class="chapter-item "><a href="reference/forge-std/deal.html"><strong aria-hidden="true">35.8.3.5.</strong> deal</a></li><li class="chapter-item "><a href="reference/forge-std/deployCode.html"><strong aria-hidden="true">35.8.3.6.</strong> deployCode</a></li><li class="chapter-item "><a href="reference/forge-std/deployCodeTo.html"><strong aria-hidden="true">35.8.3.7.</strong> deployCodeTo</a></li><li class="chapter-item "><a href="reference/forge-std/bound.html"><strong aria-hidden="true">35.8.3.8.</strong> bound</a></li><li class="chapter-item "><a href="reference/forge-std/change-prank.html"><strong aria-hidden="true">35.8.3.9.</strong> changePrank</a></li><li class="chapter-item "><a href="reference/forge-std/make-addr.html"><strong aria-hidden="true">35.8.3.10.</strong> makeAddr</a></li><li class="chapter-item "><a href="reference/forge-std/make-addr-and-key.html"><strong aria-hidden="true">35.8.3.11.</strong> makeAddrAndKey</a></li><li class="chapter-item "><a href="reference/forge-std/noGasMetering.html"><strong aria-hidden="true">35.8.3.12.</strong> noGasMetering</a></li><li class="chapter-item "><a href="reference/forge-std/assume-no-precompiles.html"><strong aria-hidden="true">35.8.3.13.</strong> assumeNoPrecompiles</a></li><li class="chapter-item "><a href="reference/forge-std/assume-payable.html"><strong aria-hidden="true">35.8.3.14.</strong> assumePayable</a></li></ol></li><li class="chapter-item "><a href="reference/forge-std/std-errors.html"><strong aria-hidden="true">35.8.4.</strong> Std 错误</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="reference/forge-std/assertionError.html"><strong aria-hidden="true">35.8.4.1.</strong> assertionError</a></li><li class="chapter-item "><a href="reference/forge-std/arithmeticError.html"><strong aria-hidden="true">35.8.4.2.</strong> arithmeticError</a></li><li class="chapter-item "><a href="reference/forge-std/divisionError.html"><strong aria-hidden="true">35.8.4.3.</strong> divisionError</a></li><li class="chapter-item "><a href="reference/forge-std/enumConversionError.html"><strong aria-hidden="true">35.8.4.4.</strong> enumConversionError</a></li><li class="chapter-item "><a href="reference/forge-std/encodeStorageError.html"><strong aria-hidden="true">35.8.4.5.</strong> encodeStorageError</a></li><li class="chapter-item "><a href="reference/forge-std/popError.html"><strong aria-hidden="true">35.8.4.6.</strong> popError</a></li><li class="chapter-item "><a href="reference/forge-std/indexOOBError.html"><strong aria-hidden="true">35.8.4.7.</strong> indexOOBError</a></li><li class="chapter-item "><a href="reference/forge-std/memOverflowError.html"><strong aria-hidden="true">35.8.4.8.</strong> memOverflowError</a></li><li class="chapter-item "><a href="reference/forge-std/zeroVarError.html"><strong aria-hidden="true">35.8.4.9.</strong> zeroVarError</a></li></ol></li><li class="chapter-item "><a href="reference/forge-std/std-storage.html"><strong aria-hidden="true">35.8.5.</strong> Std 存储</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="reference/forge-std/target.html"><strong aria-hidden="true">35.8.5.1.</strong> target</a></li><li class="chapter-item "><a href="reference/forge-std/sig.html"><strong aria-hidden="true">35.8.5.2.</strong> sig</a></li><li class="chapter-item "><a href="reference/forge-std/with_key.html"><strong aria-hidden="true">35.8.5.3.</strong> with_key</a></li><li class="chapter-item "><a href="reference/forge-std/depth.html"><strong aria-hidden="true">35.8.5.4.</strong> depth</a></li><li class="chapter-item "><a href="reference/forge-std/checked_write.html"><strong aria-hidden="true">35.8.5.5.</strong> checked_write</a></li><li class="chapter-item "><a href="reference/forge-std/find.html"><strong aria-hidden="true">35.8.5.6.</strong> find</a></li><li class="chapter-item "><a href="reference/forge-std/read.html"><strong aria-hidden="true">35.8.5.7.</strong> read</a></li></ol></li><li class="chapter-item "><a href="reference/forge-std/std-math.html"><strong aria-hidden="true">35.8.6.</strong> Std 数学</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="reference/forge-std/abs.html"><strong aria-hidden="true">35.8.6.1.</strong> abs</a></li><li class="chapter-item "><a href="reference/forge-std/delta.html"><strong aria-hidden="true">35.8.6.2.</strong> delta</a></li><li class="chapter-item "><a href="reference/forge-std/percentDelta.html"><strong aria-hidden="true">35.8.6.3.</strong> percentDelta</a></li></ol></li><li class="chapter-item "><a href="reference/forge-std/script-utils.html"><strong aria-hidden="true">35.8.7.</strong> 脚本实用工具</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="reference/forge-std/compute-create-address.html"><strong aria-hidden="true">35.8.7.1.</strong> computeCreateAddress</a></li><li class="chapter-item "><a href="reference/forge-std/derive-remember-key.html"><strong aria-hidden="true">35.8.7.2.</strong> deriveRememberKey</a></li></ol></li><li class="chapter-item "><a href="reference/forge-std/console-log.html"><strong aria-hidden="true">35.8.8.</strong> 控制台日志</a></li></ol></li><li class="chapter-item "><a href="reference/ds-test.html"><strong aria-hidden="true">35.9.</strong> DSTest 参考</a></li></ol></li><li class="chapter-item expanded "><a href="misc/index.html"><strong aria-hidden="true">36.</strong> 杂项</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="misc/struct-encoding.html"><strong aria-hidden="true">36.1.</strong> 结构编码</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Foundry Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/foundry-rs/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <img src="images/foundry-banner.png" style="border-radius: 20px">
<p>Foundry 是一个智能合约开发工具链。</p>
<p>Foundry 管理你的依赖项，编译你的项目，运行测试，部署，并让你通过命令行和 Solidity 脚本与链进行交互。</p>
<blockquote>
<p>📖 <strong>贡献</strong></p>
<p>你可以在 <a href="https://github.com/foundry-rs/book" title="" target="_blank">GitHub</a> 上为此书做出贡献。</p>
</blockquote>
<h3 id="章节"><a class="header" href="#章节">章节</a></h3>
<p><strong><a href="getting-started/installation.html">入门</a></strong></p>
<p>要开始使用 Foundry，请安装 Foundry 并设置你的第一个项目。</p>
<p><strong><a href="projects/creating-a-new-project.html">项目</a></strong></p>
<p>本节将概述如何创建和使用现有项目。</p>
<p><strong><a href="forge">Forge 概述</a></strong></p>
<p>本概述将告诉你所有关于如何使用 <code>forge</code> 开发、测试和部署智能合约的信息。</p>
<p><strong><a href="cast">Cast 概述</a></strong></p>
<p>学习如何使用 <code>cast</code> 与智能合约交互，发送交易，并从命令行获取链数据。</p>
<p><strong><a href="anvil">Anvil 概述</a></strong></p>
<p>学习关于 <code>anvil</code>，Foundry 的本地节点。</p>
<p><strong><a href="chisel">Chisel 概述</a></strong></p>
<p>学习如何使用 <code>chisel</code>，Foundry 的集成 Solidity REPL。</p>
<p><strong>配置</strong></p>
<p>关于配置 Foundry 的指南。</p>
<ul>
<li><a href="./config/">使用 <code>foundry.toml</code> 配置</a></li>
<li><a href="./config/continuous-integration.html">持续集成</a></li>
<li><a href="./config/vscode.html">与 VSCode 集成</a></li>
<li><a href="./config/shell-autocompletion.html">Shell 自动补全</a></li>
<li><a href="./config/static-analyzers.html">静态分析器</a></li>
<li><a href="./config/hardhat.html">与 Hardhat 集成</a></li>
<li><a href="./config/vyper.html">Vyper 支持</a></li>
</ul>
<p><strong>教程</strong></p>
<p>使用 Foundry 构建智能合约的教程。</p>
<ul>
<li><a href="./tutorials/solmate-nft.html">使用 Solmate 创建 NFT</a></li>
<li><a href="./tutorials/foundry-docker.html">Docker 和 Foundry</a></li>
<li><a href="./tutorials/testing-eip712.html">测试 EIP-712 签名</a></li>
<li><a href="./tutorials/solidity-scripting.html">Solidity 脚本</a></li>
<li><a href="./tutorials/forking-mainnet-with-cast-anvil.html">使用 Cast 和 Anvil 分叉主网</a></li>
<li><a href="./tutorials/learn-foundry.html">学习 Foundry 视频</a></li>
</ul>
<!-- - [增量采用]() -->
<p><strong>贡献</strong></p>
<p>帮助我们改进 Foundry：<a href="./contributing.html">贡献</a></p>
<p><strong>附录</strong></p>
<p>参考资料、故障排除等。</p>
<ul>
<li><a href="./faq.html">常见问题</a></li>
<li><a href="./reference/cli/">CLI 参考</a></li>
<li><a href="./reference/forge/">forge 命令</a></li>
<li><a href="./reference/cast/">cast 命令</a></li>
<li><a href="./reference/anvil/">anvil 命令</a></li>
<li><a href="./reference/chisel/">chisel 命令</a></li>
<li><a href="./reference/config/">配置参考</a></li>
<li><a href="./cheatcodes/">作弊码参考</a></li>
<li><a href="./reference/forge-std/">Forge 标准库参考</a></li>
<li><a href="./reference/ds-test.html">DSTest 参考</a></li>
<li><a href="misc">杂项</a></li>
</ul>
<br>
<blockquote>
<p>你也可以查看 <a href="https://github.com/crisgarner/awesome-foundry" title="" target="_blank">Awesome Foundry</a>，一个精选的 Foundry 资源、教程、工具和库的列表！</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="安装"><a class="header" href="#安装">安装</a></h2>
<p>如果在安装过程中遇到任何问题，请查看<a href="getting-started/../faq.html">常见问题解答</a>。</p>
<h3 id="预编译二进制文件"><a class="header" href="#预编译二进制文件">预编译二进制文件</a></h3>
<p>预编译二进制文件可以从<a href="https://github.com/foundry-rs/foundry/releases" title="" target="_blank">GitHub发布页面</a>获取。
这些文件最好通过使用<a href="getting-started/installation.html#using-foundryup">Foundryup</a>进行管理。</p>
<h3 id="使用-foundryup"><a class="header" href="#使用-foundryup">使用 Foundryup</a></h3>
<p>Foundryup 是 Foundry 工具链安装程序。你可以在<a href="https://github.com/foundry-rs/foundry/blob/master/foundryup/README.md" title="" target="_blank">这里</a>了解更多信息。</p>
<p>打开终端并运行以下命令：</p>
<pre><code class="language-sh">curl -L https://foundry.paradigm.xyz | bash
</code></pre>
<p>这将安装 Foundryup，然后按照屏幕上的指示操作，
这将使 <code>foundryup</code> 命令在你的 CLI 中可用。</p>
<p>运行 <code>foundryup</code> 本身将安装最新的（ nightly ）<a href="getting-started/installation.html#precompiled-binaries">预编译二进制文件</a>：<code>forge</code>、<code>cast</code>、<code>anvil</code> 和 <code>chisel</code>。
查看 <code>foundryup --help</code> 了解更多选项，例如从特定版本或提交安装。</p>
<blockquote>
<p>ℹ️ <strong>注意</strong></p>
<p>如果你使用的是 Windows，你需要安装并使用 <a href="https://gitforwindows.org/" title="" target="_blank">Git BASH</a> 或 <a href="https://learn.microsoft.com/en-us/windows/wsl/install" title="" target="_blank">WSL</a>，
作为你的终端，因为 Foundryup 目前不支持 Powershell 或 Cmd。</p>
</blockquote>
<h3 id="从源代码构建"><a class="header" href="#从源代码构建">从源代码构建</a></h3>
<h4 id="先决条件"><a class="header" href="#先决条件">先决条件</a></h4>
<p>你需要 <a href="https://rust-lang.org" title="" target="_blank">Rust</a> 编译器和 Cargo，即 Rust 包管理器。
安装两者的最简单方法是使用 <a href="https://rustup.rs/" title="" target="_blank">
<code>rustup.rs</code></a>。</p>
<p>Foundry 通常只支持在最新的稳定 Rust 版本上构建。
如果你有旧版本的 Rust，可以使用 <code>rustup</code> 进行更新：</p>
<pre><code class="language-sh">rustup update stable
</code></pre>
<p>在 Windows 上，你还需要安装最新版本的 <a href="https://visualstudio.microsoft.com/downloads/" title="" target="_blank">Visual Studio</a>，
并选择“使用 C++ 的桌面开发”工作负载选项。</p>
<h4 id="构建"><a class="header" href="#构建">构建</a></h4>
<p>你可以使用不同的 <a href="getting-started/installation.html#using-foundryup">Foundryup</a> 标志：</p>
<pre><code class="language-sh">foundryup --branch master
foundryup --path path/to/foundry
</code></pre>
<p>或者，通过使用单个 Cargo 命令：</p>
<pre><code class="language-sh">cargo install --git https://github.com/foundry-rs/foundry --profile release --locked forge cast chisel anvil
</code></pre>
<p>或者，通过手动从 <a href="https://github.com/foundry-rs/foundry" title="" target="_blank">Foundry 仓库</a> 的本地副本构建：</p>
<pre><code class="language-sh"># 克隆仓库
git clone https://github.com/foundry-rs/foundry.git
cd foundry
# 安装 Forge
cargo install --path ./crates/forge --profile release --force --locked
# 安装 Cast
cargo install --path ./crates/cast --profile release --force --locked
# 安装 Anvil
cargo install --path ./crates/anvil --profile release --force --locked
# 安装 Chisel
cargo install --path ./crates/chisel --profile release --force --locked
</code></pre>
<h3 id="在-github-action-中安装"><a class="header" href="#在-github-action-中安装">在 Github Action 中安装</a></h3>
<p>请参阅 <a href="https://github.com/foundry-rs/foundry-toolchain" title="" target="_blank">foundry-rs/foundry-toolchain</a> GitHub Action。</p>
<h3 id="使用-docker-运行-foundry"><a class="header" href="#使用-docker-运行-foundry">使用 Docker 运行 Foundry</a></h3>
<p>Foundry 也可以完全在 Docker 容器中使用。如果你没有安装 Docker，可以直接从 <a href="https://docs.docker.com/get-docker/" title="" target="_blank">Docker 的网站</a> 安装。</p>
<p>安装完成后，你可以通过运行以下命令下载最新版本：</p>
<pre><code class="language-sh">docker pull ghcr.io/foundry-rs/foundry:latest
</code></pre>
<p>也可以在本地构建 Docker 镜像。从 Foundry 仓库中运行：</p>
<pre><code class="language-sh">docker build -t foundry .
</code></pre>
<p>有关使用此镜像的示例和指南，请参阅 <a href="getting-started/../tutorials/foundry-docker">Docker 教程部分</a>。</p>
<blockquote>
<p>ℹ️ <strong>注意</strong></p>
<p>一些机器（包括带有 M1 芯片的机器）可能无法在本地构建 Docker 镜像。这是一个已知问题。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="foundry-入门"><a class="header" href="#foundry-入门">Foundry 入门</a></h2>
<p>本节概述了 <code>forge</code> 命令行工具。我们演示如何创建一个新项目、编译和测试它。</p>
<p>要使用 Foundry 启动一个新项目，请使用 <a href="getting-started/../reference/forge/forge-init.html"><code>forge init</code></a>：</p>
<pre><code class="language-sh">$ forge init hello_foundry
</code></pre>
<p>让我们看看 <code>forge</code> 为我们生成了什么：</p>
<pre><code class="language-sh">$ cd hello_foundry
$ tree . -d -L 1
.
├── lib
├── script
├── src
└── test

4 directories
</code></pre>
<p>我们可以使用 <a href="getting-started/../reference/forge/forge-build.html"><code>forge build</code></a> 构建项目：</p>
<pre><code class="language-sh">$ forge build
Compiling 27 files with Solc 0.8.19
Solc 0.8.19 finished in 1.11s
Compiler run successful!
</code></pre>
<p>并使用 <a href="getting-started/../reference/forge/forge-test.html"><code>forge test</code></a> 运行测试：</p>
<pre><code class="language-sh">$ forge test
No files changed, compilation skipped

Ran 2 tests for test/Counter.t.sol:CounterTest
[PASS] testFuzz_SetNumber(uint256) (runs: 256, μ: 31054, ~: 31288)
[PASS] test_Increment() (gas: 31303)
Suite result: ok. 2 passed; 0 failed; 0 skipped; finished in 6.29ms (5.89ms CPU time)

Ran 1 test suite in 7.54ms (6.29ms CPU time): 2 tests passed, 0 failed, 0 skipped (2 total tests)
</code></pre>
<br>
<blockquote>
<p>💡 <strong>提示</strong></p>
<p>你可以随时通过在末尾添加 <code>--help</code> 来打印任何子命令（或其子命令）的帮助信息。</p>
</blockquote>
<p>如果你是视觉学习者，可以观看<a href="getting-started/../tutorials/learn-foundry.html">这些</a>入门教程。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="创建一个新项目"><a class="header" href="#创建一个新项目">创建一个新项目</a></h2>
<p>要使用 Foundry 开始一个新项目，请使用 <a href="projects/../reference/forge/forge-init.html"><code>forge init</code></a>：</p>
<pre><code class="language-sh">$ forge init hello_foundry
</code></pre>
<p>这将使用默认模板创建一个名为 <code>hello_foundry</code> 的新目录。这还会初始化一个新的 <code>git</code> 仓库。</p>
<p>如果你想使用不同的模板创建一个新项目，可以传递 <code>--template</code> 标志，如下所示：</p>
<pre><code class="language-sh">$ forge init --template https://github.com/foundry-rs/forge-template hello_template
</code></pre>
<p>现在，让我们看看默认模板是什么样子的：</p>
<pre><code class="language-sh">$ cd hello_foundry
$ tree . -d -L 1
.
├── lib
├── script
├── src
└── test

4 directories
</code></pre>
<p>默认模板带有一个已安装的依赖项：Forge 标准库。这是用于 Foundry 项目的首选测试库。此外，模板还带有一个空的入门合约和一个简单的测试。</p>
<p>让我们构建项目：</p>
<pre><code class="language-sh">$ forge build
Compiling 27 files with Solc 0.8.19
Solc 0.8.19 finished in 1.11s
Compiler run successful!
</code></pre>
<p>并运行测试：</p>
<pre><code class="language-sh">$ forge test
No files changed, compilation skipped

Ran 2 tests for test/Counter.t.sol:CounterTest
[PASS] testFuzz_SetNumber(uint256) (runs: 256, μ: 31054, ~: 31288)
[PASS] test_Increment() (gas: 31303)
Suite result: ok. 2 passed; 0 failed; 0 skipped; finished in 6.29ms (5.89ms CPU time)

Ran 1 test suite in 7.54ms (6.29ms CPU time): 2 tests passed, 0 failed, 0 skipped (2 total tests)
</code></pre>
<p>你会注意到两个新目录已经出现：<code>out</code> 和 <code>cache</code>。</p>
<p><code>out</code> 目录包含你的合约工件，例如 ABI，而 <code>cache</code> 由 <code>forge</code> 使用，仅重新编译必要的部分。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="处理现有项目"><a class="header" href="#处理现有项目">处理现有项目</a></h2>
<p>Foundry 使得在现有项目上开发几乎没有开销。</p>
<p>在这个示例中，我们将使用 <a href="https://github.com/PaulRBerg" title="" target="_blank">PaulRBerg</a> 的 <a href="https://github.com/PaulRBerg/foundry-template" title="" target="_blank">
<code>foundry-template</code></a>。</p>
<p>首先，克隆项目并在项目目录中运行 <a href="projects/../reference/forge/forge-install.html"><code>forge install</code></a>。</p>
<pre><code class="language-sh">$ git clone https://github.com/PaulRBerg/foundry-template
$ cd foundry-template 
$ forge install
$ bun install # 安装 Solhint、Prettier 和其他 Node.js 依赖
</code></pre>
<p>我们运行 <a href="projects/../reference/forge/forge-install.html"><code>forge install</code></a> 来安装项目中的子模块依赖。</p>
<p>要构建，使用 <a href="projects/../reference/forge/forge-build.html"><code>forge build</code></a>：</p>
<pre><code class="language-sh">$ forge build
Compiling 28 files with Solc 0.8.25
Solc 0.8.25 finished in 1.40s
Compiler run successful!
</code></pre>
<p>要测试，使用 <a href="projects/../reference/forge/forge-test.html"><code>forge test</code></a>：</p>
<pre><code class="language-sh">$ forge test
No files changed, compilation skipped

Ran 3 tests for test/Foo.t.sol:FooTest
[PASS] testFork_Example() (gas: 3779)
[PASS] testFuzz_Example(uint256) (runs: 1000, μ: 9111, ~: 9111)
[PASS] test_Example() (gas: 11861)
Suite result: ok. 3 passed; 0 failed; 0 skipped; finished in 19.20ms (18.97ms CPU time)

Ran 1 test suite in 20.34ms (19.20ms CPU time): 3 tests passed, 0 failed, 0 skipped (3 total tests)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="在链上克隆已验证的合约"><a class="header" href="#在链上克隆已验证的合约">在链上克隆已验证的合约</a></h2>
<p>要在链上克隆已验证的合约作为 Forge 项目，请使用 <a href="projects/../reference/forge/forge-clone.html"><code>forge clone</code></a>，例如以太坊主网上的 <a href="https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2" title="" target="_blank">WETH9</a>：</p>
<pre><code class="language-sh">$ forge clone 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2 WETH9
</code></pre>
<p>这将创建一个新的目录 <code>WETH9</code>，将其配置为 foundry 项目，并将合约的所有源代码克隆到其中。这还会初始化一个新的 <code>git</code> 仓库。</p>
<pre><code class="language-sh">Downloading the source code of 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2 from Etherscan...
Initializing /home/zhan4987/WETH9...
Installing forge-std in /home/zhan4987/WETH9/lib/forge-std (url: Some("https://github.com/foundry-rs/forge-std"), tag: None)
Cloning into '/home/zhan4987/WETH9/lib/forge-std'...
remote: Enumerating objects: 2243, done.
remote: Counting objects: 100% (2238/2238), done.
remote: Compressing objects: 100% (778/778), done.
remote: Total 2243 (delta 1489), reused 2097 (delta 1391), pack-reused 5
Receiving objects: 100% (2243/2243), 649.07 KiB | 8.89 MiB/s, done.
Resolving deltas: 100% (1489/1489), done.
    Installed forge-std v1.8.1
    Initialized forge project
Collecting the creation information of 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2 from Etherscan...
Waiting for 5 seconds to avoid rate limit...
[⠊] Compiling...
[⠒] Compiling 1 files with 0.4.19
[⠢] Solc 0.4.19 finished in 9.50ms
Compiler run successful!
</code></pre>
<p>克隆的 Forge 项目除了普通 Forge 项目所具有的文件外，还带有一个额外的 <code>.clone.meta</code> 元数据文件。</p>
<p>让我们看看 <code>.clone.meta</code> 文件是什么样子的：</p>
<pre><code class="language-sh">{
  "path": "src/Contract.sol",
  "targetContract": "WETH9",
  "address": "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
  "chainId": 1,
  "creationTransaction": "0xb95343413e459a0f97461812111254163ae53467855c0d73e0f1e7c5b8442fa3",
  "deployer": "0x4f26ffbe5f04ed43630fdc30a87638d53d0b0876",
  "constructorArguments": "0x",
  "storageLayout": {
    "storage": [],
    "types": {}
  }
}
</code></pre>
<p><code>clone.meta</code> 是一个紧凑的 JSON 数据文件，包含链上合约实例的信息，例如合约地址、构造函数参数等。有关元数据的更多详细信息，请参阅 <a href="projects/../reference/forge/forge-clone.html#metadata">参考</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="依赖"><a class="header" href="#依赖">依赖</a></h2>
<p>Forge 默认使用 <a href="https://git-scm.com/book/en/v2/Git-Tools-Submodules" title="" target="_blank">git submodules</a> 管理依赖，这意味着它可以与任何包含智能合约的 GitHub 仓库一起工作。</p>
<h3 id="添加依赖"><a class="header" href="#添加依赖">添加依赖</a></h3>
<p>要添加依赖，运行 <a href="projects/../reference/forge/forge-install.html"><code>forge install</code></a>：</p>
<pre><code class="language-sh">$ forge install transmissions11/solmate
Installing solmate in /tmp/tmp.pIcNLOuNBZ/deps/lib/solmate (url: Some("https://github.com/transmissions11/solmate"), tag: None)
    Installed solmate
</code></pre>
<p>这将拉取 <code>solmate</code> 库，在 git 中暂存 <code>.gitmodules</code> 文件，并提交一条消息为 “Installed solmate” 的提交。</p>
<p>如果我们现在检查 <code>lib</code> 文件夹：</p>
<pre><code class="language-sh">$ tree lib -L 1
lib
├── forge-std
├── solmate
└── weird-erc20

3 directories, 0 files
</code></pre>
<p>我们可以看到 Forge 已经安装了 <code>solmate</code>！</p>
<p>默认情况下，<code>forge install</code> 安装最新的 master 分支版本。如果你想安装特定的标签或提交，可以这样做：</p>
<pre><code class="language-sh">$ forge install transmissions11/solmate@v7
</code></pre>
<h3 id="重映射依赖"><a class="header" href="#重映射依赖">重映射依赖</a></h3>
<p>Forge 可以重映射依赖，使其更容易导入。Forge 会自动尝试为你推导一些重映射：</p>
<pre><code class="language-sh">$ forge remappings
ds-test/=lib/solmate/lib/ds-test/src/
forge-std/=lib/forge-std/src/
solmate/=lib/solmate/src/
weird-erc20/=lib/weird-erc20/src/
</code></pre>
<p>这些重映射意味着：</p>
<ul>
<li>要从 <code>forge-std</code> 导入，我们会写：<code>import "forge-std/Contract.sol";</code></li>
<li>要从 <code>ds-test</code> 导入，我们会写：<code>import "ds-test/Contract.sol";</code></li>
<li>要从 <code>solmate</code> 导入，我们会写：<code>import "solmate/Contract.sol";</code></li>
<li>要从 <code>weird-erc20</code> 导入，我们会写：<code>import "weird-erc20/Contract.sol";</code></li>
</ul>
<p>你可以通过在项目根目录下创建一个 <code>remappings.txt</code> 文件来自定义这些重映射。</p>
<p>让我们创建一个名为 <code>solmate-utils</code> 的重映射，指向 solmate 仓库中的 <code>utils</code> 文件夹！</p>
<pre><code class="language-sh">@solmate-utils/=lib/solmate/src/utils/
</code></pre>
<p>你也可以在 <code>foundry.toml</code> 中设置重映射。</p>
<pre><code class="language-toml">remappings = [
    "@solmate-utils/=lib/solmate/src/utils/",
]
</code></pre>
<p>现在我们可以像这样导入 solmate 仓库中 <code>src/utils</code> 中的任何合约：</p>
<pre><code class="language-solidity">import "@solmate-utils/LibString.sol";
</code></pre>
<h3 id="更新依赖"><a class="header" href="#更新依赖">更新依赖</a></h3>
<p>你可以使用 <a href="projects/../reference/forge/forge-update.html"><code>forge update &lt;dep&gt;</code></a> 将特定依赖更新到你指定的版本的最新提交。例如，如果我们想从之前安装的 master 版本的 <code>solmate</code> 拉取最新提交，我们会运行：</p>
<pre><code class="language-sh">$ forge update lib/solmate
</code></pre>
<p>或者，你可以通过只运行 <code>forge update</code> 来一次性更新所有依赖。</p>
<h3 id="移除依赖"><a class="header" href="#移除依赖">移除依赖</a></h3>
<p>你可以使用 <a href="projects/../reference/forge/forge-remove.html"><code>forge remove &lt;deps&gt;...</code></a> 移除依赖，其中 <code>&lt;deps&gt;</code> 是依赖的完整路径或仅名称。例如，要移除 <code>solmate</code>，这两个命令是等效的：</p>
<pre><code class="language-ignore">$ forge remove solmate
# ... 等效于 ...
$ forge remove lib/solmate
</code></pre>
<h3 id="hardhat-兼容性"><a class="header" href="#hardhat-兼容性">Hardhat 兼容性</a></h3>
<p>Forge 还支持 Hardhat 风格的项目，其中依赖是 npm 包（存储在 <code>node_modules</code> 中），合约存储在 <code>contracts</code> 中，而不是 <code>src</code> 中。</p>
<p>要启用 Hardhat 兼容模式，请传递 <code>--hh</code> 标志。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="soldeer-作为包管理器"><a class="header" href="#soldeer-作为包管理器">Soldeer 作为包管理器</a></h2>
<p>如<a href="projects/./dependencies">这里</a>所述，Foundry 迄今为止一直使用 git 子模块来处理依赖关系。</p>
<p>随着项目变得越来越复杂，对原生包管理器的需求开始显现。</p>
<p>一个新的方法正在开发中，<a href="https://soldeer.xyz" title="" target="_blank">soldeer.xyz</a>，这是一个用 Rust 构建的 Solidity 原生依赖管理器，并且是开源的（查看仓库 <a href="https://github.com/mario-eth/soldeer" title="" target="_blank">https://github.com/mario-eth/soldeer</a>）。</p>
<h3 id="添加依赖-1"><a class="header" href="#添加依赖-1">添加依赖</a></h3>
<h4 id="添加存储在中央仓库的依赖"><a class="header" href="#添加存储在中央仓库的依赖">添加存储在中央仓库的依赖</a></h4>
<p>要添加依赖，您可以访问 <a href="https://soldeer.xyz" title="" target="_blank">soldeer.xyz</a> 并搜索您想要添加的依赖（例如，openzeppelin 0.5.2）。</p>
<p><img src="https://i.postimg.cc/Hm6R8MTs/Unknown-413.png" alt="image" /></p>
<p>然后只需运行 forge 命令：</p>
<pre><code class="language-bash">forge soldeer install @openzeppelin-contracts~5.0.2
</code></pre>
<p>这将从中央仓库下载依赖并安装到 <code>dependencies</code> 目录中。</p>
<p>Soldeer 可以管理两种类型的依赖配置：使用 <code>soldeer.toml</code> 或嵌入在 <code>foundry.toml</code> 中。为了与 Foundry 一起工作，您必须在 <code>foundry.toml</code> 中定义 <code>[dependencies]</code> 配置。这将告诉 <code>soldeer CLI</code> 在该处定义已安装的依赖。例如：</p>
<pre><code class="language-toml"># 完整参考 https://github.com/foundry-rs/foundry/tree/master/crates/config

[profile.default]
auto_detect_solc = false 
bytecode_hash = "none" 
fuzz = { runs = 1_000 } 
libs = ["dependencies"] # &lt;= 这很重要，需要添加
gas_reports = ["*"] 

[dependencies] # &lt;= 依赖将添加到此配置下
"@openzeppelin-contracts" = { version = "5.0.2" }
"@uniswap-universal-router" = { version = "1.6.0" }
"@prb-math" = { version = "4.0.2" }
forge-std = { version = "1.8.1" }
</code></pre>
<h4 id="添加存储在特定链接的依赖"><a class="header" href="#添加存储在特定链接的依赖">添加存储在特定链接的依赖</a></h4>
<p>如果中央仓库没有某个依赖，您可以通过提供一个 zip 存档链接来安装它。</p>
<p>例如：</p>
<pre><code class="language-bash">forge soldeer install @custom-dependency~1.0.0 https://my-website.com/custom-dependency-1-0-0.zip
</code></pre>
<p>上述命令将尝试从提供的链接下载依赖并将其安装为正常依赖。为此，您将在配置中看到一个额外的字段 <code>path</code>。</p>
<p>例如：</p>
<pre><code class="language-toml">[dependencies]
"@custom-dependency" = { version = "1.0.0", path = "https://my-website.com/custom-dependency-1-0-0.zip" }
</code></pre>
<h3 id="重映射依赖-1"><a class="header" href="#重映射依赖-1">重映射依赖</a></h3>
<p>依赖的重映射是自动执行的，Soldeer 会将依赖添加到 <code>remappings.txt</code> 中。</p>
<p>例如：</p>
<pre><code class="language-bash">@openzeppelin-contracts-5.0.2=dependencies/@openzeppelin-contracts-5.0.2
@uniswap-universal-router-1.6.0=dependencies/@uniswap-universal-router-1.6.0
@prb-math-4.0.2=dependencies/@prb-math-4.0.2
@forge-std-1.8.1=dependencies/forge-std-1.8.1
</code></pre>
<p>这些重映射意味着：</p>
<ul>
<li>要从 <code>forge-std</code> 导入，我们会写：<code>import "forge-std-1.8.1/Contract.sol";</code></li>
<li>要从 <code>@openzeppelin-contracts</code> 导入，我们会写：<code>import "@openzeppelin-contracts-5.0.2/Contract.sol";</code></li>
</ul>
<h3 id="更新依赖-1"><a class="header" href="#更新依赖-1">更新依赖</a></h3>
<p>因为 Soldeer 在配置文件（foundry 或 soldeer toml）中指定依赖，所以在团队中共享依赖配置变得更加容易。</p>
<p>例如，在 git 仓库中有一个 Foundry 配置文件，可以拉取仓库然后运行 <code>forge soldeer update</code>。此命令将自动安装在 <code>[dependencies]</code> 标签下指定的所有依赖。</p>
<pre><code class="language-toml"># 完整参考 https://github.com/foundry-rs/foundry/tree/master/crates/config

[profile.default]
auto_detect_solc = false 
bytecode_hash = "none" 
fuzz = { runs = 1_000 } 
gas_reports = ["*"] # &lt;= 这很重要，需要添加

[dependencies] # &lt;= 依赖将添加到此配置下
"@openzeppelin-contracts" = { version = "5.0.2" }
"@uniswap-universal-router" = { version = "1.6.0" }
"@prb-math" = { version = "4.0.2" }
forge-std = { version = "1.8.1" }
</code></pre>
<h3 id="移除依赖-1"><a class="header" href="#移除依赖-1">移除依赖</a></h3>
<p>要移除依赖，您必须手动从 <code>dependencies</code> 目录和 <code>[dependencies]</code> 标签中删除它。</p>
<h3 id="将新版本推送到中央仓库"><a class="header" href="#将新版本推送到中央仓库">将新版本推送到中央仓库</a></h3>
<p>Soldeer 类似于 npmjs/crates.io，鼓励所有开发者将他们的项目发布到中央仓库。</p>
<p>要做到这一点，您必须前往 <a href="https://soldeer.xyz" title="" target="_blank">soldeer.xyz</a>，创建一个账户，验证它，然后</p>
<p><img src="https://i.postimg.cc/G3VDpN2S/s1.png" alt="image" /></p>
<p>只需添加一个新项目</p>
<p><img src="https://i.postimg.cc/rsBRYd3L/s2.png" alt="image" /></p>
<p>项目创建后，您可以进入项目源并：</p>
<ul>
<li>创建一个 <code>.soldeerignore</code> 文件，该文件类似于 <code>.gitignore</code>，用于排除不需要的文件。</li>
<li>运行 <code>forge soldeer login</code> 登录到您的账户。</li>
<li>在您想要推送到中央仓库的目录中运行 <code>forge soldeer push my-project~1.0.0</code>。</li>
</ul>
<p>如果您想推送特定目录而不是当前终端所在的目录，可以使用 <code>forge soldeer push my-project~1.0.0 /path/to/directory</code>。</p>
<blockquote>
<p><strong>警告</strong> ⚠️</p>
<ul>
<li>一旦项目创建，无法删除。</li>
<li>一旦版本推送，无法删除。</li>
<li>您不能推送相同的版本两次。</li>
<li>在终端中运行的项目名称命令必须与在 Soldeer 网站上创建的项目名称匹配。</li>
<li>我们鼓励大家在导入依赖时使用版本固定，这将有助于通过确切知道正在使用的依赖版本来确保代码安全。此外，它将帮助安全研究人员进行工作。
例如，不要使用 <code>import '@openzeppelin-contracts/token/ERC20.sol'</code>，而应使用 <code>import '@openzeppelin-contracts-5.0.2/token/ERC20.sol'</code>。</li>
</ul>
</blockquote>
<ul>
<li>如果中央仓库中没有某个包，您可以在 <a href="https://github.com/mario-eth/soldeer/issues" title="" target="_blank">Soldeer Repository</a> 中打开一个问题，团队将考虑添加它。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="项目布局"><a class="header" href="#项目布局">项目布局</a></h2>
<p>Forge 在项目结构上非常灵活。默认结构如下：</p>
<pre><code class="language-ignore">.
├── README.md
├── foundry.toml
├── lib
│   └── forge-std
│       ├── LICENSE-APACHE
│       ├── LICENSE-MIT
│       ├── README.md
│       ├── foundry.toml
│       ├── package.json
│       ├── scripts
│       ├── src
│       └── test
├── script
│   └── Counter.s.sol
├── src
│   └── Counter.sol
└── test
    └── Counter.t.sol

8 directories, 10 files
</code></pre>
<ul>
<li>你可以使用 <code>foundry.toml</code> 配置 Foundry 的行为。</li>
<li>重映射在 <code>remappings.txt</code> 中指定。</li>
<li>合约的默认目录是 <code>src/</code>。</li>
<li>测试的默认目录是 <code>test/</code>，其中任何以 <code>test</code> 开头的函数都被视为测试。</li>
<li>依赖项作为 git 子模块存储在 <code>lib/</code> 中。</li>
</ul>
<p>你可以分别使用 <code>--lib-paths</code> 和 <code>--contracts</code> 标志来配置 Forge 查找依赖项和合约的位置。或者你可以在 <code>foundry.toml</code> 中进行配置。</p>
<p>结合重映射，这为你提供了支持其他工具链（如 Hardhat 和 Truffle）项目结构所需的灵活性。</p>
<p>为了自动支持 Hardhat，你还可以传递 <code>--hh</code> 标志，该标志设置以下标志：<code>--lib-paths node_modules --contracts contracts</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="forge-概述"><a class="header" href="#forge-概述">Forge 概述</a></h2>
<p>Forge 是 Foundry 附带的一个命令行工具。Forge 用于测试、构建和部署您的智能合约。</p>
<hr />
<h2 id="forge-commands"><a class="header" href="#forge-commands">Forge Commands</a></h2>
<p>Forge provides a variety of commands to help you manage your smart contracts. Below are some of the most commonly used commands.</p>
<h3 id="forge-init"><a class="header" href="#forge-init"><code>forge init</code></a></h3>
<p>Initializes a new Forge project.</p>
<pre><code class="language-sh">forge init
</code></pre>
<h3 id="forge-build"><a class="header" href="#forge-build"><code>forge build</code></a></h3>
<p>Compiles your smart contracts.</p>
<pre><code class="language-sh">forge build
</code></pre>
<h3 id="forge-test"><a class="header" href="#forge-test"><code>forge test</code></a></h3>
<p>Runs tests for your smart contracts.</p>
<pre><code class="language-sh">forge test
</code></pre>
<h3 id="forge-create"><a class="header" href="#forge-create"><code>forge create</code></a></h3>
<p>Deploys a smart contract to the network.</p>
<pre><code class="language-sh">forge create &lt;CONTRACT_NAME&gt; --rpc-url &lt;RPC_URL&gt; --private-key &lt;PRIVATE_KEY&gt;
</code></pre>
<h3 id="forge-install"><a class="header" href="#forge-install"><code>forge install</code></a></h3>
<p>Installs a dependency.</p>
<pre><code class="language-sh">forge install &lt;DEPENDENCY&gt;
</code></pre>
<h3 id="forge-update"><a class="header" href="#forge-update"><code>forge update</code></a></h3>
<p>Updates a dependency.</p>
<pre><code class="language-sh">forge update &lt;DEPENDENCY&gt;
</code></pre>
<h3 id="forge-remove"><a class="header" href="#forge-remove"><code>forge remove</code></a></h3>
<p>Removes a dependency.</p>
<pre><code class="language-sh">forge remove &lt;DEPENDENCY&gt;
</code></pre>
<h3 id="forge-config"><a class="header" href="#forge-config"><code>forge config</code></a></h3>
<p>Displays or sets configuration options.</p>
<pre><code class="language-sh">forge config [OPTIONS]
</code></pre>
<h3 id="forge-clean"><a class="header" href="#forge-clean"><code>forge clean</code></a></h3>
<p>Cleans the build artifacts and cache.</p>
<pre><code class="language-sh">forge clean
</code></pre>
<h3 id="forge-snapshot"><a class="header" href="#forge-snapshot"><code>forge snapshot</code></a></h3>
<p>Creates a gas usage snapshot.</p>
<pre><code class="language-sh">forge snapshot
</code></pre>
<h3 id="forge-flatten"><a class="header" href="#forge-flatten"><code>forge flatten</code></a></h3>
<p>Flattens the source code of a contract.</p>
<pre><code class="language-sh">forge flatten &lt;CONTRACT_PATH&gt;
</code></pre>
<h3 id="forge-inspect"><a class="header" href="#forge-inspect"><code>forge inspect</code></a></h3>
<p>Inspects a contract for specific details.</p>
<pre><code class="language-sh">forge inspect &lt;CONTRACT_NAME&gt; [FIELD]
</code></pre>
<h3 id="forge-verify-contract"><a class="header" href="#forge-verify-contract"><code>forge verify-contract</code></a></h3>
<p>Verifies a contract on a blockchain explorer.</p>
<pre><code class="language-sh">forge verify-contract &lt;CONTRACT_ADDRESS&gt; &lt;CONTRACT_NAME&gt; --chain-id &lt;CHAIN_ID&gt; --verifier &lt;VERIFIER&gt;
</code></pre>
<h3 id="forge-upload-selectors"><a class="header" href="#forge-upload-selectors"><code>forge upload-selectors</code></a></h3>
<p>Uploads function selectors to a blockchain explorer.</p>
<pre><code class="language-sh">forge upload-selectors &lt;CONTRACT_ADDRESS&gt; --chain-id &lt;CHAIN_ID&gt; --verifier &lt;VERIFIER&gt;
</code></pre>
<h3 id="forge-cache"><a class="header" href="#forge-cache"><code>forge cache</code></a></h3>
<p>Manages the cache.</p>
<pre><code class="language-sh">forge cache [OPTIONS]
</code></pre>
<h3 id="forge-completions"><a class="header" href="#forge-completions"><code>forge completions</code></a></h3>
<p>Generates shell completions.</p>
<pre><code class="language-sh">forge completions [SHELL]
</code></pre>
<h3 id="forge-help"><a class="header" href="#forge-help"><code>forge help</code></a></h3>
<p>Displays help information.</p>
<pre><code class="language-sh">forge help [COMMAND]
</code></pre>
<hr />
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<p>Forge can be configured via a <code>foundry.toml</code> file. This file allows you to set various options such as the default RPC URL, compiler settings, and more.</p>
<h3 id="example-foundrytoml"><a class="header" href="#example-foundrytoml">Example <code>foundry.toml</code></a></h3>
<pre><code class="language-toml">[default]
rpc_url = "https://mainnet.infura.io/v3/YOUR_API_KEY"
private_key = "YOUR_PRIVATE_KEY"

[profile.ci]
rpc_url = "https://rinkeby.infura.io/v3/YOUR_API_KEY"
private_key = "YOUR_PRIVATE_KEY"
</code></pre>
<h3 id="configuration-options"><a class="header" href="#configuration-options">Configuration Options</a></h3>
<ul>
<li><code>rpc_url</code>: The default RPC URL to use.</li>
<li><code>private_key</code>: The default private key to use.</li>
<li><code>compiler_version</code>: The Solidity compiler version to use.</li>
<li><code>optimizer</code>: Enable or disable the Solidity optimizer.</li>
<li><code>optimizer_runs</code>: The number of optimizer runs.</li>
<li><code>evm_version</code>: The EVM version to target.</li>
<li><code>libraries</code>: A list of libraries to link.</li>
<li><code>remappings</code>: A list of remappings for the compiler.</li>
<li><code>output_dir</code>: The directory to output build artifacts.</li>
<li><code>cache_dir</code>: The directory to use for caching.</li>
<li><code>gas_price</code>: The default gas price to use.</li>
<li><code>gas_limit</code>: The default gas limit to use.</li>
<li><code>chain_id</code>: The default chain ID to use.</li>
<li><code>verbosity</code>: The verbosity level for logging.</li>
</ul>
<hr />
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<p>Forge uses the <a href="https://dapp.tools/" title="" target="_blank">DappTools</a> testing framework by default. You can write tests in Solidity and run them using the <code>forge test</code> command.</p>
<h3 id="example-test"><a class="header" href="#example-test">Example Test</a></h3>
<pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "../src/MyContract.sol";

contract MyContractTest is Test {
    MyContract public myContract;

    function setUp() public {
        myContract = new MyContract();
    }

    function testIncrement() public {
        myContract.increment();
        assertEq(myContract.counter(), 1);
    }
}
</code></pre>
<h3 id="running-tests"><a class="header" href="#running-tests">Running Tests</a></h3>
<pre><code class="language-sh">forge test
</code></pre>
<hr />
<h2 id="deployment"><a class="header" href="#deployment">Deployment</a></h2>
<p>Forge makes it easy to deploy your smart contracts to various networks. You can specify the network and other parameters using the <code>forge create</code> command.</p>
<h3 id="example-deployment"><a class="header" href="#example-deployment">Example Deployment</a></h3>
<pre><code class="language-sh">forge create MyContract --rpc-url https://mainnet.infura.io/v3/YOUR_API_KEY --private-key YOUR_PRIVATE_KEY
</code></pre>
<h3 id="verifying-contracts"><a class="header" href="#verifying-contracts">Verifying Contracts</a></h3>
<p>After deploying a contract, you can verify it on a blockchain explorer using the <code>forge verify-contract</code> command.</p>
<pre><code class="language-sh">forge verify-contract &lt;CONTRACT_ADDRESS&gt; MyContract --chain-id 1 --verifier etherscan
</code></pre>
<hr />
<h2 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h2>
<p>Forge supports managing dependencies using the <code>forge install</code>, <code>forge update</code>, and <code>forge remove</code> commands.</p>
<h3 id="installing-a-dependency"><a class="header" href="#installing-a-dependency">Installing a Dependency</a></h3>
<pre><code class="language-sh">forge install OpenZeppelin/openzeppelin-contracts
</code></pre>
<h3 id="updating-a-dependency"><a class="header" href="#updating-a-dependency">Updating a Dependency</a></h3>
<pre><code class="language-sh">forge update OpenZeppelin/openzeppelin-contracts
</code></pre>
<h3 id="removing-a-dependency"><a class="header" href="#removing-a-dependency">Removing a Dependency</a></h3>
<pre><code class="language-sh">forge remove OpenZeppelin/openzeppelin-contracts
</code></pre>
<hr />
<h2 id="advanced-usage"><a class="header" href="#advanced-usage">Advanced Usage</a></h2>
<h3 id="customizing-the-compiler"><a class="header" href="#customizing-the-compiler">Customizing the Compiler</a></h3>
<p>You can customize the Solidity compiler settings in the <code>foundry.toml</code> file.</p>
<pre><code class="language-toml">[default]
compiler_version = "0.8.4"
optimizer = true
optimizer_runs = 200
evm_version = "berlin"
</code></pre>
<h3 id="using-remappings"><a class="header" href="#using-remappings">Using Remappings</a></h3>
<p>Remappings allow you to map import paths to different directories.</p>
<pre><code class="language-toml">[default]
remappings = [
    "openzeppelin-contracts/=lib/openzeppelin-contracts/",
    "my-contracts/=src/"
]
</code></pre>
<h3 id="managing-cache"><a class="header" href="#managing-cache">Managing Cache</a></h3>
<p>Forge uses a cache to speed up builds. You can manage the cache using the <code>forge cache</code> command.</p>
<pre><code class="language-sh">forge cache clear
</code></pre>
<h3 id="generating-shell-completions"><a class="header" href="#generating-shell-completions">Generating Shell Completions</a></h3>
<p>Forge can generate shell completions for easier command line usage.</p>
<pre><code class="language-sh">forge completions bash
</code></pre>
<hr />
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<h3 id="common-issues"><a class="header" href="#common-issues">Common Issues</a></h3>
<ul>
<li><strong>Compiler Errors</strong>: Ensure that your Solidity code is correct and that you are using the correct compiler version.</li>
<li><strong>RPC Issues</strong>: Ensure that your RPC URL is correct and that you have sufficient permissions.</li>
<li><strong>Deployment Failures</strong>: Ensure that your private key is correct and that you have sufficient funds.</li>
</ul>
<h3 id="getting-help"><a class="header" href="#getting-help">Getting Help</a></h3>
<p>If you encounter issues, you can use the <code>forge help</code> command or consult the <a href="https://book.getfoundry.sh/" title="" target="_blank">Foundry documentation</a>.</p>
<pre><code class="language-sh">forge help
</code></pre>
<hr />
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>Forge is a powerful tool for managing smart contracts, providing a comprehensive set of commands for testing, building, and deploying your contracts. With its flexible configuration options and support for dependencies, Forge is an essential part of the Foundry toolkit.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="测试"><a class="header" href="#测试">测试</a></h2>
<p>Forge 可以使用 <a href="forge/../reference/forge/forge-test.html"><code>forge test</code></a> 命令运行您的测试。所有测试都是用 Solidity 编写的。</p>
<p>Forge 会在您的源代码目录中查找测试。任何以 <code>test</code> 开头的函数都被视为测试。通常，测试会按照惯例放在 <code>test/</code> 目录中，并以 <code>.t.sol</code> 结尾。</p>
<p>以下是一个在新创建的项目中运行 <code>forge test</code> 的示例，该项目只有默认测试：</p>
<pre><code class="language-sh">$ forge test
No files changed, compilation skipped

Ran 2 tests for test/Counter.t.sol:CounterTest
[PASS] testFuzz_SetNumber(uint256) (runs: 256, μ: 31054, ~: 31288)
[PASS] test_Increment() (gas: 31303)
Suite result: ok. 2 passed; 0 failed; 0 skipped; finished in 6.29ms (5.89ms CPU time)

Ran 1 test suite in 7.54ms (6.29ms CPU time): 2 tests passed, 0 failed, 0 skipped (2 total tests)
</code></pre>
<p>您还可以通过传递过滤器来运行特定的测试：</p>
<pre><code class="language-sh">$ forge test --match-contract ComplicatedContractTest --match-test test_Deposit
Compiling 24 files with Solc 0.8.10
Solc 0.8.10 finished in 1.15s
Compiler run successful!

Ran 2 tests for test/ComplicatedContract.t.sol:ComplicatedContractTest
[PASS] test_DepositERC20() (gas: 102193)
[PASS] test_DepositETH() (gas: 61414)
Suite result: ok. 2 passed; 0 failed; 0 skipped; finished in 1.19ms (1.11ms CPU time)

Ran 1 test suite in 3.09ms (1.19ms CPU time): 2 tests passed, 0 failed, 0 skipped (2 total tests)
</code></pre>
<p>这将运行名为 <code>ComplicatedContractTest</code> 测试合约中的 <code>testDeposit</code> 测试。这些标志的反向版本也存在（<code>--no-match-contract</code> 和 <code>--no-match-test</code>）。</p>
<p>您可以使用 <code>--match-path</code> 运行与 glob 模式匹配的文件名中的测试。</p>
<pre><code class="language-sh">$ forge test --match-path test/ContractB.t.sol
Compiling 1 files with Solc 0.8.10
Solc 0.8.10 finished in 1.09s
Compiler run successful!

Ran 1 test for test/ContractB.t.sol:ContractBTest
[PASS] testExample() (gas: 257)
Suite result: ok. 1 passed; 0 failed; 0 skipped; finished in 356.91µs (37.59µs CPU time)

Ran 1 test suite in 2.68ms (356.91µs CPU time): 1 tests passed, 0 failed, 0 skipped (1 total tests)
</code></pre>
<p><code>--match-path</code> 标志的反向版本是 <code>--no-match-path</code>。</p>
<h3 id="日志和跟踪"><a class="header" href="#日志和跟踪">日志和跟踪</a></h3>
<p><code>forge test</code> 的默认行为是仅显示通过和失败测试的摘要。您可以通过增加详细程度（使用 <code>-v</code> 标志）来控制此行为。每个详细程度级别都会添加更多信息：</p>
<ul>
<li><strong>级别 2 (<code>-vv</code>)</strong>：还会显示测试期间发出的日志。这包括测试中的断言错误，显示预期值与实际值的信息。</li>
<li><strong>级别 3 (<code>-vvv</code>)</strong>：还会显示失败测试的堆栈跟踪。</li>
<li><strong>级别 4 (<code>-vvvv</code>)</strong>：显示所有测试的堆栈跟踪，并显示失败测试的设置跟踪。</li>
<li><strong>级别 5 (<code>-vvvvv</code>)</strong>：始终显示堆栈跟踪和设置跟踪。</li>
</ul>
<h3 id="监视模式"><a class="header" href="#监视模式">监视模式</a></h3>
<p>Forge 可以在您对文件进行更改时重新运行测试，使用 <code>forge test --watch</code>。</p>
<p>默认情况下，只有更改的测试文件会重新运行。如果您希望在更改时重新运行所有测试，可以使用 <code>forge test --watch --run-all</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="编写测试"><a class="header" href="#编写测试">编写测试</a></h2>
<p>测试是用 Solidity 编写的。如果测试函数回滚，则测试失败，否则通过。</p>
<p>让我们使用 <a href="https://github.com/foundry-rs/forge-std" title="" target="_blank">Forge Standard Library</a> 的 <code>Test</code> 合约来编写测试，这是使用 Forge 编写测试的首选方式。</p>
<p>在本节中，我们将使用 Forge Std 的 <code>Test</code> 合约中的函数来介绍基础知识，该合约本身是 <a href="https://github.com/dapphub/ds-test" title="" target="_blank">DSTest</a> 的超集。您将很快学习如何使用 Forge Standard Library 中的更多高级功能。</p>
<p>DSTest 提供了基本的日志记录和断言功能。要访问这些函数，请导入 <code>forge-std/Test.sol</code> 并在您的测试合约中继承 <code>Test</code>：</p>
<pre><code class="language-solidity">import "forge-std/Test.sol";
</code></pre>
<p>让我们检查一个基本的测试：</p>
<pre><code class="language-solidity">pragma solidity 0.8.10;

import "forge-std/Test.sol";

contract ContractBTest is Test {
    uint256 testNumber;

    function setUp() public {
        testNumber = 42;
    }

    function test_NumberIs42() public {
        assertEq(testNumber, 42);
    }

    function testFail_Subtract43() public {
        testNumber -= 43;
    }
}
</code></pre>
<p>Forge 在测试中使用以下关键字：</p>
<ul>
<li><code>setUp</code>：在每个测试用例运行之前调用的可选函数。</li>
</ul>
<pre><code class="language-solidity">    function setUp() public {
        testNumber = 42;
    }
</code></pre>
<ul>
<li><code>test</code>：以 <code>test</code> 前缀的函数作为测试用例运行。</li>
</ul>
<pre><code class="language-solidity">    function test_NumberIs42() public {
        assertEq(testNumber, 42);
    }
</code></pre>
<ul>
<li><code>testFail</code>：<code>test</code> 前缀的反向 - 如果函数不回滚，则测试失败。</li>
</ul>
<pre><code class="language-solidity">    function testFail_Subtract43() public {
        testNumber -= 43;
    }
</code></pre>
<p>一个好的实践是使用 <code>test_Revert[If|When]_Condition</code> 模式与 <a href="forge/../cheatcodes/expect-revert.html"><code>expectRevert</code></a> 作弊码（作弊码将在后面的<a href="forge/./cheatcodes.html">部分</a>中详细解释）结合使用。此外，其他测试实践可以在<a href="forge/../tutorials/best-practices.html">教程部分</a>中找到。现在，您可以确切地知道什么回滚以及回滚的错误是什么，而不是使用 <code>testFail</code>：</p>
<pre><code class="language-solidity">    function test_CannotSubtract43() public {
        vm.expectRevert(stdError.arithmeticError);
        testNumber -= 43;
    }
</code></pre>
<br>
<p>测试被部署到 <code>0xb4c79daB8f259C7Aee6E5b2Aa729821864227e84</code>。如果您在测试中部署合约，那么 <code>0xb4c...7e84</code> 将是其部署者。如果测试中部署的合约给予其部署者特殊权限，例如 <code>Ownable.sol</code> 的 <code>onlyOwner</code> 修饰符，那么测试合约 <code>0xb4c...7e84</code> 将拥有这些权限。</p>
<blockquote>
<p>⚠️ <strong>注意</strong></p>
<p>测试函数必须具有 <code>external</code> 或 <code>public</code> 可见性。声明为 <code>internal</code> 或 <code>private</code> 的函数不会被 Forge 拾取，即使它们带有 <code>test</code> 前缀。</p>
</blockquote>
<h3 id="共享设置"><a class="header" href="#共享设置">共享设置</a></h3>
<p>可以通过创建辅助抽象合约并在测试合约中继承它们来使用共享设置：</p>
<pre><code class="language-solidity">abstract contract HelperContract {
    address constant IMPORTANT_ADDRESS = 0x543d...;
    SomeContract someContract;
    constructor() {...}
}

contract MyContractTest is Test, HelperContract {
    function setUp() public {
        someContract = new SomeContract(0, IMPORTANT_ADDRESS);
        ...
    }
}

contract MyOtherContractTest is Test, HelperContract {
    function setUp() public {
        someContract = new SomeContract(1000, IMPORTANT_ADDRESS);
        ...
    }
}
</code></pre>
<br>
<blockquote>
<p>💡 <strong>提示</strong></p>
<p>使用 <a href="forge/../cheatcodes/get-code.html"><code>getCode</code></a> 作弊码来部署具有不兼容 Solidity 版本的合约。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="作弊码"><a class="header" href="#作弊码">作弊码</a></h2>
<p>大多数情况下，仅仅测试智能合约的输出是不够的。为了操纵区块链的状态，以及测试特定的回滚和事件，Foundry 提供了一组作弊码。</p>
<p>作弊码允许你改变区块号、身份等。它们通过在特定地址上调用特定函数来调用：<code>0x7109709ECfa91a80626fF3989D68f67F5b1DD12D</code>。</p>
<p>你可以通过 Forge 标准库中的 <code>Test</code> 合约中可用的 <code>vm</code> 实例轻松访问作弊码。Forge 标准库在后面的<a href="forge/./forge-std.html">章节</a>中有更详细的解释。</p>
<p>让我们为一个只能由其所有者调用的智能合约编写测试。</p>
<pre><code class="language-solidity">pragma solidity 0.8.10;

import "forge-std/Test.sol";

error Unauthorized();

contract OwnerUpOnly {
    address public immutable owner;
    uint256 public count;

    constructor() {
        owner = msg.sender;
    }

    function increment() external {
        if (msg.sender != owner) {
            revert Unauthorized();
        }
        count++;
    }
}

contract OwnerUpOnlyTest is Test {
    OwnerUpOnly upOnly;

    function setUp() public {
        upOnly = new OwnerUpOnly();
    }

    function test_IncrementAsOwner() public {
        assertEq(upOnly.count(), 0);
        upOnly.increment();
        assertEq(upOnly.count(), 1);
    }
}
</code></pre>
<p>如果我们现在运行 <code>forge test</code>，我们会看到测试通过，因为 <code>OwnerUpOnlyTest</code> 是 <code>OwnerUpOnly</code> 的所有者。</p>
<pre><code class="language-ignore">$ forge test
Compiling 24 files with Solc 0.8.10
Solc 0.8.10 finished in 1.20s
Compiler run successful!

Ran 1 test for test/OwnerUpOnly.t.sol:OwnerUpOnlyTest
[PASS] test_IncrementAsOwner() (gas: 29161)
Suite result: ok. 1 passed; 0 failed; 0 skipped; finished in 510.77µs (66.88µs CPU time)

Ran 1 test suite in 2.75ms (510.77µs CPU time): 1 tests passed, 0 failed, 0 skipped (1 total tests)
</code></pre>
<p>让我们确保一个绝对不是所有者的人不能增加计数：</p>
<pre><code class="language-solidity">contract OwnerUpOnlyTest is Test {
    OwnerUpOnly upOnly;

    // ...

    function testFail_IncrementAsNotOwner() public {
        vm.prank(address(0));
        upOnly.increment();
    }
}
</code></pre>
<p>如果我们现在运行 <code>forge test</code>，我们会看到所有测试都通过了。</p>
<pre><code class="language-ignore">$ forge test
No files changed, compilation skipped

Ran 2 tests for test/OwnerUpOnly.t.sol:OwnerUpOnlyTest
[PASS] testFail_IncrementAsNotOwner() (gas: 8314)
[PASS] test_IncrementAsOwner() (gas: 29161)
Suite result: ok. 2 passed; 0 failed; 0 skipped; finished in 549.31µs (206.32µs CPU time)

Ran 1 test suite in 2.96ms (549.31µs CPU time): 2 tests passed, 0 failed, 0 skipped (2 total tests)
</code></pre>
<p>测试通过是因为 <code>prank</code> 作弊码将我们的身份更改为零地址，以便下一次调用（<code>upOnly.increment()</code>）。测试用例通过是因为我们使用了 <code>testFail</code> 前缀，然而，使用 <code>testFail</code> 被认为是一种反模式，因为它没有告诉我们 <code>upOnly.increment()</code> 回滚的任何原因。</p>
<p>如果我们再次运行带有跟踪的测试，我们可以看到我们回滚了正确的错误消息。</p>
<pre><code class="language-ignore">$ forge test -vvvv --match-test testFail_IncrementAsNotOwner
No files changed, compilation skipped

Ran 1 test for test/OwnerUpOnly.t.sol:OwnerUpOnlyTest
[PASS] testFail_IncrementAsNotOwner() (gas: 8314)
Traces:
  [8314] OwnerUpOnlyTest::testFail_IncrementAsNotOwner()
    ├─ [0] VM::prank(0x0000000000000000000000000000000000000000)
    │   └─ ← [Return] 
    ├─ [247] OwnerUpOnly::increment()
    │   └─ ← [Revert] Unauthorized()
    └─ ← [Revert] Unauthorized()

Suite result: ok. 1 passed; 0 failed; 0 skipped; finished in 526.02µs (70.41µs CPU time)

Ran 1 test suite in 2.91ms (526.02µs CPU time): 1 tests passed, 0 failed, 0 skipped (1 total tests)
</code></pre>
<p>为了确保将来我们回滚是因为我们不是所有者，让我们使用 <code>expectRevert</code> 作弊码：</p>
<pre><code class="language-solidity">contract OwnerUpOnlyTest is Test {
    OwnerUpOnly upOnly;

    // ...

    // Notice that we replaced `testFail` with `test`
    function test_RevertWhen_CallerIsNotOwner() public {
        vm.expectRevert(Unauthorized.selector);
        vm.prank(address(0));
        upOnly.increment();
    }
}
</code></pre>
<p>如果我们最后一次运行 <code>forge test</code>，我们看到测试仍然通过，但这次我们确定如果因为任何其他原因回滚，它将始终失败。</p>
<pre><code class="language-ignore">$ forge test
No files changed, compilation skipped

Ran 1 test for test/OwnerUpOnly.t.sol:OwnerUpOnlyTest
[PASS] test_IncrementAsOwner() (gas: 29161)
Suite result: ok. 1 passed; 0 failed; 0 skipped; finished in 478.13µs (70.15µs CPU time)

Ran 1 test suite in 2.81ms (478.13µs CPU time): 1 tests passed, 0 failed, 0 skipped (1 total tests)
</code></pre>
<p>另一个可能不太直观的作弊码是 <code>expectEmit</code> 函数。在查看 <code>expectEmit</code> 之前，我们需要了解什么是事件。</p>
<p>事件是合约的可继承成员。当你发出一个事件时，参数会存储在区块链上。最多可以将事件的三个参数添加 <code>indexed</code> 属性，以形成称为“主题”的数据结构。主题允许用户在区块链上搜索事件。</p>
<pre><code class="language-solidity">pragma solidity 0.8.10;

import "forge-std/Test.sol";

contract EmitContractTest is Test {
    event Transfer(address indexed from, address indexed to, uint256 amount);

    function test_ExpectEmit() public {
        ExpectEmit emitter = new ExpectEmit();
        // Check that topic 1, topic 2, and data are the same as the following emitted event.
        // Checking topic 3 here doesn't matter, because `Transfer` only has 2 indexed topics.
        vm.expectEmit(true, true, false, true);
        // The event we expect
        emit Transfer(address(this), address(1337), 1337);
        // The event we get
        emitter.t();
    }

    function test_ExpectEmit_DoNotCheckData() public {
        ExpectEmit emitter = new ExpectEmit();
        // Check topic 1 and topic 2, but do not check data
        vm.expectEmit(true, true, false, false);
        // The event we expect
        emit Transfer(address(this), address(1337), 1338);
        // The event we get
        emitter.t();
    }
}

contract ExpectEmit {
    event Transfer(address indexed from, address indexed to, uint256 amount);

    function t() public {
        emit Transfer(msg.sender, address(1337), 1337);
    }
}
</code></pre>
<p>当我们调用 <code>vm.expectEmit(true, true, false, true);</code> 时，我们希望检查下一个事件的第 1 和第 2 个 <code>indexed</code> 主题。</p>
<p><code>test_ExpectEmit()</code> 中的预期 <code>Transfer</code> 事件意味着我们期望 <code>from</code> 是 <code>address(this)</code>，而 <code>to</code> 是 <code>address(1337)</code>。这与从 <code>emitter.t()</code> 发出的事件进行比较。</p>
<p>换句话说，我们正在检查 <code>emitter.t()</code> 的第一个主题是否等于 <code>address(this)</code>。<code>expectEmit</code> 的第三个参数设置为 <code>false</code>，因为不需要检查 <code>Transfer</code> 事件的第三个主题，因为只有两个。即使我们设置为 <code>true</code>，也没有关系。</p>
<p><code>expectEmit</code> 的第四个参数设置为 <code>true</code>，这意味着我们希望检查“非索引主题”，也称为数据。</p>
<p>例如，我们希望 <code>test_ExpectEmit</code> 中预期事件的数据（即 <code>amount</code>）等于实际发出事件中的数据。换句话说，我们断言 <code>emitter.t()</code> 发出的 <code>amount</code> 等于 <code>1337</code>。如果 <code>expectEmit</code> 的第四个参数设置为 <code>false</code>，我们将不会检查 <code>amount</code>。</p>
<p>换句话说，即使数量不同，<code>test_ExpectEmit_DoNotCheckData</code> 也是一个有效的测试用例，因为我们不检查数据。</p>
<br>
<blockquote>
<p>📚 <strong>参考</strong></p>
<p>请参阅<a href="forge/../cheatcodes/">作弊码参考</a>以获取所有可用作弊码的完整概述。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="forge-标准库概述"><a class="header" href="#forge-标准库概述">Forge 标准库概述</a></h2>
<p>Forge 标准库（简称 Forge Std）是一组有用的合约，使编写测试更容易、更快、更用户友好。</p>
<p>使用 Forge Std 是使用 Foundry 编写测试的首选方式。</p>
<p>它提供了开始编写测试所需的所有基本功能：</p>
<ul>
<li><code>Vm.sol</code>：最新的作弊码接口</li>
<li><code>console.sol</code> 和 <code>console2.sol</code>：Hardhat 风格的日志功能</li>
<li><code>Script.sol</code>：用于 <a href="forge/../tutorials/solidity-scripting.html">Solidity 脚本</a> 的基本实用程序</li>
<li><code>Test.sol</code>：包含标准库、作弊码实例（<code>vm</code>）和 Hardhat 控制台的 DSTest 超集</li>
</ul>
<p>只需导入 <code>Test.sol</code> 并在测试合约中继承 <code>Test</code>：</p>
<pre><code class="language-solidity">import "forge-std/Test.sol";

contract ContractTest is Test { ...
</code></pre>
<p>现在，你可以：</p>
<pre><code class="language-solidity">// 通过 `vm` 实例访问 Hevm
vm.startPrank(alice);

// 使用 Dappsys Test 进行断言和日志
assertEq(dai.balanceOf(alice), 10000e18);

// 使用 Hardhat `console` (`console2`) 进行日志
console.log(alice.balance);

// 使用 Forge Std 标准库中的任何内容
deal(address(dai), alice, 10000e18);
</code></pre>
<p>要单独导入 <code>Vm</code> 接口或 <code>console</code> 库：</p>
<pre><code class="language-solidity">import "forge-std/Vm.sol";
</code></pre>
<pre><code class="language-solidity">import "forge-std/console.sol";
</code></pre>
<p><strong>注意：</strong> <code>console2.sol</code> 包含对 <code>console.sol</code> 的补丁，允许 Forge 解码对控制台的调用跟踪，但它与 Hardhat 不兼容。</p>
<pre><code class="language-solidity">import "forge-std/console2.sol";
</code></pre>
<h3 id="标准库"><a class="header" href="#标准库">标准库</a></h3>
<p>Forge Std 目前由六个标准库组成。</p>
<h4 id="std-logs"><a class="header" href="#std-logs">Std Logs</a></h4>
<p>Std Logs 扩展了 <a href="forge/../reference/ds-test.html#logging"><code>DSTest</code></a> 库的日志事件。</p>
<h4 id="std-assertions"><a class="header" href="#std-assertions">Std Assertions</a></h4>
<p>Std Assertions 扩展了 <a href="forge/../reference/ds-test.html#asserting"><code>DSTest</code></a> 库的断言函数。</p>
<h4 id="std-cheats"><a class="header" href="#std-cheats">Std Cheats</a></h4>
<p>Std Cheats 是围绕 Forge 作弊码的包装器，使它们更安全且改善了开发体验（DX）。</p>
<p>你可以在测试合约中简单地调用它们，就像调用任何其他内部函数一样：</p>
<pre><code class="language-solidity">// 以 Alice 身份设置一个恶作剧，余额为 100 ETH
hoax(alice, 100 ether);
</code></pre>
<h4 id="std-errors"><a class="header" href="#std-errors">Std Errors</a></h4>
<p>Std Errors 提供了围绕常见内部 Solidity 错误和回滚的包装器。</p>
<p>Std Errors 在与 <a href="forge/../cheatcodes/expect-revert.html"><code>expectRevert</code></a> 作弊码结合使用时最有用，因为你不需要记住内部 Solidity 恐慌代码。注意，你必须通过 <code>stdError</code> 访问它们，因为这是一个库。</p>
<pre><code class="language-solidity">// 在下一次调用时预期一个算术错误（例如下溢）
vm.expectRevert(stdError.arithmeticError);
</code></pre>
<h4 id="std-storage"><a class="header" href="#std-storage">Std Storage</a></h4>
<p>Std Storage 使操作合约存储变得容易。它可以找到并与特定变量关联的存储槽进行读写。</p>
<p><code>Test</code> 合约已经通过 <code>stdstore</code> 提供了一个 <code>StdStorage</code> 实例，你可以通过它访问任何 std-storage 功能。注意，你必须首先在你的测试合约中添加 <code>using stdStorage for StdStorage</code>。</p>
<pre><code class="language-solidity">// 在合约 `game` 中找到变量 `score`
// 并将其值更改为 10
stdstore
    .target(address(game))
    .sig(game.score.selector)
    .checked_write(10);
</code></pre>
<h4 id="std-math"><a class="header" href="#std-math">Std Math</a></h4>
<p>Std Math 是一个包含 Solidity 中未提供的实用数学函数的库。</p>
<p>注意，你必须通过 <code>stdMath</code> 访问它们，因为这是一个库。</p>
<pre><code class="language-solidity">// 获取 -10 的绝对值
uint256 ten = stdMath.abs(-10)
</code></pre>
<br>
<blockquote>
<p>📚 <strong>参考</strong></p>
<p>请参阅 <a href="forge/../reference/forge-std/">Forge 标准库参考</a> 以获取 Forge 标准库的完整概述。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="理解追踪"><a class="header" href="#理解追踪">理解追踪</a></h2>
<p>Forge 可以为失败的测试（<code>-vvv</code>）或所有测试（<code>-vvvv</code>）生成追踪。</p>
<p>追踪遵循相同的一般格式：</p>
<pre><code class="language-ignore">  [&lt;Gas 使用量&gt;] &lt;合约&gt;::&lt;函数&gt;(&lt;参数&gt;)
    ├─ [&lt;Gas 使用量&gt;] &lt;合约&gt;::&lt;函数&gt;(&lt;参数&gt;)
    │   └─ ← &lt;返回值&gt;
    └─ ← &lt;返回值&gt;
</code></pre>
<p>每个追踪可以有许多更多的子追踪，每个子追踪表示对合约的调用和返回值。</p>
<p>如果你的终端支持颜色，追踪还会带有各种颜色：</p>
<ul>
<li><strong>绿色</strong>：表示不回滚的调用</li>
<li><strong>红色</strong>：表示回滚的调用</li>
<li><strong>蓝色</strong>：表示对作弊代码的调用</li>
<li><strong>青色</strong>：表示发出的日志</li>
<li><strong>黄色</strong>：表示合约部署</li>
</ul>
<p>Gas 使用量（标记在方括号中）是整个函数调用的总量。然而，你可能会注意到，有时一个追踪的 Gas 使用量并不完全匹配其所有子追踪的 Gas 使用量：</p>
<pre><code class="language-ignore">  [24661] OwnerUpOnlyTest::testIncrementAsOwner()
    ├─ [2262] OwnerUpOnly::count()
    │   └─ ← 0
    ├─ [20398] OwnerUpOnly::increment()
    │   └─ ← ()
    ├─ [262] OwnerUpOnly::count()
    │   └─ ← 1
    └─ ← ()
</code></pre>
<p>未计算的 Gas 是由于在调用之间发生的一些额外操作，例如算术和存储读/写。</p>
<p>Forge 会尝试解码尽可能多的签名和值，但有时这是不可能的。在这些情况下，追踪将如下所示：</p>
<pre><code class="language-ignore">  [&lt;Gas 使用量&gt;] &lt;地址&gt;::&lt;调用数据&gt;
    └─ ← &lt;返回数据&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="分叉测试"><a class="header" href="#分叉测试">分叉测试</a></h2>
<p>Forge 支持在分叉环境中进行测试，有两种不同的方法：</p>
<ul>
<li><a href="forge/fork-testing.html#forking-mode"><strong>分叉模式</strong></a> — 通过 <code>forge test --fork-url</code> 标志使用单个分叉进行所有测试</li>
<li><a href="forge/fork-testing.html#forking-cheatcodes"><strong>分叉作弊码</strong></a> — 直接在 Solidity 测试代码中创建、选择和管理多个分叉，使用 <a href="forge/../cheatcodes/forking.html">分叉作弊码</a></li>
</ul>
<p>使用哪种方法？分叉模式允许针对特定的分叉环境运行整个测试套件，而分叉作弊码提供更多的灵活性和表达性，以便在测试中使用多个分叉。您的具体用例和测试策略将有助于决定使用哪种方法。</p>
<h3 id="分叉模式"><a class="header" href="#分叉模式">分叉模式</a></h3>
<p>要在分叉环境中运行所有测试，例如分叉的以太坊主网，通过 <code>--fork-url</code> 标志传递一个 RPC URL：</p>
<pre><code class="language-bash">forge test --fork-url &lt;your_rpc_url&gt;
</code></pre>
<p>以下值将更改为分叉时刻的链上值：</p>
<ul>
<li><a href="forge/../reference/config/testing.html#block_number"><code>block_number</code></a></li>
<li><a href="forge/../reference/config/testing.html#chain_id"><code>chain_id</code></a></li>
<li><a href="forge/../reference/config/testing.html#gas_limit"><code>gas_limit</code></a></li>
<li><a href="forge/../reference/config/testing.html#gas_price"><code>gas_price</code></a></li>
<li><a href="forge/../reference/config/testing.html#block_base_fee_per_gas"><code>block_base_fee_per_gas</code></a></li>
<li><a href="forge/../reference/config/testing.html#block_coinbase"><code>block_coinbase</code></a></li>
<li><a href="forge/../reference/config/testing.html#block_timestamp"><code>block_timestamp</code></a></li>
<li><a href="forge/../reference/config/testing.html#block_difficulty"><code>block_difficulty</code></a></li>
</ul>
<p>可以使用 <code>--fork-block-number</code> 指定从哪个区块分叉：</p>
<pre><code class="language-bash">forge test --fork-url &lt;your_rpc_url&gt; --fork-block-number 1
</code></pre>
<p>分叉在需要与现有合约交互时特别有用。您可以选择这种方式进行集成测试，就像在实际网络上一样。</p>
<h4 id="缓存"><a class="header" href="#缓存">缓存</a></h4>
<p>如果同时指定了 <code>--fork-url</code> 和 <code>--fork-block-number</code>，则该区块的数据会缓存以供将来测试运行。</p>
<p>数据缓存路径为 <code>~/.foundry/cache/rpc/&lt;chain name&gt;/&lt;block number&gt;</code>。要清除缓存，只需删除目录或运行 <a href="forge/../reference/forge/forge-clean.html"><code>forge clean</code></a>（删除所有构建工件和缓存目录）。</p>
<p>也可以通过传递 <code>--no-storage-caching</code> 完全忽略缓存，或在 <code>foundry.toml</code> 中通过配置 <a href="forge/../reference/config/testing.html#no_storage_caching"><code>no_storage_caching</code></a> 和 <a href="forge/../reference/config/testing.html#rpc_storage_caching"><code>rpc_storage_caching</code></a> 来实现。</p>
<h4 id="改进的跟踪"><a class="header" href="#改进的跟踪">改进的跟踪</a></h4>
<p>Forge 支持在分叉环境中通过 Etherscan 识别合约。</p>
<p>要使用此功能，通过 <code>--etherscan-api-key</code> 标志传递 Etherscan API 密钥：</p>
<pre><code class="language-bash">forge test --fork-url &lt;your_rpc_url&gt; --etherscan-api-key &lt;your_etherscan_api_key&gt;
</code></pre>
<p>或者，您可以设置 <code>ETHERSCAN_API_KEY</code> 环境变量。</p>
<h3 id="分叉作弊码"><a class="header" href="#分叉作弊码">分叉作弊码</a></h3>
<p>分叉作弊码允许您在 Solidity 测试代码中以编程方式进入分叉模式。与通过 <code>forge</code> CLI 参数配置分叉模式不同，这些作弊码允许您在测试中按需使用分叉模式，并在测试中使用多个分叉。每个分叉通过其唯一的 <code>uint256</code> 标识符进行识别。</p>
<h4 id="使用方法"><a class="header" href="#使用方法">使用方法</a></h4>
<p>重要的是要记住，<em>所有</em> 测试函数都是隔离的，这意味着每个测试函数都在其自己的独立 EVM 中执行，状态是 <code>setUp</code> 之后的副本。</p>
<p>因此，在 <code>setUp</code> 期间创建的分叉在测试中可用。下面的代码示例使用 <a href="forge/../cheatcodes/create-fork.html"><code>createFork</code></a> 创建两个分叉，但最初不选择其中一个。每个分叉通过唯一的标识符（<code>uint256 forkId</code>）进行识别，该标识符在首次创建时分配。</p>
<p>通过将该 <code>forkId</code> 传递给 <a href="forge/../cheatcodes/select-fork.html"><code>selectFork</code></a> 来启用特定分叉。</p>
<p><a href="forge/../cheatcodes/create-select-fork.html"><code>createSelectFork</code></a> 是 <code>createFork</code> 加上 <code>selectFork</code> 的一行代码。</p>
<p>同一时间只能有一个分叉处于活动状态，当前活动分叉的标识符可以通过 <a href="forge/../cheatcodes/active-fork.html"><code>activeFork</code></a> 获取。</p>
<p>类似于 <a href="forge/../cheatcodes/roll.html"><code>roll</code></a>，您可以使用 <a href="forge/../cheatcodes/roll-fork.html"><code>rollFork</code></a> 设置分叉的 <code>block.number</code>。</p>
<p>要理解选择分叉时会发生什么，重要的是要知道分叉模式的一般工作原理：</p>
<p>每个分叉都是一个独立的 EVM，即所有分叉使用完全独立的存储。唯一的例外是 <code>msg.sender</code> 和测试合约本身的状态，这些状态在分叉切换时是持久的。换句话说，在分叉 <code>A</code> 处于活动状态时（<code>selectFork(A)</code>）所做的所有更改仅记录在分叉 <code>A</code> 的存储中，如果选择另一个分叉，则不可用。然而，记录在测试合约本身（变量）中的更改仍然可用，因为测试合约是一个 <em>持久</em> 账户。</p>
<p><code>selectFork</code> 作弊码设置带有分叉数据源的 <em>远程</em> 部分，然而 <em>本地</em> 内存跨分叉切换保持持久。这也意味着 <code>selectFork</code> 可以在任何时候使用任何分叉调用，以设置 <em>远程</em> 数据源。然而，重要的是要记住上述 <code>读/写</code> 访问规则始终适用，意味着 <em>写</em> 操作跨分叉切换是持久的。</p>
<h4 id="示例"><a class="header" href="#示例">示例</a></h4>
<h5 id="创建和选择分叉"><a class="header" href="#创建和选择分叉">创建和选择分叉</a></h5>
<pre><code class="language-solidity">contract ForkTest is Test {
    // 分叉的标识符
    uint256 mainnetFork;
    uint256 optimismFork;

    // 通过 vm.envString("varname") 访问 .env 文件中的变量
    // 将 ALCHEMY_KEY 替换为您的 alchemy 密钥或 Etherscan 密钥，根据需要更改 RPC url
    // 在您的 .env 文件中，例如：
    // MAINNET_RPC_URL = 'https://eth-mainnet.g.alchemy.com/v2/ALCHEMY_KEY'
    // string MAINNET_RPC_URL = vm.envString("MAINNET_RPC_URL");
    // string OPTIMISM_RPC_URL = vm.envString("OPTIMISM_RPC_URL");

    // 在 setup 期间创建两个 _不同的_ 分叉
    function setUp() public {
        mainnetFork = vm.createFork(MAINNET_RPC_URL);
        optimismFork = vm.createFork(OPTIMISM_RPC_URL);
    }

    // 演示分叉标识符是唯一的
    function testForkIdDiffer() public {
        assert(mainnetFork != optimismFork);
    }

    // 选择特定的分叉
    function testCanSelectFork() public {
        // 选择分叉
        vm.selectFork(mainnetFork);
        assertEq(vm.activeFork(), mainnetFork);

        // 从这里开始，如果 EVM 请求数据，则从 `mainnetFork` 获取数据并写入 `mainnetFork` 的存储
    }

    // 在同一个测试中管理多个分叉
    function testCanSwitchForks() public {
        vm.selectFork(mainnetFork);
        assertEq(vm.activeFork(), mainnetFork);

        vm.selectFork(optimismFork);
        assertEq(vm.activeFork(), optimismFork);
    }

    // 可以在任何时候创建分叉
    function testCanCreateAndSelectForkInOneStep() public {
        // 创建一个新的分叉并选择它
        uint256 anotherFork = vm.createSelectFork(MAINNET_RPC_URL);
        assertEq(vm.activeFork(), anotherFork);
    }

    // 设置分叉的 `block.number`
    function testCanSetForkBlockNumber() public {
        vm.selectFork(mainnetFork);
        vm.rollFork(1_337_000);

        assertEq(block.number, 1_337_000);
    }
}
</code></pre>
<h5 id="分离和持久的存储"><a class="header" href="#分离和持久的存储">分离和持久的存储</a></h5>
<p>如前所述，每个分叉本质上是一个独立的 EVM，具有分离的存储。</p>
<p>只有 <code>msg.sender</code> 和测试合约（<code>ForkTest</code>）的账户在分叉选择时是持久的。但任何账户都可以变成持久账户：<a href="forge/../cheatcodes/make-persistent.html"><code>makePersistent</code></a>。</p>
<p>一个 <em>持久</em> 账户是唯一的，即它存在于所有分叉上。</p>
<pre><code class="language-solidity">contract ForkTest is Test {
    // 分叉的标识符
    uint256 mainnetFork;
    uint256 optimismFork;

    // 通过 vm.envString("varname") 访问 .env 文件中的变量
    // 将 ALCHEMY_KEY 替换为您的 alchemy 密钥或 Etherscan 密钥，根据需要更改 RPC url
    // 在您的 .env 文件中，例如：
    // MAINNET_RPC_URL = 'https://eth-mainnet.g.alchemy.com/v2/ALCHEMY_KEY'
    // string MAINNET_RPC_URL = vm.envString("MAINNET_RPC_URL");
    // string OPTIMISM_RPC_URL = vm.envString("OPTIMISM_RPC_URL");

    // 在 setup 期间创建两个 _不同的_ 分叉
    function setUp() public {
        mainnetFork = vm.createFork(MAINNET_RPC_URL);
        optimismFork = vm.createFork(OPTIMISM_RPC_URL);
    }

    // 在一个分叉处于活动状态时创建新合约
    function testCreateContract() public {
        vm.selectFork(mainnetFork);
        assertEq(vm.activeFork(), mainnetFork);

        // 新合约写入 `mainnetFork` 的存储
        SimpleStorageContract simple = new SimpleStorageContract();

        // 并可以正常使用
        simple.set(100);
        assertEq(simple.value(), 100);

        // 切换到另一个合约后，我们仍然知道 `address(simple)`，但合约仅存在于 `mainnetFork` 中
        vm.selectFork(optimismFork);

        /* 此调用将因此恢复，因为 `simple` 现在指向一个在活动分叉上不存在的合约
        * 它将产生以下恢复消息：
        *
        * "Contract 0xCe71065D4017F316EC606Fe4422e11eB2c47c246 does not exist on active fork with id `1`
        *       But exists on non active forks: `[0]`"
        */
        simple.value();
    }

     // 在一个分叉处于活动状态时创建新的 _持久_ 合约
     function testCreatePersistentContract() public {
        vm.selectFork(mainnetFork);
        SimpleStorageContract simple = new SimpleStorageContract();
        simple.set(100);
        assertEq(simple.value(), 100);

        // 将合约标记为持久，以便在其他分叉处于活动状态时也可用
        vm.makePersistent(address(simple));
        assert(vm.isPersistent(address(simple)));

        vm.selectFork(optimismFork);
        assert(vm.isPersistent(address(simple)));

        // 这将成功，因为合约现在在 `optimismFork` 上也可用
        assertEq(simple.value(), 100);
     }
}

contract SimpleStorageContract {
    uint256 public value;

    function set(uint256 _value) public {
        value = _value;
    }
}
</code></pre>
<p>有关更多详细信息和示例，请参阅 <a href="forge/../cheatcodes/forking.html">分叉作弊码</a> 参考。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="高级测试"><a class="header" href="#高级测试">高级测试</a></h2>
<p>Forge 提供了多种高级测试方法：</p>
<ul>
<li><a href="forge/./fuzz-testing.html">模糊测试</a></li>
<li><a href="forge/./invariant-testing.html">不变性测试</a></li>
<li><a href="forge/./differential-ffi-testing.html">差异测试</a></li>
</ul>
<p>未来，Forge 还将支持以下测试方法：</p>
<ul>
<li><a href="forge/advanced-testing.html#">符号执行</a></li>
<li><a href="forge/advanced-testing.html#">变异测试</a></li>
</ul>
<p>每个章节都会深入探讨这些测试方法解决的问题，以及如何将它们应用到您自己的项目中。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="模糊测试"><a class="header" href="#模糊测试">模糊测试</a></h2>
<p>Forge 支持基于属性的测试。</p>
<p>基于属性的测试是一种测试通用行为而非孤立场景的方法。</p>
<p>让我们通过编写一个单元测试，找出我们正在测试的通用属性，并将其转换为基于属性的测试来理解这意味着什么：</p>
<pre><code class="language-solidity">pragma solidity 0.8.10;

import "forge-std/Test.sol";

contract Safe {
    receive() external payable {}

    function withdraw() external {
        payable(msg.sender).transfer(address(this).balance);
    }
}

contract SafeTest is Test {
    Safe safe;

    // Needed so the test contract itself can receive ether
    // when withdrawing
    receive() external payable {}

    function setUp() public {
        safe = new Safe();
    }

    function test_Withdraw() public {
        payable(address(safe)).transfer(1 ether);
        uint256 preBalance = address(this).balance;
        safe.withdraw();
        uint256 postBalance = address(this).balance;
        assertEq(preBalance + 1 ether, postBalance);
    }
}
</code></pre>
<p>运行测试，我们看到它通过了：</p>
<pre><code class="language-sh">$ forge test
Compiling 24 files with Solc 0.8.10
Solc 0.8.10 finished in 1.17s
Compiler run successful!

Ran 1 test for test/Safe.t.sol:SafeTest
[PASS] test_Withdraw() (gas: 19463)
Suite result: ok. 1 passed; 0 failed; 0 skipped; finished in 592.16µs (75.11µs CPU time)

Ran 1 test suite in 3.11ms (592.16µs CPU time): 1 tests passed, 0 failed, 0 skipped (1 total tests)
</code></pre>
<p>这个单元测试确实测试了我们可以从安全合约中提取以太币。然而，谁又能说它对所有金额都有效，而不仅仅是 1 以太币呢？</p>
<p>这里的通用属性是：给定一个安全余额，当我们提取时，我们应该得到安全合约中的所有以太币。</p>
<p>Forge 会将任何至少有一个参数的测试视为基于属性的测试，所以让我们重写：</p>
<pre><code class="language-solidity">contract SafeTest is Test {
    // ...

    function testFuzz_Withdraw(uint256 amount) public {
        payable(address(safe)).transfer(amount);
        uint256 preBalance = address(this).balance;
        safe.withdraw();
        uint256 postBalance = address(this).balance;
        assertEq(preBalance + amount, postBalance);
    }
}
</code></pre>
<p>如果我们现在运行测试，我们可以看到 Forge 运行了基于属性的测试，但对于高值的 <code>amount</code> 它会失败：</p>
<pre><code class="language-sh">$ forge test
Compiling 1 files with Solc 0.8.10
Solc 0.8.10 finished in 1.11s
Compiler run successful!

Ran 1 test for test/Safe.t.sol:SafeTest
[FAIL. Reason: EvmError: Revert; counterexample: calldata=0x29facca70004c4c48afc26c4a597160d62929bba2ce21602a73927fca0d4153272d1d4cb args=[8425429329456584736079284567647927331458703889814200072693356035849704651 [8.425e72]]] testFuzz_Withdraw(uint256) (runs: 0, μ: 0, ~: 0)
Suite result: FAILED. 0 passed; 1 failed; 0 skipped; finished in 868.73µs (470.27µs CPU time)

Ran 1 test suite in 3.57ms (868.73µs CPU time): 0 tests passed, 1 failed, 0 skipped (1 total tests)
</code></pre>
<p>默认情况下，测试合约被赋予的以太币数量是 <code>2**96 wei</code>（类似于 DappTools），所以我们必须将 <code>amount</code> 的类型限制为 <code>uint96</code>，以确保我们不会尝试发送超过我们拥有的数量：</p>
<pre><code class="language-solidity">    function testFuzz_Withdraw(uint96 amount) public {
</code></pre>
<p>现在它通过了：</p>
<pre><code class="language-sh">$ forge test
Compiling 1 files with Solc 0.8.10
Solc 0.8.10 finished in 1.15s
Compiler run successful!

Ran 1 test for test/Safe.t.sol:SafeTest
[PASS] testFuzz_Withdraw(uint96) (runs: 257, μ: 19266, ~: 19631)
Suite result: ok. 1 passed; 0 failed; 0 skipped; finished in 4.81ms (4.38ms CPU time)

Ran 1 test suite in 6.14ms (4.81ms CPU time): 1 tests passed, 0 failed, 0 skipped (1 total tests)
</code></pre>
<p>你可能希望使用 <a href="forge/../cheatcodes/assume.html"><code>assume</code></a> 作弊码排除某些情况。在这些情况下，模糊器将丢弃输入并开始新的模糊运行：</p>
<pre><code class="language-solidity">function testFuzz_Withdraw(uint96 amount) public {
    vm.assume(amount &gt; 0.1 ether);
    // 省略
}
</code></pre>
<p>有不同的方法来运行基于属性的测试，特别是参数化测试和模糊测试。Forge 仅支持模糊测试。</p>
<h3 id="解释结果"><a class="header" href="#解释结果">解释结果</a></h3>
<p>你可能注意到模糊测试与单元测试的总结方式略有不同：</p>
<ul>
<li>“runs” 指的是模糊器测试的场景数量。默认情况下，模糊器将生成 256 个场景，但用户可以设置此参数和其他测试执行参数。模糊器配置详情请参见 <a href="forge/fuzz-testing.html#configuring-fuzz-test-execution"><code>这里</code></a>。</li>
<li>“μ”（希腊字母 mu）是所有模糊运行中使用的平均气体量</li>
<li>“~”（波浪号）是所有模糊运行中使用的中位气体量</li>
</ul>
<h3 id="配置模糊测试执行"><a class="header" href="#配置模糊测试执行">配置模糊测试执行</a></h3>
<p>模糊测试执行由用户可以通过 Forge 配置原语控制的参数管理。配置可以全局应用或在每个测试基础上应用。有关此主题的详细信息，请参见
📚 <a href="forge/../reference/config/testing.html"><code>全局配置</code></a> 和 📚 <a href="forge/../reference/config/inline-test-config.html"><code>内联配置</code></a>。</p>
<h4 id="模糊测试固定装置"><a class="header" href="#模糊测试固定装置">模糊测试固定装置</a></h4>
<p>当你希望确保一组特定的值用作模糊参数的输入时，可以定义模糊测试固定装置。
这些固定装置可以在测试中声明为：</p>
<ul>
<li>以 <code>fixture</code> 为前缀的存储数组，后跟要模糊的参数名称。例如，当模糊参数 <code>amount</code> 类型为 <code>uint32</code> 时，可以定义为</li>
</ul>
<pre><code class="language-solidity">uint32[] public fixtureAmount = [1, 5, 555];
</code></pre>
<ul>
<li>以 <code>fixture</code> 为前缀的函数，后跟要模糊的参数名称。函数应返回用于模糊的值数组（固定大小或动态）。例如，当模糊参数名为 <code>owner</code> 类型为 <code>address</code> 时，可以定义为</li>
</ul>
<pre><code class="language-solidity">function fixtureOwner() public returns (address[] memory)
</code></pre>
<p>如果提供的固定装置值类型与要模糊的命名参数类型不同，则会被拒绝并引发错误。</p>
<p>一个可以使用固定装置的例子是重现 <code>DSChief</code> 漏洞。考虑以下两个函数</p>
<pre><code class="language-solidity">    function etch(address yay) public returns (bytes32 slate) {
        bytes32 hash = keccak256(abi.encodePacked(yay));

        slates[hash] = yay;

        return hash;
    }

    function voteSlate(bytes32 slate) public {
        uint weight = deposits[msg.sender];
        subWeight(weight, votes[msg.sender]);
        votes[msg.sender] = slate;
        addWeight(weight, votes[msg.sender]);
    }
</code></pre>
<p>漏洞可以通过在 <code>etch</code> 之前调用 <code>voteSlate</code>，并将 <code>slate</code> 值作为 <code>yay</code> 地址的哈希来重现。为了确保模糊器在同一运行中包含从 <code>yay</code> 地址派生的 <code>slate</code> 值，可以定义以下固定装置：</p>
<pre><code class="language-solidity">    address[] public fixtureYay = [
        makeAddr("yay1"),
        makeAddr("yay2"),
        makeAddr("yay3")
    ];

    bytes32[] public fixtureSlate = [
        keccak256(abi.encodePacked(makeAddr("yay1"))),
        keccak256(abi.encodePacked(makeAddr("yay2"))),
        keccak256(abi.encodePacked(makeAddr("yay3")))
    ];
</code></pre>
<p>以下图像显示了模糊器在声明和不声明固定装置时生成值的情况：
<img src="forge/../images/fuzzer.png" alt="Fuzzer" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="不变性测试"><a class="header" href="#不变性测试">不变性测试</a></h1>
<h2 id="概述"><a class="header" href="#概述">概述</a></h2>
<p>不变性测试允许对一组不变性表达式进行测试，这些表达式针对预定义合约中的预定义函数调用的随机序列进行测试。在每次函数调用之后，都会断言所有定义的不变性。</p>
<p>不变性测试是一种强大的工具，可以揭示协议中的逻辑错误。由于函数调用序列是随机的，并且输入是模糊的，不变性测试可以揭示边缘情况和高度复杂协议状态下的错误假设和不正确逻辑。</p>
<p>不变性测试活动有两个维度，<code>runs</code> 和 <code>depth</code>：</p>
<ul>
<li><code>runs</code>：生成和运行的函数调用序列的次数。</li>
<li><code>depth</code>：在给定的 <code>run</code> 中进行的函数调用次数。每次函数调用后都会断言所有定义的不变性。如果函数调用失败，<code>depth</code> 计数器仍然会增加。</li>
</ul>
<p>这些和其他不变性配置方面在<a href="forge/invariant-testing.html#configuring-invariant-test-execution">这里</a>解释。</p>
<p>与在 Foundry 中通过在函数名称前加上 <code>test</code> 来运行标准测试类似，不变性测试通过在函数名称前加上 <code>invariant</code> 来表示（例如，<code>function invariant_A()</code>）。</p>
<p><code>afterInvariant()</code> 函数在每次不变性运行结束时调用（如果声明了），允许进行后活动处理。此函数可用于记录活动指标（例如，选择器被调用的次数）和后模糊活动测试（例如，关闭所有头寸并断言所有资金能够退出系统）。</p>
<h3 id="配置不变性测试执行"><a class="header" href="#配置不变性测试执行">配置不变性测试执行</a></h3>
<p>不变性测试执行由用户可以通过 Forge 配置原语控制的参数管理。配置可以全局应用或按测试应用。有关此主题的详细信息，请参阅
📚 <a href="forge/../reference/config/testing.html"><code>全局配置</code></a> 和 📚 <a href="forge/../reference/config/inline-test-config.html"><code>内联配置</code></a>。</p>
<h2 id="定义不变性"><a class="header" href="#定义不变性">定义不变性</a></h2>
<p>不变性是应该在整个模糊活动过程中始终保持为真的条件表达式。一个好的不变性测试套件应该尽可能多地包含不变性，并且可以为不同的协议状态提供不同的测试套件。</p>
<p>不变性的例子包括：</p>
<ul>
<li><em>“xy=k 公式总是成立”</em> 对于 Uniswap</li>
<li><em>“所有用户余额的总和等于总供应量”</em> 对于 ERC-20 代币。</li>
</ul>
<p>有不同的方式来断言不变性，如下表所述：</p>
<table>
<tr><th>类型</th><th>解释</th><th>示例</th></tr>
<tr>
<td>直接断言</td>
<td>查询协议智能合约并断言值符合预期。</td>
<td>
<pre><code class="language-solidity">assertGe(
    token.totalAssets(),
    token.totalSupply()
)
</code></pre>
</td>
</tr>
<tr>
<td>幽灵变量断言</td>
<td>查询协议智能合约并将其与测试环境中持久化的值（幽灵变量）进行比较。</td>
<td>
<pre><code class="language-solidity">assertEq(
    token.totalSupply(),
    sumBalanceOf
)
</code></pre>
</td>
</tr>
<tr>
<td>去优化（朴素实现断言）</td>
<td>查询协议智能合约并将其与相同逻辑的朴素且通常非常低效的实现进行比较。</td>
<td>
<pre><code class="language-solidity">assertEq(
    pool.outstandingInterest(),
    test.naiveInterest()
)
</code></pre>
</td>
</tr>
</table>
<h3 id="条件不变性"><a class="header" href="#条件不变性">条件不变性</a></h3>
<p>不变性必须在给定的模糊活动过程中保持，但这并不意味着它们必须在每种情况下都成立。在某些情况下，可能会有某些不变性被引入/移除（例如，在清算期间）。</p>
<p>不建议在不变性断言中引入条件逻辑，因为它们有可能引入误报，因为代码路径不正确。例如：</p>
<pre><code class="language-solidity">function invariant_example() external {
    if (protocolCondition) return;

    assertEq(val1, val2);
}
</code></pre>
<p>在这种情况下，如果 <code>protocolCondition == true</code>，则根本不会断言不变性。有时这可能是期望的行为，但如果 <code>protocolCondition</code> 在整个模糊活动中意外为真，或者条件本身存在逻辑错误，则可能会导致问题。因此，最好尝试为该条件定义一个替代不变性，例如：</p>
<pre><code class="language-solidity">function invariant_example() external {
    if (protocolCondition) {
        assertLe(val1, val2);
        return;
    };

    assertEq(val1, val2);
}
</code></pre>
<p>处理不同协议状态下的不同不变性的另一种方法是利用针对不同场景的专用不变性测试合约。这些场景可以使用 <code>setUp</code> 函数进行引导，但更强大的方法是利用 <em>不变性目标</em> 来控制模糊器以某种方式行为，从而仅产生某些结果（例如，避免清算）。</p>
<h2 id="不变性目标"><a class="header" href="#不变性目标">不变性目标</a></h2>
<p><strong>目标合约</strong>：在给定的不变性测试模糊活动中将被调用的一组合约。这组合约默认是 <code>setUp</code> 函数中部署的所有合约，但可以自定义以允许更高级的不变性测试。</p>
<p><strong>目标发送者</strong>：不变性测试模糊器在执行模糊活动时随机选择 <code>msg.sender</code> 的值，以默认模拟系统中的多个参与者。如果需要，可以在 <code>setUp</code> 函数中自定义发送者集合。</p>
<p><strong>目标接口</strong>：在 <code>setUp</code> 期间未部署但在分叉环境中模糊的地址及其项目标识符集合（例如，<code>[(0x1, ["IERC20"]), (0x2, ("IOwnable"))]</code>）。这使得可以针对代理和使用 <code>create</code> 或 <code>create2</code> 部署的合约进行模糊。</p>
<p><strong>目标选择器</strong>：模糊器用于不变性测试的函数选择器集合。这些可以用于在给定目标合约中使用函数子集。</p>
<p><strong>目标构件</strong>：给定合约使用的所需 ABI。这些可以用于代理合约配置。</p>
<p><strong>目标构件选择器</strong>：在给定 ABI 中使用的所需函数选择器子集。这些可以用于代理合约配置。</p>
<p>在目标冲突的情况下，不变性模糊器的优先级是：</p>
<p><code>targetInterfaces | targetSelectors &gt; excludeSelectors | targetArtifactSelectors &gt; excludeContracts | excludeArtifacts &gt; targetContracts | targetArtifacts</code></p>
<h3 id="函数调用概率分布"><a class="header" href="#函数调用概率分布">函数调用概率分布</a></h3>
<p>这些合约中的函数将以随机（均匀分布的概率）调用，并带有模糊输入。</p>
<p>例如：</p>
<pre><code class="language-text">targetContract1:
├─ function1: 20%
└─ function2: 20%

targetContract2:
├─ function1: 20%
├─ function2: 20%
└─ function3: 20%
</code></pre>
<p>在设计目标合约时需要注意这一点，因为函数较少的合约中的每个函数会由于这种概率分布而被更频繁地调用。</p>
<h3 id="不变性测试辅助函数"><a class="header" href="#不变性测试辅助函数">不变性测试辅助函数</a></h3>
<p>不变性测试辅助函数包含在 <a href="https://github.com/foundry-rs/forge-std/blob/master/src/StdInvariant.sol" title="" target="_blank">
<code>forge-std</code></a> 中，以允许可配置的不变性测试设置。辅助函数如下所述：</p>
<div class="table-wrapper"><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody>
<tr><td><code>excludeContract(address newExcludedContract_)</code></td><td>将给定地址添加到 <code>_excludedContracts</code> 数组中。这组合约明确排除在目标合约之外。</td></tr>
<tr><td><code>excludeSelector(FuzzSelector memory newExcludedSelector_)</code></td><td>将给定 <code>FuzzSelector</code> 添加到 <code>_excludedSelectors</code> 数组中。这组 <code>FuzzSelector</code> 明确排除在目标合约选择器之外。</td></tr>
<tr><td><code>excludeSender(address newExcludedSender_)</code></td><td>将给定地址添加到 <code>_excludedSenders</code> 数组中。这组地址明确排除在目标发送者之外。</td></tr>
<tr><td><code>excludeArtifact(string memory newExcludedArtifact_)</code></td><td>将给定字符串添加到 <code>_excludedArtifacts</code> 数组中。这组字符串明确排除在目标构件之外。</td></tr>
<tr><td><code>targetArtifact(string memory newTargetedArtifact_)</code></td><td>将给定字符串添加到 <code>_targetedArtifacts</code> 数组中。这组字符串用于目标构件。</td></tr>
<tr><td><code>targetArtifactSelector(FuzzArtifactSelector memory newTargetedArtifactSelector_)</code></td><td>将给定 <code>FuzzArtifactSelector</code> 添加到 <code>_targetedArtifactSelectors</code> 数组中。这组 <code>FuzzArtifactSelector</code> 用于目标构件选择器。</td></tr>
<tr><td><code>targetContract(address newTargetedContract_)</code></td><td>将给定地址添加到 <code>_targetedContracts</code> 数组中。这组地址用于目标合约。这数组覆盖了 <code>setUp</code> 期间部署的合约集合。</td></tr>
<tr><td><code>targetSelector(FuzzSelector memory newTargetedSelector_)</code></td><td>将给定 <code>FuzzSelector</code> 添加到 <code>_targetedSelectors</code> 数组中。这组 <code>FuzzSelector</code> 用于目标合约选择器。</td></tr>
<tr><td><code>targetSender(address newTargetedSender_)</code></td><td>将给定地址添加到 <code>_targetedSenders</code> 数组中。这组地址用于目标发送者。</td></tr>
<tr><td><code>targetInterface(FuzzInterface memory newTargetedInterface_)</code></td><td>将给定 <code>FuzzInterface</code> 添加到 <code>_targetedInterfaces</code> 数组中。这组 <code>FuzzInterface</code> 扩展了要模糊的合约和选择器，并启用了在 <code>setUp</code> 期间未部署的地址的模糊，例如在分叉环境中模糊时。还启用了代理和使用 <code>create</code> 或 <code>create2</code> 部署的合约的模糊。</td></tr>
</tbody></table>
</div>
<h3 id="目标合约设置"><a class="header" href="#目标合约设置">目标合约设置</a></h3>
<p>目标合约可以通过以下三种方法设置：</p>
<ol>
<li>手动添加到 <code>targetContracts</code> 数组的合约将添加到目标合约集合中。</li>
<li>在 <code>setUp</code> 函数中部署的合约将自动添加到目标合约集合中（仅在未使用选项 1 手动添加合约时有效）。</li>
<li>在 <code>setUp</code> 中部署的合约可以<strong>移除</strong>目标合约，如果它们被添加到 <code>excludeContracts</code> 数组中。</li>
</ol>
<h2 id="开放测试"><a class="header" href="#开放测试">开放测试</a></h2>
<p>目标合约的默认配置设置为在设置期间部署的所有合约。对于较小的模块和更多算术合约，这效果很好。例如：</p>
<pre><code class="language-solidity">contract ExampleContract1 {

    uint256 public val1;
    uint256 public val2;
    uint256 public val3;

    function addToA(uint256 amount) external {
        val1 += amount;
        val3 += amount;
    }

    function addToB(uint256 amount) external {
        val2 += amount;
        val3 += amount;
    }

}
</code></pre>
<p>这个合约可以部署并使用默认目标合约模式进行测试：</p>
<pre><code class="language-solidity">contract InvariantExample1 is Test {

    ExampleContract1 foo;

    function setUp() external {
        foo = new ExampleContract1();
    }

    function invariant_A() external {
        assertEq(foo.val1() + foo.val2(), foo.val3());
    }

    function invariant_B() external {
        assertGe(foo.val1() + foo.val2(), foo.val3());
    }

}
</code></pre>
<p>这种设置将以 50%-50% 的概率分布调用 <code>foo.addToA()</code> 和 <code>foo.addToB()</code>，并带有模糊输入。不可避免地，输入将开始导致溢出，函数调用将开始失败。由于不变性测试中的默认配置是 <code>fail_on_revert = false</code>，这不会导致测试失败。不变性将在其余的模糊活动中保持，结果是测试将通过。输出将如下所示：</p>
<pre><code class="language-text">[PASS] invariant_A() (runs: 50, calls: 10000, reverts: 5533)
[PASS] invariant_B() (runs: 50, calls: 10000, reverts: 5533)
</code></pre>
<h2 id="基于处理器的测试"><a class="header" href="#基于处理器的测试">基于处理器的测试</a></h2>
<p>对于更复杂和集成的协议，需要更复杂的目标合约使用才能达到预期结果。为了说明如何利用处理器，以下合约将被使用（一个基于 ERC-4626 的合约，接受另一个 ERC-20 代币的存款）：</p>
<pre><code class="language-solidity">// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.17;

interface IERC20Like {

    function balanceOf(address owner_) external view returns (uint256 balance_);

    function transferFrom(
        address owner_,
        address recipient_,
        uint256 amount_
    ) external returns (bool success_);

}

contract Basic4626Deposit {

    /**********************************************************************************************/
    /*** 存储                                                                                ***/
    /**********************************************************************************************/

    address public immutable asset;

    string public name;
    string public symbol;

    uint8 public immutable decimals;

    uint256 public totalSupply;

    mapping(address =&gt; uint256) public balanceOf;

    /**********************************************************************************************/
    /*** 构造函数                                                                            ***/
    /**********************************************************************************************/

    constructor(address asset_, string memory name_, string memory symbol_, uint8 decimals_) {
        asset    = asset_;
        name     = name_;
        symbol   = symbol_;
        decimals = decimals_;
    }

    /**********************************************************************************************/
    /*** 外部函数                                                                     ***/
    /**********************************************************************************************/

    function deposit(uint256 assets_, address receiver_) external returns (uint256 shares_) {
        shares_ = convertToShares(assets_);

        require(receiver_ != address(0), "ZERO_RECEIVER");
        require(shares_   != uint256(0), "ZERO_SHARES");
        require(assets_   != uint256(0), "ZERO_ASSETS");

        totalSupply += shares_;

        // Cannot overflow because totalSupply would first overflow in the statement above.
        unchecked { balanceOf[receiver_] += shares_; }

        require(
            IERC20Like(asset).transferFrom(msg.sender, address(this), assets_),
            "TRANSFER_FROM"
        );
    }

    function transfer(address recipient_, uint256 amount_) external returns (bool success_) {
        balanceOf[msg.sender] -= amount_;

        // Cannot overflow because minting prevents overflow of totalSupply,
        // and sum of user balances == totalSupply.
        unchecked { balanceOf[recipient_] += amount_; }

        return true;
    }

    /**********************************************************************************************/
    /*** 公共视图函数                                                                  ***/
    /**********************************************************************************************/

    function convertToShares(uint256 assets_) public view returns (uint256 shares_) {
        uint256 supply_ = totalSupply;  // Cache to stack.

        shares_ = supply_ == 0 ? assets_ : (assets_ * supply_) / totalAssets();
    }

    function totalAssets() public view returns (uint256 assets_) {
        assets_ = IERC20Like(asset).balanceOf(address(this));
    }

}

</code></pre>
<h3 id="处理器函数"><a class="header" href="#处理器函数">处理器函数</a></h3>
<p>这个合约的 <code>deposit</code> 函数要求调用者拥有 ERC-20 <code>asset</code> 的非零余额。在开放不变性测试方法中，<code>deposit()</code> 和 <code>transfer()</code> 将以 50-50% 的分布调用，但它们会在每次调用时失败。这将导致不变性测试“通过”，但实际上根本没有在所需合约中操纵任何状态。这就是可以利用目标合约的地方。当合约需要一些额外的逻辑才能正常工作时，可以在一个称为 <code>Handler</code> 的专用合约中添加它。</p>
<pre><code class="language-solidity">function deposit(uint256 assets) public virtual {
    asset.mint(address(this), assets);

    asset.approve(address(token), assets);

    uint256 shares = token.deposit(assets, address(this));
}
</code></pre>
<p>这个合约将在进行函数调用之前提供必要的设置，以确保其成功。</p>
<p>在此概念的基础上，处理器可以用于开发更复杂的不变性测试。通过开放不变性测试，测试运行如下图所示，随机序列的函数调用直接使用模糊参数对协议合约进行调用。这将导致更复杂系统中的失败，如上所述。</p>
<p><img src="https://user-images.githubusercontent.com/44272939/214752968-5f0e7653-d52e-43e6-b453-cac935f5d97d.svg" alt="Blank diagram" /></p>
<p>通过手动将所有处理器合约添加到 <code>targetContracts</code> 数组中，可以确保对协议合约的所有函数调用都由处理器控制，以确保成功调用。这在下图中有详细说明。</p>
<p><img src="https://user-images.githubusercontent.com/44272939/216420091-8a5c2bcc-d586-458f-be1e-a9ea0ef5961f.svg" alt="Invariant Diagrams - Page 2" /></p>
<p>通过这种模糊器和协议之间的层，可以实现更强大的测试。</p>
<h3 id="处理器幽灵变量"><a class="header" href="#处理器幽灵变量">处理器幽灵变量</a></h3>
<p>在处理器中，可以跨多个函数调用跟踪“幽灵变量”，以为不变性测试添加额外信息。一个很好的例子是将在 ERC-4626 代币中存款后每个 LP 拥有的 <code>shares</code> 总和，并使用该不变性（<code>totalSupply == sumBalanceOf</code>）。</p>
<pre><code class="language-solidity">function deposit(uint256 assets) public virtual {
    asset.mint(address(this), assets);

    asset.approve(address(token), assets);

    uint256 shares = token.deposit(assets, address(this));

    sumBalanceOf += shares;
}
</code></pre>
<h3 id="函数级断言"><a class="header" href="#函数级断言">函数级断言</a></h3>
<p>另一个好处是能够在函数调用发生时进行断言。一个例子是在 <code>deposit</code> 函数调用期间断言 LP 的 ERC-20 余额减少了 <code>assets</code>，以及他们的 LP 代币余额增加了 <code>shares</code>。通过这种方式，处理器函数类似于模糊测试，因为它们可以接受模糊输入，执行状态更改，并在前后状态中断言。</p>
<pre><code class="language-solidity">function deposit(uint256 assets) public virtual {
    asset.mint(address(this), assets);

    asset.approve(address(token), assets);

    uint256 beforeBalance = asset.balanceOf(address(this));

    uint256 shares = token.deposit(assets, address(this));

    assertEq(asset.balanceOf(address(this)), beforeBalance - assets);

    sumBalanceOf += shares;
}
</code></pre>
<h3 id="有界无界函数"><a class="header" href="#有界无界函数">有界/无界函数</a></h3>
<p>此外，通过处理器，输入参数可以被限制为合理的预期值，使得 <code>foundry.toml</code> 中的 <code>fail_on_revert</code> 可以设置为 <code>true</code>。这可以通过 <code>forge-std</code> 中的 <code>bound()</code> 辅助函数来实现。这确保了模糊器进行的每个函数调用都必须对协议成功，才能通过测试。这对于可见性和确保协议以期望的方式进行测试的信心非常有用。</p>
<pre><code class="language-solidity">function deposit(uint256 assets) external {
    assets = bound(assets, 0, 1e30);

    asset.mint(address(this), assets);

    asset.approve(address(token), assets);

    uint256 beforeBalance = asset.balanceOf(address(this));

    uint256 shares = token.deposit(assets, address(this));

    assertEq(asset.balanceOf(address(this)), beforeBalance - assets);

    sumBalanceOf += shares;
}
</code></pre>
<p>这也可以通过从专用“无界”处理器合约继承非有界函数来实现，这些合约可用于 <code>fail_on_revert = false</code> 测试。这种测试也很有用，因为它可以揭示 <code>bound</code> 函数使用中假设的问题。</p>
<pre><code class="language-solidity">// 无界
function deposit(uint256 assets) public virtual {
    asset.mint(address(this), assets);

    asset.approve(address(token), assets);

    uint256 beforeBalance = asset.balanceOf(address(this));

    uint256 shares = token.deposit(assets, address(this));

    assertEq(asset.balanceOf(address(this)), beforeBalance - assets);

    sumBalanceOf += shares;
}
</code></pre>
<pre><code class="language-solidity">// 有界
function deposit(uint256 assets) external {
    assets = bound(assets, 0, 1e30);

    super.deposit(assets);
}
</code></pre>
<h3 id="参与者管理"><a class="header" href="#参与者管理">参与者管理</a></h3>
<p>在上面的函数调用中，可以看到 <code>address(this)</code> 是 ERC-4626 合约中的唯一存款者，这并不是其预期用途的真实表示。通过利用 <code>forge-std</code> 中的 <code>prank</code> 作弊代码，每个处理器可以管理一组参与者，并使用它们从不同的 <code>msg.sender</code> 地址执行相同的函数调用。这可以通过以下修饰符实现：</p>
<pre><code class="language-solidity">address[] public actors;

address internal currentActor;

modifier useActor(uint256 actorIndexSeed) {
    currentActor = actors[bound(actorIndexSeed, 0, actors.length - 1)];
    vm.startPrank(currentActor);
    _;
    vm.stopPrank();
}
</code></pre>
<p>使用多个参与者还允许更细粒度的幽灵变量使用。这在下面的函数中有所展示：</p>
<pre><code class="language-solidity">// 无界
function deposit(
    uint256 assets,
    uint256 actorIndexSeed
) public virtual useActor(actorIndexSeed) {
    asset.mint(currentActor, assets);

    asset.approve(address(token), assets);

    uint256 beforeBalance = asset.balanceOf(address(this));

    uint256 shares = token.deposit(assets, address(this));

    assertEq(asset.balanceOf(address(this)), beforeBalance - assets);

    sumBalanceOf += shares;

    sumDeposits[currentActor] += assets
}
</code></pre>
<pre><code class="language-solidity">// 有界
function deposit(uint256 assets, uint256 actorIndexSeed) external {
    assets = bound(assets, 0, 1e30);

    super.deposit(assets, actorIndexSeed);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="差异测试"><a class="header" href="#差异测试">差异测试</a></h2>
<p>Forge 可以用于差异测试和差异模糊测试。你甚至可以使用 <code>ffi</code> <a href="forge/../cheatcodes/ffi.html">作弊码</a> 来测试非 EVM 可执行文件。</p>
<h3 id="背景"><a class="header" href="#背景">背景</a></h3>
<p><a href="https://en.wikipedia.org/wiki/Differential_testing" title="" target="_blank">差异测试</a> 通过比较同一函数的多个实现的输出来交叉引用这些实现。想象一下，我们有一个函数规范 <code>F(X)</code>，以及该规范的两个实现：<code>f1(X)</code> 和 <code>f2(X)</code>。我们期望对于所有存在于适当输入空间中的 x，<code>f1(x) == f2(x)</code>。如果 <code>f1(x) != f2(x)</code>，我们就知道至少有一个函数没有正确实现 <code>F(X)</code>。这种测试相等性和识别差异的过程是差异测试的核心。</p>
<p>差异模糊测试是差异测试的扩展。差异模糊测试通过程序生成许多 <code>x</code> 值来发现手动选择的输入可能不会揭示的差异和边缘情况。</p>
<blockquote>
<p>注意：在这种情况下，<code>==</code> 操作符可以是相等性的自定义定义。例如，如果测试浮点实现，你可能会使用具有一定容差的近似相等性。</p>
</blockquote>
<p>这种测试的一些实际应用包括：</p>
<ul>
<li>比较升级后的实现与其前身</li>
<li>测试代码与已知的参考实现</li>
<li>确认与第三方工具和依赖项的兼容性</li>
</ul>
<p>以下是一些如何使用 Forge 进行差异测试的示例。</p>
<h3 id="入门ffi-作弊码"><a class="header" href="#入门ffi-作弊码">入门：<code>ffi</code> 作弊码</a></h3>
<p><a href="forge/../cheatcodes/ffi.html"><code>ffi</code></a> 允许你执行任意 shell 命令并捕获输出。以下是一个模拟示例：</p>
<pre><code class="language-solidity">import "forge-std/Test.sol";

contract TestContract is Test {

    function testMyFFI () public {
        string[] memory cmds = new string[](2);
        cmds[0] = "cat";
        cmds[1] = "address.txt"; // 假设包含 abi 编码的地址。
        bytes memory result = vm.ffi(cmds);
        address loadedAddress = abi.decode(result, (address));
        // 对地址进行某些操作
        // ...
    }
}
</code></pre>
<p>一个地址之前已被写入 <code>address.txt</code>，我们使用 FFI 作弊码读取它。这些数据现在可以在你的测试合约中使用。</p>
<h3 id="示例差异测试-merkle-tree-实现"><a class="header" href="#示例差异测试-merkle-tree-实现">示例：差异测试 Merkle Tree 实现</a></h3>
<p><a href="https://en.wikipedia.org/wiki/Merkle_tree" title="" target="_blank">Merkle Trees</a> 是一种在区块链应用中常用的加密承诺方案。它们的流行导致了许多不同的 Merkle Tree 生成器、证明器和验证器的实现。Merkle 根和证明通常使用 JavaScript 或 Python 等语言生成，而证明验证通常在链上的 Solidity 中进行。</p>
<p><a href="https://github.com/dmfxyz/murky" title="" target="_blank">Murky</a> 是一个完整的 Merkle 根、证明和验证的 Solidity 实现。它的测试套件包括与 OpenZeppelin 的 Merkle 证明库的差异测试，以及与参考 JavaScript 实现的根生成测试。这些测试由 Foundry 的模糊测试和 <code>ffi</code> 功能驱动。</p>
<h4 id="与参考-typescript-实现的差异模糊测试"><a class="header" href="#与参考-typescript-实现的差异模糊测试">与参考 TypeScript 实现的差异模糊测试</a></h4>
<p>使用 <code>ffi</code> 作弊码，Murky 测试其自己的 Merkle 根实现与 TypeScript 实现的差异，使用 Forge 模糊器提供的数据：</p>
<pre><code class="language-solidity">function testMerkleRootMatchesJSImplementationFuzzed(bytes32[] memory leaves) public {
    vm.assume(leaves.length &gt; 1);
    bytes memory packed = abi.encodePacked(leaves);
    string[] memory runJsInputs = new string[](8);

    // 构建 ffi 命令字符串
    runJsInputs[0] = 'npm';
    runJsInputs[1] = '--prefix';
    runJsInputs[2] = 'differential_testing/scripts/';
    runJsInputs[3] = '--silent';
    runJsInputs[4] = 'run';
    runJsInputs[5] = 'generate-root-cli';
    runJsInputs[6] = leaves.length.toString();
    runJsInputs[7] = packed.toHexString();

    // 运行命令并捕获输出
    bytes memory jsResult = vm.ffi(runJsInputs);
    bytes32 jsGeneratedRoot = abi.decode(jsResult, (bytes32));

    // 使用 Murky 计算根
    bytes32 murkyGeneratedRoot = m.getRoot(leaves);
    assertEq(murkyGeneratedRoot, jsGeneratedRoot);
}
</code></pre>
<blockquote>
<p>注意：请参见 Murky Repo 中的 <a href="https://github.com/dmfxyz/murky/blob/main/differential_testing/test/utils/Strings2.sol" title="" target="_blank">
<code>Strings2.sol</code></a> 库，该库启用了 <code>(bytes memory).toHexString()</code></p>
</blockquote>
<p>Forge 运行 <code>npm --prefix differential_testing/scripts/ --silent run generate-root-cli {numLeaves} {hexEncodedLeaves}</code>。这使用参考 JavaScript 实现计算输入数据的 Merkle 根。脚本将根打印到 stdout，并且该打印输出作为 <code>bytes</code> 在 <code>vm.ffi()</code> 的返回值中捕获。</p>
<p>然后，测试使用 Solidity 实现计算根。</p>
<p>最后，测试断言两个根完全相等。如果不相等，测试将失败。</p>
<h4 id="与-openzeppelin-的-merkle-证明库的差异模糊测试"><a class="header" href="#与-openzeppelin-的-merkle-证明库的差异模糊测试">与 OpenZeppelin 的 Merkle 证明库的差异模糊测试</a></h4>
<p>你可能希望对另一个 Solidity 实现进行差异测试。在这种情况下，不需要 <code>ffi</code>。相反，参考实现直接导入到测试中。</p>
<pre><code class="language-solidity">import "openzeppelin-contracts/contracts/utils/cryptography/MerkleProof.sol";
//...
function testCompatibilityOpenZeppelinProver(bytes32[] memory _data, uint256 node) public {
    vm.assume(_data.length &gt; 1);
    vm.assume(node &lt; _data.length);
    bytes32 root = m.getRoot(_data);
    bytes32[] memory proof = m.getProof(_data, node);
    bytes32 valueToProve = _data[node];
    bool murkyVerified = m.verifyProof(root, proof, valueToProve);
    bool ozVerified = MerkleProof.verify(proof, root, valueToProve);
    assertTrue(murkyVerified == ozVerified);
}
</code></pre>
<h4 id="与已知边缘情况的差异测试"><a class="header" href="#与已知边缘情况的差异测试">与已知边缘情况的差异测试</a></h4>
<p>差异测试并不总是模糊的——它们对于测试已知的边缘情况也很有用。在 Murky 代码库的情况下，<code>log2ceil</code> 函数的初始实现对于某些长度接近 2 的幂的数组（如 129）不起作用。作为一种安全检查，总是对这种长度的数组运行测试，并与 TypeScript 实现进行比较。你可以看到完整的测试 <a href="https://github.com/dmfxyz/murky/blob/main/differential_testing/test/DifferentialTests.t.sol#L21" title="" target="_blank">这里</a>。</p>
<h4 id="与参考数据的标准化测试"><a class="header" href="#与参考数据的标准化测试">与参考数据的标准化测试</a></h4>
<p>FFI 对于将可重复的标准化数据注入测试环境也很有用。在 Murky 库中，这被用作气体快照的基准（参见 <a href="forge/./gas-snapshots.html">forge snapshot</a>）。</p>
<pre><code class="language-solidity">bytes32[100] data;
uint256[8] leaves = [4, 8, 15, 16, 23, 42, 69, 88];

function setUp() public {
    string[] memory inputs = new string[](2);
    inputs[0] = "cat";
    inputs[1] = "src/test/standard_data/StandardInput.txt";
    bytes memory result =  vm.ffi(inputs);
    data = abi.decode(result, (bytes32[100]));
    m = new Merkle();
}

function testMerkleGenerateProofStandard() public view {
    bytes32[] memory _data = _getData();
    for (uint i = 0; i &lt; leaves.length; ++i) {
        m.getProof(_data, leaves[i]);
    }
}
</code></pre>
<p><code>src/test/standard_data/StandardInput.txt</code> 是一个包含编码的 <code>bytes32[100]</code> 数组的文本文件。它在测试之外生成，可以在任何语言的 Web3 SDK 中使用。它看起来像：</p>
<pre><code class="language-ignore">0xf910ccaa307836354233316666386231414464306335333243453944383735313..423532
</code></pre>
<p>标准化测试合约使用 <code>ffi</code> 读取文件。它将数据解码为数组，然后在这个示例中，为 8 个不同的叶子生成证明。由于数据是常量和标准的，我们可以使用此测试有意义地测量气体和性能改进。</p>
<blockquote>
<p>当然，可以直接将数组硬编码到测试中！但这使得跨合约、实现等的一致测试变得更加困难。</p>
</blockquote>
<h3 id="示例差异测试渐进式荷兰拍卖"><a class="header" href="#示例差异测试渐进式荷兰拍卖">示例：差异测试渐进式荷兰拍卖</a></h3>
<p>Paradigm 的 <a href="https://www.paradigm.xyz/2022/04/gda" title="" target="_blank">渐进式荷兰拍卖</a> 机制的参考实现包含了许多差异的、模糊的测试。这是一个很好的仓库，可以进一步探索使用 <code>ffi</code> 进行差异测试。</p>
<ul>
<li>对 <a href="https://github.com/FrankieIsLost/gradual-dutch-auction/blob/master/src/test/DiscreteGDA.t.sol#L78" title="" target="_blank">离散 GDA</a> 的差异测试</li>
<li>对 <a href="https://github.com/FrankieIsLost/gradual-dutch-auction/blob/master/src/test/ContinuousGDA.t.sol#L89" title="" target="_blank">连续 GDA</a> 的差异测试</li>
<li>参考 <a href="https://github.com/FrankieIsLost/gradual-dutch-auction/blob/master/analysis/compute_price.py" title="" target="_blank">Python 实现</a></li>
</ul>
<h3 id="参考仓库"><a class="header" href="#参考仓库">参考仓库</a></h3>
<ul>
<li><a href="https://github.com/FrankieIsLost/gradual-dutch-auction" title="" target="_blank">渐进式荷兰拍卖</a></li>
<li><a href="https://www.github.com/dmfxyz/murky" title="" target="_blank">Murky</a></li>
<li><a href="https://github.com/patrickd-/solidity-fuzzing-boilerplate" title="" target="_blank">Solidity 模糊测试模板</a></li>
</ul>
<p>如果你有另一个可以作为参考的仓库，请贡献它！</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="部署"><a class="header" href="#部署">部署</a></h2>
<p>Forge 可以使用 <a href="forge/../reference/forge/forge-create.html"><code>forge create</code></a> 命令将智能合约部署到指定的网络。</p>
<p>Forge CLI 一次只能部署一个合约。</p>
<p>如果要一次性部署和验证多个智能合约，Forge 的 <a href="forge/../tutorials/solidity-scripting.html#deploying-our-contract">Solidity 脚本</a> 会是更高效的方法。</p>
<p>要部署合约，必须提供一个 RPC URL（环境变量：<code>ETH_RPC_URL</code>）和部署合约的账户的私钥。</p>
<p>将 <code>MyContract</code> 部署到一个网络：</p>
<pre><code class="language-sh">$ forge create --rpc-url &lt;your_rpc_url&gt; --private-key &lt;your_private_key&gt; src/MyContract.sol:MyContract
compiling...
success.
Deployer: 0xa735b3c25f...
Deployed to: 0x4054415432...
Transaction hash: 0x6b4e0ff93a...
</code></pre>
<p>Solidity 文件可能包含多个合约。上面的 <code>:MyContract</code> 指定了从 <code>src/MyContract.sol</code> 文件中部署哪个合约。</p>
<p>使用 <code>--constructor-args</code> 标志向构造函数传递参数：</p>
<pre><code class="language-solidity">// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import {ERC20} from "solmate/tokens/ERC20.sol";

contract MyToken is ERC20 {
    constructor(
        string memory name,
        string memory symbol,
        uint8 decimals,
        uint256 initialSupply
    ) ERC20(name, symbol, decimals) {
        _mint(msg.sender, initialSupply);
    }
}
</code></pre>
<p>此外，我们可以通过传递 <code>--verify</code> 让 Forge 在 Etherscan、Sourcify 或 Blockscout 上验证我们的合约（如果网络支持）。</p>
<pre><code class="language-sh">$ forge create --rpc-url &lt;your_rpc_url&gt; \
    --constructor-args "ForgeUSD" "FUSD" 18 1000000000000000000000 \
    --private-key &lt;your_private_key&gt; \
    --etherscan-api-key &lt;your_etherscan_api_key&gt; \
    --verify \
    src/MyToken.sol:MyToken
</code></pre>
<h2 id="验证已存在的合约"><a class="header" href="#验证已存在的合约">验证已存在的合约</a></h2>
<p>建议在 <code>forge create</code> 时使用 <code>--verify</code> 标志，以便在部署后自动在浏览器上验证合约。
注意，对于 Etherscan，必须设置 <a href="forge/../reference/config/etherscan.html#etherscan_api_key"><code>ETHERSCAN_API_KEY</code></a>。</p>
<p>如果你要验证已部署的合约，请继续阅读。</p>
<p>你可以使用 <a href="forge/../reference/forge/forge-verify-contract.html"><code>forge verify-contract</code></a> 命令在 Etherscan、Sourcify、oklink 或 Blockscout 上验证合约。</p>
<p>必须提供：</p>
<ul>
<li>合约地址</li>
<li>合约名称或合约路径 <code>&lt;path&gt;:&lt;contractname&gt;</code></li>
<li>你的 Etherscan API 密钥（环境变量：<code>ETHERSCAN_API_KEY</code>）（如果在 Etherscan 上验证）。</li>
</ul>
<p>此外，你可能需要提供：</p>
<ul>
<li>构造函数参数的 ABI 编码格式（如果有）</li>
<li>用于构建的 <a href="https://etherscan.io/solcversions" title="" target="_blank">编译器版本</a>，带有从提交版本前缀的 8 位十六进制数字（提交通常不是 nightly 构建）。如果未指定，则会自动检测。</li>
<li>优化次数，如果激活了 Solidity 优化器。如果未指定，则会自动检测。</li>
<li><a href="https://evm-chainlist.netlify.app/" title="" target="_blank">链 ID</a>，如果合约不在以太坊主网上</li>
</ul>
<p>假设你要验证上面的 <code>MyToken</code>。你将 <a href="forge/../reference/config/solidity-compiler.html#optimizer_runs">优化次数</a> 设置为 100 万，使用 v0.8.10 编译，并部署到 Sepolia 测试网（链 ID：11155111）。注意，如果在验证时未设置 <code>--num-of-optimizations</code>，则默认为 0，而在部署时默认为 200，因此如果你使用默认编译设置，请确保传递 <code>--num-of-optimizations 200</code>。</p>
<p>以下是如何验证它：</p>
<pre><code class="language-bash">forge verify-contract \
    --chain-id 11155111 \
    --num-of-optimizations 1000000 \
    --watch \
    --constructor-args $(cast abi-encode "constructor(string,string,uint256,uint256)" "ForgeUSD" "FUSD" 18 1000000000000000000000) \
    --etherscan-api-key &lt;your_etherscan_api_key&gt; \
    --compiler-version v0.8.10+commit.fc410830 \
    &lt;the_contract_address&gt; \
    src/MyToken.sol:MyToken 

Submitted contract for verification:
                Response: `OK`
                GUID: `a6yrbjp5prvakia6bqp5qdacczyfhkyi5j1r6qbds1js41ak1a`
                url: https://sepolia.etherscan.io//address/0x6a54…3a4c#code
</code></pre>
<p>建议在 <code>verify-contract</code> 命令中使用 <a href="forge/../reference/forge/forge-verify-contract.html#verify-contract-options"><code>--watch</code></a> 标志，以便轮询验证结果。</p>
<p>如果未提供 <code>--watch</code> 标志，可以使用 <a href="forge/../reference/forge/forge-verify-check.html"><code>forge verify-check</code></a> 命令检查验证状态：</p>
<pre><code class="language-bash">$ forge verify-check --chain-id 11155111 &lt;GUID&gt; &lt;your_etherscan_api_key&gt;
Contract successfully verified.
</code></pre>
<br>
<blockquote>
<p>💡 <strong>提示</strong></p>
<p>使用 Cast 的 <a href="forge/../reference/cast/cast-abi-encode.html"><code>abi-encode</code></a> 来 ABI 编码参数。</p>
<p>在这个例子中，我们运行了 <code>cast abi-encode "constructor(string,string,uint8,uint256)" "ForgeUSD" "FUSD" 18 1000000000000000000000</code> 来 ABI 编码参数。</p>
</blockquote>
<br>
<h3 id="故障排除"><a class="header" href="#故障排除">故障排除</a></h3>
<h5 id="missing-hex-prefix-0x-for-hex-string"><a class="header" href="#missing-hex-prefix-0x-for-hex-string"><code>missing hex prefix ("0x") for hex string</code></a></h5>
<p>确保私钥字符串以 <code>0x</code> 开头。</p>
<h5 id="eip-1559-not-activated"><a class="header" href="#eip-1559-not-activated"><code>EIP-1559 not activated</code></a></h5>
<p>EIP-1559 在 RPC 服务器上不受支持或未激活。传递 <code>--legacy</code> 标志以使用传统交易而不是 EIP-1559 交易。如果你在本地环境中进行开发，可以使用 Hardhat 而不是 Ganache。</p>
<h5 id="failed-to-parse-tokens"><a class="header" href="#failed-to-parse-tokens"><code>Failed to parse tokens</code></a></h5>
<p>确保传递的参数类型正确。</p>
<h5 id="signature-error"><a class="header" href="#signature-error"><code>Signature error</code></a></h5>
<p>确保私钥正确。</p>
<h5 id="compiler-version-commit-for-verify"><a class="header" href="#compiler-version-commit-for-verify"><code>Compiler version commit for verify</code></a></h5>
<p>如果你想检查本地运行的确切提交，尝试：<code> ~/.svm/0.x.y/solc-0.x.y --version</code>，其中 <code>x</code> 和 <code>y</code> 分别是主版本号和次版本号。输出将类似于：</p>
<pre><code class="language-ignore">solc, the solidity compiler commandline interface
Version: 0.8.12+commit.f00d7308.Darwin.appleclang
</code></pre>
<p>注意：你不能直接粘贴整个字符串 “0.8.12+commit.f00d7308.Darwin.appleclang” 作为编译器版本的参数。但你可以使用提交的 8 位十六进制数字来查找 <a href="https://etherscan.io/solcversions" title="" target="_blank">编译器版本</a> 中应复制和粘贴的内容。</p>
<h3 id="已知问题"><a class="header" href="#已知问题">已知问题</a></h3>
<h4 id="验证具有模糊导入路径的合约"><a class="header" href="#验证具有模糊导入路径的合约">验证具有模糊导入路径的合约</a></h4>
<p>Forge 将源目录（<code>src</code>、<code>lib</code>、<code>test</code> 等）作为 <code>--include-path</code> 参数传递给编译器。
这意味着给定以下项目树</p>
<pre><code class="language-text">|- src
|-- folder
|--- Contract.sol
|--- IContract.sol
</code></pre>
<p>可以在 <code>Contract.sol</code> 中使用 <code>folder/IContract.sol</code> 导入路径导入 <code>IContract</code>。</p>
<p>Etherscan 无法重新编译此类源代码。考虑将导入路径更改为相对导入路径。</p>
<h4 id="验证没有字节码哈希的合约"><a class="header" href="#验证没有字节码哈希的合约">验证没有字节码哈希的合约</a></h4>
<p>目前，无法在 Etherscan 上验证 <a href="forge/../reference/config/solidity-compiler.html#bytecode_hash"><code>bytecode_hash</code></a> 设置为 <code>none</code> 的合约。
点击 <a href="https://docs.soliditylang.org/en/v0.8.13/metadata.html#usage-for-source-code-verification" title="" target="_blank">这里</a> 了解更多关于元数据哈希如何用于源代码验证的信息。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="燃气跟踪"><a class="header" href="#燃气跟踪">燃气跟踪</a></h2>
<p>Forge 可以帮助您估算合约将消耗多少燃气。</p>
<p>目前，Forge 提供了两种不同的工具来完成这项工作，但未来可能会合并它们：</p>
<ul>
<li><a href="forge/./gas-reports.html"><strong>燃气报告</strong></a>：燃气报告为您提供了 Forge 认为合约中各个函数将消耗的燃气量的概览。</li>
<li><a href="forge/./gas-snapshots.html"><strong>燃气快照</strong></a>：燃气快照为您提供了每个测试消耗的燃气量的概览。</li>
</ul>
<p>燃气报告和燃气快照在某些方面有所不同：</p>
<ul>
<li>燃气报告使用跟踪来计算单个合约调用的燃气成本。<br />
这提供了更细粒度的洞察，但代价是速度较慢。</li>
<li>燃气快照内置了更多工具，例如差异比较和将结果导出到文件。<br />
快照不如燃气报告那么细粒度，但生成速度更快。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="燃气报告"><a class="header" href="#燃气报告">燃气报告</a></h2>
<p>Forge 可以为你的合约生成燃气报告。你可以通过 <code>foundry.toml</code> 文件中的 <code>gas_reports</code> 字段配置输出燃气报告的合约。</p>
<p>要为特定合约生成报告：</p>
<pre><code class="language-toml">gas_reports = ["MyContract", "MyContractFactory"]
</code></pre>
<p>要为所有合约生成报告：</p>
<pre><code class="language-toml">gas_reports = ["*"]
</code></pre>
<p>要生成燃气报告，运行 <code>forge test --gas-report</code>。</p>
<p>你也可以将其与其他子命令结合使用，例如 <code>forge test --match-test testBurn --gas-report</code>，以生成仅与此测试相关的燃气报告。</p>
<p>示例输出：</p>
<pre><code class="language-ignore">╭───────────────────────┬─────────────────┬────────┬────────┬────────┬─────────╮
│ MockERC1155 contract  ┆                 ┆        ┆        ┆        ┆         │
╞═══════════════════════╪═════════════════╪════════╪════════╪════════╪═════════╡
│ Deployment Cost       ┆ Deployment Size ┆        ┆        ┆        ┆         │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤
│ 1082720               ┆ 5440            ┆        ┆        ┆        ┆         │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤
│ Function Name         ┆ min             ┆ avg    ┆ median ┆ max    ┆ # calls │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤
│ balanceOf             ┆ 596             ┆ 596    ┆ 596    ┆ 596    ┆ 44      │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤
│ balanceOfBatch        ┆ 2363            ┆ 4005   ┆ 4005   ┆ 5647   ┆ 2       │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤
│ batchBurn             ┆ 2126            ┆ 5560   ┆ 2584   ┆ 11970  ┆ 3       │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤
│ batchMint             ┆ 2444            ┆ 135299 ┆ 125081 ┆ 438531 ┆ 18      │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤
│ burn                  ┆ 814             ┆ 2117   ┆ 2117   ┆ 3421   ┆ 2       │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤
│ isApprovedForAll      ┆ 749             ┆ 749    ┆ 749    ┆ 749    ┆ 1       │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤
│ mint                  ┆ 26039           ┆ 31943  ┆ 27685  ┆ 118859 ┆ 22      │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤
│ safeBatchTransferFrom ┆ 2561            ┆ 137750 ┆ 126910 ┆ 461304 ┆ 8       │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤
│ safeTransferFrom      ┆ 1335            ┆ 34505  ┆ 28103  ┆ 139557 ┆ 9       │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤
│ setApprovalForAll     ┆ 24485           ┆ 24485  ┆ 24485  ┆ 24485  ┆ 12      │
╰───────────────────────┴─────────────────┴────────┴────────┴────────┴─────────╯

╭───────────────────────┬─────────────────┬────────┬────────┬────────┬─────────╮
│ Example contract      ┆                 ┆        ┆        ┆        ┆         │
╞═══════════════════════╪═════════════════╪════════╪════════╪════════╪═════════╡
│ Deployment Cost       ┆ Deployment Size ┆        ┆        ┆        ┆         │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤
│ 1082720               ┆ 5440            ┆        ┆        ┆        ┆         │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤
│ Function Name         ┆ min             ┆ avg    ┆ median ┆ max    ┆ # calls │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤
│ foo                   ┆ 596             ┆ 596    ┆ 596    ┆ 596    ┆ 44      │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤
│ bar                   ┆ 2363            ┆ 4005   ┆ 4005   ┆ 5647   ┆ 2       │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤
│ baz                   ┆ 2126            ┆ 5560   ┆ 2584   ┆ 11970  ┆ 3       │
╰───────────────────────┴─────────────────┴────────┴────────┴────────┴─────────╯
</code></pre>
<p>你也可以通过 <code>foundry.toml</code> 文件中的 <code>gas_reports_ignore</code> 字段忽略合约：</p>
<pre><code class="language-toml">gas_reports_ignore = ["Example"]
</code></pre>
<p>这将改变输出为：</p>
<pre><code class="language-ignore">╭───────────────────────┬─────────────────┬────────┬────────┬────────┬─────────╮
│ MockERC1155 contract  ┆                 ┆        ┆        ┆        ┆         │
╞═══════════════════════╪═════════════════╪════════╪════════╪════════╪═════════╡
│ Deployment Cost       ┆ Deployment Size ┆        ┆        ┆        ┆         │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤
│ 1082720               ┆ 5440            ┆        ┆        ┆        ┆         │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤
│ Function Name         ┆ min             ┆ avg    ┆ median ┆ max    ┆ # calls │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤
│ balanceOf             ┆ 596             ┆ 596    ┆ 596    ┆ 596    ┆ 44      │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤
│ balanceOfBatch        ┆ 2363            ┆ 4005   ┆ 4005   ┆ 5647   ┆ 2       │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤
│ batchBurn             ┆ 2126            ┆ 5560   ┆ 2584   ┆ 11970  ┆ 3       │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤
│ batchMint             ┆ 2444            ┆ 135299 ┆ 125081 ┆ 438531 ┆ 18      │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤
│ burn                  ┆ 814             ┆ 2117   ┆ 2117   ┆ 3421   ┆ 2       │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤
│ isApprovedForAll      ┆ 749             ┆ 749    ┆ 749    ┆ 749    ┆ 1       │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤
│ mint                  ┆ 26039           ┆ 31943  ┆ 27685  ┆ 118859 ┆ 22      │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤
│ safeBatchTransferFrom ┆ 2561            ┆ 137750 ┆ 126910 ┆ 461304 ┆ 8       │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤
│ safeTransferFrom      ┆ 1335            ┆ 34505  ┆ 28103  ┆ 139557 ┆ 9       │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤
│ setApprovalForAll     ┆ 24485           ┆ 24485  ┆ 24485  ┆ 24485  ┆ 12      │
╰───────────────────────┴─────────────────┴────────┴────────┴────────┴─────────╯
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="气体快照"><a class="header" href="#气体快照">气体快照</a></h2>
<p>Forge 可以为所有测试函数生成气体快照。这对于了解合约消耗的气体量或比较各种优化前后的气体使用情况非常有用。</p>
<p>要生成气体快照，请运行 <a href="forge/../reference/forge/forge-snapshot.html"><code>forge snapshot</code></a>。</p>
<p>默认情况下，这将生成一个名为 <code>.gas-snapshot</code> 的文件，其中包含所有测试及其相应的气体使用情况。</p>
<pre><code class="language-ignore">$ forge snapshot
$ cat .gas-snapshot

ERC20Test:testApprove() (gas: 31162)
ERC20Test:testBurn() (gas: 59875)
ERC20Test:testFailTransferFromInsufficientAllowance() (gas: 81034)
ERC20Test:testFailTransferFromInsufficientBalance() (gas: 81662)
ERC20Test:testFailTransferInsufficientBalance() (gas: 52882)
ERC20Test:testInfiniteApproveTransferFrom() (gas: 90167)
ERC20Test:testMetadata() (gas: 14606)
ERC20Test:testMint() (gas: 53830)
ERC20Test:testTransfer() (gas: 60473)
ERC20Test:testTransferFrom() (gas: 84152)
</code></pre>
<h3 id="过滤"><a class="header" href="#过滤">过滤</a></h3>
<p>如果您想指定不同的输出文件，请运行 <code>forge snapshot --snap &lt;FILE_NAME&gt;</code>。</p>
<p>您还可以按气体使用情况对结果进行排序。使用 <code>--asc</code> 选项按升序排序结果，使用 <code>--desc</code> 按降序排序结果。</p>
<p>最后，您还可以为所有测试指定最小/最大气体阈值。要仅包含高于阈值的结果，可以使用 <code>--min &lt;VALUE&gt;</code> 选项。同样，要仅包含低于阈值的结果，可以使用 <code>--max &lt;VALUE&gt;</code> 选项。</p>
<p>请记住，这些更改将应用于快照文件，而不是显示在屏幕上的快照。</p>
<p>您还可以将其与 <code>forge test</code> 的过滤器结合使用，例如 <code>forge snapshot --match-path contracts/test/ERC721.t.sol</code> 以生成与此测试合约相关的气体快照。</p>
<h3 id="比较气体使用情况"><a class="header" href="#比较气体使用情况">比较气体使用情况</a></h3>
<p>如果您想将当前快照文件与最新更改进行比较，可以使用 <code>--diff</code> 或 <code>--check</code> 选项。</p>
<p><code>--diff</code> 将比较快照并显示从快照中的变化。</p>
<p>它还可以选择性地接受文件名（<code>--diff &lt;FILE_NAME&gt;</code>），默认情况下为 <code>.gas-snapshot</code>。</p>
<p>例如：</p>
<pre><code class="language-ignore">$ forge snapshot --diff .gas-snapshot2

Running 10 tests for src/test/ERC20.t.sol:ERC20Test
[PASS] testApprove() (gas: 31162)
[PASS] testBurn() (gas: 59875)
[PASS] testFailTransferFromInsufficientAllowance() (gas: 81034)
[PASS] testFailTransferFromInsufficientBalance() (gas: 81662)
[PASS] testFailTransferInsufficientBalance() (gas: 52882)
[PASS] testInfiniteApproveTransferFrom() (gas: 90167)
[PASS] testMetadata() (gas: 14606)
[PASS] testMint() (gas: 53830)
[PASS] testTransfer() (gas: 60473)
[PASS] testTransferFrom() (gas: 84152)
Test result: ok. 10 passed; 0 failed; finished in 2.86ms
testBurn() (gas: 0 (0.000%))
testFailTransferFromInsufficientAllowance() (gas: 0 (0.000%))
testFailTransferFromInsufficientBalance() (gas: 0 (0.000%))
testFailTransferInsufficientBalance() (gas: 0 (0.000%))
testInfiniteApproveTransferFrom() (gas: 0 (0.000%))
testMetadata() (gas: 0 (0.000%))
testMint() (gas: 0 (0.000%))
testTransfer() (gas: 0 (0.000%))
testTransferFrom() (gas: 0 (0.000%))
testApprove() (gas: -8 (-0.000%))
Overall gas change: -8 (-0.000%)
</code></pre>
<p><code>--check</code> 将比较快照与现有快照文件并显示所有差异（如果有）。您可以通过提供不同的文件名来更改要比较的文件：<code>--check &lt;FILE_NAME&gt;</code>。</p>
<p>例如：</p>
<pre><code class="language-ignore">$ forge snapshot --check .gas-snapshot2

Running 10 tests for src/test/ERC20.t.sol:ERC20Test
[PASS] testApprove() (gas: 31162)
[PASS] testBurn() (gas: 59875)
[PASS] testFailTransferFromInsufficientAllowance() (gas: 81034)
[PASS] testFailTransferFromInsufficientBalance() (gas: 81662)
[PASS] testFailTransferInsufficientBalance() (gas: 52882)
[PASS] testInfiniteApproveTransferFrom() (gas: 90167)
[PASS] testMetadata() (gas: 14606)
[PASS] testMint() (gas: 53830)
[PASS] testTransfer() (gas: 60473)
[PASS] testTransferFrom() (gas: 84152)
Test result: ok. 10 passed; 0 failed; finished in 2.47ms
Diff in "ERC20Test::testApprove()": consumed "(gas: 31162)" gas, expected "(gas: 31170)" gas 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="调试器"><a class="header" href="#调试器">调试器</a></h2>
<p>Forge 附带了一个交互式调试器。</p>
<p>调试器可以通过 <a href="forge/../reference/forge/forge-debug.html"><code>forge debug</code></a> 和 <a href="forge/../reference/forge/forge-test.html"><code>forge test</code></a> 访问。</p>
<p>使用 <code>forge test</code>：</p>
<pre><code class="language-sh">$ forge test --debug $FUNC
</code></pre>
<p>其中 <code>$FUNC</code> 是你想要调试的函数的签名。例如：</p>
<pre><code class="language-sh">$ forge test --debug "testSomething()"
</code></pre>
<p>如果你有多个合约具有相同函数名，你需要使用 <code>--match-path</code> 和 <code>--match-contract</code> 将匹配的函数限制为仅一个。</p>
<p>如果匹配的测试是一个模糊测试，调试器将打开第一个失败的模糊场景，或者最后一个成功的场景，以先到者为准。</p>
<p>使用 <code>forge debug</code>：</p>
<pre><code class="language-sh">$ forge debug --debug $FILE --sig $FUNC
</code></pre>
<p>其中 <code>$FILE</code> 是你想要调试的合约的路径，<code>$FUNC</code> 是你想要调试的函数的签名。例如：</p>
<pre><code class="language-sh">$ forge debug --debug src/SomeContract.sol --sig "myFunc(uint256,string)" 123 "hello"
</code></pre>
<p>你也可以使用 <code>--sig</code> 指定原始调用数据，而不是函数签名。</p>
<p>如果你的源文件包含多个合约，使用 <code>--target-contract</code> 标志指定你想要调试的合约。</p>
<h3 id="调试器布局"><a class="header" href="#调试器布局">调试器布局</a></h3>
<p><img src="forge/../images/debugger.png" alt="调试器 UI 的图像" /></p>
<p>当调试器运行时，你会看到一个分为四个象限的终端：</p>
<ul>
<li><strong>象限 1</strong>：调试会话中的操作码，当前操作码高亮显示。此外，还会显示当前账户的地址、程序计数器和累积的 gas 使用量。</li>
<li><strong>象限 2</strong>：当前堆栈，以及堆栈的大小。</li>
<li><strong>象限 3</strong>：源代码视图。</li>
<li><strong>象限 4</strong>：EVM 的当前内存。</li>
</ul>
<p>当你逐步执行代码时，你会注意到堆栈和内存中的单词有时会改变颜色。</p>
<p>对于内存：</p>
<ul>
<li><strong>红色单词</strong> 是当前操作码即将写入的。</li>
<li><strong>绿色单词</strong> 是前一个操作码写入的。</li>
<li><strong>青色单词</strong> 是当前操作码正在读取的。</li>
</ul>
<p>对于堆栈，<strong>青色单词</strong> 是当前操作码正在读取或弹出的。</p>
<blockquote>
<p>⚠️ <strong>注意</strong></p>
<p>在大多数测试框架中，第一个失败的测试断言是报告的那个。
在 foundry 中，最后一个失败的测试断言（来自 DSTest 或 cheatcodes）是报告的那个。</p>
</blockquote>
<h3 id="导航"><a class="header" href="#导航">导航</a></h3>
<h3 id="通用"><a class="header" href="#通用">通用</a></h3>
<ul>
<li><kbd>q</kbd>：退出调试器</li>
<li><kbd>h</kbd>：显示帮助</li>
</ul>
<h3 id="导航调用"><a class="header" href="#导航调用">导航调用</a></h3>
<ul>
<li><kbd>0-9</kbd> + <kbd>k</kbd>：向后步进一定次数（或者用鼠标向上滚动）</li>
<li><kbd>0-9</kbd> + <kbd>j</kbd>：向前步进一定次数（或者用鼠标向下滚动）</li>
<li><kbd>g</kbd>：移动到交易的开头</li>
<li><kbd>G</kbd>：移动到交易的结尾</li>
<li><kbd>c</kbd>：移动到前一个调用类型的指令（即 <a href="https://www.evm.codes/#f1" title="" target="_blank">
<code>CALL</code></a>、<a href="https://www.evm.codes/#fa" title="" target="_blank">
<code>STATICCALL</code></a>、<a href="https://www.evm.codes/#f4" title="" target="_blank">
<code>DELEGATECALL</code></a> 和 <a href="https://www.evm.codes/#f2" title="" target="_blank">
<code>CALLCODE</code></a>）。</li>
<li><kbd>C</kbd>：移动到下一个调用类型的指令</li>
<li><kbd>a</kbd>：移动到前一个 <a href="https://www.evm.codes/#f1" title="" target="_blank">
<code>JUMP</code></a> 或 <a href="https://www.evm.codes/#57" title="" target="_blank">
<code>JUMPI</code></a> 指令</li>
<li><kbd>s</kbd>：移动到下一个 <a href="https://www.evm.codes/#5b" title="" target="_blank">
<code>JUMPDEST</code></a> 指令</li>
<li><kbd>’</kbd> + <kbd>a-z</kbd>：移动到由 <a href="forge/../cheatcodes/breakpoint.html"><code>vm.breakpoint</code></a> cheatcode 设置的 <code>&lt;char&gt;</code> 断点</li>
</ul>
<h3 id="导航内存"><a class="header" href="#导航内存">导航内存</a></h3>
<ul>
<li><kbd>Ctrl</kbd> + <kbd>j</kbd>：向下滚动内存视图</li>
<li><kbd>Ctrl</kbd> + <kbd>k</kbd>：向上滚动内存视图</li>
<li><kbd>m</kbd>：以 UTF8 格式显示内存</li>
</ul>
<h3 id="导航堆栈"><a class="header" href="#导航堆栈">导航堆栈</a></h3>
<ul>
<li><kbd>J</kbd>：向下滚动堆栈视图</li>
<li><kbd>K</kbd>：向上滚动堆栈视图</li>
<li><kbd>t</kbd>：在堆栈上显示标签，以查看当前操作码将消耗哪些项目</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-概述"><a class="header" href="#cast-概述">Cast 概述</a></h2>
<p>Cast 是 Foundry 的命令行工具，用于执行以太坊 RPC 调用。您可以通过命令行进行智能合约调用、发送交易或检索任何类型的链上数据！</p>
<h3 id="如何使用-cast"><a class="header" href="#如何使用-cast">如何使用 Cast</a></h3>
<p>要使用 Cast，请运行 <a href="cast/../reference/cast/cast.html"><code>cast</code></a> 命令，后跟一个子命令：</p>
<pre><code class="language-bash">$ cast &lt;subcommand&gt;
</code></pre>
<h4 id="示例-1"><a class="header" href="#示例-1">示例</a></h4>
<p>让我们使用 <code>cast</code> 来检索 DAI 代币的总供应量：</p>
<pre><code class="language-bash">$ cast call 0x6b175474e89094c44da98b954eedeac495271d0f "totalSupply()(uint256)" --rpc-url https://eth-mainnet.alchemyapi.io/v2/Lc7oIGYeL_QvInzI0Wiu_pOZZDEKBrdf
3203038914444116705728126916 [3.203e27]
</code></pre>
<p><code>cast</code> 还提供了许多方便的子命令，例如用于解码 calldata：</p>
<pre><code class="language-bash">$ cast 4byte-decode 0x1F1F897F676d00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003e7
1) "fulfillRandomness(bytes32,uint256)"
0x676d000000000000000000000000000000000000000000000000000000000000
999
</code></pre>
<p>您还可以使用 <code>cast</code> 发送任意消息。以下是一个在两个 Anvil 账户之间发送消息的示例。</p>
<pre><code class="language-bash">$ cast send --private-key &lt;Your Private Key&gt; 0x3c44cdddb6a900fa2b585dd299e03d12fa4293bc $(cast from-utf8 "hello world") --rpc-url http://127.0.0.1:8545/
</code></pre>
<br>
<blockquote>
<p>📚 <strong>参考</strong></p>
<p>请参阅 <a href="cast/../reference/cast/"><code>cast</code> 参考</a> 以获取所有可用子命令的完整概述。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="anvil-概述"><a class="header" href="#anvil-概述">Anvil 概述</a></h2>
<p>Anvil 是 Foundry 附带的一个本地测试网节点。你可以使用它来测试从前端调用的合约或通过 RPC 进行交互。</p>
<p>Anvil 是 Foundry 套件的一部分，与 <code>forge</code>、<code>cast</code> 和 <code>chisel</code> 一起安装。如果你还没有安装 Foundry，请参见 <a href="anvil/../getting-started/installation.html">Foundry 安装</a>。</p>
<blockquote>
<p>注意：如果你安装了旧版本的 Foundry，你需要重新安装 <code>foundryup</code> 以便下载 Anvil。</p>
</blockquote>
<h3 id="如何使用-anvil"><a class="header" href="#如何使用-anvil">如何使用 Anvil</a></h3>
<p>要使用 Anvil，只需输入 <code>anvil</code>。你应该会看到一组可用的账户和私钥，以及节点正在监听的地址和端口。</p>
<p>Anvil 具有高度的可配置性。你可以运行 <code>anvil -h</code> 来查看所有配置选项。</p>
<p>一些基本选项包括：</p>
<pre><code class="language-bash"># 要生成和配置的开发账户数量。[默认值：10]
anvil -a, --accounts &lt;ACCOUNTS&gt;

# 使用的 EVM 硬分叉。[默认值：latest]
anvil --hardfork &lt;HARDFORK&gt;

# 监听的端口号。[默认值：8545]
anvil  -p, --port &lt;PORT&gt;
</code></pre>
<blockquote>
<p>📚 <strong>参考</strong></p>
<p>请参见 <a href="anvil/../reference/anvil/"><code>anvil</code> 参考</a> 以获取有关 Anvil 及其功能的深入信息。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="chisel-概述"><a class="header" href="#chisel-概述">Chisel 概述</a></h2>
<p>Chisel 是 Foundry 附带的高级 Solidity REPL。它可以在本地或分叉网络上快速测试 Solidity 代码片段的行为。</p>
<p>Chisel 是 Foundry 套件的一部分，与 <code>forge</code>、<code>cast</code> 和 <code>anvil</code> 一起安装。如果您还没有安装 Foundry，请参阅 <a href="chisel/../getting-started/installation.html">Foundry 安装</a>。</p>
<blockquote>
<p>注意：如果您安装了旧版本的 Foundry，则需要重新安装 <code>foundryup</code> 以便下载 Chisel。</p>
</blockquote>
<h3 id="如何使用-chisel"><a class="header" href="#如何使用-chisel">如何使用 Chisel</a></h3>
<p>要使用 Chisel，只需输入 <code>chisel</code>。然后，开始编写 Solidity 代码！Chisel 将对每个输入提供详细的反馈。</p>
<p>Chisel 可以在 Foundry 项目内部和外部使用。如果在 Foundry 项目根目录中执行二进制文件，Chisel 将继承项目的配置选项。</p>
<p>要查看可用命令，请在 REPL 中输入 <code>!help</code>。</p>
<blockquote>
<p>📚 <strong>参考</strong></p>
<p>有关 Chisel 及其功能的深入信息，请参阅 <a href="chisel/../reference/chisel/"><code>chisel</code> 参考</a>。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="使用-foundrytoml-进行配置"><a class="header" href="#使用-foundrytoml-进行配置">使用 <code>foundry.toml</code> 进行配置</a></h2>
<p>Forge 可以使用一个名为 <code>foundry.toml</code> 的配置文件进行配置，该文件放置在项目的根目录中。</p>
<p>配置可以通过配置文件进行命名空间划分。默认的配置文件名为 <code>default</code>，所有其他配置文件都继承自该配置文件。您可以自由地自定义 <code>default</code> 配置文件，并根据需要添加任意数量的新配置文件。</p>
<p>此外，您可以在主目录中创建一个全局的 <code>foundry.toml</code> 文件。</p>
<p>让我们来看一个包含两个配置文件的配置文件：默认配置文件，始终启用优化器，以及一个 CI 配置文件，始终显示跟踪信息：</p>
<pre><code class="language-toml">[profile.default]
optimizer = true
optimizer_runs = 20_000

[profile.ci]
verbosity = 4
</code></pre>
<p>运行 <code>forge</code> 时，可以使用 <code>FOUNDRY_PROFILE</code> 环境变量指定要使用的配置文件。</p>
<h3 id="独立部分"><a class="header" href="#独立部分">独立部分</a></h3>
<p>除了配置文件部分外，配置文件还可以包含独立部分（如 <code>[fmt]</code>、<code>[fuzz]</code>、<code>[invariant]</code> 等）。默认情况下，每个独立部分都属于 <code>default</code> 配置文件。
即 <code>[fmt]</code> 等同于 <code>[profile.default.fmt]</code>。</p>
<p>要为 <code>default</code> 以外的其他配置文件配置独立部分，请使用语法 <code>[profile.&lt;profile name&gt;.&lt;standalone&gt;]</code>。
即 <code>[profile.ci.fuzz]</code>。</p>
<br>
<blockquote>
<p>📚 <strong>参考</strong></p>
<p>请参阅 <a href="config/../reference/config/"><code>foundry.toml</code> 参考</a> 以获取完整的配置概览。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="持续集成"><a class="header" href="#持续集成">持续集成</a></h2>
<h3 id="github-actions"><a class="header" href="#github-actions">GitHub Actions</a></h3>
<p>要使用 GitHub Actions 测试您的项目，以下是一个示例工作流程：</p>
<pre><code class="language-yml">on: [push]

name: test

jobs:
  check:
    name: Foundry 项目
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          submodules: recursive

      - name: 安装 Foundry
        uses: foundry-rs/foundry-toolchain@v1
        with:
          version: nightly

      - name: 运行测试
        run: forge test -vvv
</code></pre>
<h3 id="travis-ci"><a class="header" href="#travis-ci">Travis CI</a></h3>
<p>要使用 Travis CI 测试您的项目，以下是一个示例工作流程：</p>
<pre><code class="language-yml">language: rust
cache:
  cargo: true
  directories:
    - $HOME/.foundry

install:
  - curl -L https://foundry.paradigm.xyz | bash
  - export PATH=$PATH:$HOME/.foundry/bin
  - foundryup -b master

script:
  - forge test -vvv
</code></pre>
<h2 id="gitlab-ci"><a class="header" href="#gitlab-ci">GitLab CI</a></h2>
<p>要使用 GitLab CI 测试您的项目，以下是一个示例工作流程：
注意：请查看 <a href="https://docs.gitlab.com/runner/executors/docker.html#how-pull-policies-work" title="" target="_blank">Policy</a> 以获取远程镜像</p>
<pre><code class="language-yml">variables:
  GIT_SUBMODULE_STRATEGY: recursive

jobs:
  image: ghcr.io/foundry-rs/foundry
  script:
    - forge install
    - forge test -vvv
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="集成到-vscode"><a class="header" href="#集成到-vscode">集成到 VSCode</a></h2>
<p>您可以通过安装 <a href="https://github.com/juanfranblanco/vscode-solidity" title="" target="_blank">VSCode Solidity 扩展</a> 来为 Visual Studio Code 获取 Solidity 支持。</p>
<p>为了让扩展与 Foundry 更好地配合，您可能需要调整一些设置。</p>
<h3 id="1-重映射"><a class="header" href="#1-重映射">1. 重映射</a></h3>
<p>您可能希望将重映射放在 <code>remappings.txt</code> 中。</p>
<p>如果它们已经在 <code>foundry.toml</code> 中，请将它们复制过来并使用 <code>remappings.txt</code> 代替。如果您只是使用 Foundry 提供的自动生成的重映射，请运行 <code>forge remappings &gt; remappings.txt</code>。</p>
<h3 id="2-依赖项"><a class="header" href="#2-依赖项">2. 依赖项</a></h3>
<p>您可能需要将以下内容添加到您的 <code>.vscode/settings.json</code> 中，以便扩展能够找到您的依赖项：</p>
<pre><code class="language-json">{
  "solidity.packageDefaultDependenciesContractsDirectory": "src",
  "solidity.packageDefaultDependenciesDirectory": "lib"
}
</code></pre>
<p>其中 <code>src</code> 是源代码目录，<code>lib</code> 是您的依赖项目录。</p>
<h3 id="3-格式化器"><a class="header" href="#3-格式化器">3. 格式化器</a></h3>
<p>要启用 Foundry 内置的格式化器，以便在保存时自动格式化您的代码，您可以将以下设置添加到您的 <code>.vscode/settings.json</code> 中：</p>
<pre><code class="language-json">{
  "editor.formatOnSave": true,
  "[solidity]": {
    "editor.defaultFormatter": "JuanBlanco.solidity" 
  },
  "solidity.formatter": "forge",
}
</code></pre>
<p>要配置格式化器设置，请参考 <a href="config/../reference/config/formatter.html">格式化器</a> 参考。</p>
<h3 id="4-solc-版本"><a class="header" href="#4-solc-版本">4. Solc 版本</a></h3>
<p>最后，建议指定一个 Solidity 编译器版本：</p>
<pre><code class="language-json">"solidity.compileUsingRemoteVersion": "v0.8.17"
</code></pre>
<p>为了使 Foundry 与所选版本保持一致，请将以下内容添加到您的 <code>foundry.toml</code> 中的 <code>default</code> 配置文件中。</p>
<pre><code class="language-toml">solc = "0.8.17"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="自动补全脚本"><a class="header" href="#自动补全脚本">自动补全脚本</a></h2>
<p>你可以为 <code>bash</code>、<code>elvish</code>、<code>fish</code>、<code>powershell</code> 和 <code>zsh</code> 生成自动补全脚本。</p>
<h3 id="zsh"><a class="header" href="#zsh">zsh</a></h3>
<p>首先，确保在你的 <code>~/.zshrc</code> 文件中包含以下内容（如果没有，请添加）：</p>
<pre><code class="language-sh">autoload -U compinit
compinit -i
</code></pre>
<p>然后运行：</p>
<pre><code class="language-sh">forge completions zsh | sudo tee /usr/local/share/zsh/site-functions/_forge
cast completions zsh | sudo tee /usr/local/share/zsh/site-functions/_cast
anvil completions zsh | sudo tee /usr/local/share/zsh/site-functions/_anvil
</code></pre>
<p>对于 macOS：</p>
<pre><code class="language-sh">forge completions zsh &gt; /opt/homebrew/completions/zsh/_forge
cast completions zsh &gt; /opt/homebrew/completions/zsh/_cast
anvil completions zsh &gt; /opt/homebrew/completions/zsh/_anvil
</code></pre>
<h3 id="fish"><a class="header" href="#fish">fish</a></h3>
<pre><code class="language-sh">mkdir -p $HOME/.config/fish/completions
forge completions fish &gt; $HOME/.config/fish/completions/forge.fish
cast completions fish &gt; $HOME/.config/fish/completions/cast.fish
anvil completions fish &gt; $HOME/.config/fish/completions/anvil.fish
source $HOME/.config/fish/config.fish
</code></pre>
<h3 id="bash"><a class="header" href="#bash">bash</a></h3>
<pre><code class="language-sh">mkdir -p $HOME/.local/share/bash-completion/completions
forge completions bash &gt; $HOME/.local/share/bash-completion/completions/forge
cast completions bash &gt; $HOME/.local/share/bash-completion/completions/cast
anvil completions bash &gt; $HOME/.local/share/bash-completion/completions/anvil
exec bash
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="静态分析器"><a class="header" href="#静态分析器">静态分析器</a></h2>
<h3 id="slither"><a class="header" href="#slither">Slither</a></h3>
<p>要使用 <a href="https://github.com/crytic/slither" title="" target="_blank">slither</a> 测试您的项目，以下是一个示例 <code>slither.config.json</code>：</p>
<pre><code class="language-json">{
  "filter_paths": "lib"
}
</code></pre>
<p>要在项目的根目录下运行 Slither 进行整个项目的测试，请使用以下命令：</p>
<pre><code class="language-sh">slither .
</code></pre>
<p>默认情况下（截至版本 0.10.0），这将跳过测试和脚本。要强制包含测试和脚本，请添加 <code>--foundry-compile-all</code> 标志。</p>
<p>要运行 Slither 对单个文件进行测试，请使用以下命令：</p>
<pre><code class="language-sh">slither src/Contract.sol
</code></pre>
<p>注意，这需要在 foundry 配置文件中配置 <a href="https://book.getfoundry.sh/reference/config/solidity-compiler#solc_version" title="" target="_blank">solc 版本</a>。</p>
<p>您不需要通过 <code>solc_remaps</code> 选项提供重映射，因为 Slither 会自动检测 Foundry 项目中的重映射。Slither 将调用 <code>forge</code> 进行构建。</p>
<p>更多信息请参见 <a href="https://github.com/crytic/slither/wiki/Usage" title="" target="_blank">Slither wiki</a>。</p>
<p>为了使用自定义配置，例如上面提到的示例 <code>slither.config.json</code>，以下命令是根据 <a href="https://github.com/crytic/slither/wiki/Usage#configuration-file" title="" target="_blank">slither-wiki</a> 提到的。默认情况下，slither 会查找 <code>slither.config.json</code>，但您可以定义路径和任何其他 <code>json</code> 文件：</p>
<pre><code class="language-sh">slither --config-file &lt;path&gt;/file.config.json .
</code></pre>
<p>示例输出（原始）：</p>
<pre><code class="language-bash">Pragma version^0.8.13 (Counter.sol#2) 需要一个过于新的版本，不值得信任。建议使用 0.6.12/0.7.6/0.8.7 进行部署
solc-0.8.13 不推荐用于部署
参考: https://github.com/crytic/slither/wiki/Detector-Documentation#incorrect-versions-of-solidity

setNumber(uint256) 应声明为 external:
        - Counter.setNumber(uint256) (Counter.sol#7-9)
increment() 应声明为 external:
        - Counter.increment() (Counter.sol#11-13)
参考: https://github.com/crytic/slither/wiki/Detector-Documentation#public-function-that-could-be-declared-external
Counter.sol 已分析（1 个合约，78 个检测器），4 个结果
</code></pre>
<p>Slither 还有一个用于 CI/CD 的 <a href="https://github.com/marketplace/actions/slither-action" title="" target="_blank">GitHub Action</a>。</p>
<h3 id="mythril"><a class="header" href="#mythril">Mythril</a></h3>
<p>要使用 <a href="https://github.com/ConsenSys/mythril" title="" target="_blank">mythril</a> 测试您的项目，以下是一个示例 <code>mythril.config.json</code>：</p>
<pre><code class="language-json">{
  "remappings": [
    "ds-test/=lib/ds-test/src/",
    "forge-std/=lib/forge-std/src/"
  ],
  "optimizer": {
    "enabled": true,
    "runs": 200
  }
}
</code></pre>
<p>注意，您需要将 <code>rustc</code> 切换到 nightly 版本来安装 <code>mythril</code>：</p>
<pre><code class="language-ignore">rustup default nightly
pip3 install mythril
myth analyze src/Contract.sol --solc-json mythril.config.json
</code></pre>
<p>更多信息请参见 <a href="https://mythril-classic.readthedocs.io/en/develop/" title="" target="_blank">mythril 文档</a>。</p>
<p>您可以使用 <code>--solc-json</code> 标志将自定义的 Solc 编译器输出传递给 Mythril。例如：</p>
<pre><code class="language-bash">$ myth analyze src/Counter.sol --solc-json mythril.config.json
.
.
mythril.laser.plugin.loader [INFO]: 加载激光插件: coverage
mythril.laser.plugin.loader [INFO]: 加载激光插件: mutation-pruner
.
.
代码覆盖率达到 11.56%: 608060405234801561001057600080fd5b5060f78061001f6000396000f3fe6080604052348015600f57600080fd5b5060043610603c5760003560e01c80633fb5c1cb1460415780638381f58a146053578063d09de08a14606d575b600080fd5b6051604c3660046083565b600055565b005b605b60005481565b60405190815260200160405180910390f35b6051600080549080607c83609b565b9190505550565b600060208284031215609457600080fd5b5035919050565b60006001820160ba57634e487b7160e01b600052601160045260246000fd5b506001019056fea2646970667358221220659fce8aadca285da9206b61f95de294d3958c409cc3011ded856f421885867464736f6c63430008100033
mythril.laser.plugin.plugins.coverage.coverage_plugin [INFO]: 代码覆盖率达到 90.13%: 6080604052348015600f57600080fd5b5060043610603c5760003560e01c80633fb5c1cb1460415780638381f58a146053578063d09de08a14606d575b600080fd5b6051604c3660046083565b600055565b005b605b60005481565b60405190815260200160405180910390f35b6051600080549080607c83609b565b9190505550565b600060208284031215609457600080fd5b5035919050565b60006001820160ba57634e487b7160e01b600052601160045260246000fd5b506001019056fea2646970667358221220659fce8aadca285da9206b61f95de294d3958c409cc3011ded856f421885867464736f6c63430008100033
mythril.laser.plugin.plugins.instruction_profiler [INFO]: 总时间: 1.0892839431762695 s
[ADD         ]   0.9974 %,  nr      9,  total   0.0109 s,  avg   0.0012 s,  min   0.0011 s,  max   0.0013 s
.
.
[SWAP1       ]   1.8446 %,  nr     18,  total   0.0201 s,  avg   0.0011 s,  min   0.0010 s,  max   0.0013 s
[SWAP2       ]   0.8858 %,  nr      9,  total   0.0096 s,  avg   0.0011 s,  min   0.0010 s,  max   0.0011 s

mythril.analysis.security [INFO]: 开始分析
mythril.mythril.mythril_analyzer [INFO]: 求解器统计: 
查询次数: 61 
求解时间: 3.6820807456970215
分析成功完成。未检测到问题。
</code></pre>
<p>如果发现任何问题，这些发现将在输出末尾列出。由于默认的 <code>Counter.sol</code> 没有任何逻辑，<code>mythx</code> 报告未发现任何问题。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="与-hardhat-集成"><a class="header" href="#与-hardhat-集成">与 Hardhat 集成</a></h2>
<p>可以在 <a href="https://hardhat.org/" title="" target="_blank">Hardhat</a> 项目中使用 Foundry。本文假设您的系统中已经安装了 Foundry 和 node。本文还假设您熟悉 Foundry 和 Hardhat。</p>
<h3 id="为什么不能开箱即用"><a class="header" href="#为什么不能开箱即用">为什么不能开箱即用？</a></h3>
<p>Hardhat 默认期望库安装在 <code>node_modules</code> 中，这是所有 NodeJS 依赖项的默认文件夹。Foundry 期望它们在 <code>lib</code> 中。当然，<a href="config/../reference/config/overview.html">我们可以配置 Foundry</a>，但不容易配置到 <code>node_modules</code> 的目录结构。</p>
<p>因此，推荐的设置是使用 <a href="https://www.npmjs.com/package/@nomicfoundation/hardhat-foundry" title="" target="_blank">hardhat-foundry</a>。当正确安装和使用 hardhat-foundry 时，Hardhat 将使用 Foundry 使用的相同合约目录，并且能够使用通过 <code>forge install</code> 安装的依赖项。</p>
<p>本文将涵盖两种场景：</p>
<ol>
<li>在 Foundry 项目中添加 Hardhat，以及，</li>
<li>在 Hardhat 项目中添加 Foundry。</li>
</ol>
<h3 id="直接给我示例仓库"><a class="header" href="#直接给我示例仓库">直接给我示例仓库！</a></h3>
<p><a href="https://github.com/foundry-rs/HardhatInFoundry" title="" target="_blank">请看这里！</a></p>
<p>如果您想将此示例应用到现有的 Foundry 项目或了解其工作原理，请继续阅读：</p>
<h3 id="在-foundry-项目中添加-hardhat"><a class="header" href="#在-foundry-项目中添加-hardhat">在 Foundry 项目中添加 Hardhat</a></h3>
<p>在您的 Foundry 项目工作目录中：</p>
<ol>
<li><code>npm init -y</code> - 这将设置一个 <code>package.json</code> 文件。</li>
<li><code>npm i --save-dev hardhat</code> - 将 Hardhat 作为开发依赖项安装到您的项目中。</li>
<li><code>npx hardhat init</code> - 在同一目录中初始化您的 Hardhat 项目，并选择“<strong>Create an empty hardhat.config.js</strong>”选项。这将创建一个基本的 <code>hardhat.config.js</code> 文件。</li>
<li><code>npm i --save-dev @nomicfoundation/hardhat-foundry @nomicfoundation/hardhat-toolbox</code> - 这将安装 hardhat-foundry 插件和 Hardhat 工具箱插件，这是运行 Hardhat 测试所需的所有基本依赖项的组合。</li>
</ol>
<p>您的 hardhat.config.js 文件应如下所示以使插件工作：</p>
<pre><code class="language-javascript">require("@nomicfoundation/hardhat-toolbox");
require("@nomicfoundation/hardhat-foundry");
/** @type import('hardhat/config').HardhatUserConfig */
module.exports = {
  solidity: "0.8.19",
};
</code></pre>
<ol start="5">
<li>默认情况下，Foundry 项目附带一个简单的 <code>Counter.sol</code> 合约和几个测试。在与默认 <code>Counter.t.sol</code> 文件平行的 <code>test</code> 目录中创建一个名为 <code>Counter.t.js</code> 的文件。</li>
<li>将以下代码添加到 <code>Counter.t.js</code> 文件中：</li>
</ol>
<pre><code class="language-javascript">const { expect } = require("chai");
const hre = require("hardhat");
const { loadFixture } = require("@nomicfoundation/hardhat-toolbox/network-helpers");

describe("Counter contract", function () {
  async function CounterLockFixture() {
    const counter = await ethers.deployContract("Counter");
    await counter.setNumber(0);

    return { counter };
  }

  it("Should increment the number correctly", async function () {
    const { counter } = await loadFixture(CounterLockFixture);
    await counter.increment();
    expect(await counter.number()).to.equal(1);
  });

  // 这不是模糊测试，因为 Hardhat 尚不支持模糊测试。
  it("Should set the number correctly", async function () {
    const { counter } = await loadFixture(CounterLockFixture);
    await counter.setNumber(100);
    expect(await counter.number()).to.equal(100);
  });
});
</code></pre>
<p>这段代码将执行与默认 <code>Counter.t.sol</code> 文件相同的测试。</p>
<p>就是这样！
您可以在同一个 <code>test</code> 目录中创建 Hardhat 和 Foundry 测试，并分别使用 <code>npx hardhat test</code> 和 <code>forge test</code> 运行它们。
查看 <a href="https://hardhat.org/docs" title="" target="_blank">Hardhat 的文档</a> 以了解更多信息。</p>
<h3 id="在-hardhat-项目中添加-foundry"><a class="header" href="#在-hardhat-项目中添加-foundry">在 Hardhat 项目中添加 Foundry</a></h3>
<p>在您的 Hardhat 项目工作目录中：</p>
<ol>
<li><code>npm i --save-dev @nomicfoundation/hardhat-foundry</code> - 安装 hardhat-foundry 插件。</li>
<li>将 <code>require("@nomicfoundation/hardhat-foundry");</code> 添加到您的 <code>hardhat.config.js</code> 文件顶部。</li>
</ol>
<blockquote>
<p>ℹ️ <strong>注意</strong>
步骤 3 仅在您的目录是已初始化的 git 仓库时有效。如果尚未初始化，请运行 <code>git init</code>。</p>
</blockquote>
<ol start="3">
<li>在终端中运行 <code>npx hardhat init-foundry</code>。这将根据您现有 Hardhat 项目的配置生成一个 <code>foundry.toml</code> 文件，并安装 <code>forge-std</code> 库。</li>
</ol>
<p>Hardhat 现在将在同一目录中设置一个基本的 Foundry 项目，并在 <code>foundry.toml</code> 文件中进行一些配置，以确保 Foundry 知道在哪里查找您的合约、测试和依赖项。您可以随时通过编辑 <code>foundry.toml</code> 文件来更改这些配置。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="vyper-支持"><a class="header" href="#vyper-支持">Vyper 支持</a></h2>
<p>Foundry 支持编译和测试 Vyper 合约。</p>
<h3 id="1-编译"><a class="header" href="#1-编译">1. 编译</a></h3>
<p>您可以按照<a href="https://vyper.readthedocs.io/en/stable/installing-vyper.html" title="" target="_blank">这里</a>的说明安装 Vyper。如果您的 PATH 中有 <code>vyper</code>，Foundry 将自动使用它。</p>
<p>否则，您可以在 <code>foundry.toml</code> 中通过添加以下内容来设置 <code>vyper</code> 的路径：</p>
<pre><code class="language-toml">[vyper]
path = "/path/to/vyper"
</code></pre>
<h3 id="2-solidity-测试"><a class="header" href="#2-solidity-测试">2. Solidity 测试</a></h3>
<p>让我们为这个简单的 Counter 合约编写一个测试：</p>
<pre><code class="language-vyper">number: public(uint256)

@deploy
@payable
def __init__(initial_number: uint256):
    self.number = initial_number

@external
def set_number(new_number: uint256):
    self.number = new_number

@external
def increment():
    self.number += 1
</code></pre>
<p>我们可以使用 <code>forge-std</code> 中的 <code>deployCode</code> 作弊码来部署它，并用以下 Solidity 测试来测试它：</p>
<pre><code class="language-solidity">import {Test} from "forge-std/Test.sol";

interface ICounter {
    function increment() external;
    function number() external view returns (uint256);
    function set_number(uint256 newNumber) external;
}

contract CounterTest is Test {
    ICounter public counter;
    uint256 initialNumber = 5;

    function setUp() public {
        counter = ICounter(deployCode("Counter", abi.encode(initialNumber)));
        assertEq(counter.number(), initialNumber);
    }

    function test_Increment() public {
        counter.increment();
        assertEq(counter.number(), initialNumber + 1);
    }

    function testFuzz_SetNumber(uint256 x) public {
        counter.set_number(x);
        assertEq(counter.number(), x);
    }
}
</code></pre>
<h3 id="3-部署"><a class="header" href="#3-部署">3. 部署</a></h3>
<p>您可以通过 <code>forge create</code> 命令部署 Vyper 合约：</p>
<pre><code class="language-bash">forge create Counter --constructor-args '1' --rpc-url $RPC_URL --private-key $PRIVATE_KEY
</code></pre>
<p>通过 <code>deployCode</code>，您也可以在脚本中部署 Vyper 合约：</p>
<pre><code class="language-solidity">import {Script} from "forge-std/Script.sol";

contract CounterScript is Script {
    function run() public {
        vm.broadcast();
        deployCode("src/Counter.vy", abi.encode(1));
    }
}
</code></pre>
<h3 id="4-vyper-脚本"><a class="header" href="#4-vyper-脚本">4. Vyper 脚本</a></h3>
<p>您可以像编写 Solidity 脚本一样编写 Vyper 脚本：</p>
<pre><code class="language-vyper">interface Vm:
    def startBroadcast(): nonpayable

interface ICounter:
    def increment(): nonpayable
    def number() -&gt; uint256: view

vm: constant(Vm) = Vm(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D)

@external
def run(counter: address):
    number_before: uint256 = staticcall ICounter(counter).number()

    extcall vm.startBroadcast()
    extcall ICounter(counter).increment()

    number_after: uint256 = staticcall ICounter(counter).number()

    assert number_after == number_before + 1
</code></pre>
<p>这样的脚本可以通过以下命令运行：</p>
<pre><code class="language-bash">forge script script/Increment.s.vy  --sig 'run' '&lt;counter address&gt;' --rpc-url $RPC_URL --broadcast  --private-key $PRIVATE_KEY
</code></pre>
<h3 id="5-限制"><a class="header" href="#5-限制">5. 限制</a></h3>
<ul>
<li>虽然您可以编写和运行 Vyper 测试和脚本，但 Vyper 中没有 <code>new</code> 关键字允许您部署合约。这将在未来通过新的作弊码得到解决。</li>
<li>Vyper 不允许具有相同名称但参数类型不同的重载。因此，某些作弊码组合可能需要使用变通方法。（例如 <code>startBroadcast(address sender)</code> 和 <code>startBroadcast(uint256 pk)</code>）</li>
<li><code>forge coverage</code> 目前不支持 Vyper 合约。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="最佳实践"><a class="header" href="#最佳实践">最佳实践</a></h1>
<p>本指南记录了在使用 Foundry 进行开发时的建议最佳实践。通常情况下，建议尽可能使用 <a href="tutorials/../reference/config/formatter.html"><code>forge fmt</code></a> 处理，任何此工具未处理的内容如下所述。</p>
<ul>
<li><a href="tutorials/best-practices.html#best-practices">最佳实践</a>
<ul>
<li><a href="tutorials/best-practices.html#general-contract-guidance">通用合约指南</a></li>
<li><a href="tutorials/best-practices.html#tests">测试</a>
<ul>
<li><a href="tutorials/best-practices.html#general-test-guidance">通用测试指南</a></li>
<li><a href="tutorials/best-practices.html#fork-tests">分叉测试</a></li>
<li><a href="tutorials/best-practices.html#test-harnesses">测试工具</a>
<ul>
<li><a href="tutorials/best-practices.html#internal-functions">内部函数</a></li>
<li><a href="tutorials/best-practices.html#private-functions">私有函数</a></li>
<li><a href="tutorials/best-practices.html#workaround-functions">工作区函数</a></li>
</ul>
</li>
<li><a href="tutorials/best-practices.html#best-practices-1">最佳实践</a></li>
<li><a href="tutorials/best-practices.html#taint-analysis">污染分析</a></li>
</ul>
</li>
<li><a href="tutorials/best-practices.html#scripts">脚本</a>
<ul>
<li><a href="tutorials/best-practices.html#private-key-management">私钥管理</a></li>
</ul>
</li>
<li><a href="tutorials/best-practices.html#comments">注释</a></li>
<li><a href="tutorials/best-practices.html#resources">资源</a></li>
</ul>
</li>
</ul>
<h2 id="通用合约指南"><a class="header" href="#通用合约指南">通用合约指南</a></h2>
<ol>
<li>
<p>始终使用命名导入语法，不要导入整个文件。这限制了导入的内容仅为命名的项目，而不是文件中的所有内容。导入整个文件可能会导致 solc 抱怨重复定义和 slither 出错，尤其是在仓库增长并且有更多依赖项且名称重叠时。</p>
<ul>
<li>好：<code>import {MyContract} from "src/MyContract.sol"</code> 仅导入 <code>MyContract</code>。</li>
<li>坏：<code>import "src/MyContract.sol"</code> 导入 <code>MyContract.sol</code> 中的所有内容。（导入 <code>forge-std/Test</code> 或 <code>Script</code> 可以是一个例外，这样你可以获得控制台库等）。</li>
</ul>
</li>
<li>
<p>注意导入时绝对路径和相对路径之间的权衡（绝对路径相对于仓库根目录，例如 <code>"src/interfaces/IERC20.sol"</code>），并选择最适合你项目的方法：</p>
<ul>
<li>绝对路径更容易看到文件的来源，并且在移动文件时减少变动。</li>
<li>相对路径使你的编辑器更有可能提供诸如 linting 和自动完成等功能，因为编辑器/扩展可能不理解你的重映射。</li>
</ul>
</li>
<li>
<p>如果从依赖项复制库（而不是导入它），请在配置文件中使用 <code>ignore = []</code> 选项以避免格式化该文件。这使得与原始文件的差异对比更简单，便于审查和审计。</p>
</li>
<li>
<p>同样，可以自由使用 <code>// forgefmt: disable-*</code> 注释指令来忽略看起来更适合手动格式化的代码行/部分。<code>*</code> 的支持值有：</p>
<ul>
<li><code>disable-line</code></li>
<li><code>disable-next-line</code></li>
<li><code>disable-next-item</code></li>
<li><code>disable-start</code></li>
<li><code>disable-end</code></li>
</ul>
</li>
</ol>
<p>来自 <a href="https://twitter.com/samczsun" title="" target="_blank">samsczun</a> 的 <a href="https://www.youtube.com/watch?v=Wm3t8Fuiy1E" title="" target="_blank">How Do You Even Write Secure Code Anyways</a> 演讲的额外最佳实践：</p>
<ul>
<li>使用描述性变量名。</li>
<li>限制活动变量的数量。</li>
<li>没有冗余逻辑。</li>
<li>尽可能早退出以减少查看代码时的精神负担。</li>
<li>相关代码应放在一起。</li>
<li>删除未使用的代码。</li>
</ul>
<h2 id="测试-1"><a class="header" href="#测试-1">测试</a></h2>
<h3 id="通用测试指南"><a class="header" href="#通用测试指南">通用测试指南</a></h3>
<ol>
<li>
<p>对于测试 <code>MyContract.sol</code>，测试文件应为 <code>MyContract.t.sol</code>。对于测试 <code>MyScript.s.sol</code>，测试文件应为 <code>MyScript.t.sol</code>。</p>
<ul>
<li>如果合约很大并且你想将其拆分到多个文件中，可以按逻辑分组，如 <code>MyContract.owner.t.sol</code>、<code>MyContract.deposits.t.sol</code> 等。</li>
</ul>
</li>
<li>
<p>切勿在 <code>setUp</code> 函数中进行断言，而是使用专门的测试，如 <code>test_SetUpState()</code>，如果你需要确保 <code>setUp</code> 函数按预期工作。更多信息请参见 <a href="https://github.com/foundry-rs/foundry/issues/1291" title="" target="_blank">foundry-rs/foundry#1291</a>。</p>
</li>
<li>
<p>对于单元测试，有两种主要的组织测试的方法：</p>
<ol>
<li>
<p>将合约视为描述块：</p>
<ul>
<li><code>contract Add</code> 包含 <code>MyContract</code> 的 <code>add</code> 方法的所有单元测试。</li>
<li><code>contract Supply</code> 包含 <code>supply</code> 方法的所有测试。</li>
<li><code>contract Constructor</code> 包含构造函数的所有测试。</li>
<li>这种方法的好处是较小的合约应该比大合约编译得更快，因此这种方法在测试套件变大时应该节省时间。</li>
</ul>
</li>
<li>
<p>每个被测试的合约有一个测试合约，并尽可能多地使用工具和固定装置：</p>
<ul>
<li><code>contract MyContractTest</code> 包含 <code>MyContract</code> 的所有单元测试。</li>
<li><code>function test_add_AddsTwoNumbers()</code> 存在于 <code>MyContractTest</code> 中以测试 <code>add</code> 方法。</li>
<li><code>function test_supply_UsersCanSupplyTokens()</code> 也存在于 <code>MyContractTest</code> 中以测试 <code>supply</code> 方法。</li>
<li>这种方法的好处是测试输出按被测试的合约分组，这使得快速查看失败位置更容易。</li>
</ul>
</li>
</ol>
</li>
<li>
<p>所有测试的一些通用指南：</p>
<ul>
<li>测试合约/函数应按被测试合约中的原始函数顺序编写。</li>
<li>测试同一函数的所有单元测试应连续存在于测试文件中。</li>
<li>测试合约可以继承任何你想要的辅助合约。例如，测试 <code>MyContract</code> 的 <code>contract MyContractTest</code> 可能继承自 forge-std 的 <code>Test</code>，以及你自己的 <code>TestUtilities</code> 辅助合约。</li>
</ul>
</li>
<li>
<p>集成测试应存在于相同的 <code>test</code> 目录中，并具有清晰的命名约定。这些可以在专用文件中，或者在与现有单元测试相关的测试文件中。</p>
</li>
<li>
<p>保持测试命名的</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h2 id="使用-solmate-创建-nft"><a class="header" href="#使用-solmate-创建-nft">使用 Solmate 创建 NFT</a></h2>
<p>本教程将指导您使用 Foundry 和 <a href="https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol" title="" target="_blank">Solmate</a> 创建一个 OpenSea 兼容的 NFT。本教程的完整实现可以在此处找到 <a href="https://github.com/FredCoen/nft-tutorial" title="" target="_blank">这里</a>。</p>
<h5 id="本教程仅用于说明目的并按原样提供本教程未经过审计也未完全测试本教程中的代码不应在生产环境中使用"><a class="header" href="#本教程仅用于说明目的并按原样提供本教程未经过审计也未完全测试本教程中的代码不应在生产环境中使用">本教程仅用于说明目的，并按原样提供。本教程未经过审计也未完全测试。本教程中的代码不应在生产环境中使用。</a></h5>
<h3 id="创建项目并安装依赖"><a class="header" href="#创建项目并安装依赖">创建项目并安装依赖</a></h3>
<p>首先按照 <a href="tutorials/../getting-started/installation.html">入门部分</a> 中概述的步骤设置一个 Foundry 项目。我们还将安装 Solmate 以获取其 ERC721 实现，以及一些 OpenZeppelin 实用库。通过从项目根目录运行以下命令来安装依赖项：</p>
<pre><code class="language-bash">forge install transmissions11/solmate Openzeppelin/openzeppelin-contracts
</code></pre>
<p>这些依赖项将作为 git 子模块添加到您的项目中。</p>
<p>如果您正确地按照说明操作，您的项目结构应如下所示：</p>
<p><img src="tutorials/../images/nft-tutorial/nft-tutorial-project-structure.png" alt="项目结构" /></p>
<h3 id="实现一个基本的-nft"><a class="header" href="#实现一个基本的-nft">实现一个基本的 NFT</a></h3>
<p>然后，我们将样板合约 <code>src/Contract.sol</code> 重命名为 <code>src/NFT.sol</code> 并替换代码：</p>
<pre><code class="language-solidity">// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.10;

import "solmate/tokens/ERC721.sol";
import "openzeppelin-contracts/contracts/utils/Strings.sol";

contract NFT is ERC721 {
    uint256 public currentTokenId;

    constructor(
        string memory _name,
        string memory _symbol
    ) ERC721(_name, _symbol) {}

    function mintTo(address recipient) public payable returns (uint256) {
        uint256 newItemId = ++currentTokenId;
        _safeMint(recipient, newItemId);
        return newItemId;
    }

    function tokenURI(uint256 id) public view virtual override returns (string memory) {
        return Strings.toString(id);
    }
}
</code></pre>
<p>让我们来看看这个非常基本的 NFT 实现。我们首先从 git 子模块中导入两个合约。我们导入 Solmate 的 gas 优化 ERC721 标准实现，我们的 NFT 合约将继承自该实现。我们的构造函数接受 NFT 的 <code>_name</code> 和 <code>_symbol</code> 参数，并将它们传递给父 ERC721 实现的构造函数。最后，我们实现了 <code>mintTo</code> 函数，允许任何人铸造一个 NFT。该函数递增 <code>currentTokenId</code> 并使用父合约的 <code>_safeMint</code> 函数。</p>
<h3 id="使用-forge-编译和部署"><a class="header" href="#使用-forge-编译和部署">使用 forge 编译和部署</a></h3>
<p>要编译 NFT 合约，请运行 <code>forge build</code>。您可能会遇到由于错误映射导致的构建失败：</p>
<pre><code class="language-text">Error:
Compiler run failed
error[6275]: ParserError: Source "lib/openzeppelin-contracts/contracts/contracts/utils/Strings.sol" not found: File not found. Searched the following locations: "/PATH/TO/REPO".
 --&gt; src/NFT.sol:5:1:
  |
5 | import "openzeppelin-contracts/contracts/utils/Strings.sol";
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</code></pre>
<p>这可以通过设置正确的重映射来修复。在项目中创建一个 <code>remappings.txt</code> 文件并添加以下行：</p>
<pre><code class="language-text">openzeppelin-contracts/=lib/openzeppelin-contracts/
</code></pre>
<p>（您可以在 <a href="tutorials/../projects/dependencies.html">依赖文档</a> 中了解更多关于重映射的信息。</p>
<p>默认情况下，编译器输出将在 <code>out</code> 目录中。要使用 Forge 部署我们编译的合约，我们必须为要使用的 RPC 端点和私钥设置环境变量。</p>
<p>通过运行以下命令设置环境变量：</p>
<pre><code class="language-bash">export RPC_URL=&lt;Your RPC endpoint&gt;
export PRIVATE_KEY=&lt;Your wallets private key&gt;
</code></pre>
<p>设置完成后，您可以通过运行以下命令并添加相关的构造函数参数来使用 Forge 部署 NFT 合约：</p>
<pre><code class="language-bash">forge create NFT --rpc-url=$RPC_URL --private-key=$PRIVATE_KEY --constructor-args &lt;name&gt; &lt;symbol&gt;
</code></pre>
<p>如果成功部署，您将看到部署钱包的地址、合约地址以及交易哈希打印到终端。</p>
<h3 id="从您的合约中铸造-nft"><a class="header" href="#从您的合约中铸造-nft">从您的合约中铸造 NFT</a></h3>
<p>使用 Cast，Foundry 的命令行工具与智能合约交互、发送交易和获取链数据，可以简化在 NFT 合约上调用函数的过程。让我们看看如何使用它从我们的 NFT 合约中铸造 NFT。</p>
<p>鉴于您在部署期间已经设置了 RPC 和私钥环境变量，通过运行以下命令从您的合约中铸造一个 NFT：</p>
<pre><code class="language-bash">cast send --rpc-url=$RPC_URL &lt;contractAddress&gt;  "mintTo(address)" &lt;arg&gt; --private-key=$PRIVATE_KEY
</code></pre>
<p>做得好！您刚刚从您的合约中铸造了第一个 NFT。您可以通过运行以下 <code>cast call</code> 命令来检查 NFT 的所有者，<code>currentTokenId</code> 等于 <strong>1</strong>。您提供的地址应作为所有者返回。</p>
<pre><code class="language-bash">cast call --rpc-url=$RPC_URL --private-key=$PRIVATE_KEY &lt;contractAddress&gt; "ownerOf(uint256)" 1
</code></pre>
<h3 id="扩展我们的-nft-合约功能和测试"><a class="header" href="#扩展我们的-nft-合约功能和测试">扩展我们的 NFT 合约功能和测试</a></h3>
<p>让我们通过添加元数据来表示 NFT 的内容，以及设置铸造价格、最大供应量和提取铸造收益的可能性来扩展我们的 NFT。要继续操作，您可以用下面的代码片段替换当前的 NFT 合约：</p>
<pre><code class="language-solidity">// SPDX-License-Identifier: UNLICENSED
pragma solidity &gt;=0.8.10;

import "solmate/tokens/ERC721.sol";
import "openzeppelin-contracts/contracts/utils/Strings.sol";
import "openzeppelin-contracts/contracts/access/Ownable.sol";

error MintPriceNotPaid();
error MaxSupply();
error NonExistentTokenURI();
error WithdrawTransfer();

contract NFT is ERC721, Ownable {

    using Strings for uint256;
    string public baseURI;
    uint256 public currentTokenId;
    uint256 public constant TOTAL_SUPPLY = 10_000;
    uint256 public constant MINT_PRICE = 0.08 ether;

    constructor(
        string memory _name,
        string memory _symbol,
        string memory _baseURI
    ) ERC721(_name, _symbol) {
        baseURI = _baseURI;
    }

    function mintTo(address recipient) public payable returns (uint256) {
        if (msg.value != MINT_PRICE) {
            revert MintPriceNotPaid();
        }
        uint256 newTokenId = currentTokenId + 1;
        if (newTokenId &gt; TOTAL_SUPPLY) {
            revert MaxSupply();
        }
        currentTokenId = newTokenId;
        _safeMint(recipient, newTokenId);
        return newTokenId;
    }

    function tokenURI(uint256 tokenId)
        public
        view
        virtual
        override
        returns (string memory)
    {
        if (ownerOf(tokenId) == address(0)) {
            revert NonExistentTokenURI();
        }
        return
            bytes(baseURI).length &gt; 0
                ? string(abi.encodePacked(baseURI, tokenId.toString()))
                : "";
    }

    function withdrawPayments(address payable payee) external onlyOwner {
        if (address(this).balance == 0) {
            revert WithdrawTransfer();
        }
        
        payable(payee).transfer(address(this).balance);
    }

    function _checkOwner() internal view override {
        require(msg.sender == owner(), "Ownable: caller is not the owner");
    }
}
</code></pre>
<p>除了其他功能外，我们还添加了可以通过任何前端应用程序（如 OpenSea）查询的元数据，通过调用 NFT 合约上的 <code>tokenURI</code> 方法。</p>
<blockquote>
<p><strong>注意</strong>：如果您想在部署时提供一个真实的 URL 到构造函数，并托管此 NFT 合约的元数据，请按照 <a href="https://docs.opensea.io/docs/part-3-upload-metadata" title="" target="_blank">此处</a> 概述的步骤操作。</p>
</blockquote>
<p>让我们测试一些添加的功能，以确保它们按预期工作。Foundry 通过 Forge 提供了一个极快的 EVM 原生测试框架。</p>
<p>在您的测试文件夹中，将当前的 <code>Contract.t.sol</code> 测试文件重命名为 <code>NFT.t.sol</code>。该文件将包含所有关于 NFT 的 <code>mintTo</code> 方法的测试。接下来，用以下内容替换现有的样板代码：</p>
<pre><code class="language-solidity">// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.10;

import "forge-std/Test.sol";
import "../src/NFT.sol";

contract NFTTest is Test {
    using stdStorage for StdStorage;

    NFT private nft;

    function setUp() public {
        // Deploy NFT contract
        nft = new NFT("NFT_tutorial", "TUT", "baseUri");
    }

    function test_RevertMintWithoutValue() public {
        vm.expectRevert(MintPriceNotPaid.selector);
        nft.mintTo(address(1));
    }

    function test_MintPricePaid() public {
        nft.mintTo{value: 0.08 ether}(address(1));
    }

    function test_RevertMintMaxSupplyReached() public {
        uint256 slot = stdstore
            .target(address(nft))
            .sig("currentTokenId()")
            .find();
        bytes32 loc = bytes32(slot);
        bytes32 mockedCurrentTokenId = bytes32(abi.encode(10000));
        vm.store(address(nft), loc, mockedCurrentTokenId);
        vm.expectRevert(MaxSupply.selector);
        nft.mintTo{value: 0.08 ether}(address(1));
    }

    function test_RevertMintToZeroAddress() public {
        vm.expectRevert("INVALID_RECIPIENT");
        nft.mintTo{value: 0.08 ether}(address(0));
    }

    function test_NewMintOwnerRegistered() public {
        nft.mintTo{value: 0.08 ether}(address(1));
        uint256 slotOfNewOwner = stdstore
            .target(address(nft))
            .sig(nft.ownerOf.selector)
            .with_key(address(1))
            .find();

        uint160 ownerOfTokenIdOne = uint160(
            uint256(
                (vm.load(address(nft), bytes32(abi.encode(slotOfNewOwner))))
            )
        );
        assertEq(address(ownerOfTokenIdOne), address(1));
    }

    function test_BalanceIncremented() public {
        nft.mintTo{value: 0.08 ether}(address(1));
        uint256 slotBalance = stdstore
            .target(address(nft))
            .sig(nft.balanceOf.selector)
            .with_key(address(1))
            .find();

        uint256 balanceFirstMint = uint256(
            vm.load(address(nft), bytes32(slotBalance))
        );
        assertEq(balanceFirstMint, 1);

        nft.mintTo{value: 0.08 ether}(address(1));
        uint256 balanceSecondMint = uint256(
            vm.load(address(nft), bytes32(slotBalance))
        );
        assertEq(balanceSecondMint, 2);
    }

    function test_SafeContractReceiver() public {
        Receiver receiver = new Receiver();
        nft.mintTo{value: 0.08 ether}(address(receiver));
        uint256 slotBalance = stdstore
            .target(address(nft))
            .sig(nft.balanceOf.selector)
            .with_key(address(receiver))
            .find();

        uint256 balance = uint256(vm.load(address(nft), bytes32(slotBalance)));
        assertEq(balance, 1);
    }

    function test_RevertUnSafeContractReceiver() public {
        // Adress set to 11, because first 10 addresses are restricted for precompiles
        vm.etch(address(11), bytes("mock code"));
        vm.expectRevert(bytes(""));
        nft.mintTo{value: 0.08 ether}(address(11));
    }

    function test_WithdrawalWorksAsOwner() public {
        // Mint an NFT, sending eth to the contract
        Receiver receiver = new Receiver();
        address payable payee = payable(address(0x1337));
        uint256 priorPayeeBalance = payee.balance;
        nft.mintTo{value: nft.MINT_PRICE()}(address(receiver));
        // Check that the balance of the contract is correct
        assertEq(address(nft).balance, nft.MINT_PRICE());
        uint256 nftBalance = address(nft).balance;
        // Withdraw the balance and assert it was transferred
        nft.withdrawPayments(payee);
        assertEq(payee.balance, priorPayeeBalance + nftBalance);
    }

    function test_WithdrawalFailsAsNotOwner() public {
        // Mint an NFT, sending eth to the contract
        Receiver receiver = new Receiver();
        nft.mintTo{value: nft.MINT_PRICE()}(address(receiver));
        // Check that the balance of the contract is correct
        assertEq(address(nft).balance, nft.MINT_PRICE());
        // Confirm that a non-owner cannot withdraw
        vm.expectRevert("Ownable: caller is not the owner");
        vm.startPrank(address(0xd3ad));
        nft.withdrawPayments(payable(address(0xd3ad)));
        vm.stopPrank();
    }
}

contract Receiver is ERC721TokenReceiver {
    function onERC721Received(
        address operator,
        address from,
        uint256 id,
        bytes calldata data
    ) external override returns (bytes4) {
        return this.onERC721Received.selector;
    }
}

</code></pre>
<p>测试套件设置为一个合约，其中 <code>setUp</code> 方法在每个单独的测试之前运行。</p>
<p>如您所见，Forge 提供了许多 <a href="tutorials/../cheatcodes/">作弊码</a> 来操纵状态以适应您的测试场景。</p>
<p>例如，我们的 <code>testFailMaxSupplyReached</code> 测试检查当 NFT 的最大供应量达到时尝试铸造是否失败。因此，需要使用存储作弊码将 NFT 合约的 <code>currentTokenId</code> 设置为最大供应量，该作弊码允许您写入合约的存储槽。可以使用 <a href="https://github.com/foundry-rs/forge-std/" title="" target="_blank">
<code>forge-std</code></a> 帮助库轻松找到要写入的存储槽。您可以使用以下命令运行测试：</p>
<pre><code class="language-bash">forge test
</code></pre>
<p>如果您想将 Forge 技能付诸实践，请为 NFT 合约的其余方法编写测试。欢迎将它们 PR 到 <a href="https://github.com/FredCoen/nft-tutorial" title="" target="_blank">nft-tutorial</a>，您将在其中找到本教程的完整实现。</p>
<h3 id="函数调用的-gas-报告"><a class="header" href="#函数调用的-gas-报告">函数调用的 Gas 报告</a></h3>
<p>Foundry 提供了关于合约的综合 Gas 报告。对于测试中的每个函数调用，它返回最小、平均、中位数和最大 Gas 成本。要打印 Gas 报告，只需运行：</p>
<pre><code class="language-bash">forge test --gas-report
</code></pre>
<p>这在查看合约中的各种 Gas 优化时非常方便。</p>
<p>让我们看看通过将 OpenZeppelin 替换为 Solmate 进行 ERC721 实现所节省的 Gas。您可以在此处找到使用这两个库的 NFT 实现 <a href="https://github.com/FredCoen/nft-tutorial" title="" target="_blank">这里</a>。在运行 <code>forge test --gas-report</code> 时，以下是该存储库的 Gas 报告结果。</p>
<p>如您所见，我们使用 Solmate 的实现在成功铸造时节省了大约 500 Gas（<code>mintTo</code> 函数调用的最大 Gas 成本）。</p>
<p><img src="tutorials/../images/nft-tutorial/gas-report-solmate-nft.png" alt="Gas report solmate NFT" /></p>
<p><img src="tutorials/../images/nft-tutorial/gas-report-oz-nft.png" alt="Gas report OZ NFT" /></p>
<p>就是这样，我希望这能为您提供一个很好的实践基础，了解如何开始使用 Foundry。我们认为，没有比在 Solidity 中编写测试更好的方式来深入理解 Solidity 了。您还将体验到在 JavaScript 和 Solidity 之间切换的上下文切换更少。祝您编码愉快！</p>
<blockquote>
<p>注意：请按照 <a href="tutorials/./solidity-scripting.html">此教程</a> 学习如何使用 Solidity 脚本部署此处使用的 NFT 合约。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="使用-docker-化-foundry-项目"><a class="header" href="#使用-docker-化-foundry-项目">使用 Docker 化 Foundry 项目</a></h2>
<p>本教程将向您展示如何使用 Foundry 的 Docker 镜像构建、测试和部署智能合约。它改编自 <a href="tutorials/./solmate-nft.html">solmate nft</a> 教程中的代码。如果您还没有完成该教程，并且对 Solidity 还不熟悉，建议您先从该教程开始。或者，如果您对 Docker 和 Solidity 有一定的了解，可以使用您现有的项目并相应调整。NFT 和 Docker 部分的完整源代码可在 <a href="https://github.com/dmfxyz/foundry-docker-tutorial" title="" target="_blank">这里</a> 找到。</p>
<blockquote>
<p>本教程仅用于说明目的，并按原样提供。教程未经过审计也未完全测试。本教程中的代码不应在生产环境中使用。</p>
</blockquote>
<h3 id="安装和设置"><a class="header" href="#安装和设置">安装和设置</a></h3>
<p>运行本教程所需的唯一安装是 Docker，以及可选的您选择的 IDE。
请按照 <a href="tutorials//getting-started/installation.html#using-with-docker">Docker 安装说明</a> 进行操作。</p>
<p>为了使未来的命令更简洁，让我们重新标记镜像：
<code>docker tag ghcr.io/foundry-rs/foundry:latest foundry:latest</code></p>
<p>本地安装 Foundry 不是严格要求的，但可能有助于调试。您可以使用 <a href="tutorials//getting-started/installation.html#using-foundryup">foundryup</a> 进行安装。</p>
<p>最后，要使用本教程中的 <code>cast</code> 或 <code>forge create</code> 部分，您需要访问一个以太坊节点。如果您没有运行自己的节点（很可能），可以使用第三方节点服务。本教程中不会推荐特定的提供商。了解节点即服务的好地方是 <a href="https://ethereum.org/en/developers/docs/nodes-and-clients/nodes-as-a-service/" title="" target="_blank">Ethereum 的文章</a>。</p>
<p><strong>在本教程的其余部分中，假设您的以太坊节点的 RPC 端点设置如下</strong>：<code>export RPC_URL=&lt;YOUR_RPC_URL&gt;</code></p>
<h3 id="foundry-docker-镜像的介绍"><a class="header" href="#foundry-docker-镜像的介绍">Foundry Docker 镜像的介绍</a></h3>
<p>Docker 镜像主要有两种使用方式：</p>
<ol>
<li>直接作为 forge 和 cast 的接口</li>
<li>作为构建您自己的容器化测试、构建和部署工具的基础镜像</li>
</ol>
<p>我们将涵盖这两种方式，但首先让我们看看如何使用 Docker 与 Foundry 进行交互。这也是测试本地安装是否成功的好方法！</p>
<p>我们可以对 Docker 镜像运行任何 <code>cast</code> <a href="tutorials//reference/cast/">命令</a>。让我们获取最新的区块信息：</p>
<pre><code class="language-sh">$ docker run foundry "cast block --rpc-url $RPC_URL latest"
baseFeePerGas        "0xb634241e3"
difficulty           "0x2e482bdf51572b"
extraData            "0x486976656f6e20686b"
gasLimit             "0x1c9c380"
gasUsed              "0x652993"
hash                 "0x181748772da2f968bcc91940c8523bb6218a7d57669ded06648c9a9fb6839db5"
logsBloom            "0x406010046100001198c220108002b606400029444814008210820c04012804131847150080312500300051044208430002008029880029011520380060262400001c538d00440a885a02219d49624aa110000003094500022c003600a00258009610c410323580032000849a0408a81a0a060100022505202280c61880c80020e080244400440404520d210429a0000400010089410c8408162903609c920014028a94019088681018c909980701019201808040004100000080540610a9144d050020220c10a24c01c000002005400400022420140e18100400e10254926144c43a200cc008142080854088100128844003010020c344402386a8c011819408"
miner                "0x1ad91ee08f21be3de0ba2ba6918e714da6b45836"
mixHash              "0xb920857687476c1bcb21557c5f6196762a46038924c5f82dc66300347a1cfc01"
nonce                "0x1ce6929033fbba90"
number               "0xdd3309"
parentHash           "0x39c6e1aa997d18a655c6317131589fd327ae814ef84e784f5eb1ab54b9941212"
receiptsRoot         "0x4724f3b270dcc970f141e493d8dc46aeba6fffe57688210051580ac960fe0037"
sealFields           []
sha3Uncles           "0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347"
size                 "0x1d6bb"
stateRoot            "0x0d4b714990132cf0f21801e2931b78454b26aad706fc6dc16b64e04f0c14737a"
timestamp            "0x6246259b"
totalDifficulty      "0x9923da68627095fd2e7"
transactions         [...]
uncles               []
</code></pre>
<p>如果我们在包含一些 Solidity <a href="https://github.com/dmfxyz/foundry-docker-tutorial" title="" target="_blank">源代码</a> 的目录中，我们可以将该目录挂载到 Docker 中，并按需使用 <code>forge</code>。例如：</p>
<pre><code class="language-sh">$ docker run -v $PWD:/app foundry "forge test --root /app --watch"
No files changed, compilation skipped

Ran 8 tests for test/SolmateNft.sol:SolmateNftTests
[PASS] testBalanceIncremented() (gas: 217400)
[PASS] testFailMaxSupplyReached() (gas: 134524)
[PASS] testFailMintToZeroAddress() (gas: 34521)
[PASS] testFailNoMintPricePaid() (gas: 5568)
[PASS] testFailUnSafeContractReceiver() (gas: 3524)
[PASS] testMintPricePaid() (gas: 81321)
[PASS] testNewMintOwnerRegistered() (gas: 190741)
[PASS] testSafeContractReceiver() (gas: 272636)
Suite result: ok. 8 passed; 0 failed; 0 skipped; finished in 1.47ms (1.23ms CPU time)

Ran 8 tests for test/OpenZeppelinNft.t.sol:OpenZeppelinNftTests
[PASS] testBalanceIncremented() (gas: 217829)
[PASS] testFailMaxSupplyReached() (gas: 134524)
[PASS] testFailMintToZeroAddress() (gas: 34577)
[PASS] testFailNoMintPricePaid() (gas: 5568)
[PASS] testFailUnSafeContractReceiver() (gas: 3524)
[PASS] testMintPricePaid() (gas: 81554)
[PASS] testNewMintOwnerRegistered() (gas: 190956)
[PASS] testSafeContractReceiver() (gas: 273132)
Suite result: ok. 8 passed; 0 failed; 0 skipped; finished in 1.47ms (1.12ms CPU time)

Ran 2 test suites in 2.93ms (2.95ms CPU time): 16 tests passed, 0 failed, 0 skipped (16 total tests)
</code></pre>
<p>您可以看到我们的代码完全在容器中编译和测试。此外，由于我们传递了 <code>--watch</code> 选项，容器将在检测到更改时重新编译代码。</p>
<blockquote>
<p>注意：Foundry Docker 镜像基于 alpine 构建，旨在尽可能精简。因此，它目前不包括 <code>git</code> 等开发资源。如果您计划在容器中管理整个开发生命周期，应在 Foundry 镜像之上构建自定义开发镜像。</p>
</blockquote>
<h3 id="创建构建和测试镜像"><a class="header" href="#创建构建和测试镜像">创建“构建和测试”镜像</a></h3>
<p>让我们使用 Foundry Docker 镜像作为基础来构建我们自己的 Docker 镜像。我们将使用该镜像来：</p>
<ol>
<li>构建我们的 Solidity 代码</li>
<li>运行我们的 Solidity 测试</li>
</ol>
<p>一个简单的 <code>Dockerfile</code> 可以实现这两个目标：</p>
<pre><code class="language-docker"># 使用最新的 foundry 镜像
FROM ghcr.io/foundry-rs/foundry

# 将我们的源代码复制到容器中
WORKDIR /app

# 构建和测试源代码
COPY . .
RUN forge build
RUN forge test
</code></pre>
<p>您可以构建这个 Docker 镜像，并在容器中观察 forge 构建/运行测试：</p>
<pre><code class="language-sh">$ docker build --no-cache --progress=plain .
</code></pre>
<p>现在，如果我们的一个测试失败会发生什么？随意修改 <code>src/test/NFT.t.sol</code> 以使其中一个测试失败。尝试再次构建镜像。</p>
<pre><code class="language-sh">$ docker build --no-cache --progress=plain .
&lt;...&gt;
#9 0.522 Failed tests:
#9 0.522 [FAIL. Reason: Ownable: caller is not the owner] testWithdrawalFailsAsNotOwner() (gas: 193917)
#9 0.522
#9 0.522 Encountered a total of 1 failing tests, 9 tests succeeded
------
error: failed to solve: executor failed running [/bin/sh -c forge test]: exit code: 1
</code></pre>
<p>我们的镜像构建失败了，因为我们的测试失败了！这实际上是一个很好的特性，因为这意味着如果我们有一个成功构建的 Docker 镜像（因此可供使用），我们就知道镜像中的代码通过了测试。*</p>
<blockquote>
<p>*当然，您的 Docker 镜像的保管链非常重要。Docker 层哈希对于验证非常有用。在生产环境中，考虑 <a href="https://docs.docker.com/engine/security/trust/#:~:text=To%20sign%20a%20Docker%20Image,the%20local%20Docker%20trust%20repository" title="" target="_blank">签署您的 Docker 镜像</a>。</p>
</blockquote>
<h3 id="创建部署镜像"><a class="header" href="#创建部署镜像">创建部署镜像</a></h3>
<p>现在，我们将继续构建一个更高级的 Dockerfile。让我们添加一个入口点，允许我们使用构建（并测试！）的镜像来部署我们的代码。我们先针对 Rinkeby 测试网。</p>
<pre><code class="language-docker"># 使用最新的 foundry 镜像
FROM ghcr.io/foundry-rs/foundry

# 将我们的源代码复制到容器中
WORKDIR /app

# 构建和测试源代码
COPY . .
RUN forge build
RUN forge test

# 设置入口点为 forge 部署命令
ENTRYPOINT ["forge", "create"]
</code></pre>
<p>让我们构建镜像，这次给它一个名称：</p>
<pre><code class="language-sh">$ docker build --no-cache --progress=plain -t nft-deployer .
</code></pre>
<p>以下是我们如何使用 Docker 镜像进行部署：</p>
<pre><code class="language-sh">$ docker run nft-deployer --rpc-url $RPC_URL --constructor-args "ForgeNFT" "FNFT" "https://ethereum.org" --private-key $PRIVATE_KEY ./src/NFT.sol:NFT
No files changed, compilation skipped
Deployer: 0x496e09fcb240c33b8fda3b4b74d81697c03b6b3d
Deployed to: 0x23d465eaa80ad2e5cdb1a2345e4b54edd12560d3
Transaction hash: 0xf88c68c4a03a86b0e7ecb05cae8dea36f2896cd342a6af978cab11101c6224a9
</code></pre>
<p>我们刚刚完全在 Docker 容器中构建、测试和部署了我们的合约！本教程旨在用于测试网，但您可以运行完全相同的 Docker 镜像针对主网，并确信相同的代码由相同的工具部署。</p>
<h3 id="为什么这很有用"><a class="header" href="#为什么这很有用">为什么这很有用？</a></h3>
<p>Docker 是关于可移植性、可重复性和环境不变性的。这意味着您可以减少在不同环境、网络、开发人员等之间切换时对意外变化的担忧。以下是一些基本的例子，说明为什么 <strong>我</strong> 喜欢使用 Docker 镜像进行智能合约部署：</p>
<ul>
<li>减少确保系统级依赖在部署环境之间匹配的开销（例如，您的生产运行器是否总是与您的开发运行器具有相同版本的 <code>forge</code>？）</li>
<li>增加信心，确保代码在部署前经过测试且未被更改（例如，如果在上述镜像中，您的代码在部署时重新编译，这是一个重大危险信号）。</li>
<li>减轻职责分离的痛点：拥有您主网凭证的人不需要确保他们拥有最新的编译器、代码库等。很容易确保在测试网中某人运行的 Docker 部署镜像与针对主网的镜像相同。</li>
<li>冒着听起来像 Web2 的风险，Docker 在几乎所有公共云提供商中都是一个被接受的标准。它使得与区块链交互的作业、任务等的调度变得容易。</li>
</ul>
<h3 id="故障排除-1"><a class="header" href="#故障排除-1">故障排除</a></h3>
<p>如上所述，Foundry 镜像默认不包括 <code>git</code>。这可能会导致某些命令在没有明确原因的情况下失败。例如：</p>
<pre><code class="language-bash">$ docker run foundry "forge init --no-git /test"
Initializing /test...
Installing ds-test in "/test/lib/ds-test", (url: https://github.com/dapphub/ds-test, tag: None)
Error:
   0: No such file or directory (os error 2)

Location:
   cli/src/cmd/forge/install.rs:107
</code></pre>
<p>在这种情况下，失败仍然是由缺少 <code>git</code> 安装引起的。推荐的解决方法是基于现有的 Foundry 镜像构建，并安装任何其他所需的开发依赖项。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="测试-eip-712-签名"><a class="header" href="#测试-eip-712-签名">测试 EIP-712 签名</a></h2>
<h3 id="介绍"><a class="header" href="#介绍">介绍</a></h3>
<p><a href="https://eips.ethereum.org/EIPS/eip-712" title="" target="_blank">EIP-712</a> 引入了在链下签署交易的能力，其他用户可以在链上执行这些交易。一个常见的例子是 <a href="https://eips.ethereum.org/EIPS/eip-2612" title="" target="_blank">EIP-2612</a> 无 gas 代币批准。</p>
<p>传统上，设置用户或合约从所有者余额中转移 ERC-20 代币的允许额度需要所有者在链上提交批准。由于这证明是糟糕的用户体验，DAI 引入了 ERC-20 <code>permit</code>（后来标准化为 EIP-2612），允许所有者在链下签署批准，然后支出者（或任何人！）可以在链上提交 <code>transferFrom</code> 之前执行。</p>
<p>本指南将介绍如何使用 Foundry 在 Solidity 中测试这种模式。</p>
<h3 id="深入探讨"><a class="header" href="#深入探讨">深入探讨</a></h3>
<p>首先，我们将介绍一个基本的代币转移：</p>
<ul>
<li>所有者在链下签署批准</li>
<li>支出者在链上调用 <code>permit</code> 和 <code>transferFrom</code></li>
</ul>
<p>我们将使用 <a href="https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol" title="" target="_blank">Solmate 的 ERC-20</a>，因为 EIP-712 和 EIP-2612 的功能已经包含在内。如果你还没有看过完整的合约，可以先浏览一下 - 这里是 <code>permit</code> 的实现：</p>
<pre><code class="language-solidity">    /*//////////////////////////////////////////////////////////////
                             EIP-2612 LOGIC
    //////////////////////////////////////////////////////////////*/

    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public virtual {
        require(deadline &gt;= block.timestamp, "PERMIT_DEADLINE_EXPIRED");

        // Unchecked because the only math done is incrementing
        // the owner's nonce which cannot realistically overflow.
        unchecked {
            address recoveredAddress = ecrecover(
                keccak256(
                    abi.encodePacked(
                        "\x19\x01",
                        DOMAIN_SEPARATOR(),
                        keccak256(
                            abi.encode(
                                keccak256(
                                    "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"
                                ),
                                owner,
                                spender,
                                value,
                                nonces[owner]++,
                                deadline
                            )
                        )
                    )
                ),
                v,
                r,
                s
            );

            require(recoveredAddress != address(0) &amp;&amp; recoveredAddress == owner, "INVALID_SIGNER");

            allowance[recoveredAddress][spender] = value;
        }

        emit Approval(owner, spender, value);
    }
</code></pre>
<p>我们还将使用一个自定义的 <code>SigUtils</code> 合约来帮助创建、哈希和链下签署批准。</p>
<pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity 0.8.20;

contract SigUtils {
    bytes32 internal DOMAIN_SEPARATOR;

    constructor(bytes32 _DOMAIN_SEPARATOR) {
        DOMAIN_SEPARATOR = _DOMAIN_SEPARATOR;
    }

    // keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");
    bytes32 public constant PERMIT_TYPEHASH =
        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;

    struct Permit {
        address owner;
        address spender;
        uint256 value;
        uint256 nonce;
        uint256 deadline;
    }

    // 计算 permit 的哈希
    function getStructHash(Permit memory _permit)
        internal
        pure
        returns (bytes32)
    {
        return
            keccak256(
                abi.encode(
                    PERMIT_TYPEHASH,
                    _permit.owner,
                    _permit.spender,
                    _permit.value,
                    _permit.nonce,
                    _permit.deadline
                )
            );
    }

    // 计算用于恢复签名者的完整编码 EIP-712 消息的哈希
    function getTypedDataHash(Permit memory _permit)
        public
        view
        returns (bytes32)
    {
        return
            keccak256(
                abi.encodePacked(
                    "\x19\x01",
                    DOMAIN_SEPARATOR,
                    getStructHash(_permit)
                )
            );
    }
}
</code></pre>
<h3 id="处理动态值"><a class="header" href="#处理动态值">处理动态值</a></h3>
<p>虽然上面 getStructHash() 函数中传递的 Permit 结构体不包含任何动态值类型，但如果你使用它们，重要的是要记住 ‘bytes’ 和 ‘string’ 类型必须编码为其内容的 ‘keccak256’ 哈希。更多关于 <a href="https://github.com/ethereum/EIPs/blob/8061f8e2243eaae829d1fa91f7a763c889aca371/EIPS/eip-712.md?plain=1#L135" title="" target="_blank">EIP 712 规范的这方面内容</a>。</p>
<p><strong>设置</strong></p>
<ul>
<li>部署一个模拟 ERC-20 代币和带有代币 EIP-712 域分隔符的 <code>SigUtils</code> 助手</li>
<li>创建私钥来模拟所有者和支出者</li>
<li>使用 <code>vm.addr</code> <a href="https://book.getfoundry.sh/cheatcodes/addr.html" title="" target="_blank">作弊码</a> 导出他们的地址</li>
<li>为所有者铸造一个测试代币</li>
</ul>
<pre><code class="language-solidity">
contract Token_ERC20 is MockERC20 {
    constructor(string memory name, string memory symbol, uint8 decimals) {
        initialize(name, symbol, decimals);
    }

    function mint(address to, uint256 value) public virtual {
        _mint(to, value);
    }

    function burn(address from, uint256 value) public virtual {
        _burn(from, value);
    }
}

contract ERC20Test is Test {
    Token_ERC20 internal token;
    SigUtils internal sigUtils;

    uint256 internal ownerPrivateKey;
    uint256 internal spenderPrivateKey;

    address internal owner;
    address internal spender;

    function setUp() public {
        token = new Token_ERC20("Token", "TKN", 18);
        sigUtils = new SigUtils(token.DOMAIN_SEPARATOR());

        ownerPrivateKey = 0xA11CE;
        spenderPrivateKey = 0xB0B;

        owner = vm.addr(ownerPrivateKey);
        spender = vm.addr(spenderPrivateKey);

        token.mint(owner, 1e18);
    }
</code></pre>
<p><strong>测试: <code>permit</code></strong></p>
<ul>
<li>为支出者创建一个批准</li>
<li>使用 <code>sigUtils.getTypedDataHash</code> 计算其摘要</li>
<li>使用所有者的私钥通过 <code>vm.sign</code> <a href="https://book.getfoundry.sh/cheatcodes/sign.html" title="" target="_blank">作弊码</a> 签署摘要</li>
<li>存储签名的 <code>uint8 v, bytes32 r, bytes32 s</code></li>
<li>使用签署的批准和签名调用 <code>permit</code> 以在链上执行批准</li>
</ul>
<pre><code class="language-solidity">    function test_Permit() public {
        SigUtils.Permit memory permit = SigUtils.Permit({
            owner: owner,
            spender: spender,
            value: 1e18,
            nonce: 0,
            deadline: 1 days
        });

        bytes32 digest = sigUtils.getTypedDataHash(permit);

        (uint8 v, bytes32 r, bytes32 s) = vm.sign(ownerPrivateKey, digest);

        token.permit(
            permit.owner,
            permit.spender,
            permit.value,
            permit.deadline,
            v,
            r,
            s
        );

        assertEq(token.allowance(owner, spender), 1e18);
        assertEq(token.nonces(owner), 1);
    }
</code></pre>
<ul>
<li>确保在过期截止时间、无效签名者、无效随机数和签名重放的调用失败</li>
</ul>
<pre><code class="language-solidity">    function testRevert_ExpiredPermit() public {
        SigUtils.Permit memory permit = SigUtils.Permit({
            owner: owner,
            spender: spender,
            value: 1e18,
            nonce: token.nonces(owner),
            deadline: 1 days
        });

        bytes32 digest = sigUtils.getTypedDataHash(permit);

        (uint8 v, bytes32 r, bytes32 s) = vm.sign(ownerPrivateKey, digest);

        vm.warp(1 days + 1 seconds); // 快进一秒超过截止时间

        vm.expectRevert("PERMIT_DEADLINE_EXPIRED");
        token.permit(
            permit.owner,
            permit.spender,
            permit.value,
            permit.deadline,
            v,
            r,
            s
        );
    }

    function testRevert_InvalidSigner() public {
        SigUtils.Permit memory permit = SigUtils.Permit({
            owner: owner,
            spender: spender,
            value: 1e18,
            nonce: token.nonces(owner),
            deadline: 1 days
        });

        bytes32 digest = sigUtils.getTypedDataHash(permit);

        (uint8 v, bytes32 r, bytes32 s) = vm.sign(spenderPrivateKey, digest); // 支出者签署所有者的批准

        vm.expectRevert("INVALID_SIGNER");
        token.permit(
            permit.owner,
            permit.spender,
            permit.value,
            permit.deadline,
            v,
            r,
            s
        );
    }

    function testRevert_InvalidNonce() public {
        SigUtils.Permit memory permit = SigUtils.Permit({
            owner: owner,
            spender: spender,
            value: 1e18,
            nonce: 1, // 链上存储的所有者随机数是 0
            deadline: 1 days
        });

        bytes32 digest = sigUtils.getTypedDataHash(permit);

        (uint8 v, bytes32 r, bytes32 s) = vm.sign(ownerPrivateKey, digest);

        vm.expectRevert("INVALID_SIGNER");
        token.permit(
            permit.owner,
            permit.spender,
            permit.value,
            permit.deadline,
            v,
            r,
            s
        );
    }

    function testRevert_SignatureReplay() public {
        SigUtils.Permit memory permit = SigUtils.Permit({
            owner: owner,
            spender: spender,
            value: 1e18,
            nonce: 0,
            deadline: 1 days
        });

        bytes32 digest = sigUtils.getTypedDataHash(permit);

        (uint8 v, bytes32 r, bytes32 s) = vm.sign(ownerPrivateKey, digest);

        token.permit(
            permit.owner,
            permit.spender,
            permit.value,
            permit.deadline,
            v,
            r,
            s
        );

        vm.expectRevert("INVALID_SIGNER");
        token.permit(
            permit.owner,
            permit.spender,
            permit.value,
            permit.deadline,
            v,
            r,
            s
        );
    }
</code></pre>
<p><strong>测试: <code>transferFrom</code></strong></p>
<ul>
<li>创建、签署并执行支出者的批准</li>
<li>使用 <code>vm.prank</code> <a href="https://book.getfoundry.sh/cheatcodes/prank.html" title="" target="_blank">作弊码</a> 作为支出者调用 <code>tokenTransfer</code> 以执行转移</li>
</ul>
<pre><code class="language-solidity">    function test_TransferFromLimitedPermit() public {
        SigUtils.Permit memory permit = SigUtils.Permit({
            owner: owner,
            spender: spender,
            value: 1e18,
            nonce: 0,
            deadline: 1 days
        });

        bytes32 digest = sigUtils.getTypedDataHash(permit);

        (uint8 v, bytes32 r, bytes32 s) = vm.sign(ownerPrivateKey, digest);

        token.permit(
            permit.owner,
            permit.spender,
            permit.value,
            permit.deadline,
            v,
            r,
            s
        );

        vm.prank(spender);
        token.transferFrom(owner, spender, 1e18);

        assertEq(token.balanceOf(owner), 0);
        assertEq(token.balanceOf(spender), 1e18);
        assertEq(token.allowance(owner, spender), 0);
    }

    function test_TransferFromMaxPermit() public {
        SigUtils.Permit memory permit = SigUtils.Permit({
            owner: owner,
            spender: spender,
            value: type(uint256).max,
            nonce: 0,
            deadline: 1 days
        });

        bytes32 digest = sigUtils.getTypedDataHash(permit);

        (uint8 v, bytes32 r, bytes32 s) = vm.sign(ownerPrivateKey, digest);

        token.permit(
            permit.owner,
            permit.spender,
            permit.value,
            permit.deadline,
            v,
            r,
            s
        );

        vm.prank(spender);
        token.transferFrom(owner, spender, 1e18);

        assertEq(token.balanceOf(owner), 0);
        assertEq(token.balanceOf(spender), 1e18);
        assertEq(token.allowance(owner, spender), type(uint256).max);
    }
</code></pre>
<ul>
<li>确保在无效允许额度和无效余额的调用失败</li>
</ul>
<pre><code class="language-solidity">    function testFail_InvalidAllowance() public {
        SigUtils.Permit memory permit = SigUtils.Permit({
            owner: owner,
            spender: spender,
            value: 5e17, // 仅批准 0.5 个代币
            nonce: 0,
            deadline: 1 days
        });

        bytes32 digest = sigUtils.getTypedDataHash(permit);

        (uint8 v, bytes32 r, bytes32 s) = vm.sign(ownerPrivateKey, digest);

        token.permit(
            permit.owner,
            permit.spender,
            permit.value,
            permit.deadline,
            v,
            r,
            s
        );

        vm.prank(spender);
        token.transferFrom(owner, spender, 1e18); // 尝试转移 1 个代币
    }

    function testFail_InvalidBalance() public {
        SigUtils.Permit memory permit = SigUtils.Permit({
            owner: owner,
            spender: spender,
            value: 2e18, // 批准 2 个代币
            nonce: 0,
            deadline: 1 days
        });

        bytes32 digest = sigUtils.getTypedDataHash(permit);

        (uint8 v, bytes32 r, bytes32 s) = vm.sign(ownerPrivateKey, digest);

        token.permit(
            permit.owner,
            permit.spender,
            permit.value,
            permit.deadline,
            v,
            r,
            s
        );

        vm.prank(spender);
        token.transferFrom(owner, spender, 2e18); // 尝试转移 2 个代币（所有者仅拥有 1 个）
    }
</code></pre>
<h3 id="捆绑示例"><a class="header" href="#捆绑示例">捆绑示例</a></h3>
<p>这里是一个 <a href="https://github.com/kulkarohan/deposit/blob/main/src/Deposit.sol" title="" target="_blank">模拟合约</a> 的部分，它只是存入 ERC-20 代币。注意 <code>deposit</code> 需要一个初步的 <code>approve</code> 或 <code>permit</code> 交易才能转移代币，而 <code>depositWithPermit</code> 在一个交易中设置允许额度并转移代币。</p>
<pre><code class="language-solidity">    ///                                                          ///
    ///                           DEPOSIT                        ///
    ///                                                          ///

    /// @notice 存入 ERC-20 代币（需要预批准）
    /// @param _tokenContract ERC-20 代币地址
    /// @param _amount 代币数量
    function deposit(address _tokenContract, uint256 _amount) external {
        ERC20(_tokenContract).transferFrom(msg.sender, address(this), _amount);

        userDeposits[msg.sender][_tokenContract] += _amount;

        emit TokenDeposit(msg.sender, _tokenContract, _amount);
    }

    ///                                                          ///
    ///                      DEPOSIT w/ PERMIT                   ///
    ///                                                          ///

    /// @notice 使用签名批准存入 ERC-20 代币
    /// @param _tokenContract ERC-20 代币地址
    /// @param _amount 转移的代币数量
    /// @param _owner 签署批准的用户
    /// @param _spender 转移代币的用户（即本合约）
    /// @param _value 批准支出者的代币数量
    /// @param _deadline 批准过期的时间戳
    /// @param _v 签名的第 129 字节和链 ID
    /// @param _r 签名的前 64 字节
    /// @param _s 签名的第 64-128 字节
    function depositWithPermit(
        address _tokenContract,
        uint256 _amount,
        address _owner,
        address _spender,
        uint256 _value,
        uint256 _deadline,
        uint8 _v,
        bytes32 _r,
        bytes32 _s
    ) external {
        ERC20(_tokenContract).permit(
            _owner,
            _spender,
            _value,
            _deadline,
            _v,
            _r,
            _s
        );

        ERC20(_tokenContract).transferFrom(_owner, address(this), _amount);

        userDeposits[_owner][_tokenContract] += _amount;

        emit TokenDeposit(_owner, _tokenContract, _amount);
    }
</code></pre>
<p><strong>设置</strong></p>
<ul>
<li>部署 <code>Deposit</code> 合约、模拟 ERC-20 代币和带有代币 EIP-712 域分隔符的 <code>SigUtils</code> 助手</li>
<li>创建一个私钥来模拟所有者（支出者现在是 <code>Deposit</code> 地址）</li>
<li>使用 <code>vm.addr</code> <a href="https://book.getfoundry.sh/cheatcodes/addr.html" title="" target="_blank">作弊码</a> 导出所有者地址</li>
<li>为所有者铸造一个测试代币</li>
</ul>
<pre><code class="language-solidity">contract DepositTest is Test {
    Deposit internal deposit;
    MockERC20 internal token;
    SigUtils internal sigUtils;

    uint256 internal ownerPrivateKey;
    address internal owner;

    function setUp() public {
        deposit = new Deposit();
        token = new MockERC20();
        sigUtils = new SigUtils(token.DOMAIN_SEPARATOR());

        ownerPrivateKey = 0xA11CE;
        owner = vm.addr(ownerPrivateKey);

        token.mint(owner, 1e18);
    }
</code></pre>
<p><strong>测试: <code>depositWithPermit</code></strong></p>
<ul>
<li>为 <code>Deposit</code> 合约创建一个批准</li>
<li>使用 <code>sigUtils.getTypedDataHash</code> 计算其摘要</li>
<li>使用所有者的私钥通过 <code>vm.sign</code> <a href="https://book.getfoundry.sh/cheatcodes/sign.html" title="" target="_blank">作弊码</a> 签署摘要</li>
<li>存储签名的 <code>uint8 v, bytes32 r, bytes32 s</code>
<ul>
<li><em>注意:</em> 可以通过 <code>bytes signature = abi.encodePacked(r, s, v)</code> 转换为字节</li>
</ul>
</li>
<li>使用签署的批准和签名调用 <code>depositWithPermit</code> 以将代币转移到合约中</li>
</ul>
<pre><code class="language-solidity">    function test_DepositWithLimitedPermit() public {
        SigUtils.Permit memory permit = SigUtils.Permit({
            owner: owner,
            spender: address(deposit),
            value: 1e18,
            nonce: token.nonces(owner),
            deadline: 1 days
        });

        bytes32 digest = sigUtils.getTypedDataHash(permit);

        (uint8 v, bytes32 r, bytes32 s) = vm.sign(ownerPrivateKey, digest);

        deposit.depositWithPermit(
            address(token),
            1e18,
            permit.owner,
            permit.spender,
            permit.value,
            permit.deadline,
            v,
            r,
            s
        );

        assertEq(token.balanceOf(owner), 0);
        assertEq(token.balanceOf(address(deposit)), 1e18);

        assertEq(token.allowance(owner, address(deposit)), 0);
        assertEq(token.nonces(owner), 1);

        assertEq(deposit.userDeposits(owner, address(token)), 1e18);
    }

    function test_DepositWithMaxPermit() public {
        SigUtils.Permit memory permit = SigUtils.Permit({
            owner: owner,
            spender: address(deposit),
            value: type(uint256).max,
            nonce: token.nonces(owner),
            deadline: 1 days
        });

        bytes32 digest = sigUtils.getTypedDataHash(permit);

        (uint8 v, bytes32 r, bytes32 s) = vm.sign(ownerPrivateKey, digest);

        deposit.depositWithPermit(
            address(token),
            1e18,
            permit.owner,
            permit.spender,
            permit.value,
            permit.deadline,
            v,
            r,
            s
        );

        assertEq(token.balanceOf(owner), 0);
        assertEq(token.balanceOf(address(deposit)), 1e18);

        assertEq(token.allowance(owner, address(deposit)), type(uint256).max);
        assertEq(token.nonces(owner), 1);

        assertEq(deposit.userDeposits(owner, address(token)), 1e18);
    }
</code></pre>
<ul>
<li>确保无效 <code>permit</code> 和 <code>transferFrom</code> 调用失败，如前所示</li>
</ul>
<h3 id="tldr"><a class="header" href="#tldr">TLDR</a></h3>
<p>使用 Foundry 作弊码 <code>addr</code>、<code>sign</code> 和 <code>prank</code> 在 Foundry 中测试 EIP-712 签名。</p>
<p>所有源代码可以在 <a href="https://github.com/kulkarohan/deposit" title="" target="_blank">这里</a> 找到。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="solidity-脚本"><a class="header" href="#solidity-脚本">Solidity 脚本</a></h2>
<h3 id="简介"><a class="header" href="#简介">简介</a></h3>
<p>Solidity 脚本是一种使用 Solidity 声明式部署合约的方式，而不是使用更受限制且不太友好的 <a href="tutorials/../reference/forge/forge-create.html"><code>forge create</code></a>。</p>
<p>Solidity 脚本类似于你在使用 Hardhat 等工具时编写的脚本；不同的是，它们是用 Solidity 而不是 JavaScript 编写的，并且它们在快速的 Foundry EVM 后端上运行，提供干运行功能。</p>
<h3 id="高级概述"><a class="header" href="#高级概述">高级概述</a></h3>
<p><code>forge script</code> 不是同步工作的。首先，它会收集脚本中的所有交易，然后才会广播它们。它基本上可以分为四个阶段：</p>
<ol>
<li>本地模拟 - 合约脚本在本地 EVM 中运行。如果提供了 rpc/fork URL，它将在该上下文中执行脚本。任何来自 <code>vm.broadcast</code> 和/或 <code>vm.startBroadcast</code> 的<strong>外部调用</strong>（非静态，非内部）将被附加到一个列表中。</li>
<li>链上模拟 - 可选。如果提供了 rpc/fork URL，那么它将在此处顺序执行前一阶段收集的所有交易。</li>
<li>广播 - 可选。如果提供了 <code>--broadcast</code> 标志并且前一阶段成功，它将广播在步骤 <code>1</code> 中收集并在步骤 <code>2</code> 中模拟的交易。</li>
<li>验证 - 可选。如果提供了 <code>--verify</code> 标志，有 API 密钥，并且前一阶段成功，它将尝试验证合约（例如 Etherscan）。</li>
</ol>
<p>鉴于这个流程，重要的是要注意到，其行为可能受外部状态/参与者影响的交易可能会有与步骤 <code>2</code> 中模拟的结果不同的结果。例如，抢先交易。</p>
<h3 id="设置"><a class="header" href="#设置">设置</a></h3>
<p>让我们尝试使用 Solidity 脚本部署在 solmate 教程中制作的 NFT 合约。首先，我们需要通过以下方式创建一个新的 Foundry 项目：</p>
<pre><code class="language-sh">forge init solidity-scripting
</code></pre>
<p>由于 solmate 教程中的 NFT 合约继承了 <code>solmate</code> 和 <code>OpenZeppelin</code> 合约，我们需要将它们作为依赖项安装：</p>
<pre><code class="language-sh"># 进入项目
cd solidity-scripting

# 安装 Solmate 和 OpenZeppelin 合约作为依赖项
forge install transmissions11/solmate Openzeppelin/openzeppelin-contracts@v5.0.1
</code></pre>
<p>接下来，我们需要删除 <code>src</code> 文件夹中的 <code>Counter.sol</code> 文件，并创建另一个名为 <code>NFT.sol</code> 的文件。你可以通过运行以下命令来完成：</p>
<pre><code class="language-sh">rm src/Counter.sol test/Counter.t.sol &amp;&amp; touch src/NFT.sol &amp;&amp; ls src
</code></pre>
<p><img src="tutorials/../images/solidity-scripting/set-up-commands.png" alt="设置命令" /></p>
<p>完成后，你应该打开你喜欢的代码编辑器，并将下面的代码复制到 <code>NFT.sol</code> 文件中。</p>
<pre><code class="language-solidity">// SPDX-License-Identifier: UNLICENSED
pragma solidity &gt;=0.8.10;

import "solmate/tokens/ERC721.sol";
import "openzeppelin-contracts/contracts/utils/Strings.sol";
import "openzeppelin-contracts/contracts/access/Ownable.sol";

error MintPriceNotPaid();
error MaxSupply();
error NonExistentTokenURI();
error WithdrawTransfer();

contract NFT is ERC721, Ownable {

    using Strings for uint256;
    string public baseURI;
    uint256 public currentTokenId;
    uint256 public constant TOTAL_SUPPLY = 10_000;
    uint256 public constant MINT_PRICE = 0.08 ether;

    constructor(
        string memory _name,
        string memory _symbol,
        string memory _baseURI
    ) ERC721(_name, _symbol) Ownable(msg.sender) {
        baseURI = _baseURI;
    }

    function mintTo(address recipient) public payable returns (uint256) {
        if (msg.value != MINT_PRICE) {
            revert MintPriceNotPaid();
        }
        uint256 newTokenId = ++currentTokenId;
        if (newTokenId &gt; TOTAL_SUPPLY) {
            revert MaxSupply();
        }
        _safeMint(recipient, newTokenId);
        return newTokenId;
    }

    function tokenURI(uint256 tokenId)
        public
        view
        virtual
        override
        returns (string memory)
    {
        if (ownerOf(tokenId) == address(0)) {
            revert NonExistentTokenURI();
        }
        return
            bytes(baseURI).length &gt; 0
                ? string(abi.encodePacked(baseURI, tokenId.toString()))
                : "";
    }

    function withdrawPayments(address payable payee) external onlyOwner {
        uint256 balance = address(this).balance;
        (bool transferTx, ) = payee.call{value: balance}("");
        if (!transferTx) {
            revert WithdrawTransfer();
        }
    }
}
</code></pre>
<p>现在，让我们尝试编译我们的合约，确保一切正常。</p>
<pre><code class="language-sh">forge build
</code></pre>
<p>如果你的输出看起来像这样，合约成功编译。
<img src="tutorials/../images/solidity-scripting/compile-successful.png" alt="编译成功" /></p>
<h3 id="部署我们的合约"><a class="header" href="#部署我们的合约">部署我们的合约</a></h3>
<p>我们将把 <code>NFT</code> 合约部署到 Sepolia 测试网，但为此我们需要配置 Foundry，设置 Sepolia RPC URL、一个有 Sepolia Eth 资金的账户的私钥，以及一个用于验证 NFT 合约的 Etherscan 密钥。</p>
<blockquote>
<p>💡 注意：你可以在这里获取一些 Sepolia 测试网 ETH <a href="https://sepoliafaucet.com/" title="" target="_blank">here</a>。</p>
</blockquote>
<h4 id="环境配置"><a class="header" href="#环境配置">环境配置</a></h4>
<p>一旦你有了所有这些，创建一个 <code>.env</code> 文件并添加变量。Foundry 会自动加载项目目录中存在的 <code>.env</code> 文件。</p>
<p>.env 文件应遵循以下格式：</p>
<pre><code class="language-sh">SEPOLIA_RPC_URL=
PRIVATE_KEY=
ETHERSCAN_API_KEY=
</code></pre>
<p>现在我们需要编辑 <code>foundry.toml</code> 文件。项目根目录中应该已经有一个。</p>
<p>在文件末尾添加以下行：</p>
<pre><code class="language-toml">[rpc_endpoints]
sepolia = "${SEPOLIA_RPC_URL}"

[etherscan]
sepolia = { key = "${ETHERSCAN_API_KEY}" }
</code></pre>
<p>这为 Sepolia 创建了一个 <a href="tutorials/../cheatcodes/rpc.html">RPC 别名</a> 并加载了 Etherscan API 密钥。</p>
<h4 id="编写脚本"><a class="header" href="#编写脚本">编写脚本</a></h4>
<p>接下来，我们需要创建一个文件夹并命名为 <code>script</code>，并在其中创建一个名为 <code>NFT.s.sol</code> 的文件。这是我们将创建部署脚本的地方。</p>
<p><code>NFT.s.sol</code> 的内容应如下所示：</p>
<pre><code class="language-solidity">// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import "forge-std/Script.sol";
import "../src/NFT.sol";

contract MyScript is Script {
    function run() external {
        uint256 deployerPrivateKey = vm.envUint("PRIVATE_KEY");
        vm.startBroadcast(deployerPrivateKey);

        NFT nft = new NFT("NFT_tutorial", "TUT", "baseUri");

        vm.stopBroadcast();
    }
}
</code></pre>
<p>现在让我们阅读代码并弄清楚它的实际含义和作用。</p>
<pre><code class="language-solidity">// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;
</code></pre>
<p>记住，即使这是一个脚本，它仍然像一个智能合约一样工作，但从未部署，所以就像任何其他用 Solidity 编写的智能合约一样，必须指定 <code>pragma version</code>。</p>
<pre><code class="language-solidity">import "forge-std/Script.sol";
import "../src/NFT.sol";
</code></pre>
<p>就像我们可能在编写测试时导入 Forge Std 以获取测试工具一样，Forge Std 也提供了一些脚本工具，我们在这里导入。</p>
<p>下一行只是导入 <code>NFT</code> 合约。</p>
<pre><code class="language-solidity">contract MyScript is Script {
</code></pre>
<p>我们创建了一个名为 <code>MyScript</code> 的合约，并继承了 Forge Std 中的 <code>Script</code>。</p>
<pre><code class="language-solidity">function run() external {
</code></pre>
<p>默认情况下，脚本通过调用名为 <code>run</code> 的函数来执行，这是我们的入口点。</p>
<pre><code class="language-solidity">uint256 deployerPrivateKey = vm.envUint("PRIVATE_KEY");
</code></pre>
<p>这从我们的 <code>.env</code> 文件中加载私钥。<strong>注意：</strong> 在 <code>.env</code> 文件中暴露私钥并将其加载到程序中时必须小心。这仅推荐用于非特权部署者或在本地 / 测试设置中使用。对于生产设置，请查看 Foundry 支持的各种 <a href="tutorials/../reference/forge/forge-script.html#wallet-options---raw">钱包选项</a>。</p>
<pre><code class="language-solidity">vm.startBroadcast(deployerPrivateKey);
</code></pre>
<p>这是一个特殊的作弊码，记录由我们的主脚本合约进行的调用和合约创建。我们传递 <code>deployerPrivateKey</code> 以指示它使用该密钥签署交易。稍后，我们将广播这些交易以部署我们的 NFT 合约。</p>
<pre><code class="language-solidity">NFT nft = new NFT("NFT_tutorial", "TUT", "baseUri");
</code></pre>
<p>这里我们只是创建了我们的 NFT 合约。因为我们在这行之前调用了 <code>vm.startBroadcast()</code>，合约创建将被 Forge 记录，正如前面提到的，我们可以广播交易以在链上部署合约。广播交易日志将默认存储在 <code>broadcast</code> 目录中。你可以通过在 <code>foundry.toml</code> 文件中设置 <a href="tutorials/../reference/config/project.html#broadcast"><code>broadcast</code></a> 来更改日志位置。</p>
<p>现在你已经了解了脚本智能合约的作用，让我们运行它。</p>
<p>你应该已经将前面提到的变量添加到 <code>.env</code> 文件中，以便下一部分能够工作。</p>
<p>在项目根目录运行：</p>
<pre><code class="language-sh"># 加载 .env 文件中的变量
source .env

# 部署并验证我们的合约
forge script --chain sepolia script/NFT.s.sol:MyScript --rpc-url $SEPOLIA_RPC_URL --broadcast --verify -vvvv
</code></pre>
<p>Forge 将运行我们的脚本并为我们广播交易——这可能需要一段时间，因为 Forge 还会等待交易收据。一分钟左右后，你应该会看到类似这样的内容：</p>
<p><img src="tutorials/../images/solidity-scripting/contract-verified.png" alt="合约已验证" /></p>
<p>这确认你已成功将 <code>NFT</code> 合约部署到 Sepolia 测试网，并在 Etherscan 上验证了它，所有这些都通过一个命令完成。</p>
<h3 id="本地部署"><a class="header" href="#本地部署">本地部署</a></h3>
<p>你可以通过将端口配置为 <code>fork-url</code> 来部署到 Anvil，本地测试网。</p>
<p>在这里，我们在账户方面有两个选项。我们可以不带任何标志启动 anvil 并使用提供的私钥之一。或者，我们可以传递一个助记词给 anvil 使用。</p>
<h4 id="使用-anvil-的默认账户"><a class="header" href="#使用-anvil-的默认账户">使用 Anvil 的默认账户</a></h4>
<p>首先，启动 Anvil：</p>
<pre><code class="language-sh">anvil
</code></pre>
<p>更新你的 <code>.env</code> 文件，使用 Anvil 提供给你的私钥。</p>
<p>然后运行以下脚本：</p>
<pre><code class="language-sh">forge script script/NFT.s.sol:MyScript --fork-url http://localhost:8545 --broadcast
</code></pre>
<h4 id="使用自定义助记词"><a class="header" href="#使用自定义助记词">使用自定义助记词</a></h4>
<p>在你的 <code>.env</code> 文件中添加以下行，并用你的助记词完成：</p>
<pre><code class="language-sh">MNEMONIC=
</code></pre>
<p>我们之前设置的 <code>PRIVATE_KEY</code> 环境变量应该是这个助记词中的前 10 个账户之一。</p>
<p>使用自定义助记词启动 Anvil：</p>
<pre><code class="language-sh">source .env

anvil -m $MNEMONIC
</code></pre>
<p>然后运行以下脚本：</p>
<pre><code class="language-sh">forge script script/NFT.s.sol:MyScript --fork-url http://localhost:8545 --broadcast
</code></pre>
<blockquote>
<p>💡 注意：本教程的完整实现可以在这里找到 <a href="https://github.com/Perelyn-sama/solidity-scripting" title="" target="_blank">here</a>，关于 Solidity 脚本的进一步阅读，你可以查看 <code>forge script</code> <a href="tutorials/../reference/forge/forge-script.html">参考</a>。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="使用-create2-进行确定性部署"><a class="header" href="#使用-create2-进行确定性部署">使用 CREATE2 进行确定性部署</a></h2>
<h3 id="介绍-1"><a class="header" href="#介绍-1">介绍</a></h3>
<p>作为 2019 年 <a href="https://ethereum.org/en/history/#constantinople" title="" target="_blank">Constantinople 分叉</a> 的一部分，<code>CREATE2</code> 操作码被纳入 EVM，其起源可以追溯到 <a href="https://eips.ethereum.org/EIPS/eip-1014" title="" target="_blank">EIP-1014</a>。
<code>CREATE2</code> 允许你根据部署者控制的参数将智能合约部署到确定性的地址。
因此，它经常被提及为启用“反事实”部署，你可以在尚未创建的地址上进行交互，因为 <code>CREATE2</code> 保证已知代码可以放置在该地址上。
这与 <code>CREATE</code> 操作码形成对比，后者的部署合约地址是部署者 nonce 的函数。
使用 <code>CREATE2</code>，你可以在多个网络上使用相同的部署者账户将合约部署到相同的地址，即使该地址的 nonce 不同。</p>
<blockquote>
<p>ℹ️ <strong>注意</strong>
本指南旨在帮助理解 <code>CREATE2</code>。在大多数用例中，你不需要编写和使用自己的部署者，可以使用现有的确定性部署者。在 forge 脚本中，使用 <code>new MyContract{salt: salt}()</code> 将使用位于 <a href="https://github.com/Arachnid/deterministic-deployment-proxy" title="" target="_blank">0x4e59b44847b379578588920ca78fbf26c0b4956c</a> 的确定性部署者。</p>
</blockquote>
<p>在本教程中，我们将：</p>
<ol>
<li>查看一个 <code>CREATE2</code> 工厂实现。</li>
<li>使用传统的部署方法部署工厂。</li>
<li>使用这个已部署的工厂在确定性地址上部署一个简单的计数器合约。</li>
<li>通过在 Foundry 中编写一个简单的测试来模拟这一系列事件。</li>
</ol>
<h3 id="前提条件"><a class="header" href="#前提条件">前提条件</a></h3>
<ol>
<li>需要对 Solidity 和 Foundry 有一定的了解，建议对内联汇编有一定的了解。
参考 <a href="https://docs.soliditylang.org/en/latest/assembly.html" title="" target="_blank">官方 Solidity 文档</a> 了解内联汇编的基础知识。</li>
<li>确保你的系统上已经 <a href="tutorials/../getting-started/installation.html">安装</a> 了 Foundry。</li>
<li><a href="tutorials/../projects/creating-a-new-project.html">初始化</a> 一个新的 Foundry 项目。</li>
</ol>
<h3 id="create2-工厂"><a class="header" href="#create2-工厂">CREATE2 工厂</a></h3>
<p>在 <code>src</code> 目录中创建一个名为 <code>Create2.sol</code> 的文件。
初始化一个名为 <code>Create2</code> 的合约，如下所示：</p>
<pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract Create2 {

    error Create2EmptyBytecode();

    error Create2FailedDeployment();
}
</code></pre>
<p>这些错误旨在对工厂部署进行一些合理性检查，并在触发时回滚整个交易。
如果传递给 <code>deploy</code> 函数的字节码为空，则触发 <code>Create2EmptyBytecode()</code> 错误，如果部署因任何原因失败，则触发 <code>Create2FailedDeployment()</code> 错误。</p>
<blockquote>
<p>ℹ️ <strong>注意</strong></p>
<p>请注意，<code>CREATE2</code> 部署可能由于多种原因失败。例如，如果字节码无效，或者在计算的地址上已经部署了合约。如果你的构造函数因任何原因回滚，你的部署也可能失败。</p>
</blockquote>
<p>接下来，创建一个名为 <code>deploy</code> 的函数：</p>
<pre><code class="language-solidity">function deploy(bytes32 salt, bytes memory creationCode) external payable returns (address addr) {
 
 }
</code></pre>
<p>该函数接受两个输入：</p>
<ol>
<li>用于计算最终地址的 <code>salt</code>。这基本上可以是任何我们想要的随机值。</li>
<li>我们要部署的合约的创建代码。</li>
</ol>
<p>新部署的合约地址在成功部署后返回。</p>
<blockquote>
<p>ℹ️ <strong>注意</strong></p>
<p>你可以使用 <code>CREATE2</code> 向正在部署的合约发送 ETH，但前提是它有一个可支付的构造函数。
如果你尝试在没有可支付构造函数的情况下向其发送 ETH，交易将回滚。</p>
</blockquote>
<p>在 deploy 函数的顶部添加这个回滚语句。我们希望如果以下条件不满足，函数拒绝部署请求：</p>
<pre><code class="language-solidity">    if (creationCode.length == 0) {
        revert Create2EmptyBytecode();
    }
</code></pre>
<p>接下来，我们将使用内联汇编调用 <code>CREATE2</code> 操作码，这可以使用 <code>assembly</code> 关键字完成：</p>
<p>要调用 <a href="https://docs.soliditylang.org/en/latest/yul.html#evm-dialect" title="" target="_blank">内联汇编中的 CREATE2 操作码</a>，我们需要传入四个参数：</p>
<pre><code class="language-solidity">    assembly {
        addr := create2(callvalue(), add(creationCode, 0x20), mload(creationCode), salt)
    }
</code></pre>
<ol>
<li>作为部署的一部分，我们要发送到新地址的 ETH 数量。这里我们传入 <code>callvalue()</code>，这是作为交易的一部分发送到工厂合约的 ETH 数量。可以将其视为 <code>msg.value</code> 的低级版本。</li>
<li>第二个和第三个参数指的是我们的字节码所在的内存范围。<code>add(bytecode, 0x20)</code> 接受内存中 <code>bytes</code> 变量字节码位置的引用，并跳过 32 字节（十六进制的 0x20）以指向实际的字节码。</li>
</ol>
<blockquote>
<p>ℹ️ <strong>注意</strong></p>
<p>Solidity 中的 <code>bytes</code> 类型是动态大小的字节数组，其中内存的前 32 字节表示数组的长度，其余字节表示实际数据。因此，当我们传入 <code>bytes</code> 变量的引用时，我们需要跳过前 32 字节以指向实际数据。
在 <a href="https://www.evm.codes/?fork=shanghai" title="" target="_blank">evm.codes</a> 上阅读更多关于 <code>add</code> 和 <code>mload</code> 操作码的信息。</p>
</blockquote>
<p>最后，如果部署因任何原因失败，我们将回滚整个交易，在这种情况下，<code>CREATE2</code> 操作码将返回一个 0 地址：</p>
<pre><code class="language-solidity">        if (addr == address(0)) {
            revert Create2FailedDeployment();
        }
</code></pre>
<p>最后，让我们创建一个名为 <code>computeAddress</code> 的视图函数。该函数应接受 <code>salt</code> 和 <code>creationCode</code> 作为参数，并返回使用 <code>deploy</code> 函数部署的合约地址：</p>
<pre><code class="language-solidity">function computeAddress(bytes32 salt, bytes32 creationCodeHash) external view returns (address addr) {

 }
</code></pre>
<p>在函数内部，粘贴以下代码，该代码使用内联汇编计算地址，执行与 <code>CREATE2</code> 操作码相同的计算：</p>
<pre><code class="language-solidity">    address contractAddress = address(this);
        
    assembly {
        let ptr := mload(0x40)

        mstore(add(ptr, 0x40), creationCodeHash)
        mstore(add(ptr, 0x20), salt)
        mstore(ptr, contractAddress)
        let start := add(ptr, 0x0b)
        mstore8(start, 0xff)
        addr := keccak256(start, 85)
    }
</code></pre>
<p>在尝试理解这里的汇编代码之前，让我们看一下 <code>CREATE2</code> 操作码用于计算地址的公式：</p>
<pre><code class="language-bash">keccak256(0xff ++ address ++ salt ++ keccak256(bytecode))[12:]
</code></pre>
<p><code>0xff</code> 是一个硬编码的前缀，防止使用 <code>CREATE</code> 和 <code>CREATE2</code> 部署的地址之间的哈希碰撞。
<code>address</code> 参数指的是调用 <code>CREATE2</code> 操作码的合约地址，在我们的例子中是工厂合约。
这四个参数连接在一起，并使用 <code>keccak256</code> 生成一个 32 字节的哈希。
前 12 字节被截断，剩下的 20 字节用作部署合约的地址。</p>
<p><code>computeAddress</code> 函数中的整个汇编代码试图在不调用 <code>CREATE2</code> 操作码的情况下重现相同的公式：</p>
<ol>
<li><code>mload(0x40)</code> 将自由内存指针加载到内存中。这是指向内存数组中下一个自由内存槽的指针。在 <a href="https://docs.soliditylang.org/en/latest/assembly.html#memory-management" title="" target="_blank">Solidity 文档</a> 中阅读更多关于这方面的信息。</li>
<li><code>mstore(add(ptr, 0x40), bytecodeHash)</code> 从 <code>ptr + 0x40</code> 指向的内存位置开始存储 <code>bytecodeHash</code>，即 <code>ptr + 64 字节</code>。</li>
<li><code>mstore(add(ptr, 0x20), salt)</code> 在 <code>ptr + 0x20</code> 指向的内存位置存储 <code>salt</code>。</li>
<li><code>mstore(ptr, contractAddress)</code> 在 <code>ptr</code> 指向的内存位置存储 <code>contractAddress</code>。</li>
</ol>
<blockquote>
<p>ℹ️ <strong>注意</strong></p>
<p>回想一下，传递给 <code>computeAddress</code> 函数的所有参数都是 32 字节长，并在内存中存储为 32 字节值。然而，Solidity 中的地址是 20 字节长，并在内存中存储为 32 字节值，其中前 12 字节被 0 替换。
因此，当我们需要跳过 12 字节以指向实际地址时。</p>
</blockquote>
<ol start="5">
<li><code>let start := add(ptr, 0x0b)</code> 创建一个新变量 <code>start</code>，指向内存位置 <code>ptr + 0x0b</code>，即 <code>ptr + 11 字节</code>。</li>
<li>最后，mstore8 操作码可用于在内存位置存储单个字节。在这里，我们在 <code>start</code> 指向的内存位置存储值 <code>0xff</code>，该位置占用内存槽的第 12 字节。</li>
<li>将所有值打包到正确的内存位置后，我们现在可以对从 <code>start</code> 开始的内存槽调用 <code>keccak256</code>，并将内存槽的长度作为第二个参数传递。这将返回一个 32 字节的哈希，我们可以截断以获得最终地址。</li>
</ol>
<blockquote>
<p>ℹ️ <strong>注意</strong></p>
<p>你可以查看这个工厂实现的完整代码 <a href="https://github.com/Genesis3800/CREATE2Factory/blob/main/src/Create2.sol" title="" target="_blank">这里</a>。
还可以查看 OpenZeppelin 的 <a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/793d92a3331538d126033cbacb1ee5b8a7d95adc/contracts/utils/Create2.sol" title="" target="_blank">CREATE2 库实现</a>，该实现为本教程提供了灵感。
最后，Forge 提供了一些开箱即用的 <code>CREATE2</code> 地址计算辅助函数。<a href="https://github.com/foundry-rs/forge-std/blob/f73c73d2018eb6a111f35e4dae7b4f27401e9421/src/StdUtils.sol#L122-L134" title="" target="_blank">查看它们</a>。</p>
</blockquote>
<h3 id="测试我们的工厂"><a class="header" href="#测试我们的工厂">测试我们的工厂</a></h3>
<p>在 <code>test</code> 目录中创建一个名为 <code>Create2.t.sol</code> 的文件。
初始化一个名为 <code>Create2Test</code> 的合约，如下所示：</p>
<pre><code class="language-solidity">// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import {Counter} from "../src/Counter.sol";
import {Create2} from "../src/Create2.sol";

contract Create2Test is Test {

}
</code></pre>
<p>初始化以下状态变量和 <code>setUp()</code> 函数：</p>
<pre><code class="language-solidity">    Create2 internal create2;
    Counter internal counter;

    function setUp() public {
        create2 = new Create2();
        counter = new Counter();
    }
</code></pre>
<p>创建一个名为 <code>testDeterministicDeploy()</code> 的新函数，该函数：</p>
<ol>
<li>部署一个新的 <code>Create2</code> 合约实例。</li>
<li>向我们将用于模拟所有后续调用者的特定地址分配 100 ETH，使用 <code>prank</code> 作弊码。</li>
<li>设置 <code>salt</code> 和 <code>bytecode</code> 参数</li>
<li>使用之前部署的 <code>Create2</code> 合约在确定性地址上部署 <code>Counter</code> 合约。</li>
<li>通过断言计算的地址等于部署的地址，检查合约是否部署在正确的地址上。</li>
</ol>
<pre><code class="language-solidity">    function testDeterministicDeploy() public {
        vm.deal(address(0x1), 100 ether);

        vm.startPrank(address(0x1));  
        bytes32 salt = "12345";
        bytes memory creationCode = abi.encodePacked(type(Counter).creationCode);

        address computedAddress = create2.computeAddress(salt, keccak256(creationCode));
        address deployedAddress = create2.deploy(salt , creationCode);
        vm.stopPrank();

        assertEq(computedAddress, deployedAddress);  
    }
</code></pre>
<p>保存所有文件，并使用 <code>forge test --match-path test/Create2.t.sol -vvvv</code> 运行测试。
你的测试应该在没有错误的情况下通过。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="使用-cast-和-anvil-分叉主网"><a class="header" href="#使用-cast-和-anvil-分叉主网">使用 Cast 和 Anvil 分叉主网</a></h2>
<h3 id="介绍-2"><a class="header" href="#介绍-2">介绍</a></h3>
<p>通过结合 <a href="tutorials/../reference/anvil/">Anvil</a> 和 <a href="tutorials/../reference/cast/">Cast</a>，您可以分叉并测试与真实网络上的合约进行交互。本教程的目标是向您展示如何将 Dai 代币从一个持有 Dai 的用户转移到由 Anvil 创建的账户。</p>
<h3 id="设置-1"><a class="header" href="#设置-1">设置</a></h3>
<p>让我们从分叉主网开始。</p>
<pre><code class="language-sh">anvil --fork-url https://mainnet.infura.io/v3/$INFURA_KEY
</code></pre>
<p>您将看到创建了 10 个账户及其公钥和私钥。我们将使用 <code>0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266</code>（我们称这个用户为 Alice）。</p>
<h3 id="转移-dai"><a class="header" href="#转移-dai">转移 Dai</a></h3>
<p>前往 Etherscan 并搜索 Dai 代币的持有者（<a href="https://etherscan.io/token/0x6b175474e89094c44da98b954eedeac495271d0f#balances" title="" target="_blank">这里</a>）。让我们选择一个随机的账户。在这个例子中，我们将使用 <code>0xfc2eE3bD619B7cfb2dE2C797b96DeeCbD7F68e46</code>。让我们将合约和账户导出为环境变量：</p>
<pre><code class="language-sh">export ALICE=0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266
export DAI=0x6b175474e89094c44da98b954eedeac495271d0f
export UNLUCKY_USER=0xfc2eE3bD619B7cfb2dE2C797b96DeeCbD7F68e46
</code></pre>
<p>我们可以使用 <a href="tutorials/../reference/cast/cast-call.html"><code>cast call</code></a> 检查 Alice 的余额：</p>
<pre><code class="language-sh">$ cast call $DAI \
  "balanceOf(address)(uint256)" \
  $ALICE
0
</code></pre>
<p>同样，我们也可以使用 <code>cast call</code> 检查不幸用户的余额：</p>
<pre><code class="language-sh">$ cast call $DAI \
  "balanceOf(address)(uint256)" \
  $UNLUCKY_USER
21840114973524208109322438
</code></pre>
<p>让我们使用 <a href="tutorials/../reference/cast/cast-send.html"><code>cast send</code></a> 从不幸运用户向 Alice 转移一些代币：</p>
<pre><code class="language-sh"># 这会调用 Anvil 并让我们模拟不幸用户
$ cast rpc anvil_impersonateAccount $UNLUCKY_USER
$ cast send $DAI \
--from $UNLUCKY_USER \
  "transfer(address,uint256)(bool)" \
  $ALICE \
  300000000000000000000000 \
  --unlocked
blockHash               0xbf31c45f6935a0714bb4f709b5e3850ab0cc2f8bffe895fefb653d154e0aa062
blockNumber             15052891
...
</code></pre>
<p>让我们检查转移是否成功：</p>
<pre><code class="language-sh">cast call $DAI \
  "balanceOf(address)(uint256)" \
  $ALICE
300000000000000000000000

$ cast call $DAI \
  "balanceOf(address)(uint256)" \
  $UNLUCKY_USER
21540114973524208109322438
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="foundry-教程非官方视频"><a class="header" href="#foundry-教程非官方视频">Foundry 教程（非官方）视频</a></h2>
<p>来自区块链教育者的非官方 <em>YouTube 播放列表</em> Foundry 教程。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">URL</th><th style="text-align: center">描述</th><th style="text-align: center">作者</th></tr></thead><tbody>
<tr><td style="text-align: center"><a href="https://www.youtube.com/playlist?list=PL4Rj_WH6yLgWe7TxankiqkrkVKXIwOP42" target="_blank"><img src="https://i.ytimg.com/vi/umepbfKp5rI/hq720.jpg" alt=""></a></td><td style="text-align: center"><a href="https://www.youtube.com/playlist?list=PL4Rj_WH6yLgWe7TxankiqkrkVKXIwOP42" target="_blank"></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center"><em>区块链开发者, Solidity, Foundry 全课程 2023</em> ~ 学习 Solidity, 区块链开发, &amp; 智能合约 由 AI 驱动 - 全课程</a></td><td style="text-align: center"><a href="https://www.youtube.com/@PatrickAlphaC" target="_blank">Patrick Collins</a></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center"><a href="https://youtube.com/playlist?list=PLO5VPQH6OWdUrKEWPF07CSuVm3T99DQki" target="_blank"><img src="https://i.ytimg.com/vi/tgs5q-GJmg4/hq720.jpg" alt=""></a></td><td style="text-align: center"><a href="https://youtube.com/playlist?list=PLO5VPQH6OWdUrKEWPF07CSuVm3T99DQki" target="_blank"></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center"><em>Foundry</em> ~  Foundry 初学者视频播放列表</a></td><td style="text-align: center"><a href="https://www.youtube.com/@smartcontractprogrammer" target="_blank">Smart Contract Programmer</a></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center"><a href="https://www.youtube.com/watch?v=hOB1Yiuxojk" target="_blank"><img src="https://i.ytimg.com/vi/hOB1Yiuxojk/maxresdefault.jpg" alt=""></a></td><td style="text-align: center"><a href="https://www.youtube.com/watch?v=hOB1Yiuxojk" target="_blank">Foundry 智能合约开发完全介绍</a></td><td style="text-align: center"><a href="https://www.youtube.com/@axelar-network" target="_blank">Axelar</a></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h2 id="常见问题解答"><a class="header" href="#常见问题解答">常见问题解答</a></h2>
<p>这是一个常见问题和答案的集合。如果你在这里没有找到你的问题，请加入 [Telegram 支持频道][tg-support]，让我们帮助你！</p>
<h3 id="我无法从源码构建"><a class="header" href="#我无法从源码构建">我无法从源码构建！</a></h3>
<p>确保你使用的是最新的稳定 Rust 工具链：</p>
<pre><code class="language-sh">rustup default stable
rustup update stable
</code></pre>
<h3 id="运行-forgecast-时出现-libusb-错误"><a class="header" href="#运行-forgecast-时出现-libusb-错误">运行 <code>forge</code>/<code>cast</code> 时出现 <code>libusb</code> 错误</a></h3>
<p>如果你使用的是发布的二进制文件，在 MacOS 上可能会看到以下错误：</p>
<pre><code class="language-sh">dyld: Library not loaded: /usr/local/opt/libusb/lib/libusb-1.0.0.dylib
</code></pre>
<p>为了解决这个问题，你必须安装 <code>libusb</code> 库：</p>
<pre><code class="language-sh">brew install libusb
</code></pre>
<h3 id="glibc-版本过旧"><a class="header" href="#glibc-版本过旧"><code>GLIBC</code> 版本过旧</a></h3>
<p>如果你在使用 <code>foundryup</code> 后遇到类似以下的错误：</p>
<pre><code class="language-sh">forge: /lib/x86_64-linux-gnu/libc.so.6: version 'GLIBC_2.29' not found (required by forge)
</code></pre>
<p>有两个解决方法：</p>
<ol>
<li><a href="./getting-started/installation.html#building-from-source">从源码构建</a></li>
<li><a href="./getting-started/installation.html#using-foundry-with-docker">使用 Docker</a></li>
</ol>
<h3 id="救命我看不到我的日志"><a class="header" href="#救命我看不到我的日志">救命！我看不到我的日志！</a></h3>
<p>Forge 默认不显示日志。如果你想查看 Hardhat 的 <code>console.log</code> 或 DSTest 风格的 <code>log_*</code> 事件日志，你需要运行 [<code>forge test</code>][forge-test] 并设置详细度为 2（<code>-vv</code>）。</p>
<p>如果你想查看其他合约发出的事件，你需要启用 traces。为此，将详细度设置为 3（<code>-vvv</code>）以查看失败的测试的 traces，或设置为 4（<code>-vvvv</code>）以查看所有测试的 traces。</p>
<h3 id="我的测试失败了我不知道为什么"><a class="header" href="#我的测试失败了我不知道为什么">我的测试失败了，我不知道为什么！</a></h3>
<p>为了更好地了解你的测试为何失败，尝试使用 traces。要启用 traces，你需要在 [forge test][forge-test] 上将详细度至少增加到 3（<code>-vvv</code>），但你可以增加到 5（<code>-vvvvv</code>）以获得更多的 traces。</p>
<p>你可以在我们的 [理解 Traces][traces] 章节中了解更多关于 traces 的信息。</p>
<h3 id="如何使用-consolelog"><a class="header" href="#如何使用-consolelog">如何使用 <code>console.log</code>？</a></h3>
<p>要使用 Hardhat 的 <code>console.log</code>，你必须通过从 [这里][console-log] 复制文件来将其添加到你的项目中。</p>
<p>或者，你可以使用 [Forge Std][forge-std]，它自带 <code>console.log</code>。要使用 Forge Std 中的 <code>console.log</code>，你必须导入它：</p>
<pre><code class="language-solidity">import "forge-std/console.sol";
</code></pre>
<h3 id="如何运行特定的测试"><a class="header" href="#如何运行特定的测试">如何运行特定的测试？</a></h3>
<p>如果你只想运行几个测试，可以使用 <code>--match-test</code> 来过滤测试函数，使用 <code>--match-contract</code> 来过滤测试合约，以及使用 <code>--match-path</code> 来过滤测试文件在 [<code>forge test</code>][forge-test] 上。</p>
<h3 id="如何使用特定的-solidity-编译器"><a class="header" href="#如何使用特定的-solidity-编译器">如何使用特定的 Solidity 编译器？</a></h3>
<p>Forge 会尝试自动检测适用于你项目的 Solidity 编译器。</p>
<p>要使用特定的 Solidity 编译器，你可以在配置文件中设置 [<code>solc</code>][config-solc]，或者在支持的 Forge 命令中传递 <code>--use solc:&lt;version&gt;</code>（例如 [<code>forge build</code>][forge-build] 或 [<code>forge test</code>][forge-test]）。也可以接受 solc 二进制文件的路径。要使用特定的本地 solc 二进制文件，可以在配置文件中设置 <code>solc = "&lt;path to solc&gt;"</code>，或者传递 <code>--use "&lt;path to solc&gt;"</code>。solc 版本/路径也可以通过环境变量 <code>FOUNDRY_SOLC=&lt;version/path&gt;</code> 设置，但命令行参数 <code>--use</code> 优先。</p>
<p>例如，如果你有一个支持所有 0.7.x Solidity 版本的项目，但你想用 solc 0.7.0 编译，你可以使用 <code>forge build --use solc:0.7.0</code>。</p>
<h3 id="如何从实时网络分叉"><a class="header" href="#如何从实时网络分叉">如何从实时网络分叉？</a></h3>
<p>要从实时网络分叉，请在 [<code>forge test</code>][forge-test] 上传递 <code>--fork-url &lt;URL&gt;</code>。你还可以使用 <code>--fork-block-number &lt;BLOCK&gt;</code> 从特定区块分叉，这会增加测试的确定性，并允许 Forge 缓存该区块的链数据。</p>
<p>例如，要从以太坊主网在区块 10,000,000 分叉，你可以使用：<code>forge test --fork-url $MAINNET_RPC_URL --fork-block-number 10000000</code>。</p>
<h3 id="如何添加我自己的断言"><a class="header" href="#如何添加我自己的断言">如何添加我自己的断言？</a></h3>
<p>你可以通过创建自己的基础测试合约并让该合约继承你选择的测试框架来添加自己的断言。</p>
<p>例如，如果你使用 DSTest，你可以创建一个基础测试合约如下：</p>
<pre><code class="language-solidity">contract TestBase is DSTest {
    function myCustomAssertion(uint a, uint b) {
      if (a != b) {
          emit log_string("a 和 b 不匹配");
          fail();
      }
    }
}
</code></pre>
<p>然后在你</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="贡献"><a class="header" href="#贡献">贡献</a></h1>
<p>感谢您对改进 Foundry 的兴趣！</p>
<p>在任何层次上都有多种贡献的机会。无论您是刚刚开始学习 Rust 还是经验最丰富的专家，我们都需要您的帮助。</p>
<p>任何贡献都不会太小，所有贡献都是有价值的。</p>
<p>本文档将帮助您入门。不要让文档吓到您。它应该被视为一个指南，帮助您导航整个过程。</p>
<p><a href="https://t.me/foundry_rs" title="" target="_blank">开发 Telegram</a> 可用于解决本指南未涵盖的任何问题。</p>
<p>首先查看 <a href="https://github.com/foundry-rs/foundry/blob/master/CONTRIBUTING.md" title="" target="_blank">贡献指南</a></p>
<p>一些文章将带您了解第一步：</p>
<ul>
<li><a href="https://dev.to/teddav/foundry-open-source-contribution-1k2d" title="" target="_blank">进行第一次贡献</a></li>
<li><a href="https://dev.to/teddav/foundry-add-a-cheatcode-5hc8" title="" target="_blank">添加一个 cheatcode</a>（已过时，请参阅 <a href="https://github.com/foundry-rs/foundry/blob/master/docs/dev/cheatcodes.md#adding-a-new-cheatcode" title="" target="_blank">Foundry 开发文档</a> 获取更短但最新的教程）</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="参考资料"><a class="header" href="#参考资料">参考资料</a></h2>
<ul>
<li><a href="reference/./cli/">CLI 参考</a></li>
<li><a href="reference/./forge/">forge 命令</a></li>
<li><a href="reference/./cast/">cast 命令</a></li>
<li><a href="reference/./anvil/">anvil 参考</a></li>
<li><a href="reference/./chisel/">chisel 参考</a></li>
<li><a href="reference/./config/">配置参考</a></li>
<li><a href="reference/../cheatcodes/">作弊码参考</a></li>
<li><a href="reference/./forge-std">Forge 标准库参考</a></li>
<li><a href="reference/./ds-test.html">ds-test 参考</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cli-参考"><a class="header" href="#cli-参考">CLI 参考</a></h1>
<!-- Generated by scripts/gen_output/help.py -->
<p>从 <code>--help</code> 输出自动生成的 CLI 参考。</p>
<ul>
<li>
<p><a href="reference/cli/./forge.html"><code>forge</code></a></p>
<ul>
<li><a href="reference/cli/./forge/bind.html"><code>forge bind</code></a></li>
<li><a href="reference/cli/./forge/build.html"><code>forge build</code></a></li>
<li><a href="reference/cli/./forge/cache.html"><code>forge cache</code></a>
<ul>
<li><a href="reference/cli/./forge/cache/clean.html"><code>forge cache clean</code></a></li>
<li><a href="reference/cli/./forge/cache/ls.html"><code>forge cache ls</code></a></li>
</ul>
</li>
<li><a href="reference/cli/./forge/clean.html"><code>forge clean</code></a></li>
<li><a href="reference/cli/./forge/clone.html"><code>forge clone</code></a></li>
<li><a href="reference/cli/./forge/completions.html"><code>forge completions</code></a></li>
<li><a href="reference/cli/./forge/config.html"><code>forge config</code></a></li>
<li><a href="reference/cli/./forge/coverage.html"><code>forge coverage</code></a></li>
<li><a href="reference/cli/./forge/create.html"><code>forge create</code></a></li>
<li><a href="reference/cli/./forge/debug.html"><code>forge debug</code></a></li>
<li><a href="reference/cli/./forge/doc.html"><code>forge doc</code></a></li>
<li><a href="reference/cli/./forge/flatten.html"><code>forge flatten</code></a></li>
<li><a href="reference/cli/./forge/fmt.html"><code>forge fmt</code></a></li>
<li><a href="reference/cli/./forge/geiger.html"><code>forge geiger</code></a></li>
<li><a href="reference/cli/./forge/generate.html"><code>forge generate</code></a>
<ul>
<li><a href="reference/cli/./forge/generate/test.html"><code>forge generate test</code></a></li>
</ul>
</li>
<li><a href="reference/cli/./forge/generate-fig-spec.html"><code>forge generate-fig-spec</code></a></li>
<li><a href="reference/cli/./forge/init.html"><code>forge init</code></a></li>
<li><a href="reference/cli/./forge/inspect.html"><code>forge inspect</code></a></li>
<li><a href="reference/cli/./forge/install.html"><code>forge install</code></a></li>
<li><a href="reference/cli/./forge/remappings.html"><code>forge remappings</code></a></li>
<li><a href="reference/cli/./forge/remove.html"><code>forge remove</code></a></li>
<li><a href="reference/cli/./forge/script.html"><code>forge script</code></a></li>
<li><a href="reference/cli/./forge/selectors.html"><code>forge selectors</code></a>
<ul>
<li><a href="reference/cli/./forge/selectors/collision.html"><code>forge selectors collision</code></a></li>
<li><a href="reference/cli/./forge/selectors/upload.html"><code>forge selectors upload</code></a></li>
<li><a href="reference/cli/./forge/selectors/list.html"><code>forge selectors list</code></a></li>
</ul>
</li>
<li><a href="reference/cli/./forge/snapshot.html"><code>forge snapshot</code></a></li>
<li><a href="reference/cli/./forge/soldeer.html"><code>forge soldeer</code></a>
<ul>
<li><a href="reference/cli/./forge/soldeer/install.html"><code>forge soldeer install</code></a></li>
<li><a href="reference/cli/./forge/soldeer/update.html"><code>forge soldeer update</code></a></li>
<li><a href="reference/cli/./forge/soldeer/login.html"><code>forge soldeer login</code></a></li>
<li><a href="reference/cli/./forge/soldeer/push.html"><code>forge soldeer push</code></a></li>
<li><a href="reference/cli/./forge/soldeer/version-dry-run.html"><code>forge soldeer version-dry-run</code></a></li>
</ul>
</li>
<li><a href="reference/cli/./forge/test.html"><code>forge test</code></a></li>
<li><a href="reference/cli/./forge/tree.html"><code>forge tree</code></a></li>
<li><a href="reference/cli/./forge/update.html"><code>forge update</code></a></li>
<li><a href="reference/cli/./forge/verify-bytecode.html"><code>forge verify-bytecode</code></a></li>
<li><a href="reference/cli/./forge/verify-check.html"><code>forge verify-check</code></a></li>
<li><a href="reference/cli/./forge/verify-contract.html"><code>forge verify-contract</code></a></li>
</ul>
</li>
<li>
<p><a href="reference/cli/./cast.html"><code>cast</code></a></p>
<ul>
<li><a href="reference/cli/./cast/4byte.html"><code>cast 4byte</code></a></li>
<li><a href="reference/cli/./cast/4byte-decode.html"><code>cast 4byte-decode</code></a></li>
<li><a href="reference/cli/./cast/4byte-event.html"><code>cast 4byte-event</code></a></li>
<li><a href="reference/cli/./cast/abi-decode.html"><code>cast abi-decode</code></a></li>
<li><a href="reference/cli/./cast/abi-encode.html"><code>cast abi-encode</code></a></li>
<li><a href="reference/cli/./cast/access-list.html"><code>cast access-list</code></a></li>
<li><a href="reference/cli/./cast/address-zero.html"><code>cast address-zero</code></a></li>
<li><a href="reference/cli/./cast/admin.html"><code>cast admin</code></a></li>
<li><a href="reference/cli/./cast/age.html"><code>cast age</code></a></li>
<li><a href="reference/cli/./cast/balance.html"><code>cast balance</code></a></li>
<li><a href="reference/cli/./cast/base-fee.html"><code>cast base-fee</code></a></li>
<li><a href="reference/cli/./cast/bind.html"><code>cast bind</code></a></li>
<li><a href="reference/cli/./cast/block.html"><code>cast block</code></a></li>
<li><a href="reference/cli/./cast/block-number.html"><code>cast block-number</code></a></li>
<li><a href="reference/cli/./cast/call.html"><code>cast call</code></a>
<ul>
<li><a href="reference/cli/./cast/call/--create.html"><code>cast call --create</code></a></li>
</ul>
</li>
<li><a href="reference/cli/./cast/calldata.html"><code>cast calldata</code></a></li>
<li><a href="reference/cli/./cast/calldata-decode.html"><code>cast calldata-decode</code></a></li>
<li><a href="reference/cli/./cast/chain.html"><code>cast chain</code></a></li>
<li><a href="reference/cli/./cast/chain-id.html"><code>cast chain-id</code></a></li>
<li><a href="reference/cli/./cast/client.html"><code>cast client</code></a></li>
<li><a href="reference/cli/./cast/code.html"><code>cast code</code></a></li>
<li><a href="reference/cli/./cast/codesize.html"><code>cast codesize</code></a></li>
<li><a href="reference/cli/./cast/completions.html"><code>cast completions</code></a></li>
<li><a href="reference/cli/./cast/compute-address.html"><code>cast compute-address</code></a></li>
<li><a href="reference/cli/./cast/concat-hex.html"><code>cast concat-hex</code></a></li>
<li><a href="reference/cli/./cast/create2.html"><code>cast create2</code></a></li>
<li><a href="reference/cli/./cast/decode-transaction.html"><code>cast decode-transaction</code></a></li>
<li><a href="reference/cli/./cast/disassemble.html"><code>cast disassemble</code></a></li>
<li><a href="reference/cli/./cast/estimate.html"><code>cast estimate</code></a>
<ul>
<li><a href="reference/cli/./cast/estimate/--create.html"><code>cast estimate --create</code></a></li>
</ul>
</li>
<li><a href="reference/cli/./cast/etherscan-source.html"><code>cast etherscan-source</code></a></li>
<li><a href="reference/cli/./cast/find-block.html"><code>cast find-block</code></a></li>
<li><a href="reference/cli/./cast/format-bytes32-string.html"><code>cast format-bytes32-string</code></a></li>
<li><a href="reference/cli/./cast/from-bin.html"><code>cast from-bin</code></a></li>
<li><a href="reference/cli/./cast/from-fixed-point.html"><code>cast from-fixed-point</code></a></li>
<li><a href="reference/cli/./cast/from-rlp.html"><code>cast from-rlp</code></a></li>
<li><a href="reference/cli/./cast/from-utf8.html"><code>cast from-utf8</code></a></li>
<li><a href="reference/cli/./cast/from-wei.html"><code>cast from-wei</code></a></li>
<li><a href="reference/cli/./cast/gas-price.html"><code>cast gas-price</code></a></li>
<li><a href="reference/cli/./cast/generate-fig-spec.html"><code>cast generate-fig-spec</code></a></li>
<li><a href="reference/cli/./cast/hash-zero.html"><code>cast hash-zero</code></a></li>
<li><a href="reference/cli/./cast/implementation.html"><code>cast implementation</code></a></li>
<li><a href="reference/cli/./cast/index.html"><code>cast index</code></a></li>
<li><a href="reference/cli/./cast/index-erc7201.html"><code>cast index-erc7201</code></a></li>
<li><a href="reference/cli/./cast/interface.html"><code>cast interface</code></a></li>
<li><a href="reference/cli/./cast/keccak.html"><code>cast keccak</code></a></li>
<li><a href="reference/cli/./cast/logs.html"><code>cast logs</code></a></li>
<li><a href="reference/cli/./cast/lookup-address.html"><code>cast lookup-address</code></a></li>
<li><a href="reference/cli/./cast/max-int.html"><code>cast max-int</code></a></li>
<li><a href="reference/cli/./cast/max-uint.html"><code>cast max-uint</code></a></li>
<li><a href="reference/cli/./cast/min-int.html"><code>cast min-int</code></a></li>
<li><a href="reference/cli/./cast/mktx.html"><code>cast mktx</code></a>
<ul>
<li><a href="reference/cli/./cast/mktx/--create.html"><code>cast mktx --create</code></a></li>
</ul>
</li>
<li><a href="reference/cli/./cast/namehash.html"><code>cast namehash</code></a></li>
<li><a href="reference/cli/./cast/nonce.html"><code>cast nonce</code></a></li>
<li><a href="reference/cli/./cast/parse-bytes32-address.html"><code>cast parse-bytes32-address</code></a></li>
<li><a href="reference/cli/./cast/parse-bytes32-string.html"><code>cast parse-bytes32-string</code></a></li>
<li><a href="reference/cli/./cast/pretty-calldata.html"><code>cast pretty-calldata</code></a></li>
<li><a href="reference/cli/./cast/proof.html"><code>cast proof</code></a></li>
<li><a href="reference/cli/./cast/publish.html"><code>cast publish</code></a></li>
<li><a href="reference/cli/./cast/receipt.html"><code>cast receipt</code></a></li>
<li><a href="reference/cli/./cast/resolve-name.html"><code>cast resolve-name</code></a></li>
<li><a href="reference/cli/./cast/rpc.html"><code>cast rpc</code></a></li>
<li><a href="reference/cli/./cast/run.html"><code>cast run</code></a></li>
<li><a href="reference/cli/./cast/selectors.html"><code>cast selectors</code></a></li>
<li><a href="reference/cli/./cast/send.html"><code>cast send</code></a>
<ul>
<li><a href="reference/cli/./cast/send/--create.html"><code>cast send --create</code></a></li>
</ul>
</li>
<li><a href="reference/cli/./cast/shl.html"><code>cast shl</code></a></li>
<li><a href="reference/cli/./cast/shr.html"><code>cast shr</code></a></li>
<li><a href="reference/cli/./cast/sig.html"><code>cast sig</code></a></li>
<li><a href="reference/cli/./cast/sig-event.html"><code>cast sig-event</code></a></li>
<li><a href="reference/cli/./cast/storage.html"><code>cast storage</code></a></li>
<li><a href="reference/cli/./cast/to-ascii.html"><code>cast to-ascii</code></a></li>
<li><a href="reference/cli/./cast/to-base.html"><code>cast to-base</code></a></li>
<li><a href="reference/cli/./cast/to-bytes32.html"><code>cast to-bytes32</code></a></li>
<li><a href="reference/cli/./cast/to-check-sum-address.html"><code>cast to-check-sum-address</code></a></li>
<li><a href="reference/cli/./cast/to-dec.html"><code>cast to-dec</code></a></li>
<li><a href="reference/cli/./cast/to-fixed-point.html"><code>cast to-fixed-point</code></a></li>
<li><a href="reference/cli/./cast/to-hex.html"><code>cast to-hex</code></a></li>
<li><a href="reference/cli/./cast/to-hexdata.html"><code>cast to-hexdata</code></a></li>
<li><a href="reference/cli/./cast/to-int256.html"><code>cast to-int256</code></a></li>
<li><a href="reference/cli/./cast/to-rlp.html"><code>cast to-rlp</code></a></li>
<li><a href="reference/cli/./cast/to-uint256.html"><code>cast to-uint256</code></a></li>
<li><a href="reference/cli/./cast/to-unit.html"><code>cast to-unit</code></a></li>
<li><a href="reference/cli/./cast/to-utf8.html"><code>cast to-utf8</code></a></li>
<li><a href="reference/cli/./cast/to-wei.html"><code>cast to-wei</code></a></li>
<li><a href="reference/cli/./cast/tx.html"><code>cast tx</code></a></li>
<li><a href="reference/cli/./cast/upload-signature.html"><code>cast upload-signature</code></a></li>
<li><a href="reference/cli/./cast/wallet.html"><code>cast wallet</code></a>
<ul>
<li><a href="reference/cli/./cast/wallet/new.html"><code>cast wallet new</code></a></li>
<li><a href="reference/cli/./cast/wallet/new-mnemonic.html"><code>cast wallet new-mnemonic</code></a></li>
<li><a href="reference/cli/./cast/wallet/vanity.html"><code>cast wallet vanity</code></a></li>
<li><a href="reference/cli/./cast/wallet/address.html"><code>cast wallet address</code></a></li>
<li><a href="reference/cli/./cast/wallet/sign.html"><code>cast wallet sign</code></a></li>
<li><a href="reference/cli/./cast/wallet/verify.html"><code>cast wallet verify</code></a></li>
<li><a href="reference/cli/./cast/wallet/import.html"><code>cast wallet import</code></a></li>
<li><a href="reference/cli/./cast/wallet/list.html"><code>cast wallet list</code></a></li>
<li><a href="reference/cli/./cast/wallet/private-key.html"><code>cast wallet private-key</code></a></li>
<li><a href="reference/cli/./cast/wallet/decrypt-keystore.html"><code>cast wallet decrypt-keystore</code></a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="reference/cli/./anvil.html"><code>anvil</code></a></p>
<ul>
<li><a href="reference/cli/./anvil/completions.html"><code>anvil completions</code></a></li>
<li><a href="reference/cli/./anvil/generate-fig-spec.html"><code>anvil generate-fig-spec</code></a></li>
</ul>
</li>
<li>
<p><a href="reference/cli/./chisel.html"><code>chisel</code></a></p>
<ul>
<li><a href="reference/cli/./chisel/list.html"><code>chisel list</code></a></li>
<li><a href="reference/cli/./chisel/load.html"><code>chisel load</code></a></li>
<li><a href="reference/cli/./chisel/view.html"><code>chisel view</code></a></li>
<li><a href="reference/cli/./chisel/clear-cache.html"><code>chisel clear-cache</code></a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># forge

构建、测试、模糊测试、调试和部署 Solidity 合约

```bash
$ forge --help
Usage: forge &lt;COMMAND&gt;

Commands:
  bind               生成智能合约的 Rust 绑定
  build              构建项目的智能合约 [别名: b, compile]
  cache              管理 Foundry 缓存
  clean              删除构建产物和缓存目录 [别名: cl]
  clone              从 Etherscan 克隆合约
  completions        生成 shell 自动补全脚本 [别名: com]
  config             显示当前配置 [别名: co]
  coverage           生成覆盖率报告
  create             部署智能合约 [别名: c]
  debug              将单个智能合约作为脚本进行调试 [别名: d]
  doc                为项目生成文档
  flatten            将源文件及其所有导入合并到一个文件中 [别名: f]
  fmt                格式化 Solidity 源文件
  geiger             检测项目及其依赖中不安全作弊代码的使用
  generate           生成脚手架文件
  generate-fig-spec  生成 Fig 自动补全规范 [别名: fig]
  help               打印此消息或给定子命令的帮助信息
  init               创建一个新的 Forge 项目
  inspect            获取智能合约的专用信息 [别名: in]
  install            安装一个或多个依赖 [别名: i]
  remappings         获取项目自动推断的重映射 [别名: re]
  remove             删除一个或多个依赖 [别名: rm]
  script             将智能合约作为脚本运行，构建可以发送到链上的交易
  selectors          函数选择器工具 [别名: se]
  snapshot           创建每个测试的 gas 使用快照 [别名: s]
  soldeer            Soldeer 依赖管理器
  test               运行项目的测试 [别名: t]
  tree               显示项目依赖图的树形可视化 [别名: tr]
  update             更新一个或多个依赖 [别名: u]
  verify-bytecode    验证已部署的字节码与其源码 [别名: vb]
  verify-check       检查 Etherscan 上的验证状态 [别名: vc]
  verify-contract    在 Etherscan 上验证智能合约 [别名: v]

Options:
  -h, --help     打印帮助信息
  -V, --version  打印版本信息

在书中找到更多信息: http://book.getfoundry.sh/reference/forge/forge.html
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forge-bind"><a class="header" href="#forge-bind">forge bind</a></h1>
<p>生成智能合约的 Rust 绑定</p>
<pre><code class="language-bash">$ forge bind --help
Usage: forge bind [OPTIONS]

Options:
  -b, --bindings-path &lt;PATH&gt;
          存储合约工件的路径

      --select &lt;SELECT&gt;
          仅生成名称匹配指定过滤器的合约的绑定

      --select-all
          显式生成所有合约的绑定
          
          默认情况下，所有以 `Test` 或 `Script` 结尾的合约会被排除。

      --crate-name &lt;NAME&gt;
          生成的 Rust crate 的名称。
          
          这应该是一个有效的 crates.io crate 名称，然而，此命令目前不会验证这一点。
          
          [默认值: foundry-contracts]

      --crate-version &lt;VERSION&gt;
          生成的 Rust crate 的版本。
          
          这应该是一个标准的 semver 版本字符串，然而，此命令目前不会验证这一点。
          
          [默认值: 0.1.0]

      --module
          将绑定生成为模块而不是 crate

      --overwrite
          覆盖现有的生成绑定。
          
          默认情况下，命令会检查绑定是否正确，然后退出。如果传递了 --overwrite，则会删除并覆盖绑定。

      --single-file
          将绑定生成为单个文件

      --skip-cargo-toml
          跳过 Cargo.toml 一致性检查

      --skip-build
          在生成绑定之前跳过运行 forge build

      --skip-extra-derives
          不在生成的绑定中添加任何额外的 derives

      --alloy
          为 `alloy` 库生成绑定，而不是 `ethers`

      --alloy-version &lt;ALLOY_VERSION&gt;
          指定 alloy 版本

      --ethers
          为 `ethers` 库生成绑定，而不是 `alloy`（默认，已弃用）

  -h, --help
          打印帮助信息（使用 '-h' 查看摘要）

缓存选项:
      --force
          清除缓存和工件文件夹并重新编译

构建选项:
      --no-cache
          禁用缓存

      --skip &lt;SKIP&gt;...
          跳过构建名称包含给定过滤器的文件。
          
          `test` 和 `script` 是 `.t.sol` 和 `.s.sol` 的别名。

链接器选项:
      --libraries &lt;LIBRARIES&gt;
          设置预链接的库
          
          [环境变量: DAPP_LIBRARIES=]

编译器选项:
      --ignored-error-codes &lt;ERROR_CODES&gt;
          忽略 solc 警告的错误代码

      --deny-warnings
          警告将触发编译器错误

      --no-auto-detect
          不自动检测 `solc` 版本

      --use &lt;SOLC_VERSION&gt;
          指定用于构建的 solc 版本或本地 solc 的路径。
          
          有效值格式为 `x.y.z`、`solc:x.y.z` 或 `path/to/solc`。

      --offline
          不访问网络。
          
          缺失的 solc 版本不会被安装。

      --via-ir
          使用 Yul 中间表示编译管道

      --no-metadata
          不在字节码中附加任何元数据。
          
          这相当于将 `bytecode_hash` 设置为 `none` 并将 `cbor_metadata` 设置为 `false`。

      --silent
          启动时不打印任何内容

      --ast
          在编译器输出中包含 AST 作为 JSON

      --evm-version &lt;VERSION&gt;
          目标 EVM 版本

      --optimize
          激活 Solidity 优化器

      --optimizer-runs &lt;RUNS&gt;
          优化器运行次数

      --extra-output &lt;SELECTOR&gt;...
          在合约的工件中包含的额外输出。
          
          示例键: evm.assembly, ewasm, ir, irOptimized, metadata
          
          完整描述请参见
          &lt;https://docs.soliditylang.org/en/v0.8.13/using-the-compiler.html#input-description&gt;

      --extra-output-files &lt;SELECTOR&gt;...
          写入单独文件的额外输出。
          
          有效值: metadata, ir, irOptimized, ewasm, evm.assembly

项目选项:
  -o, --out &lt;PATH&gt;
          合约工件文件夹的路径

      --revert-strings &lt;REVERT&gt;
          回退字符串配置。
          
          可能的值为 "default"、"strip"（移除）、"debug"（Solidity 生成的回退字符串）和 "verboseDebug"

      --build-info
          生成构建信息文件

      --build-info-path &lt;PATH&gt;
          构建信息文件的输出路径目录

      --root &lt;PATH&gt;
          项目的根路径。
          
          默认情况下是 Git 仓库的根目录（如果在 Git 仓库中），或者当前工作目录。

  -C, --contracts &lt;PATH&gt;
          合约源目录

  -R, --remappings &lt;REMAPPINGS&gt;
          项目的重映射

      --remappings-env &lt;ENV&gt;
          从环境获取项目的重映射

      --cache-path &lt;PATH&gt;
          编译器缓存的路径

      --lib-paths &lt;PATH&gt;
          库文件夹的路径

      --hardhat
          使用 Hardhat 风格的项目布局。
          
          这相当于使用: `--contracts contracts --lib-paths node_modules`。
          
          [别名: hh]

      --config-path &lt;FILE&gt;
          配置文件的路径
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-json">{
  "translation": "# forge build\n\n构建项目的智能合约\n\n```bash\n$ forge build --help\nUsage: forge build [OPTIONS] [PATHS]...\n\nOptions:\n  -h, --help\n          打印帮助信息（使用 '-h' 查看摘要）\n\nBuild options:\n      --names\n          打印已编译合约的名称\n\n      --sizes\n          打印已编译合约的大小\n\n      --no-cache\n          禁用缓存\n\n      --skip &lt;SKIP&gt;...\n          跳过构建名称包含给定过滤器的文件。\n          \n          `test` 和 `script` 是 `.t.sol` 和 `.s.sol` 的别名。\n\n  [PATHS]...\n          从指定路径构建源文件\n\nCache options:\n      --force\n          清除缓存和 artifacts 文件夹并重新编译\n\nLinker options:\n      --libraries &lt;LIBRARIES&gt;\n          设置预链接的库\n          \n          [env: DAPP_LIBRARIES=]\n\nCompiler options:\n      --ignored-error-codes &lt;ERROR_CODES&gt;\n          忽略 solc 警告的错误代码\n\n      --deny-warnings\n          警告将触发编译器错误\n\n      --no-auto-detect\n          不自动检测 `solc` 版本\n\n      --use &lt;SOLC_VERSION&gt;\n          指定用于构建的 solc 版本或本地 solc 的路径。\n          \n          有效值格式为 `x.y.z`、`solc:x.y.z` 或 `path/to/solc`。\n\n      --offline\n          不访问网络。\n          \n          缺失的 solc 版本将不会被安装。\n\n      --via-ir\n          使用 Yul 中间表示编译管道\n\n      --no-metadata\n          不在字节码中附加任何元数据。\n          \n          这相当于将 `bytecode_hash` 设置为 `none` 并将 `cbor_metadata` 设置为 `false`。\n\n      --silent\n          启动时不打印任何内容\n\n      --ast\n          在编译器输出中包含 AST 为 JSON 格式\n\n      --evm-version &lt;VERSION&gt;\n          目标 EVM 版本\n\n      --optimize\n          激活 Solidity 优化器\n\n      --optimizer-runs &lt;RUNS&gt;\n          优化器运行次数\n\n      --extra-output &lt;SELECTOR&gt;...\n          在合约的 artifact 中包含额外的输出。\n          \n          示例键：evm.assembly、ewasm、ir、irOptimized、metadata\n          \n          完整描述请参见\n          &lt;https://docs.soliditylang.org/en/v0.8.13/using-the-compiler.html#input-description&gt;\n\n      --extra-output-files &lt;SELECTOR&gt;...\n          写入单独文件的额外输出。\n          \n          有效值：metadata、ir、irOptimized、ewasm、evm.assembly\n\nProject options:\n  -o, --out &lt;PATH&gt;\n          合约 artifacts 文件夹的路径\n\n      --revert-strings &lt;REVERT&gt;\n          回退字符串配置。\n          \n          可能的值为 \"default\"、\"strip\"（移除）、\"debug\"（Solidity 生成的回退字符串）和 \"verboseDebug\"\n\n      --build-info\n          生成构建信息文件\n\n      --build-info-path &lt;PATH&gt;\n          构建信息文件的输出路径目录\n\n      --root &lt;PATH&gt;\n          项目的根路径。\n          \n          默认情况下是 Git 仓库的根目录（如果在 Git 仓库中），否则为当前工作目录。\n\n  -C, --contracts &lt;PATH&gt;\n          合约源目录\n\n  -R, --remappings &lt;REMAPPINGS&gt;\n          项目的 remappings\n\n      --remappings-env &lt;ENV&gt;\n          从环境获取的项目的 remappings\n\n      --cache-path &lt;PATH&gt;\n          编译器缓存的路径\n\n      --lib-paths &lt;PATH&gt;\n          库文件夹的路径\n\n      --hardhat\n          使用 Hardhat 风格的项目布局。\n          \n          这相当于使用：`--contracts contracts --lib-paths node_modules`。\n          \n          [aliases: hh]\n\n      --config-path &lt;FILE&gt;\n          配置文件的路径\n\nWatch options:\n  -w, --watch [&lt;PATH&gt;...]\n          监视给定的文件或目录以进行更改。\n          \n          如果未提供路径，则监视项目的源文件和测试目录。\n\n      --no-restart\n          不重新启动命令，即使它仍在运行\n\n      --run-all\n          明确地在更改时重新运行所有测试。\n          \n          默认情况下，仅执行上次修改的测试文件的测试。\n\n      --watch-delay &lt;DELAY&gt;\n          文件更新防抖延迟。\n          \n          在延迟期间，传入的更改事件会被累积，只有在延迟过去后才会采取行动。注意，这并不意味着会启动命令：如果给出了 --no-restart 并且命令已经在运行，行动的结果将是什么都不做。\n          \n          默认值为 50ms。默认情况下解析为十进制秒，但使用带有 `ms` 后缀的整数可能更方便。\n          \n          在使用 --poll 模式时，您可能需要更大的持续时间，以避免磁盘 I/O 过载。\n\n      --format-json\n          以 json 格式输出编译错误。这在您想在其他工具中使用输出时很有用\n```"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># forge cache

管理 Foundry 缓存

```bash
$ forge cache --help
Usage: forge cache &lt;COMMAND&gt;

Commands:
  clean  清除全局 Foundry 目录中的缓存数据
  ls     显示全局 Foundry 目录中的缓存数据
  help   打印此消息或给定子命令的帮助信息

Options:
  -h, --help  打印帮助信息
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># forge cache clean

清除全局foundry目录中的缓存数据

```bash
$ forge cache clean --help
Usage: forge cache clean [OPTIONS] [CHAINS]...

Arguments:
  [CHAINS]...
          要清除缓存的链。
          
          也可以是 "all" 以清除所有链的缓存。
          
          [env: CHAIN=]
          [default: all]

Options:
  -b, --blocks &lt;BLOCKS&gt;...
          要清除缓存的区块

      --etherscan
          是否清除Etherscan缓存

  -h, --help
          打印帮助信息（使用 '-h' 查看摘要）
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># forge cache ls

显示从全局foundry目录缓存的数据

```bash
$ forge cache ls --help
Usage: forge cache ls [CHAINS]...

Arguments:
  [CHAINS]...
          要列出缓存的链。
          
          也可以是 "all" 以列出所有链。
          
          [env: CHAIN=]
          [default: all]

Options:
  -h, --help
          打印帮助信息（使用 '-h' 查看摘要）
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># forge clean

删除构建产物和缓存目录

```bash
$ forge clean --help
Usage: forge clean [OPTIONS]

Options:
      --root &lt;PATH&gt;
          项目的根路径。
          
          默认情况下，如果在一个Git仓库中，则为Git仓库的根路径，否则为当前工作目录。

  -h, --help
          打印帮助信息（使用'-h'查看简要摘要）
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># forge clone

从Etherscan克隆一个合约

```bash
$ forge clone --help
Usage: forge clone [OPTIONS] &lt;ADDRESS&gt; [PATH]

Arguments:
  &lt;ADDRESS&gt;
          要克隆的合约地址

  [PATH]
          克隆项目的根目录
          
          [默认值: .]

Options:
      --no-remappings-txt
          不生成remappings.txt文件。而是将remappings保留在配置中

      --keep-directory-structure
          保留从Etherscan收集的原始目录结构。
          
          如果设置了此标志，克隆项目的目录结构将保持不变。默认情况下，目录结构会重新组织以提高可读性，但可能会导致某些编译失败。

  -e, --etherscan-api-key &lt;KEY&gt;
          Etherscan（或等效）API密钥
          
          [环境变量: ETHERSCAN_API_KEY=]

  -c, --chain &lt;CHAIN&gt;
          链名称或EIP-155链ID
          
          [环境变量: CHAIN=]

      --shallow
          执行浅克隆而不是深克隆。
          
          提高性能并减少磁盘使用，但阻止切换分支或标签。

      --no-git
          安装时不将依赖项作为子模块添加

      --no-commit
          不创建提交

  -q, --quiet
          不打印任何消息

  -h, --help
          打印帮助信息（使用'-h'查看摘要）
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># forge completions

生成 shell 自动补全脚本

```bash
$ forge completions --help
Usage: forge completions &lt;SHELL&gt;

Arguments:
  &lt;SHELL&gt;  [possible values: bash, elvish, fish, powershell, zsh]

Options:
  -h, --help  Print help
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-json">{
  "translation": "# forge config\n\n显示当前配置\n\n```bash\n$ forge config --help\nUsage: forge config [OPTIONS] [PATHS]...\n\nOptions:\n      --basic\n          仅打印当前设置的基本配置值\n\n      --json\n          以JSON格式打印当前设置的配置值\n\n      --fix\n          尝试修复任何配置警告\n\n  -h, --help\n          打印帮助信息（使用'-h'查看摘要）\n\nBuild options:\n      --names\n          打印编译的合约名称\n\n      --sizes\n          打印编译的合约大小\n\n      --no-cache\n          禁用缓存\n\n      --skip &lt;SKIP&gt;...\n          跳过构建名称包含给定过滤器的文件。\n          \n          `test` 和 `script` 是 `.t.sol` 和 `.s.sol` 的别名。\n\n  [PATHS]...\n          从指定路径构建源文件\n\nCache options:\n      --force\n          清除缓存和artifacts文件夹并重新编译\n\nLinker options:\n      --libraries &lt;LIBRARIES&gt;\n          设置预链接的库\n          \n          [env: DAPP_LIBRARIES=]\n\nCompiler options:\n      --ignored-error-codes &lt;ERROR_CODES&gt;\n          忽略指定错误代码的solc警告\n\n      --deny-warnings\n          警告将触发编译器错误\n\n      --no-auto-detect\n          不自动检测`solc`版本\n\n      --use &lt;SOLC_VERSION&gt;\n          指定用于构建的solc版本或本地solc路径。\n          \n          有效值格式为 `x.y.z`、`solc:x.y.z` 或 `path/to/solc`。\n\n      --offline\n          不访问网络。\n          \n          缺失的solc版本将不会被安装。\n\n      --via-ir\n          使用Yul中间表示编译管道\n\n      --no-metadata\n          不在字节码中附加任何元数据。\n          \n          这相当于将 `bytecode_hash` 设置为 `none` 并将 `cbor_metadata` 设置为 `false`。\n\n      --silent\n          启动时不打印任何内容\n\n      --ast\n          在编译器输出中包含AST为JSON格式\n\n      --evm-version &lt;VERSION&gt;\n          目标EVM版本\n\n      --optimize\n          激活Solidity优化器\n\n      --optimizer-runs &lt;RUNS&gt;\n          优化器运行次数\n\n      --extra-output &lt;SELECTOR&gt;...\n          在合约的artifact中包含额外的输出。\n          \n          示例键：evm.assembly、ewasm、ir、irOptimized、metadata\n          \n          完整描述请参见\n          &lt;https://docs.soliditylang.org/en/v0.8.13/using-the-compiler.html#input-description&gt;\n\n      --extra-output-files &lt;SELECTOR&gt;...\n          将额外输出写入单独的文件。\n          \n          有效值：metadata、ir、irOptimized、ewasm、evm.assembly\n\nProject options:\n  -o, --out &lt;PATH&gt;\n          合约artifacts文件夹的路径\n\n      --revert-strings &lt;REVERT&gt;\n          回退字符串配置。\n          \n          可能的值为 \"default\"、\"strip\"（移除）、\"debug\"（Solidity生成的回退字符串）和 \"verboseDebug\"\n\n      --build-info\n          生成构建信息文件\n\n      --build-info-path &lt;PATH&gt;\n          构建信息文件的输出路径\n\n      --root &lt;PATH&gt;\n          项目的根路径。\n          \n          默认情况下为Git仓库的根路径（如果在Git仓库中）或当前工作目录。\n\n  -C, --contracts &lt;PATH&gt;\n          合约源目录\n\n  -R, --remappings &lt;REMAPPINGS&gt;\n          项目的remappings\n\n      --remappings-env &lt;ENV&gt;\n          从环境设置项目的remappings\n\n      --cache-path &lt;PATH&gt;\n          编译器缓存的路径\n\n      --lib-paths &lt;PATH&gt;\n          库文件夹的路径\n\n      --hardhat\n          使用Hardhat风格的工程布局。\n          \n          这相当于使用：`--contracts contracts --lib-paths node_modules`。\n          \n          [aliases: hh]\n\n      --config-path &lt;FILE&gt;\n          配置文件的路径\n\nWatch options:\n  -w, --watch [&lt;PATH&gt;...]\n          监视给定的文件或目录以进行更改。\n          \n          如果未提供路径，则监视项目的源文件和测试目录。\n\n      --no-restart\n          命令仍在运行时不重启命令\n\n      --run-all\n          明确地在更改时重新运行所有测试。\n          \n          默认情况下，仅执行最后修改的测试文件的测试。\n\n      --watch-delay &lt;DELAY&gt;\n          文件更新防抖延迟。\n          \n          在延迟期间，传入的更改事件会被累积，只有在延迟结束后才会采取行动。注意，这并不意味着会启动命令：如果给出了 `--no-restart` 并且命令已经在运行，行动的结果将是什么都不做。\n          \n          默认值为50ms。默认情况下解析为十进制秒，但使用带有 `ms` 后缀的整数可能更方便。\n          \n          在使用 `--poll` 模式时，您可能需要更大的持续时间，以避免磁盘I/O过载。\n\n      --format-json\n          以json格式输出编译错误。这在您想在其他工具中使用输出时很有用\n\nEVM options:\n  -f, --fork-url &lt;URL&gt;\n          通过远程端点获取状态，而不是从空状态开始。\n          \n          如果您想从特定区块号获取状态，请参见 --fork-block-number。\n          \n          [aliases: rpc-url]\n\n      --fork-block-number &lt;BLOCK&gt;\n          通过远程端点从特定区块号获取状态。\n          \n          请参见 --fork-url。\n\n      --fork-retries &lt;RETRIES&gt;\n          重试次数。\n          \n          请参见 --fork-url。\n\n      --fork-retry-backoff &lt;BACKOFF&gt;\n          遇到错误时的初始重试退避。\n          \n          请参见 --fork-url。\n\n      --no-storage-caching\n          明确禁用RPC缓存。\n          \n          所有存储槽完全从端点读取。\n          \n          此标志覆盖项目的配置文件。\n          \n          请参见 --fork-url。\n\n      --initial-balance &lt;BALANCE&gt;\n          部署的测试合约的初始余额\n\n      --sender &lt;ADDRESS&gt;\n          执行测试的地址\n\n      --ffi\n          启用FFI cheatcode\n\n      --always-use-create-2-factory\n          在所有情况下包括测试和非广播脚本中使用create 2工厂\n\n  -v, --verbosity...\n          EVM的详细程度。\n          \n          多次传递以增加详细程度（例如 -v、-vv、-vvv）。\n          \n          详细程度级别：\n          - 2：打印所有测试的日志\n          - 3：打印失败测试的执行 traces\n          - 4：打印所有测试的执行 traces，以及失败测试的设置 traces\n          - 5：打印所有测试的执行和设置 traces\n\nFork config:\n      --compute-units-per-second &lt;CUPS&gt;\n          设置此提供商假设的每秒可用计算单元数\n          \n          默认值：330\n          \n          请参见 --fork-url 和\n          &lt;https://docs.alchemy.com/reference/compute-units#what-are-cups-compute-units-per-second&gt;\n\n      --no-rpc-rate-limit\n          禁用此节点提供商的速率限制。\n          \n          请参见 --fork-url 和\n          &lt;https://docs.alchemy.com/reference/compute-units#what-are-cups-compute-units-per-second&gt;\n          \n          [aliases: no-rate-limit]\n\nExecutor environment config:\n      --gas-limit &lt;GAS_LIMIT&gt;\n          区块 gas 限制\n\n      --code-size-limit &lt;CODE_SIZE&gt;\n          EIP-170：合约代码大小限制（字节）。增加此值有助于测试。默认值为 0x6000（~25kb）\n\n      --chain &lt;CHAIN&gt;\n          链名称或EIP-155链ID\n          \n          [aliases: chain-id]\n\n      --gas-price &lt;GAS_PRICE&gt;\n          gas 价格\n\n      --block-base-fee-per-gas &lt;FEE&gt;\n          区块基础费用\n          \n          [aliases: base-fee]\n\n      --tx-origin &lt;ADDRESS&gt;\n          交易发起者\n\n      --block-coinbase &lt;ADDRESS&gt;\n          区块的coinbase\n\n      --block-timestamp &lt;TIMESTAMP&gt;\n          区块的时间戳\n\n      --block-number &lt;BLOCK&gt;\n          区块号\n\n      --block-difficulty &lt;DIFFICULTY&gt;\n          区块难度\n\n      --block-prevrandao &lt;PREVRANDAO&gt;\n          区块的prevrandao值。注意：合并前此字段为mix_hash\n\n      --block-gas-limit &lt;GAS_LIMIT&gt;\n          区块 gas 限制\n\n      --memory-limit &lt;MEMORY_LIMIT&gt;\n          EVM执行的内存限制（字节）。如果超过此限制，将抛出 `MemoryLimitOOG` 结果。\n          \n          默认值为128MiB。\n\n      --disable-block-gas-limit\n          是否禁用区块 gas 限制检查\n          \n          [aliases: no-gas-limit]\n\n      --isolate\n          是否启用调用的隔离。在隔离模式下，所有顶级调用都作为单独的交易在单独的EVM上下文中执行，从而实现更精确的gas计算和交易状态更改\n```"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forge-coverage"><a class="header" href="#forge-coverage">forge coverage</a></h1>
<p>生成覆盖率报告</p>
<pre><code class="language-bash">$ forge coverage --help
Usage: forge coverage [OPTIONS]

Options:
      --report &lt;REPORT&gt;
          用于覆盖率的报告类型。
          
          此标志可以多次使用。
          
          [默认值: summary]
          [可能的值: summary, lcov, debug, bytecode]

      --ir-minimum
          启用 viaIR 并使用最小优化
          
          这可以修复大多数“堆栈太深”错误，同时产生相对准确的源映射。

  -r, --report-file &lt;PATH&gt;
          输出报告的路径。
          
          如果未指定，报告将存储在项目的根目录中。

      --include-libs
          是否在覆盖率报告中包含库

  -h, --help
          打印帮助信息（使用 '-h' 查看摘要）

Test options:
      --debug &lt;TEST_FUNCTION&gt;
          在调试器中运行测试。
          
          传递给此标志的参数是要运行的测试函数的名称，其工作方式与 --match-test 相同。
          
          如果多个测试符合指定的条件，必须添加额外的过滤器，直到找到一个测试（参见 --match-contract 和 --match-path）。
          
          匹配的测试将在调试器中打开，无论测试结果如何。
          
          如果匹配的测试是模糊测试，则会在第一个失败案例中打开调试器。如果模糊测试没有失败，则会在最后一个模糊案例中打开调试器。
          
          有关更精细的控制，请参见 forge run。

      --gas-report
          打印 gas 报告
          
          [环境变量: FORGE_GAS_REPORT=]

      --allow-failure
          即使测试失败也退出代码 0
          
          [环境变量: FORGE_ALLOW_FAILURE=]

      --fail-fast
          在第一次失败后停止运行测试

      --etherscan-api-key &lt;KEY&gt;
          Etherscan（或等效）API 密钥
          
          [环境变量: ETHERSCAN_API_KEY=]

      --fuzz-seed &lt;FUZZ_SEED&gt;
          设置用于生成模糊测试随机性的种子

      --fuzz-runs &lt;RUNS&gt;
          [环境变量: FOUNDRY_FUZZ_RUNS=]

      --fuzz-input-file &lt;FUZZ_INPUT_FILE&gt;
          从文件中重新运行模糊测试失败案例

      --max-threads &lt;MAX_THREADS&gt;
          使用的最大并发线程数。默认值是可用 CPU 的数量

Display options:
  -j, --json
          以 JSON 格式输出测试结果

  -l, --list
          列出测试而不是运行它们

      --summary
          打印测试摘要表

      --detailed
          打印详细的测试摘要表

Test filtering:
      --match-test &lt;REGEX&gt;
          仅运行匹配指定正则表达式的测试函数
          
          [别名: mt]

      --no-match-test &lt;REGEX&gt;
          仅运行不匹配指定正则表达式的测试函数
          
          [别名: nmt]

      --match-contract &lt;REGEX&gt;
          仅运行匹配指定正则表达式的合约中的测试
          
          [别名: mc]

      --no-match-contract &lt;REGEX&gt;
          仅运行不匹配指定正则表达式的合约中的测试
          
          [别名: nmc]

      --match-path &lt;GLOB&gt;
          仅运行匹配指定全局模式源文件中的测试
          
          [别名: mp]

      --no-match-path &lt;GLOB&gt;
          仅运行不匹配指定全局模式源文件中的测试
          
          [别名: nmp]

EVM options:
  -f, --fork-url &lt;URL&gt;
          通过远程端点获取状态，而不是从空状态开始。
          
          如果要从特定区块号获取状态，请参见 --fork-block-number。
          
          [别名: rpc-url]

      --fork-block-number &lt;BLOCK&gt;
          通过远程端点从特定区块号获取状态。
          
          参见 --fork-url。

      --fork-retries &lt;RETRIES&gt;
          重试次数。
          
          参见 --fork-url。

      --fork-retry-backoff &lt;BACKOFF&gt;
          遇到错误时的初始重试退避。
          
          参见 --fork-url。

      --no-storage-caching
          显式禁用 RPC 缓存。
          
          所有存储槽完全从端点读取。
          
          此标志覆盖项目的配置文件。
          
          参见 --fork-url。

      --initial-balance &lt;BALANCE&gt;
          部署测试合约的初始余额

      --sender &lt;ADDRESS&gt;
          执行测试的地址

      --ffi
          启用 FFI 作弊码

      --always-use-create-2-factory
          在所有情况下使用 create 2 工厂，包括测试和非广播脚本

  -v, --verbosity...
          EVM 的详细程度。
          
          多次传递以增加详细程度（例如 -v, -vv, -vvv）。
          
          详细程度级别：
          - 2: 打印所有测试的日志
          - 3: 打印失败测试的执行 traces
          - 4: 打印所有测试的执行 traces 和失败测试的设置 traces
          - 5: 打印所有测试的执行和设置 traces

Fork config:
      --compute-units-per-second &lt;CUPS&gt;
          设置此提供者假设的每秒可用计算单元数
          
          默认值: 330
          
          参见 --fork-url 和
          &lt;https://docs.alchemy.com/reference/compute-units#what-are-cups-compute-units-per-second&gt;

      --no-rpc-rate-limit
          禁用此节点提供者的速率限制。
          
          参见 --fork-url 和
          &lt;https://docs.alchemy.com/reference/compute-units#what-are-cups-compute-units-per-second&gt;
          
          [别名: no-rate-limit]

Executor environment config:
      --gas-limit &lt;GAS_LIMIT&gt;
          区块 gas 限制

      --code-size-limit &lt;CODE_SIZE&gt;
          EIP-170: 合约代码大小限制（字节）。增加此值有助于测试。默认值为 0x6000（~25kb）

      --chain &lt;CHAIN&gt;
          链名称或 EIP-155 链 ID
          
          [别名: chain-id]

      --gas-price &lt;GAS_PRICE&gt;
          gas 价格

      --block-base-fee-per-gas &lt;FEE&gt;
          区块的基础费用
          
          [别名: base-fee]

      --tx-origin &lt;ADDRESS&gt;
          交易发起者

      --block-coinbase &lt;ADDRESS&gt;
          区块的 coinbase

      --block-timestamp &lt;TIMESTAMP&gt;
          区块的时间戳

      --block-number &lt;BLOCK&gt;
          区块号

      --block-difficulty &lt;DIFFICULTY&gt;
          区块难度

      --block-prevrandao &lt;PREVRANDAO&gt;
          区块的 prevrandao 值。注意：合并前此字段为 mix_hash

      --block-gas-limit &lt;GAS_LIMIT&gt;
          区块 gas 限制

      --memory-limit &lt;MEMORY_LIMIT&gt;
          EVM 执行的内存限制（字节）。如果超过此限制，将抛出 `MemoryLimitOOG` 结果。
          
          默认值为 128MiB。

      --disable-block-gas-limit
          是否禁用区块 gas 限制检查
          
          [别名: no-gas-limit]

      --isolate
          是否启用调用的隔离。在隔离模式下，所有顶级调用作为单独的交易在单独的 EVM 上下文中执行，实现更精确的 gas 计算和交易状态变化

Cache options:
      --force
          清除缓存和 artifacts 文件夹并重新编译

Build options:
      --no-cache
          禁用缓存

      --skip &lt;SKIP&gt;...
          跳过构建名称包含给定过滤器的文件。
          
          `test` 和 `script` 是 `.t.sol` 和 `.s.sol` 的别名。

Linker options:
      --libraries &lt;LIBRARIES&gt;
          设置预链接的库
          
          [环境变量: DAPP_LIBRARIES=]

Compiler options:
      --ignored-error-codes &lt;ERROR_CODES&gt;
          忽略 solc 警告的错误代码

      --deny-warnings
          警告将触发编译器错误

      --no-auto-detect
          不自动检测 `solc` 版本

      --use &lt;SOLC_VERSION&gt;
          指定用于构建的 solc 版本或本地 solc 路径。
          
          有效值格式为 `x.y.z`、`solc:x.y.z` 或 `path/to/solc`。

      --offline
          不访问网络。
          
          缺失的 solc 版本不会被安装。

      --via-ir
          使用 Yul 中间表示编译管道

      --no-metadata
          不在字节码中附加任何元数据。
          
          这相当于将 `bytecode_hash` 设置为 `none` 并将 `cbor_metadata` 设置为 `false`。

      --silent
          启动时不打印任何内容

      --ast
          在编译器输出中包含 AST 作为 JSON

      --evm-version &lt;VERSION&gt;
          目标 EVM 版本

      --optimize
          激活 Solidity 优化器

      --optimizer-runs &lt;RUNS&gt;
          优化器运行次数

      --extra-output &lt;SELECTOR&gt;...
          在合约的 artifact 中包含额外的输出。
          
          示例键: evm.assembly, ewasm, ir, irOptimized, metadata
          
          完整描述请参见
          &lt;https://docs.soliditylang.org/en/v0.8.13/using-the-compiler.html#input-description&gt;

      --extra-output-files &lt;SELECTOR&gt;...
          写入单独文件的额外输出。
          
          有效值: metadata, ir, irOptimized, ewasm, evm.assembly

Project options:
  -o, --out &lt;PATH&gt;
          合约 artifacts 文件夹的路径

      --revert-strings &lt;REVERT&gt;
          回退字符串配置。
          
          可能的值为 "default"、"strip"（移除）、"debug"（Solidity 生成的回退字符串）和 "verboseDebug"

      --build-info
          生成构建信息文件

      --build-info-path &lt;PATH&gt;
          构建信息文件的输出路径

      --root &lt;PATH&gt;
          项目的根路径。
          
          默认情况下是 Git 仓库的根目录（如果在 Git 仓库中），或者当前工作目录。

  -C, --contracts &lt;PATH&gt;
          合约源目录

  -R, --remappings &lt;REMAPPINGS&gt;
          项目的 remappings

      --remappings-env &lt;ENV&gt;
          从环境变量中获取项目的 remappings

      --cache-path &lt;PATH&gt;
          编译器缓存的路径

      --lib-paths &lt;PATH&gt;
          库文件夹的路径

      --hardhat
          使用 Hardhat 风格的
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># forge create

部署智能合约

```bash
$ forge create --help
Usage: forge create [OPTIONS] &lt;CONTRACT&gt;

Arguments:
  &lt;CONTRACT&gt;
          合约标识符，格式为 `&lt;路径&gt;:&lt;合约名称&gt;`

Options:
      --constructor-args &lt;ARGS&gt;...
          构造函数参数

      --constructor-args-path &lt;PATH&gt;
          包含构造函数参数的文件路径

      --verify
          创建后验证合约

      --unlocked
          通过 `eth_sendTransaction` 使用 `--from` 参数或 `$ETH_FROM` 作为发送者

      --show-standard-json-input
          如果提供了 `--verify`，则打印标准 json 编译器输入。
          
          标准 json 编译器输入可以用于在浏览器中手动提交合约验证。

  -h, --help
          打印帮助信息（使用 '-h' 查看摘要）

Display options:
      --json
          以 JSON 格式打印部署信息

Cache options:
      --force
          清除缓存和 artifacts 文件夹并重新编译

Build options:
      --no-cache
          禁用缓存

      --skip &lt;SKIP&gt;...
          跳过构建文件名包含给定过滤器的文件。
          
          `test` 和 `script` 是 `.t.sol` 和 `.s.sol` 的别名。

Linker options:
      --libraries &lt;LIBRARIES&gt;
          设置预链接的库
          
          [env: DAPP_LIBRARIES=]

Compiler options:
      --ignored-error-codes &lt;ERROR_CODES&gt;
          忽略 solc 警告的错误代码

      --deny-warnings
          警告将触发编译器错误

      --no-auto-detect
          不自动检测 `solc` 版本

      --use &lt;SOLC_VERSION&gt;
          指定用于构建的 solc 版本或本地 solc 的路径。
          
          有效值格式为 `x.y.z`、`solc:x.y.z` 或 `path/to/solc`。

      --offline
          不访问网络。
          
          缺失的 solc 版本将不会被安装。

      --via-ir
          使用 Yul 中间表示编译管道

      --no-metadata
          不在字节码中附加任何元数据。
          
          这相当于将 `bytecode_hash` 设置为 `none` 并将 `cbor_metadata` 设置为 `false`。

      --silent
          启动时不打印任何内容

      --ast
          在编译器输出中包含 AST 作为 JSON

      --evm-version &lt;VERSION&gt;
          目标 EVM 版本

      --optimize
          激活 Solidity 优化器

      --optimizer-runs &lt;RUNS&gt;
          优化器运行次数

      --extra-output &lt;SELECTOR&gt;...
          在合约的 artifact 中包含的额外输出。
          
          示例键：evm.assembly、ewasm、ir、irOptimized、metadata
          
          完整描述请参见
          &lt;https://docs.soliditylang.org/en/v0.8.13/using-the-compiler.html#input-description&gt;

      --extra-output-files &lt;SELECTOR&gt;...
          写入单独文件的额外输出。
          
          有效值：metadata、ir、irOptimized、ewasm、evm.assembly

Project options:
  -o, --out &lt;PATH&gt;
          合约 artifacts 文件夹的路径

      --revert-strings &lt;REVERT&gt;
          回退字符串配置。
          
          可能的值为 "default"、"strip"（移除）、"debug"（Solidity 生成的回退字符串）和 "verboseDebug"

      --build-info
          生成构建信息文件

      --build-info-path &lt;PATH&gt;
          构建信息文件将写入的目录输出路径

      --root &lt;PATH&gt;
          项目的根路径。
          
          默认情况下是 Git 仓库的根路径（如果在 Git 仓库中），或者当前工作目录。

  -C, --contracts &lt;PATH&gt;
          合约源目录

  -R, --remappings &lt;REMAPPINGS&gt;
          项目的 remappings

      --remappings-env &lt;ENV&gt;
          从环境获取的项目的 remappings

      --cache-path &lt;PATH&gt;
          编译器缓存的路径

      --lib-paths &lt;PATH&gt;
          库文件夹的路径

      --hardhat
          使用 Hardhat 风格的
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># forge debug

调试单个智能合约作为脚本

```bash
$ forge debug --help
Usage: forge debug [OPTIONS] &lt;PATH&gt; [ARGS]...

Arguments:
  &lt;PATH&gt;
          你要运行的合约。可以是文件路径或合约名称。
          
          如果同一个文件中存在多个合约，你必须使用 --target-contract 指定目标合约。

  [ARGS]...
          传递给脚本函数的参数

Options:
      --target-contract &lt;CONTRACT_NAME&gt;
          你要运行的合约名称
          
          [aliases: tc]

  -s, --sig &lt;SIGNATURE&gt;
          你要调用的合约函数签名，或原始调用数据
          
          [default: run()]

      --debug
          在调试器中打开脚本

  -h, --help
          打印帮助信息（使用 '-h' 查看摘要）

缓存选项：
      --force
          清除缓存和 artifacts 文件夹并重新编译

      --no-cache
          禁用缓存

      --skip &lt;SKIP&gt;...
          跳过构建名称包含给定过滤器的文件。
          
          `test` 和 `script` 是 `.t.sol` 和 `.s.sol` 的别名。

链接器选项：
      --libraries &lt;LIBRARIES&gt;
          设置预链接的库
          
          [env: DAPP_LIBRARIES=]

编译器选项：
      --ignored-error-codes &lt;ERROR_CODES&gt;
          忽略 solc 警告的错误代码

      --deny-warnings
          警告将触发编译器错误

      --no-auto-detect
          不要自动检测 `solc` 版本

      --use &lt;SOLC_VERSION&gt;
          指定用于构建的 solc 版本，或本地 solc 的路径。
          
          有效值格式为 `x.y.z`、`solc:x.y.z` 或 `path/to/solc`。

      --offline
          不要访问网络。
          
          缺失的 solc 版本将不会被安装。

      --via-ir
          使用 Yul 中间表示编译管道

      --no-metadata
          不要在字节码中附加任何元数据。
          
          这相当于将 `bytecode_hash` 设置为 `none` 并将 `cbor_metadata` 设置为 `false`。

      --silent
          启动时不要打印任何内容

      --ast
          在编译器输出中包含 AST 作为 JSON

      --evm-version &lt;VERSION&gt;
          目标 EVM 版本

      --optimize
          激活 Solidity 优化器

      --optimizer-runs &lt;RUNS&gt;
          优化器运行次数

      --extra-output &lt;SELECTOR&gt;...
          在合约的 artifact 中包含的额外输出。
          
          示例键：evm.assembly, ewasm, ir, irOptimized, metadata
          
          完整描述请参见
          &lt;https://docs.soliditylang.org/en/v0.8.13/using-the-compiler.html#input-description&gt;

      --extra-output-files &lt;SELECTOR&gt;...
          写入单独文件的额外输出。
          
          有效值：metadata, ir, irOptimized, ewasm, evm.assembly

项目选项：
  -o, --out &lt;PATH&gt;
          合约 artifacts 文件夹的路径

      --revert-strings &lt;REVERT&gt;
          回退字符串配置。
          
          可能的值为 "default"、"strip"（移除）、"debug"（Solidity 生成的回退字符串）和 "verboseDebug"

      --build-info
          生成构建信息文件

      --build-info-path &lt;PATH&gt;
          构建信息文件的输出路径目录

      --root &lt;PATH&gt;
          项目的根路径。
          
          默认情况下是 Git 仓库的根目录（如果在 Git 仓库中），或当前工作目录。

  -C, --contracts &lt;PATH&gt;
          合约源目录

  -R, --remappings &lt;REMAPPINGS&gt;
          项目的 remappings

      --remappings-env &lt;ENV&gt;
          从环境获取的项目的 remappings

      --cache-path &lt;PATH&gt;
          编译器缓存的路径

      --lib-paths &lt;PATH&gt;
          库文件夹的路径

      --hardhat
          使用 Hardhat 风格的项目布局。
          
          这相当于使用：`--contracts contracts --lib-paths node_modules`。
          
          [aliases: hh]

      --config-path &lt;FILE&gt;
          配置文件的路径

EVM 选项：
  -f, --fork-url &lt;URL&gt;
          从远程端点获取状态，而不是从空状态开始。
          
          如果你想从特定区块号获取状态，请参见 --fork-block-number。
          
          [aliases: rpc-url]

      --fork-block-number &lt;BLOCK&gt;
          从远程端点获取特定区块号的状态。
          
          请参见 --fork-url。

      --fork-retries &lt;RETRIES&gt;
          重试次数。
          
          请参见 --fork-url。

      --fork-retry-backoff &lt;BACKOFF&gt;
          遇到错误时的初始重试退避。
          
          请参见 --fork-url。

      --no-storage-caching
          显式禁用 RPC 缓存。
          
          所有存储槽完全从端点读取。
          
          此标志覆盖项目的配置文件。
          
          请参见 --fork-url。

      --initial-balance &lt;BALANCE&gt;
          部署的测试合约的初始余额

      --sender &lt;ADDRESS&gt;
          将执行测试的地址

      --ffi
          启用 FFI 作弊码

      --always-use-create-2-factory
          在所有情况下（包括测试和非广播脚本）使用 create 2 工厂

  -v, --verbosity...
          EVM 的详细程度。
          
          多次传递以增加详细程度（例如 -v、-vv、-vvv）。
          
          详细程度级别：
          - 2：打印所有测试的日志
          - 3：打印失败测试的执行 traces
          - 4：打印所有测试的执行 traces，以及失败测试的设置 traces
          - 5：打印所有测试的执行和设置 traces

Fork 配置：
      --compute-units-per-second &lt;CUPS&gt;
          设置此提供者假设可用的计算单元每秒数量
          
          默认值：330
          
          请参见 --fork-url 和
          &lt;https://docs.alchemy.com/reference/compute-units#what-are-cups-compute-units-per-second&gt;

      --no-rpc-rate-limit
          禁用此节点提供者的速率限制。
          
          请参见 --fork-url 和
          &lt;https://docs.alchemy.com/reference/compute-units#what-are-cups-compute-units-per-second&gt;
          
          [aliases: no-rate-limit]

执行环境配置：
      --gas-limit &lt;GAS_LIMIT&gt;
          区块 gas 限制

      --code-size-limit &lt;CODE_SIZE&gt;
          EIP-170：合约代码大小限制（字节）。增加此值有助于测试。默认值为 0x6000（~25kb）

      --chain &lt;CHAIN&gt;
          链名称或 EIP-155 链 ID
          
          [aliases: chain-id]

      --gas-price &lt;GAS_PRICE&gt;
          gas 价格

      --block-base-fee-per-gas &lt;FEE&gt;
          区块的基础费用
          
          [aliases: base-fee]

      --tx-origin &lt;ADDRESS&gt;
          交易发起者

      --block-coinbase &lt;ADDRESS&gt;
          区块的 coinbase

      --block-timestamp &lt;TIMESTAMP&gt;
          区块的时间戳

      --block-number &lt;BLOCK&gt;
          区块号

      --block-difficulty &lt;DIFFICULTY&gt;
          区块难度

      --block-prevrandao &lt;PREVRANDAO&gt;
          区块的 prevrandao 值。注意：合并前此字段为 mix_hash

      --block-gas-limit &lt;GAS_LIMIT&gt;
          区块 gas 限制

      --memory-limit &lt;MEMORY_LIMIT&gt;
          EVM 执行的内存限制（字节）。如果超过此限制，将抛出 `MemoryLimitOOG` 结果。
          
          默认值为 128MiB。

      --disable-block-gas-limit
          是否禁用区块 gas 限制检查
          
          [aliases: no-gas-limit]

      --isolate
          是否启用调用的隔离。在隔离模式下，所有顶级调用都作为单独的交易在单独的 EVM 上下文中执行，实现更精确的 gas 计算和交易状态变化
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># forge doc

生成项目的文档

```bash
$ forge doc --help
Usage: forge doc [OPTIONS]

Options:
      --root &lt;PATH&gt;
          项目的根路径。
          
          默认情况下，如果是 Git 仓库，则为仓库的根目录，否则为当前工作目录。

  -o, --out &lt;PATH&gt;
          文档的输出路径。
          
          默认情况下，它是项目根目录下的 `docs/` 目录。

  -b, --build
          从生成的文件构建 `mdbook`

  -s, --serve
          提供文档服务

      --open
          在浏览器中打开文档服务后

      --hostname &lt;HOSTNAME&gt;
          提供文档服务的主机名

  -p, --port &lt;PORT&gt;
          提供文档服务的端口

      --deployments [&lt;DEPLOYMENTS&gt;]
          到 `hardhat-deploy` 或 `forge-deploy` 工件目录的相对路径。留空为默认值

  -i, --include-libraries
          是否为外部库创建文档

  -h, --help
          打印帮助信息（使用 '-h' 查看摘要）
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># forge flatten

将源文件及其所有导入合并到一个文件中

```bash
$ forge flatten --help
Usage: forge flatten [OPTIONS] &lt;PATH&gt;

Arguments:
  &lt;PATH&gt;
          要合并的合约路径

Options:
  -o, --output &lt;PATH&gt;
          输出合并后合约的路径。
          
          如果未指定，合并后的合约将输出到标准输出。

  -h, --help
          打印帮助信息（使用 '-h' 查看摘要）

项目选项:
      --root &lt;PATH&gt;
          项目的根路径。
          
          默认情况下，如果在一个 Git 仓库中，则为 Git 仓库的根目录，否则为当前工作目录。

  -C, --contracts &lt;PATH&gt;
          合约源代码目录

  -R, --remappings &lt;REMAPPINGS&gt;
          项目的重映射

      --remappings-env &lt;ENV&gt;
          从环境获取的项目重映射

      --cache-path &lt;PATH&gt;
          编译器缓存路径

      --lib-paths &lt;PATH&gt;
          库文件夹路径

      --hardhat
          使用 Hardhat 风格的项目布局。
          
          这等同于使用：`--contracts contracts --lib-paths node_modules`。
          
          [aliases: hh]

      --config-path &lt;FILE&gt;
          配置文件路径
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># forge fmt

格式化 Solidity 源文件

```bash
$ forge fmt --help
Usage: forge fmt [OPTIONS] [PATH]...

Arguments:
  [PATH]...
          文件路径、目录或 '-' 从标准输入读取

Options:
      --root &lt;PATH&gt;
          项目的根路径。
          
          默认情况下是 Git 仓库的根路径（如果在 Git 仓库中），否则是当前工作目录。

      --check
          以 'check' 模式运行。
          
          如果输入格式正确则退出代码为 0。如果需要格式化则退出代码为 1。

  -r, --raw
          在 'check' 和标准输入模式下，输出原始格式化代码而不是差异

  -h, --help
          打印帮助信息（使用 '-h' 查看摘要）
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forge-geiger"><a class="header" href="#forge-geiger">forge geiger</a></h1>
<p>检测项目及其依赖项中使用的不安全作弊代码</p>
<pre><code class="language-bash">$ forge geiger --help
Usage: forge geiger [OPTIONS] [PATH]...

Arguments:
  [PATH]...
          要检测的文件或目录路径

Options:
      --root &lt;PATH&gt;
          项目的根路径。
          
          默认情况下是 Git 仓库的根路径（如果在 Git 仓库中），或者当前工作目录。

      --check
          以“检查”模式运行。
          
          程序的退出代码将是找到的不安全作弊代码的数量。

      --ignore &lt;PATH&gt;...
          要忽略的通配符

      --full
          打印所有文件的报告，即使没有找到不安全函数

  -h, --help
          打印帮助信息（使用 '-h' 查看摘要）
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forge-generate"><a class="header" href="#forge-generate">forge generate</a></h1>
<p>生成脚手架文件</p>
<pre><code class="language-bash">$ forge generate --help
Usage: forge generate &lt;COMMAND&gt;

Commands:
  test  为给定的合约生成测试文件脚手架
  help  打印此消息或给定子命令的帮助信息

Options:
  -h, --help  打印帮助信息
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># forge generate test

为给定的合约生成测试文件

```bash
$ forge generate test --help
Usage: forge generate test --contract-name &lt;CONTRACT_NAME&gt;

Options:
  -c, --contract-name &lt;CONTRACT_NAME&gt;  用于生成测试的合约名称
  -h, --help                           打印帮助信息
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># forge generate-fig-spec

生成 Fig 自动补全规范

```bash
$ forge generate-fig-spec --help
Usage: forge generate-fig-spec

Options:
  -h, --help  打印帮助信息
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># forge init

创建一个新的 Forge 项目

```bash
$ forge init --help
Usage: forge init [OPTIONS] [PATH]

Arguments:
  [PATH]
          新项目的根目录
          
          [默认值: .]

Options:
  -t, --template &lt;TEMPLATE&gt;
          从模板开始

  -b, --branch &lt;BRANCH&gt;
          只能与模板选项一起使用的分支参数。如果未指定，则使用默认分支

      --offline
          不要从网络安装依赖项
          
          [别名: no-deps]

      --force
          即使指定的根目录不为空，也要创建项目

      --vscode
          创建一个包含 Solidity 设置的 .vscode/settings.json 文件，并生成一个 remappings.txt 文件

      --shallow
          执行浅克隆而不是深克隆。
          
          提高性能并减少磁盘使用，但阻止切换分支或标签。

      --no-git
          安装时不将依赖项作为子模块添加

      --no-commit
          不要创建提交

  -q, --quiet
          不打印任何消息

  -h, --help
          打印帮助信息（使用 '-h' 查看摘要）
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># forge inspect

获取智能合约的专门信息

```bash
$ forge inspect --help
Usage: forge inspect [OPTIONS] &lt;CONTRACT&gt; &lt;FIELD&gt;

Arguments:
  &lt;CONTRACT&gt;
          要检查的合约标识符，格式为 `(&lt;路径&gt;:)?&lt;合约名称&gt;`

  &lt;FIELD&gt;
          要检查的合约构件字段
          
          [可能的值: abi, bytecode, deployedBytecode, assembly, assemblyOptimized,
          methodIdentifiers, gasEstimates, storageLayout, devdoc, ir, irOptimized, metadata,
          userdoc, ewasm, errors, events]

Options:
      --pretty
          如果支持，以漂亮的格式打印选定的字段

  -h, --help
          打印帮助信息（使用 '-h' 查看摘要）

缓存选项:
      --force
          清除缓存和构件文件夹并重新编译

      --no-cache
          禁用缓存

      --skip &lt;SKIP&gt;...
          跳过构建名称包含给定过滤器的文件。
          
          `test` 和 `script` 是 `.t.sol` 和 `.s.sol` 的别名。

链接器选项:
      --libraries &lt;LIBRARIES&gt;
          设置预链接的库
          
          [环境变量: DAPP_LIBRARIES=]

编译器选项:
      --ignored-error-codes &lt;ERROR_CODES&gt;
          忽略 solc 警告的错误代码

      --deny-warnings
          警告将触发编译器错误

      --no-auto-detect
          不要自动检测 `solc` 版本

      --use &lt;SOLC_VERSION&gt;
          指定用于构建的 solc 版本或本地 solc 的路径。
          
          有效值格式为 `x.y.z`、`solc:x.y.z` 或 `path/to/solc`。

      --offline
          不要访问网络。
          
          缺失的 solc 版本将不会被安装。

      --via-ir
          使用 Yul 中间表示编译管道

      --no-metadata
          不要在字节码中附加任何元数据。
          
          这相当于将 `bytecode_hash` 设置为 `none` 并将 `cbor_metadata` 设置为 `false`。

      --silent
          启动时不要打印任何内容

      --ast
          在编译器输出中包含 AST 的 JSON

      --evm-version &lt;VERSION&gt;
          目标 EVM 版本

      --optimize
          激活 Solidity 优化器

      --optimizer-runs &lt;RUNS&gt;
          优化器运行的次数

      --extra-output &lt;SELECTOR&gt;...
          在合约的构件中包含额外的输出。
          
          示例键: evm.assembly, ewasm, ir, irOptimized, metadata
          
          完整描述请参见
          &lt;https://docs.soliditylang.org/en/v0.8.13/using-the-compiler.html#input-description&gt;

      --extra-output-files &lt;SELECTOR&gt;...
          写入单独文件的额外输出。
          
          有效值: metadata, ir, irOptimized, ewasm, evm.assembly

项目选项:
  -o, --out &lt;PATH&gt;
          合约构件文件夹的路径

      --revert-strings &lt;REVERT&gt;
          回退字符串配置。
          
          可能的值为 "default"、"strip"（移除）、"debug"（Solidity 生成的回退字符串）和 "verboseDebug"

      --build-info
          生成构建信息文件

      --build-info-path &lt;PATH&gt;
          构建信息文件将写入的目录输出路径

      --root &lt;PATH&gt;
          项目的根路径。
          
          默认情况下是 Git 仓库的根目录（如果在 Git 仓库中），或者当前工作目录。

  -C, --contracts &lt;PATH&gt;
          合约源目录

  -R, --remappings &lt;REMAPPINGS&gt;
          项目的重映射

      --remappings-env &lt;ENV&gt;
          从环境变量中获取项目的重映射

      --cache-path &lt;PATH&gt;
          编译器缓存的路径

      --lib-paths &lt;PATH&gt;
          库文件夹的路径

      --hardhat
          使用 Hardhat 风格的项目布局。
          
          这相当于使用: `--contracts contracts --lib-paths node_modules`。
          
          [别名: hh]

      --config-path &lt;FILE&gt;
          配置文件的路径
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># forge install

安装一个或多个依赖项。

```bash
$ forge install --help
Usage: forge install [OPTIONS] [DEPENDENCIES]...
    forge install [OPTIONS] &lt;github 用户名&gt;/&lt;github 项目&gt;@&lt;标签&gt;...
    forge install [OPTIONS] &lt;别名&gt;=&lt;github 用户名&gt;/&lt;github 项目&gt;@&lt;标签&gt;...
    forge install [OPTIONS] &lt;https:// git 地址&gt;...

Arguments:
  [DEPENDENCIES]...
          要安装的依赖项。
          
          依赖项可以是一个原始 URL，或 GitHub 仓库的路径。
          
          此外，可以通过在依赖路径后添加 @ 来提供 ref。
          
          ref 可以是：
          - 分支：master
          - 标签：v1.2.3
          - 提交：8e8128
          
          可以通过 `&lt;别名&gt;=` 后缀添加目标安装目录。依赖项将安装到 `lib/&lt;别名&gt;`。

Options:
      --root &lt;PATH&gt;
          项目的根路径。
          
          默认情况下是 Git 仓库的根目录（如果在 Git 仓库中），或当前工作目录。

      --shallow
          执行浅克隆而不是深克隆。
          
          提高性能并减少磁盘使用，但阻止切换分支或标签。

      --no-git
          安装时不将依赖项添加为子模块

      --no-commit
          不创建提交

  -q, --quiet
          不打印任何消息

  -h, --help
          打印帮助信息（使用 '-h' 查看摘要）
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># forge remappings

获取项目自动推断的重映射

```bash
$ forge remappings --help
Usage: forge remappings [OPTIONS]

Options:
      --root &lt;PATH&gt;
          项目的根路径。
          
          默认情况下是 Git 仓库的根目录（如果在 Git 仓库中），或者当前工作目录。

      --pretty
          以分组形式美观地打印重映射

  -h, --help
          打印帮助信息（使用 '-h' 查看摘要）
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># forge remove

移除一个或多个依赖项

```bash
$ forge remove --help
Usage: forge remove [OPTIONS] &lt;DEPENDENCIES&gt;...

Arguments:
  &lt;DEPENDENCIES&gt;...
          你想要移除的依赖项

Options:
      --root &lt;PATH&gt;
          项目的根路径。
          
          默认情况下是 Git 仓库的根路径（如果在 Git 仓库中），或者当前工作目录。

  -f, --force
          覆盖最新的检查

  -h, --help
          打印帮助信息（使用 '-h' 查看摘要）
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># forge script

运行智能合约作为脚本，构建可以发送到链上的交易

```bash
$ forge script --help
Usage: forge script [OPTIONS] &lt;PATH&gt; [ARGS]...

Arguments:
  &lt;PATH&gt;
          你要运行的合约。可以是文件路径或合约名称。
          
          如果同一个文件中存在多个合约，你必须使用
          --target-contract 指定目标合约。

  [ARGS]...
          传递给脚本函数的参数

Options:
      --target-contract &lt;CONTRACT_NAME&gt;
          你要运行的合约名称
          
          [aliases: tc]

  -s, --sig &lt;SIG&gt;
          你要在合约中调用的函数的签名，或原始调用数据
          
          [default: run()]

      --priority-gas-price &lt;PRICE&gt;
          EIP1559 交易的每单位 gas 的最大优先费用
          
          [env: ETH_PRIORITY_GAS_PRICE=]

      --legacy
          使用传统交易而不是 EIP1559 交易。
          
          对于没有 EIP1559 的常见网络会自动启用。

      --broadcast
          广播交易

      --batch-size &lt;BATCH_SIZE&gt;
          交易的批量大小。
          
          如果批量处理不可用或启用了 `--slow`，则忽略并设置为 1。
          
          [default: 100]

      --skip-simulation
          跳过链上模拟

  -g, --gas-estimate-multiplier &lt;GAS_ESTIMATE_MULTIPLIER&gt;
          相对百分比乘以 gas 估计值
          
          [default: 130]

      --unlocked
          通过 `eth_sendTransaction` 发送，使用 `--from` 参数或 `$ETH_FROM` 作为发送者

      --resume
          恢复提交之前失败或超时的交易。
          
          它不会再次模拟脚本，并且期望 nonce 保持不变。
          
          例如：如果交易 N 的 nonce 为 22，那么账户应该有 nonce 22，否则会失败。

      --multi
          如果存在，--resume 或 --verify 将被假定为多链部署

      --debug
          在调试器中打开脚本。
          
          优先于 broadcast。

      --slow
          确保交易在其前一个交易被确认并成功后才发送

      --non-interactive
          禁用部署大合约时可能出现的交互提示。
          
          有关合约大小限制的更多信息，请参见 EIP-170：
          &lt;https://eips.ethereum.org/EIPS/eip-170&gt;

      --etherscan-api-key &lt;KEY&gt;
          Etherscan（或等效）API 密钥
          
          [env: ETHERSCAN_API_KEY=]

      --verify
          验证脚本收据中找到的所有合约（如果有）

      --json
          以 JSON 格式输出结果

      --with-gas-price &lt;PRICE&gt;
          传统交易的 gas 价格，或 EIP1559 交易的每单位 gas 的最大费用
          
          [env: ETH_GAS_PRICE=]

  -h, --help
          打印帮助信息（使用 '-h' 查看摘要）

Cache options:
      --force
          清除缓存和 artifacts 文件夹并重新编译

Build options:
      --no-cache
          禁用缓存

      --skip &lt;SKIP&gt;...
          跳过构建名称包含给定过滤器的文件。
          
          `test` 和 `script` 是 `.t.sol` 和 `.s.sol` 的别名。

Linker options:
      --libraries &lt;LIBRARIES&gt;
          设置预链接的库
          
          [env: DAPP_LIBRARIES=]

Compiler options:
      --ignored-error-codes &lt;ERROR_CODES&gt;
          忽略 solc 警告的错误代码

      --deny-warnings
          警告将触发编译器错误

      --no-auto-detect
          不自动检测 `solc` 版本

      --use &lt;SOLC_VERSION&gt;
          指定用于构建的 solc 版本或本地 solc 路径。
          
          有效值格式为 `x.y.z`、`solc:x.y.z` 或 `path/to/solc`。

      --offline
          不访问网络。
          
          缺失的 solc 版本不会被安装。

      --via-ir
          使用 Yul 中间表示编译管道

      --no-metadata
          不在字节码中附加任何元数据。
          
          这相当于将 `bytecode_hash` 设置为 `none` 并将 `cbor_metadata` 设置为 `false`。

      --silent
          启动时不打印任何内容

      --ast
          在编译器输出中包含 AST 作为 JSON

      --evm-version &lt;VERSION&gt;
          目标 EVM 版本

      --optimize
          激活 Solidity 优化器

      --optimizer-runs &lt;RUNS&gt;
          优化器运行次数

      --extra-output &lt;SELECTOR&gt;...
          在合约的 artifact 中包含额外的输出。
          
          示例键：evm.assembly、ewasm、ir、irOptimized、metadata
          
          完整描述请参见
          &lt;https://docs.soliditylang.org/en/v0.8.13/using-the-compiler.html#input-description&gt;

      --extra-output-files &lt;SELECTOR&gt;...
          写入单独文件的额外输出。
          
          有效值：metadata、ir、irOptimized、ewasm、evm.assembly

Project options:
  -o, --out &lt;PATH&gt;
          合约 artifacts 文件夹的路径

      --revert-strings &lt;REVERT&gt;
          回退字符串配置。
          
          可能的值为 "default"、"strip"（移除）、"debug"（Solidity 生成的回退字符串）和 "verboseDebug"

      --build-info
          生成构建信息文件

      --build-info-path &lt;PATH&gt;
          构建信息文件将写入的目录输出路径

      --root &lt;PATH&gt;
          项目的根路径。
          
          默认情况下是 Git 仓库的根目录（如果在 Git 仓库中），或当前工作目录。

  -C, --contracts &lt;PATH&gt;
          合约源目录

  -R, --remappings &lt;REMAPPINGS&gt;
          项目的 remappings

      --remappings-env &lt;ENV&gt;
          从环境获取项目的 remappings

      --cache-path &lt;PATH&gt;
          编译器缓存的路径

      --lib-paths &lt;PATH&gt;
          库文件夹的路径

      --hardhat
          使用 Hardhat 风格的项目布局。
          
          这相当于使用：`--contracts contracts --lib-paths node_modules`。
          
          [aliases: hh]

      --config-path &lt;FILE&gt;
          配置文件的路径

Wallet options - raw:
  -a, --froms [&lt;ADDRESSES&gt;...]
          发送者账户
          
          [env: ETH_FROM=]

  -i, --interactives &lt;NUM&gt;
          打开一个交互提示以输入你的私钥。
          
          取一个值表示要输入的密钥数量。
          
          [default: 0]

      --private-keys &lt;RAW_PRIVATE_KEYS&gt;
          使用提供的私钥

      --private-key &lt;RAW_PRIVATE_KEY&gt;
          使用提供的私钥

      --mnemonics &lt;MNEMONICS&gt;
          使用指定路径的助记词文件的助记词短语

      --mnemonic-passphrases &lt;PASSPHRASE&gt;
          使用 BIP39 助记词的密码短语

      --mnemonic-derivation-paths &lt;PATH&gt;
          钱包派生路径。
          
          适用于 --mnemonic-path 和硬件钱包。

      --mnemonic-indexes &lt;INDEXES&gt;
          使用给定助记词索引的私钥。
          
          可与 --mnemonics、--ledger、--aws 和 --trezor 一起使用。
          
          [default: 0]

Wallet options - keystore:
      --keystore &lt;PATHS&gt;
          使用给定文件夹或文件中的 keystore
          
          [env: ETH_KEYSTORE=]
          [aliases: keystores]

      --account &lt;ACCOUNT_NAMES&gt;
          使用默认 keystores 文件夹（~/.foundry/keystores）中按文件名指定的 keystore
          
          [env: ETH_KEYSTORE_ACCOUNT=]
          [aliases: accounts]

      --password &lt;PASSWORDS&gt;
          keystore 密码。
          
          与 --keystore 一起使用。

      --password-file &lt;PATHS&gt;
          keystore 密码文件路径。
          
          与 --keystore 一起使用。
          
          [env: ETH_PASSWORD=]

Wallet options - hardware wallet:
  -l, --ledger
          使用 Ledger 硬件钱包

  -t, --trezor
          使用 Trezor 硬件钱包

Wallet options - remote:
      --aws
          使用 AWS Key Management Service

EVM options:
  -f, --fork-url &lt;URL&gt;
          通过远程端点获取状态，而不是从空状态开始。
          
          如果你想从特定区块号获取状态，请参见 --fork-block-number。
          
          [aliases: rpc-url]

      --fork-block-number &lt;BLOCK&gt;
          通过远程端点从特定区块号获取状态。
          
          请参见 --fork-url。

      --fork-retries &lt;RETRIES&gt;
          重试次数。
          
          请参见 --fork-url。

      --fork-retry-backoff &lt;BACKOFF&gt;
          遇到错误时的初始重试退避。
          
          请参见 --fork-url。

      --no-storage-caching
          显式禁用 RPC 缓存。
          
          所有存储槽都完全从端点读取。
          
          此标志覆盖项目的配置文件。
          
          请参见 --fork-url。

      --initial-balance &lt;BALANCE&gt;
          部署测试合约的初始余额

      --sender &lt;ADDRESS&gt;
          执行测试的地址

      --ffi
          启用 FFI cheatcode

      --always-use-create-2-factory
          在所有情况下（包括测试和非广播脚本）使用 create 2 工厂

  -v, --verbosity...
          EVM 的详细程度。
          
          多次传递以增加详细程度（例如 -v、-vv、-vvv）。
          
          详细程度级别：
          - 2：打印所有测试的日志
          - 3：打印失败测试的执行 traces
          - 4：打印所有测试的执行 traces，以及失败测试的设置 traces
          - 5：打印所有测试的执行和设置 traces

Fork config:
      --compute-units-per-second &lt;CUPS&gt;
          设置此提供商假设可用的每秒计算单位数
          
          默认值：330
          
          请参见 --fork-url 和
          &lt;https://docs.alchemy.com/reference/compute-units#what-are-cups-compute-units-per-second&gt;

      --no-rpc-rate-limit
          禁用此节点提供商的速率限制。
          
          请参见 --fork-url 和
          &lt;https://docs.alchemy.com/reference/compute-units#what-are-cups-compute-units-per-second&gt;
          
          [aliases: no-rate-limit]

Executor environment config:
      --gas-limit &lt;GAS_LIMIT&gt;
          区块 gas 限制

      --code-size-limit &lt;CODE_SIZE&gt;
          EIP-170：合约代码大小限制（字节）。增加此值有助于测试。默认值为 0x6000（~25kb）

      --chain &lt;CHAIN&gt;
          链名称或 EIP-155 链 ID
          
          [aliases: chain-id]

      --gas-price &lt;GAS_PRICE&gt;
          gas 价格

      --block-base-fee-per-gas &lt;FEE&gt;
          区块的基础费用
          
          [aliases: base-fee]

      --tx-origin &lt;ADDRESS&gt;
          交易发起者

      --block-coinbase &lt;ADDRESS&gt;
          区块的 coinbase

      --block-timestamp &lt;TIMESTAMP&gt;
          区块的时间戳

      --block-number &lt;BLOCK&gt;
          区块号

      --block-difficulty &lt;DIFFICULTY&gt;
          区块难度

      --block-prevrandao &lt;PREVRANDAO&gt;
          区块的 prevrandao 值。注意：合并前此字段为 mix_hash

      --block-gas-limit &lt;GAS_LIMIT&gt;
          区块 gas 限制

      --memory-limit &lt;MEMORY_LIMIT&gt;
          EVM 执行的每单位内存限制（字节）。如果超过此限制，将抛出 `MemoryLimitOOG` 结果。
          
          默认值为 128MiB。

      --disable-block-gas-limit
          是否禁用区块 gas 限制检查
          
          [aliases: no-gas-limit]

      --isolate
          是否启用调用的隔离。在隔离模式下，所有顶级调用都作为单独的交易在单独的 EVM 上下文中执行，实现更精确的 gas 会计和交易状态更改

      --retries &lt;RETRIES&gt;
          验证重试次数
          
          [default: 5]

      --delay &lt;DELAY&gt;
          验证尝试之间的可选延迟（秒）
          
          [default: 5]

Verifier options:
      --verifier &lt;VERIFIER&gt;
          使用的合约验证提供商
          
          [default: etherscan]
          [possible values: etherscan, sourcify, blockscout, oklink]

      --verifier-url &lt;VERIFIER_URL&gt;
          如果使用自定义提供商，则设置验证 URL
          
          [env: VERIFIER_URL=]
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># forge selectors

函数选择器工具

```bash
$ forge selectors --help
Usage: forge selectors &lt;COMMAND&gt;

Commands:
  collision  检查合约之间的选择器冲突 [aliases: co]
  upload     将选择器上传到注册表 [aliases: up]
  list       列出当前工作区的选择器 [aliases: ls]
  help       打印此消息或给定子命令的帮助

Options:
  -h, --help  打印帮助
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># forge selectors collision

检查合约之间的选择器冲突

```bash
$ forge selectors collision --help
Usage: forge selectors collision [OPTIONS] &lt;FIRST_CONTRACT&gt; &lt;SECOND_CONTRACT&gt;

Arguments:
  &lt;FIRST_CONTRACT&gt;
          要检查选择器冲突的两个合约中的第一个合约，格式为
          `(&lt;路径&gt;:)?&lt;合约名称&gt;`

  &lt;SECOND_CONTRACT&gt;
          要检查选择器冲突的两个合约中的第二个合约，格式为
          `(&lt;路径&gt;:)?&lt;合约名称&gt;`

Options:
  -h, --help
          打印帮助信息（使用 '-h' 查看摘要）

Cache options:
      --force
          清除缓存和 artifacts 文件夹并重新编译

Build options:
      --no-cache
          禁用缓存

      --skip &lt;SKIP&gt;...
          跳过构建名称包含给定过滤器的文件。
          
          `test` 和 `script` 是 `.t.sol` 和 `.s.sol` 的别名。

Linker options:
      --libraries &lt;LIBRARIES&gt;
          设置预链接的库
          
          [env: DAPP_LIBRARIES=]

Compiler options:
      --ignored-error-codes &lt;ERROR_CODES&gt;
          忽略 solc 警告的错误代码

      --deny-warnings
          警告将触发编译器错误

      --no-auto-detect
          不自动检测 `solc` 版本

      --use &lt;SOLC_VERSION&gt;
          指定用于构建的 solc 版本或本地 solc 的路径。
          
          有效值格式为 `x.y.z`、`solc:x.y.z` 或 `path/to/solc`。

      --offline
          不访问网络。
          
          缺失的 solc 版本将不会被安装。

      --via-ir
          使用 Yul 中间表示编译管道

      --no-metadata
          不在字节码中附加任何元数据。
          
          这等同于将 `bytecode_hash` 设置为 `none` 并将 `cbor_metadata` 设置为 `false`。

      --silent
          启动时不打印任何内容

      --ast
          在编译器输出中包含 AST 的 JSON

      --evm-version &lt;VERSION&gt;
          目标 EVM 版本

      --optimize
          激活 Solidity 优化器

      --optimizer-runs &lt;RUNS&gt;
          优化器运行次数

      --extra-output &lt;SELECTOR&gt;...
          在合约的 artifact 中包含的额外输出。
          
          示例键：evm.assembly、ewasm、ir、irOptimized、metadata
          
          完整描述请参见
          &lt;https://docs.soliditylang.org/en/v0.8.13/using-the-compiler.html#input-description&gt;

      --extra-output-files &lt;SELECTOR&gt;...
          写入单独文件的额外输出。
          
          有效值：metadata、ir、irOptimized、ewasm、evm.assembly

Project options:
  -o, --out &lt;PATH&gt;
          合约 artifacts 文件夹的路径

      --revert-strings &lt;REVERT&gt;
          回退字符串配置。
          
          可能的值为 "default"、"strip"（移除）、"debug"（Solidity 生成的回退字符串）和 "verboseDebug"

      --build-info
          生成构建信息文件

      --build-info-path &lt;PATH&gt;
          构建信息文件将写入的目录输出路径

      --root &lt;PATH&gt;
          项目的根路径。
          
          默认情况下是 Git 仓库的根目录（如果在仓库中），或当前工作目录。

  -C, --contracts &lt;PATH&gt;
          合约源目录

  -R, --remappings &lt;REMAPPINGS&gt;
          项目的 remappings

      --remappings-env &lt;ENV&gt;
          从环境获取的项目的 remappings

      --cache-path &lt;PATH&gt;
          编译器缓存的路径

      --lib-paths &lt;PATH&gt;
          库文件夹的路径

      --hardhat
          使用 Hardhat 风格的项目布局。
          
          这等同于使用：`--contracts contracts --lib-paths node_modules`。
          
          [aliases: hh]

      --config-path &lt;FILE&gt;
          配置文件的路径
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># forge selectors upload

上传选择器到注册表

```bash
$ forge selectors upload --help
Usage: forge selectors upload [OPTIONS] [CONTRACT]

Arguments:
  [CONTRACT]
          要上传选择器的合约名称

Options:
      --all
          上传项目中所有合约的选择器

  -h, --help
          打印帮助信息（使用 '-h' 查看摘要）

项目选项:
      --root &lt;PATH&gt;
          项目的根路径。
          
          默认情况下是 Git 仓库的根路径（如果在 Git 仓库中），或者当前工作目录。

  -C, --contracts &lt;PATH&gt;
          合约源代码目录

  -R, --remappings &lt;REMAPPINGS&gt;
          项目的重映射

      --remappings-env &lt;ENV&gt;
          从环境变量中获取项目的重映射

      --cache-path &lt;PATH&gt;
          编译器缓存路径

      --lib-paths &lt;PATH&gt;
          库文件夹路径

      --hardhat
          使用 Hardhat 风格的项目布局。
          
          这等同于使用：`--contracts contracts --lib-paths node_modules`。
          
          [aliases: hh]

      --config-path &lt;FILE&gt;
          配置文件路径
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># forge selectors list

列出当前工作区的选择器

```bash
$ forge selectors list --help
Usage: forge selectors list [OPTIONS] [CONTRACT]

Arguments:
  [CONTRACT]
          要列出选择器的合约名称。

Options:
  -h, --help
          打印帮助信息（使用 '-h' 查看简要帮助）

项目选项:
      --root &lt;PATH&gt;
          项目的根路径。
          
          默认情况下，如果在一个 Git 仓库中，则为 Git 仓库的根路径，否则为当前工作目录。

  -C, --contracts &lt;PATH&gt;
          合约源代码目录

  -R, --remappings &lt;REMAPPINGS&gt;
          项目的重映射

      --remappings-env &lt;ENV&gt;
          从环境变量中获取的项目重映射

      --cache-path &lt;PATH&gt;
          编译器缓存的路径

      --lib-paths &lt;PATH&gt;
          库文件夹的路径

      --hardhat
          使用 Hardhat 风格的项目布局。
          
          这等同于使用：`--contracts contracts --lib-paths node_modules`。
          
          [aliases: hh]

      --config-path &lt;FILE&gt;
          配置文件的路径
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># forge snapshot

创建每个测试的 gas 使用快照

```bash
$ forge snapshot --help
Usage: forge snapshot [OPTIONS]

Options:
      --diff [&lt;SNAPSHOT_FILE&gt;]
          输出与预先存在的快照的差异。
          
          默认情况下，比较使用 .gas-snapshot。

      --check [&lt;SNAPSHOT_FILE&gt;]
          与预先存在的快照进行比较，如果不匹配则退出并返回代码 1。
          
          如果快照不匹配，则输出差异。
          
          默认情况下，比较使用 .gas-snapshot。

      --snap &lt;FILE&gt;
          快照的输出文件
          
          [默认值: .gas-snapshot]

      --tolerance &lt;SNAPSHOT_THRESHOLD&gt;
          容忍 gas 偏差到指定百分比

  -h, --help
          打印帮助信息（使用 '-h' 查看摘要）

Test options:
      --debug &lt;TEST_FUNCTION&gt;
          在调试器中运行测试。
          
          传递给此标志的参数是要运行的测试函数的名称，其工作方式与 --match-test 相同。
          
          如果多个测试匹配指定的条件，必须添加额外的过滤器，直到找到一个测试（参见 --match-contract 和 --match-path）。
          
          匹配的测试将在调试器中打开，无论测试结果如何。
          
          如果匹配的测试是 fuzz 测试，则会在第一个失败案例中打开调试器。如果 fuzz 测试没有失败，则会在最后一个 fuzz 案例中打开调试器。
          
          有关更精细的控制，参见 forge run。

      --gas-report
          打印 gas 报告
          
          [环境变量: FORGE_GAS_REPORT=]

      --allow-failure
          即使测试失败也退出并返回代码 0
          
          [环境变量: FORGE_ALLOW_FAILURE=]

      --fail-fast
          在第一次失败后停止运行测试

      --etherscan-api-key &lt;KEY&gt;
          Etherscan（或等效）API 密钥
          
          [环境变量: ETHERSCAN_API_KEY=]

      --fuzz-seed &lt;FUZZ_SEED&gt;
          设置用于生成 fuzz 运行随机性的种子

      --fuzz-runs &lt;RUNS&gt;
          [环境变量: FOUNDRY_FUZZ_RUNS=]

      --fuzz-input-file &lt;FUZZ_INPUT_FILE&gt;
          从文件重新运行 fuzz 失败

      --max-threads &lt;MAX_THREADS&gt;
          使用的最大并发线程数。默认值是可用 CPU 的数量

Display options:
  -j, --json
          以 JSON 格式输出测试结果

  -l, --list
          列出测试而不是运行它们

      --summary
          打印测试摘要表

      --detailed
          打印详细的测试摘要表

Test filtering:
      --match-test &lt;REGEX&gt;
          仅运行匹配指定正则表达式的测试函数
          
          [别名: mt]

      --no-match-test &lt;REGEX&gt;
          仅运行不匹配指定正则表达式的测试函数
          
          [别名: nmt]

      --match-contract &lt;REGEX&gt;
          仅运行匹配指定正则表达式的合约中的测试
          
          [别名: mc]

      --no-match-contract &lt;REGEX&gt;
          仅运行不匹配指定正则表达式的合约中的测试
          
          [别名: nmc]

      --match-path &lt;GLOB&gt;
          仅运行匹配指定 glob 模式的源文件中的测试
          
          [别名: mp]

      --no-match-path &lt;GLOB&gt;
          仅运行不匹配指定 glob 模式的源文件中的测试
          
          [别名: nmp]

EVM options:
  -f, --fork-url &lt;URL&gt;
          通过远程端点获取状态，而不是从空状态开始。
          
          如果要从特定块号获取状态，参见 --fork-block-number。
          
          [别名: rpc-url]

      --fork-block-number &lt;BLOCK&gt;
          通过远程端点从特定块号获取状态。
          
          参见 --fork-url。

      --fork-retries &lt;RETRIES&gt;
          重试次数。
          
          参见 --fork-url。

      --fork-retry-backoff &lt;BACKOFF&gt;
          遇到错误时的初始重试退避。
          
          参见 --fork-url。

      --no-storage-caching
          显式禁用 RPC 缓存。
          
          所有存储槽完全从端点读取。
          
          此标志覆盖项目的配置文件。
          
          参见 --fork-url。

      --initial-balance &lt;BALANCE&gt;
          部署测试合约的初始余额

      --sender &lt;ADDRESS&gt;
          执行测试的地址

      --ffi
          启用 FFI cheatcode

      --always-use-create-2-factory
          在所有情况下使用 create 2 工厂，包括测试和非广播脚本

  -v, --verbosity...
          EVM 的详细程度。
          
          多次传递以增加详细程度（例如 -v, -vv, -vvv）。
          
          详细程度级别：
          - 2: 打印所有测试的日志
          - 3: 打印失败测试的执行 traces
          - 4: 打印所有测试的执行 traces，以及失败测试的设置 traces
          - 5: 打印所有测试的执行和设置 traces

Fork config:
      --compute-units-per-second &lt;CUPS&gt;
          设置此提供者假设的每秒可用计算单元数
          
          默认值: 330
          
          参见 --fork-url 和
          &lt;https://docs.alchemy.com/reference/compute-units#what-are-cups-compute-units-per-second&gt;

      --no-rpc-rate-limit
          禁用此节点提供者的速率限制。
          
          参见 --fork-url 和
          &lt;https://docs.alchemy.com/reference/compute-units#what-are-cups-compute-units-per-second&gt;
          
          [别名: no-rate-limit]

Executor environment config:
      --gas-limit &lt;GAS_LIMIT&gt;
          区块 gas 限制

      --code-size-limit &lt;CODE_SIZE&gt;
          EIP-170: 合约代码大小限制（字节）。增加此值有助于测试。默认值是 0x6000（~25kb）

      --chain &lt;CHAIN&gt;
          链名称或 EIP-155 链 ID
          
          [别名: chain-id]

      --gas-price &lt;GAS_PRICE&gt;
          gas 价格

      --block-base-fee-per-gas &lt;FEE&gt;
          区块基础费用
          
          [别名: base-fee]

      --tx-origin &lt;ADDRESS&gt;
          交易发起者

      --block-coinbase &lt;ADDRESS&gt;
          区块的 coinbase

      --block-timestamp &lt;TIMESTAMP&gt;
          区块的时间戳

      --block-number &lt;BLOCK&gt;
          区块号

      --block-difficulty &lt;DIFFICULTY&gt;
          区块难度

      --block-prevrandao &lt;PREVRANDAO&gt;
          区块 prevrandao 值。注意：合并前此字段为 mix_hash

      --block-gas-limit &lt;GAS_LIMIT&gt;
          区块 gas 限制

      --memory-limit &lt;MEMORY_LIMIT&gt;
          EVM 执行的内存限制（字节）。如果超过此限制，将抛出 `MemoryLimitOOG` 结果。
          
          默认值是 128MiB。

      --disable-block-gas-limit
          是否禁用区块 gas 限制检查
          
          [别名: no-gas-limit]

      --isolate
          是否启用调用的隔离。在隔离模式下，所有顶级调用作为单独的交易在单独的 EVM 上下文中执行，实现更精确的 gas 计算和交易状态变化

Cache options:
      --force
          清除缓存和 artifacts 文件夹并重新编译

Build options:
      --no-cache
          禁用缓存

      --skip &lt;SKIP&gt;...
          跳过构建文件名包含给定过滤器的文件。
          
          `test` 和 `script` 是 `.t.sol` 和 `.s.sol` 的别名。

Linker options:
      --libraries &lt;LIBRARIES&gt;
          设置预链接的库
          
          [环境变量: DAPP_LIBRARIES=]

Compiler options:
      --ignored-error-codes &lt;ERROR_CODES&gt;
          忽略 solc 警告的错误代码

      --deny-warnings
          警告将触发编译器错误

      --no-auto-detect
          不自动检测 `solc` 版本

      --use &lt;SOLC_VERSION&gt;
          指定用于构建的 solc 版本或本地 solc 路径。
          
          有效值格式为 `x.y.z`、`solc:x.y.z` 或 `path/to/solc`。

      --offline
          不访问网络。
          
          将不会安装缺失的 solc 版本。

      --via-ir
          使用 Yul 中间表示编译管道

      --no-metadata
          不在字节码中附加任何元数据。
          
          这相当于将 `bytecode_hash` 设置为 `none` 并将 `cbor_metadata` 设置为 `false`。

      --silent
          启动时不打印任何内容

      --ast
          在编译器输出中包含 AST 作为 JSON

      --evm-version &lt;VERSION&gt;
          目标 EVM 版本

      --optimize
          激活 Solidity 优化器

      --optimizer-runs &lt;RUNS&gt;
          优化器运行次数

      --extra-output &lt;SELECTOR&gt;...
          在合约的 artifact 中包含额外的输出。
          
          示例键: evm.assembly, ewasm, ir, irOptimized, metadata
          
          完整描述参见
          &lt;https://docs.soliditylang.org/en/v0.8.13/using-the-compiler.html#input-description&gt;

      --extra-output-files &lt;SELECTOR&gt;...
          写入单独文件的额外输出。
          
          有效值: metadata, ir, irOptimized, ewasm, evm.assembly

Project options:
  -o, --out &lt;PATH&gt;
          合约 artifacts 文件夹的路径

      --revert-strings &lt;REVERT&gt;
          回退字符串配置。
          
          可能的值是 "default"、"strip"（删除）、"debug"（Solidity 生成的回退字符串）和 "verboseDebug"

      --build-info
          生成构建信息文件

      --build-info-path &lt;PATH&gt;
          构建信息文件将写入的目录输出路径

      --root &lt;PATH&gt;
          项目的根路径。
          
          默认情况下是 Git 仓库的根目录（如果在 Git 仓库中），或者当前工作目录。

  -C, --contracts &lt;PATH&gt;
          合约源目录

  -R, --remappings &lt;REMAPPINGS&gt;
          项目的 remappings

      --remappings-env &lt;ENV&gt;
          从环境获取项目的 remappings

      --cache-path &lt;PATH&gt;
          编译器缓存的路径

      --lib-paths &lt;PATH&gt;
          库文件夹的路径

      --hardhat
          使用 Hardhat 风格的
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-json">{
  "translated_text": "# forge soldeer\n\nSoldeer 依赖管理器\n\n```bash\n$ forge soldeer --help\nUsage: forge soldeer install [DEPENDENCY]~[VERSION] &lt;REMOTE_URL&gt;\n    forge soldeer push [DEPENDENCY]~[VERSION] &lt;CUSTOM_PATH_OF_FILES&gt;\n    forge soldeer login\n    forge soldeer update\n    forge soldeer version\n\nCommands:\n  install          从 soldeer 仓库或自定义 URL 安装依赖，URL 指向一个 zip 文件。\n                      示例：soldeer install @openzeppelin-contracts~2.3.0，`~` 非常重要，用于区分名称和需要安装的版本。\n  update           通过读取配置文件更新依赖。\n  login            登录到中央仓库以推送依赖。\n  push             将依赖推送到仓库。PATH_TO_DEPENDENCY 是可选的，如果没有提供，将使用当前目录。\n                      示例：如果目录是 /home/soldeer/my_project 并且你没有指定 PATH_TO_DEPENDENCY，\n                      则 /home/soldeer/my_project 中的文件将被推送到仓库。\n                      如果你指定了 PATH_TO_DEPENDENCY，则指定目录中的文件将被推送到仓库。\n                      如果你想忽略某些文件，可以在项目根目录创建一个 .soldeerignore 文件并添加你想忽略的文件。\n                      .soldeerignore 的工作方式类似于 .gitignore。\n  version-dry-run  \n  help             打印此消息或给定子命令的帮助信息\n\nOptions:\n  -h, --help  打印帮助信息\n```"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-json">{
  "translation": "# forge soldeer install\n\n从 soldeer 仓库或自定义 URL 安装依赖项，该 URL 指向一个 zip 文件。\n\n```bash\n$ forge soldeer install --help\nUsage: soldeer install &lt;DEPENDENCY&gt;~&lt;VERSION&gt; [URL]\n\nArguments:\n  &lt;DEPENDENCY&gt;  \n  [REMOTE_URL]  \n\nOptions:\n  -h, --help  打印帮助信息\n\n更多信息，请阅读 README.md\n```"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forge-soldeer-update"><a class="header" href="#forge-soldeer-update">forge soldeer update</a></h1>
<p>更新依赖项通过读取配置文件。</p>
<pre><code class="language-bash">$ forge soldeer update --help
Usage: soldeer update

Options:
  -h, --help  打印帮助信息

更多信息，请阅读 README.md
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forge-soldeer-login"><a class="header" href="#forge-soldeer-login">forge soldeer login</a></h1>
<p>登录到中央仓库以推送依赖项。</p>
<pre><code class="language-bash">$ forge soldeer login --help
Usage: soldeer login

Options:
  -h, --help  打印帮助信息

更多信息，请阅读 README.md
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># forge soldeer push

将依赖项推送到仓库。PATH_TO_DEPENDENCY 是可选的，如果没有提供，则使用默认路径。

```bash
$ forge soldeer push --help
Usage: soldeer push &lt;DEPENDENCY&gt;~&lt;VERSION&gt; [PATH_TO_DEPENDENCY]

Arguments:
  &lt;DEPENDENCY&gt;  
  [PATH]        

Options:
  -h, --help  打印帮助信息

更多信息，请阅读 README.md
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># forge soldeer version-dry-run

```bash
$ forge soldeer version-dry-run --help
用法: forge soldeer version-dry-run

选项:
  -h, --help  打印帮助信息
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forge-test-1"><a class="header" href="#forge-test-1">forge test</a></h1>
<p>运行项目的测试</p>
<pre><code class="language-bash">$ forge test --help
Usage: forge test [OPTIONS]

Options:
  -h, --help
          打印帮助信息（使用 '-h' 查看摘要）

Test options:
      --debug &lt;TEST_FUNCTION&gt;
          在调试器中运行测试。
          
          传递给此标志的参数是要运行的测试函数的名称，其工作方式与 --match-test 相同。
          
          如果多个测试匹配指定的标准，则必须添加额外的过滤器，直到找到一个测试（参见 --match-contract 和 --match-path）。
          
          匹配的测试将在调试器中打开，无论测试结果如何。
          
          如果匹配的测试是模糊测试，则它将在第一个失败案例上打开调试器。如果模糊测试没有失败，它将在最后一个模糊案例上打开调试器。
          
          有关更精细的模糊案例控制，请参见 forge run。

      --gas-report
          打印 gas 报告
          
          [env: FORGE_GAS_REPORT=]

      --allow-failure
          即使测试失败也退出代码 0
          
          [env: FORGE_ALLOW_FAILURE=]

      --fail-fast
          在第一次失败后停止运行测试

      --etherscan-api-key &lt;KEY&gt;
          Etherscan（或等效）API 密钥
          
          [env: ETHERSCAN_API_KEY=]

      --fuzz-seed &lt;FUZZ_SEED&gt;
          设置用于生成模糊运行随机性的种子

      --fuzz-runs &lt;RUNS&gt;
          [env: FOUNDRY_FUZZ_RUNS=]

      --fuzz-input-file &lt;FUZZ_INPUT_FILE&gt;
          从文件中重新运行模糊失败

      --max-threads &lt;MAX_THREADS&gt;
          使用的最大并发线程数。默认值是可用 CPU 的数量

Display options:
  -j, --json
          以 JSON 格式输出测试结果

  -l, --list
          列出测试而不是运行它们

      --summary
          打印测试摘要表

      --detailed
          打印详细的测试摘要表

Test filtering:
      --match-test &lt;REGEX&gt;
          仅运行匹配指定正则表达式的测试函数
          
          [aliases: mt]

      --no-match-test &lt;REGEX&gt;
          仅运行不匹配指定正则表达式的测试函数
          
          [aliases: nmt]

      --match-contract &lt;REGEX&gt;
          仅运行匹配指定正则表达式的合约中的测试
          
          [aliases: mc]

      --no-match-contract &lt;REGEX&gt;
          仅运行不匹配指定正则表达式的合约中的测试
          
          [aliases: nmc]

      --match-path &lt;GLOB&gt;
          仅运行匹配指定全局模式的源文件中的测试
          
          [aliases: mp]

      --no-match-path &lt;GLOB&gt;
          仅运行不匹配指定全局模式的源文件中的测试
          
          [aliases: nmp]

EVM options:
  -f, --fork-url &lt;URL&gt;
          通过远程端点获取状态，而不是从空状态开始。
          
          如果要从特定块号获取状态，请参见 --fork-block-number。
          
          [aliases: rpc-url]

      --fork-block-number &lt;BLOCK&gt;
          通过远程端点从特定块号获取状态。
          
          参见 --fork-url。

      --fork-retries &lt;RETRIES&gt;
          重试次数。
          
          参见 --fork-url。

      --fork-retry-backoff &lt;BACKOFF&gt;
          遇到错误时的初始重试退避。
          
          参见 --fork-url。

      --no-storage-caching
          显式禁用 RPC 缓存。
          
          所有存储槽完全从端点读取。
          
          此标志覆盖项目的配置文件。
          
          参见 --fork-url。

      --initial-balance &lt;BALANCE&gt;
          部署测试合约的初始余额

      --sender &lt;ADDRESS&gt;
          将执行测试的地址

      --ffi
          启用 FFI 作弊码

      --always-use-create-2-factory
          在所有情况下使用 create 2 工厂，包括测试和非广播脚本

  -v, --verbosity...
          EVM 的详细程度。
          
          多次传递以增加详细程度（例如 -v, -vv, -vvv）。
          
          详细程度级别：
          - 2: 打印所有测试的日志
          - 3: 打印失败测试的执行 traces
          - 4: 打印所有测试的执行 traces，以及失败测试的设置 traces
          - 5: 打印所有测试的执行和设置 traces

Fork config:
      --compute-units-per-second &lt;CUPS&gt;
          设置此提供商假设的可用计算单元数每秒
          
          默认值：330
          
          参见 --fork-url 和
          &lt;https://docs.alchemy.com/reference/compute-units#what-are-cups-compute-units-per-second&gt;

      --no-rpc-rate-limit
          禁用此节点提供商的速率限制。
          
          参见 --fork-url 和
          &lt;https://docs.alchemy.com/reference/compute-units#what-are-cups-compute-units-per-second&gt;
          
          [aliases: no-rate-limit]

Executor environment config:
      --gas-limit &lt;GAS_LIMIT&gt;
          区块 gas 限制

      --code-size-limit &lt;CODE_SIZE&gt;
          EIP-170: 合约代码大小限制（字节）。增加此值有助于测试。默认值为 0x6000（~25kb）

      --chain &lt;CHAIN&gt;
          链名称或 EIP-155 链 ID
          
          [aliases: chain-id]

      --gas-price &lt;GAS_PRICE&gt;
          gas 价格

      --block-base-fee-per-gas &lt;FEE&gt;
          区块的基础费用
          
          [aliases: base-fee]

      --tx-origin &lt;ADDRESS&gt;
          交易发起者

      --block-coinbase &lt;ADDRESS&gt;
          区块的 coinbase

      --block-timestamp &lt;TIMESTAMP&gt;
          区块的时间戳

      --block-number &lt;BLOCK&gt;
          区块号

      --block-difficulty &lt;DIFFICULTY&gt;
          区块难度

      --block-prevrandao &lt;PREVRANDAO&gt;
          区块的 prevrandao 值。注意：合并前此字段为 mix_hash

      --block-gas-limit &lt;GAS_LIMIT&gt;
          区块 gas 限制

      --memory-limit &lt;MEMORY_LIMIT&gt;
          EVM 执行的内存限制（字节）。如果超过此限制，将抛出 `MemoryLimitOOG` 结果。
          
          默认值为 128MiB。

      --disable-block-gas-limit
          是否禁用区块 gas 限制检查
          
          [aliases: no-gas-limit]

      --isolate
          是否启用调用的隔离。在隔离模式下，所有顶级调用作为单独的交易在单独的 EVM 上下文中执行，实现更精确的 gas 计算和交易状态变化

Cache options:
      --force
          清除缓存和 artifacts 文件夹并重新编译

Build options:
      --no-cache
          禁用缓存

      --skip &lt;SKIP&gt;...
          跳过构建文件名包含给定过滤器的文件。
          
          `test` 和 `script` 是 `.t.sol` 和 `.s.sol` 的别名。

Linker options:
      --libraries &lt;LIBRARIES&gt;
          设置预链接的库
          
          [env: DAPP_LIBRARIES=]

Compiler options:
      --ignored-error-codes &lt;ERROR_CODES&gt;
          忽略 solc 警告的错误代码

      --deny-warnings
          警告将触发编译器错误

      --no-auto-detect
          不自动检测 `solc` 版本

      --use &lt;SOLC_VERSION&gt;
          指定用于构建的 solc 版本或本地 solc 的路径。
          
          有效值格式为 `x.y.z`、`solc:x.y.z` 或 `path/to/solc`。

      --offline
          不访问网络。
          
          缺失的 solc 版本将不会被安装。

      --via-ir
          使用 Yul 中间表示编译管道

      --no-metadata
          不在字节码中附加任何元数据。
          
          这相当于将 `bytecode_hash` 设置为 `none` 并将 `cbor_metadata` 设置为 `false`。

      --silent
          启动时不打印任何内容

      --ast
          在编译器输出中包含 AST 为 JSON

      --evm-version &lt;VERSION&gt;
          目标 EVM 版本

      --optimize
          激活 Solidity 优化器

      --optimizer-runs &lt;RUNS&gt;
          优化器运行次数

      --extra-output &lt;SELECTOR&gt;...
          在合约的 artifact 中包含额外的输出。
          
          示例键：evm.assembly、ewasm、ir、irOptimized、metadata
          
          完整描述请参见
          &lt;https://docs.soliditylang.org/en/v0.8.13/using-the-compiler.html#input-description&gt;

      --extra-output-files &lt;SELECTOR&gt;...
          写入单独文件的额外输出。
          
          有效值：metadata、ir、irOptimized、ewasm、evm.assembly

Project options:
  -o, --out &lt;PATH&gt;
          合约 artifacts 文件夹的路径

      --revert-strings &lt;REVERT&gt;
          回退字符串配置。
          
          可能的值为 "default"、"strip"（移除）、"debug"（Solidity 生成的回退字符串）和 "verboseDebug"

      --build-info
          生成构建信息文件

      --build-info-path &lt;PATH&gt;
          构建信息文件将写入的目录输出路径

      --root &lt;PATH&gt;
          项目的根路径。
          
          默认情况下是 Git 仓库的根目录（如果在 Git 仓库中），否则是当前工作目录。

  -C, --contracts &lt;PATH&gt;
          合约源目录

  -R, --remappings &lt;REMAPPINGS&gt;
          项目的 remappings

      --remappings-env &lt;ENV&gt;
          从环境获取项目的 remappings

      --cache-path &lt;PATH&gt;
          编译器缓存的路径

      --lib-paths &lt;PATH&gt;
          库文件夹的路径

      --hardhat
          使用 Hardhat 风格的项目布局。
          
          这相当于使用：`--contracts contracts --lib-paths node_modules`。
          
          [aliases: hh]

      --config-path &lt;FILE&gt;
          配置文件的路径

Watch options:
  -w, --watch [&lt;PATH&gt;...]
          监视给定的文件或目录以进行更改。
          
          如果未提供路径，则监视项目的源和测试目录。

      --no-restart
          不重新启动命令，即使它仍在运行

      --run-all
          明确地在更改时重新运行所有测试。
          
          默认情况下，仅执行上次修改的测试文件的测试。

      --watch-delay &lt;DELAY&gt;
          文件更新防抖延迟。
          
          在延迟期间，传入的更改事件被累积，只有在延迟过去后才采取行动。注意，这并不意味着命令将启动：如果给出了 --no-restart 并且命令已经在运行，行动的结果将是不做任何事情。
          
          默认值为 50ms。默认情况下解析为十进制秒，但使用带有 `ms` 后缀的整数可能更方便。
          
          在使用 --poll 模式时，您可能需要更大的持续时间，以避免过度加载磁盘 I/O。

      --show-progress
          显示测试执行进度
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># forge tree

显示项目的依赖关系图的树状可视化

```bash
$ forge tree --help
Usage: forge tree [OPTIONS]

Options:
      --no-dedupe
          不要去重（重复所有共享依赖）

      --charset &lt;CHARSET&gt;
          在输出中使用的字符集。
          
          [可能的值: utf8, ascii]
          
          [默认值: utf8]

  -h, --help
          打印帮助信息（使用 '-h' 查看摘要）

项目选项:
      --root &lt;PATH&gt;
          项目的根路径。
          
          默认情况下是 Git 仓库的根目录（如果在仓库中），或者当前工作目录。

  -C, --contracts &lt;PATH&gt;
          合约源代码目录

  -R, --remappings &lt;REMAPPINGS&gt;
          项目的重映射

      --remappings-env &lt;ENV&gt;
          从环境获取的项目重映射

      --cache-path &lt;PATH&gt;
          编译器缓存路径

      --lib-paths &lt;PATH&gt;
          库文件夹路径

      --hardhat
          使用 Hardhat 风格的项目布局。
          
          这等同于使用: `--contracts contracts --lib-paths node_modules`。
          
          [别名: hh]

      --config-path &lt;FILE&gt;
          配置文件路径
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># forge update

更新一个或多个依赖项。

```bash
$ forge update --help
Usage: forge update [OPTIONS] [DEPENDENCIES]...

Arguments:
  [DEPENDENCIES]...
          你想要更新的依赖项

Options:
      --root &lt;PATH&gt;
          项目的根路径。
          
          默认情况下是 Git 仓库的根路径（如果在 Git 仓库中），或者当前工作目录。

  -f, --force
          覆盖最新的检查

  -r, --recursive
          递归更新子模块

  -h, --help
          打印帮助信息（使用 '-h' 查看摘要）
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># forge verify-bytecode

验证已部署的字节码与其源代码

```bash
$ forge verify-bytecode --help
Usage: forge verify-bytecode [OPTIONS] &lt;ADDRESS&gt; &lt;CONTRACT&gt; [ROOT]

Arguments:
  &lt;ADDRESS&gt;
          要验证的合约地址

  &lt;CONTRACT&gt;
          合约标识符，格式为 `&lt;路径&gt;:&lt;合约名称&gt;`

  [ROOT]
          项目根目录的路径

Options:
      --block &lt;BLOCK&gt;
          应验证字节码的区块

      --constructor-args &lt;ARGS&gt;
          用于生成创建代码的构造函数参数
          
          [aliases: encoded-constructor-args]

      --constructor-args-path &lt;PATH&gt;
          包含构造函数参数的文件路径

  -r, --rpc-url &lt;RPC_URL&gt;
          用于验证的 RPC URL
          
          [env: ETH_RPC_URL=]

      --verification-type &lt;TYPE&gt;
          验证类型：`full` 或 `partial`。参考：
          &lt;https://docs.sourcify.dev/docs/full-vs-partial-match/&gt;
          
          [default: full]
          [possible values: full, partial]

  -e, --etherscan-api-key &lt;KEY&gt;
          Etherscan（或等效）API 密钥
          
          [env: ETHERSCAN_API_KEY=]

  -c, --chain &lt;CHAIN&gt;
          链名称或 EIP-155 链 ID
          
          [env: CHAIN=]

      --skip &lt;SKIP&gt;...
          跳过构建文件名包含给定过滤器的文件。
          
          `test` 和 `script` 是 `.t.sol` 和 `.s.sol` 的别名。

      --json
          抑制日志并将 JSON 结果输出到标准输出

  -h, --help
          打印帮助信息（使用 '-h' 查看摘要）
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># forge verify-check

检查在Etherscan上的验证状态

```bash
$ forge verify-check --help
Usage: forge verify-check [OPTIONS] &lt;ID&gt;

Arguments:
  &lt;ID&gt;
          验证ID。
          
          对于Etherscan - 提交GUID。
          
          对于Sourcify - 合约地址。

Options:
      --retries &lt;RETRIES&gt;
          重试验证的尝试次数
          
          [default: 5]

      --delay &lt;DELAY&gt;
          在验证尝试之间应用的可选延迟，以秒为单位
          
          [default: 5]

  -e, --etherscan-api-key &lt;KEY&gt;
          Etherscan（或等效）API密钥
          
          [env: ETHERSCAN_API_KEY=]

  -c, --chain &lt;CHAIN&gt;
          链名称或EIP-155链ID
          
          [env: CHAIN=]

  -h, --help
          打印帮助信息（使用'-h'查看摘要）

Verifier options:
      --verifier &lt;VERIFIER&gt;
          使用的合约验证提供商
          
          [default: etherscan]
          [possible values: etherscan, sourcify, blockscout, oklink]

      --verifier-url &lt;VERIFIER_URL&gt;
          如果使用自定义提供商，则为验证URL
          
          [env: VERIFIER_URL=]
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forge-verify-contract-1"><a class="header" href="#forge-verify-contract-1">forge verify-contract</a></h1>
<p>在 Etherscan 上验证智能合约</p>
<pre><code class="language-bash">$ forge verify-contract --help
Usage: forge verify-contract [OPTIONS] &lt;ADDRESS&gt; [CONTRACT]

Arguments:
  &lt;ADDRESS&gt;
          要验证的合约地址

  [CONTRACT]
          合约标识符，格式为 `&lt;路径&gt;:&lt;合约名称&gt;`

Options:
      --constructor-args &lt;ARGS&gt;
          构造函数参数的 ABI 编码
          
          [aliases: encoded-constructor-args]

      --constructor-args-path &lt;PATH&gt;
          包含构造函数参数的文件路径

      --guess-constructor-args
          尝试从链上创建代码中提取构造函数参数

      --compiler-version &lt;VERSION&gt;
          用于构建智能合约的 `solc` 版本

      --num-of-optimizations &lt;NUM&gt;
          用于构建智能合约的优化运行次数
          
          [aliases: optimizer-runs]

      --flatten
          在验证前展平源代码

  -f, --force
          在验证前不编译展平的智能合约（如果传递了 --flatten）

      --skip-is-verified-check
          在验证前不检查合约是否已验证

      --watch
          提交后等待验证结果

      --root &lt;PATH&gt;
          项目的根路径。
          
          默认情况下是 Git 仓库的根路径（如果在 Git 仓库中），或者当前工作目录。

      --show-standard-json-input
          打印标准 json 编译器输入。
          
          标准 json 编译器输入可以用于在浏览器中手动提交合约验证。

      --via-ir
          使用 Yul 中间表示编译管道

      --evm-version &lt;EVM_VERSION&gt;
          EVM 版本。
          
          覆盖配置中指定的版本。

  -e, --etherscan-api-key &lt;KEY&gt;
          Etherscan（或等效）API 密钥
          
          [env: ETHERSCAN_API_KEY=]

  -c, --chain &lt;CHAIN&gt;
          链名称或 EIP-155 链 ID
          
          [env: CHAIN=]

  -r, --rpc-url &lt;URL&gt;
          RPC 端点
          
          [env: ETH_RPC_URL=]

      --flashbots
          使用 Flashbots RPC URL 并启用快速模式（&lt;https://rpc.flashbots.net/fast&gt;）。
          
          这会私下共享交易给所有注册的构建者。
          
          参见：&lt;https://docs.flashbots.net/flashbots-protect/quick-start#faster-transactions&gt;

      --jwt-secret &lt;JWT_SECRET&gt;
          RPC 端点的 JWT 密钥。
          
          JWT 密钥将用于创建 RPC 的 JWT。例如，可以使用以下命令模拟 CL `engine_forkchoiceUpdated` 调用：
          
          cast rpc --jwt-secret &lt;JWT_SECRET&gt; engine_forkchoiceUpdatedV2
          '["0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc",
          "0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc",
          "0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc"]'
          
          [env: ETH_RPC_JWT_SECRET=]

      --retries &lt;RETRIES&gt;
          重试验证的次数
          
          [default: 5]

      --delay &lt;DELAY&gt;
          在验证尝试之间应用的可选延迟，以秒为单位
          
          [default: 5]

  -h, --help
          打印帮助信息（使用 '-h' 查看摘要）

Linker options:
      --libraries &lt;LIBRARIES&gt;
          设置预链接的库
          
          [env: DAPP_LIBRARIES=]

Verifier options:
      --verifier &lt;VERIFIER&gt;
          使用的合约验证提供者
          
          [default: etherscan]
          [possible values: etherscan, sourcify, blockscout, oklink]

      --verifier-url &lt;VERIFIER_URL&gt;
          自定义提供者的验证 URL
          
          [env: VERIFIER_URL=]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-json">{
  "translation": "# cast\n\n从命令行舒适地执行以太坊 RPC 调用\n\n```bash\n$ cast --help\nUsage: cast &lt;COMMAND&gt;\n\nCommands:\n  4byte                  从 https://openchain.xyz 获取给定选择器的函数签名 [别名: 4, 4b]\n  4byte-decode           使用 https://openchain.xyz 解码 ABI 编码的调用数据 [别名: 4d, 4bd]\n  4byte-event            从 https://openchain.xyz 获取给定 topic 0 的事件签名 [别名: 4e, 4be, topic0-event, t0e]\n  abi-decode             解码 ABI 编码的输入或输出数据 [别名: ad, --abi-decode]\n  abi-encode             对给定的函数参数进行 ABI 编码，不包括选择器 [别名: ae]\n  access-list            为交易创建访问列表 [别名: ac, acl]\n  address-zero           打印零地址 [别名: --address-zero, az]\n  admin                  获取 EIP-1967 管理员账户 [别名: adm]\n  age                    获取区块的时间戳 [别名: a]\n  balance                获取账户的余额（以 wei 为单位） [别名: b]\n  base-fee               获取区块的基础费用 [别名: ba, fee, basefee]\n  bind                   从给定的 ABI 生成 Rust 绑定 [别名: bi]\n  block                  获取区块信息 [别名: bl]\n  block-number           获取最新的区块号 [别名: bn]\n  call                   在不发布交易的情况下对账户进行调用 [别名: c]\n  calldata               ABI 编码函数及其参数 [别名: cd]\n  calldata-decode        解码 ABI 编码的输入数据 [别名: --calldata-decode, cdd]\n  chain                  获取当前链的符号名称\n  chain-id               获取以太坊链 ID [别名: ci, cid]\n  client                 获取当前客户端版本 [别名: cl]\n  code                   获取合约的运行时字节码 [别名: co]\n  codesize               获取合约的运行时字节码大小 [别名: cs]\n  completions            生成 shell 补全脚本 [别名: com]\n  compute-address        从给定的 nonce 和部署者地址计算合约地址 [别名: ca]\n  concat-hex             连接十六进制字符串 [别名: --concat-hex, ch]\n  create2                使用 CREATE2 生成确定性合约地址 [别名: c2]\n  decode-transaction     解码原始签名的 EIP 2718 类型交易 [别名: dt]\n  disassemble            将十六进制编码的字节码反汇编为单独的/人类可读的指令 [别名: da]\n  estimate               估计交易的 gas 成本 [别名: e]\n  etherscan-source       从 Etherscan 获取合约的源代码 [别名: et, src]\n  find-block             获取最接近提供时间戳的区块号 [别名: f]\n  format-bytes32-string  将字符串格式化为 bytes32 编码 [别名: --format-bytes32-string]\n  from-bin               将二进制数据转换为十六进制数据 [别名: --from-bin, from-binx, fb]\n  from-fixed-point       将定点数转换为整数 [别名: --from-fix, ff]\n  from-rlp               解码 RLP 编码的数据 [别名: --from-rlp]\n  from-utf8              将 UTF8 文本转换为十六进制 [别名: --from-ascii, --from-utf8, from-ascii, fu, fa]\n  from-wei               将 wei 转换为 ETH 金额 [别名: --from-wei, fw]\n  gas-price              获取当前的 gas 价格 [别名: g]\n  generate-fig-spec      生成 Fig 自动补全规范 [别名: fig]\n  hash-zero              打印零哈希 [别名: --hash-zero, hz]\n  help                   打印此消息或给定子命令的帮助\n  implementation         获取 EIP-1967 实现账户 [别名: impl]\n  index                  计算映射中条目的存储槽 [别名: in]\n  index-erc7201          按照 `ERC-7201: Namespaced Storage Layout` 计算存储槽 [别名: index7201, in7201]\n  interface              从给定的 ABI 生成 Solidity 接口 [别名: i]\n  keccak                 使用 Keccak-256 哈希任意数据 [别名: k, keccak256]\n  logs                   按签名或 topic 获取日志 [别名: l]\n  lookup-address         执行 ENS 反向查找 [别名: la]\n  max-int                打印给定整数类型的最大值 [别名: --max-int, maxi]\n  max-uint               打印给定整数类型的最大值 [别名: --max-uint, maxu]\n  min-int                打印给定整数类型的最小值 [别名: --min-int, mini]\n  mktx                   构建并签署交易 [别名: m]\n  namehash               计算 ENS 名称的 namehash [别名: na, nh]\n  nonce                  获取账户的 nonce [别名: n]\n  parse-bytes32-address  从 bytes32 编码解析校验和地址 [别名: --parse-bytes32-address]\n  parse-bytes32-string   从 bytes32 编码解析字符串 [别名: --parse-bytes32-string]\n  pretty-calldata        美化打印调用数据 [别名: pc]\n  proof                  为给定的存储槽生成存储证明 [别名: pr]\n  publish                将原始交易发布到网络 [别名: p]\n  receipt                获取交易的收据 [别名: re]\n  resolve-name           执行 ENS 查找 [别名: rn]\n  rpc                    执行原始 JSON-RPC 请求 [别名: rp]\n  run                    在本地环境中运行已发布的交易并打印跟踪 [别名: r]\n  selectors              从字节码中提取函数选择器和参数 [别名: sel]\n  send                   签署并发布交易 [别名: s]\n  shl                    执行左移操作\n  shr                    执行右移操作\n  sig                    获取函数的签名 [别名: si]\n  sig-event              从事件字符串生成事件签名 [别名: se]\n  storage                获取合约存储槽的原始值 [别名: st]\n  to-ascii               将十六进制数据转换为 ASCII 字符串 [别名: --to-ascii, tas, 2as]\n  to-base                将一个基数的数字转换为另一个基数 [别名: --to-base, --to-radix, to-radix, tr, 2r]\n  to-bytes32             将十六进制数据右填充到 32 字节 [别名: --to-bytes32, tb, 2b]\n  to-check-sum-address   将地址转换为校验和格式（EIP-55） [别名: --to-checksum-address, --to-checksum, to-checksum, ta, 2a]\n  to-dec                 将一个基数的数字转换为十进制 [别名: --to-dec, td, 2d]\n  to-fixed-point         将整数转换为定点数 [别名: --to-fix, tf, 2f]\n  to-hex                 将一个基数的数字转换为另一个基数 [别名: --to-hex, th, 2h]\n  to-hexdata             将输入规范化为小写、0x 前缀的十六进制 [别名: --to-hexdata, thd, 2hd]\n  to-int256              将数字转换为十六进制编码的 int256 [别名: --to-int256, ti, 2i]\n  to-rlp                 RLP 编码十六进制数据或十六进制数据数组 [别名: --to-rlp]\n  to-uint256             将数字转换为十六进制编码的 uint256 [别名: --to-uint256, tu, 2u]\n  to-unit                将 ETH 金额转换为其他单位（ether、gwei 或 wei） [别名: --to-unit, tun, 2un]\n  to-utf8                将十六进制数据转换为 utf-8 字符串 [别名: --to-utf8, tu8, 2u8]\n  to-wei                 将 ETH 金额转换为 wei [别名: --to-wei, tw, 2w]\n  tx                     获取交易信息 [别名: t]\n  upload-signature       将给定的签名上传到 https://openchain.xyz [别名: ups]\n  wallet                 钱包管理工具 [别名: w]\n\nOptions:\n  -h, --help     打印帮助\n  -V, --version  打印版本\n\n在书中找到更多信息: http://book.getfoundry.sh/reference/cast/cast.html\n```"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># cast 4byte

从 https://openchain.xyz 获取给定选择器的函数签名

```bash
$ cast 4byte --help
用法: cast 4byte [SELECTOR]

参数:
  [SELECTOR]  函数选择器

选项:
  -h, --help  打印帮助信息
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># cast 4byte-decode

使用 https://openchain.xyz 解码 ABI 编码的调用数据

```bash
$ cast 4byte-decode --help
Usage: cast 4byte-decode [CALLDATA]

Arguments:
  [CALLDATA]   ABI 编码的调用数据

Options:
  -h, --help  打印帮助信息
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># cast 4byte-event

从 https://openchain.xyz 获取给定 topic 0 的事件签名。

```bash
$ cast 4byte-event --help
Usage: cast 4byte-event [TOPIC_0]

Arguments:
  [TOPIC_0]  主题 0

Options:
  -h, --help  打印帮助信息
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># cast abi-decode

解码 ABI 编码的输入或输出数据。

```bash
$ cast abi-decode --help
Usage: cast abi-decode [OPTIONS] &lt;SIG&gt; &lt;CALLDATA&gt;

Arguments:
  &lt;SIG&gt;
          函数签名，格式为 `&lt;name&gt;(&lt;in-types&gt;)(&lt;out-types&gt;)`

  &lt;CALLDATA&gt;
          ABI 编码的 calldata

Options:
  -h, --help
          打印帮助信息（使用 '-h' 查看简要帮助）

解码输入数据而不是输出数据：
  -i, --input
          是否解码输入数据或输出数据
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># cast abi-encode

ABI 编码给定的函数参数，不包括选择器

```bash
$ cast abi-encode --help
Usage: cast abi-encode [OPTIONS] &lt;SIG&gt; [ARGS]...

Arguments:
  &lt;SIG&gt;      函数签名
  [ARGS]...  函数的参数

Options:
      --packed  是否使用紧凑编码
  -h, --help    打印帮助信息
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># cast access-list

创建一个用于交易的访问列表

```bash
$ cast access-list --help
Usage: cast access-list [OPTIONS] [TO] [SIG] [ARGS]...

Arguments:
  [TO]
          交易的目标地址

  [SIG]
          要调用的函数的签名

  [ARGS]...
          要调用的函数的参数

Options:
  -B, --block &lt;BLOCK&gt;
          查询的区块高度。
          
          也可以是以下标签之一：earliest, finalized, safe, latest, 或 pending。

  -h, --help
          打印帮助信息（使用 '-h' 查看摘要）

Display options:
  -j, --json
          以 JSON 格式打印访问列表

Transaction options:
      --gas-limit &lt;GAS_LIMIT&gt;
          交易的 gas 限制
          
          [env: ETH_GAS_LIMIT=]

      --gas-price &lt;PRICE&gt;
          传统交易的 gas 价格，或 EIP1559 交易的每 gas 最大费用
          
          [env: ETH_GAS_PRICE=]

      --priority-gas-price &lt;PRICE&gt;
          EIP1559 交易的每 gas 最大优先费用
          
          [env: ETH_PRIORITY_GAS_PRICE=]

      --value &lt;VALUE&gt;
          交易中发送的以太币，可以是以 wei 为单位指定，或以带单位的字符串指定。
          
          例如：1ether, 10gwei, 0.01ether

      --nonce &lt;NONCE&gt;
          交易的 nonce

      --legacy
          发送传统交易而不是 EIP1559 交易。
          
          在没有 EIP1559 的常见网络上会自动启用。

      --blob
          发送 EIP-4844 blob 交易

      --blob-gas-price &lt;BLOB_PRICE&gt;
          EIP-4844 blob 交易的 gas 价格
          
          [env: ETH_BLOB_GAS_PRICE=]

Ethereum options:
  -r, --rpc-url &lt;URL&gt;
          RPC 端点
          
          [env: ETH_RPC_URL=]

      --flashbots
          使用 Flashbots RPC URL 并启用快速模式（&lt;https://rpc.flashbots.net/fast&gt;）。
          
          这将私密地与所有注册的构建者共享交易。
          
          参见：&lt;https://docs.flashbots.net/flashbots-protect/quick-start#faster-transactions&gt;

      --jwt-secret &lt;JWT_SECRET&gt;
          RPC 端点的 JWT 密钥。
          
          JWT 密钥将用于创建 RPC 的 JWT。例如，可以使用以下命令模拟 CL `engine_forkchoiceUpdated` 调用：
          
          cast rpc --jwt-secret &lt;JWT_SECRET&gt; engine_forkchoiceUpdatedV2
          '["0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc",
          "0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc",
          "0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc"]'
          
          [env: ETH_RPC_JWT_SECRET=]

  -e, --etherscan-api-key &lt;KEY&gt;
          Etherscan（或类似）API 密钥
          
          [env: ETHERSCAN_API_KEY=]

  -c, --chain &lt;CHAIN&gt;
          链名称或 EIP-155 链 ID
          
          [env: CHAIN=]

Wallet options - raw:
  -f, --from &lt;ADDRESS&gt;
          发送者账户
          
          [env: ETH_FROM=]

  -i, --interactive
          打开交互式提示以输入您的私钥

      --private-key &lt;RAW_PRIVATE_KEY&gt;
          使用提供的私钥

      --mnemonic &lt;MNEMONIC&gt;
          使用指定路径的助记词文件的助记词短语

      --mnemonic-passphrase &lt;PASSPHRASE&gt;
          使用助记词的 BIP39 密码短语

      --mnemonic-derivation-path &lt;PATH&gt;
          钱包派生路径。
          
          适用于 --mnemonic-path 和硬件钱包。

      --mnemonic-index &lt;INDEX&gt;
          使用给定助记词索引的私钥。
          
          与 --mnemonic-path 一起使用。
          
          [default: 0]

Wallet options - keystore:
      --keystore &lt;PATH&gt;
          使用给定文件夹或文件中的 keystore
          
          [env: ETH_KEYSTORE=]

      --account &lt;ACCOUNT_NAME&gt;
          通过其文件名从默认 keystore 文件夹（~/.foundry/keystores）中使用 keystore
          
          [env: ETH_KEYSTORE_ACCOUNT=]

      --password &lt;PASSWORD&gt;
          keystore 密码。
          
          与 --keystore 一起使用。

      --password-file &lt;PASSWORD_FILE&gt;
          keystore 密码文件路径。
          
          与 --keystore 一起使用。
          
          [env: ETH_PASSWORD=]

Wallet options - hardware wallet:
  -l, --ledger
          使用 Ledger 硬件钱包

  -t, --trezor
          使用 Trezor 硬件钱包

Wallet options - remote:
      --aws
          使用 AWS Key Management Service
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-json">{
  "translation": "# 打印零地址\n\n打印零地址\n\n```bash\n$ cast address-zero --help\nUsage: cast address-zero\n\nOptions:\n  -h, --help  打印帮助信息\n```"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-json">{
  "translation": "# cast admin\n\n获取 EIP-1967 管理员账户\n\n```bash\n$ cast admin --help\nUsage: cast admin [OPTIONS] &lt;WHO&gt;\n\nArguments:\n  &lt;WHO&gt;\n          要获取 nonce 的地址\n\nOptions:\n  -B, --block &lt;BLOCK&gt;\n          查询的区块高度。\n          \n          也可以是以下标签之一：earliest、finalized、safe、latest 或 pending。\n\n  -r, --rpc-url &lt;URL&gt;\n           RPC 端点\n          \n          [env: ETH_RPC_URL=]\n\n      --flashbots\n          使用 Flashbots RPC URL 并启用快速模式（&lt;https://rpc.flashbots.net/fast&gt;）。\n          \n          这将私密地与所有注册的构建者共享交易。\n          \n          参见：&lt;https://docs.flashbots.net/flashbots-protect/quick-start#faster-transactions&gt;\n\n      --jwt-secret &lt;JWT_SECRET&gt;\n          RPC 端点的 JWT 密钥。\n          \n          JWT 密钥将用于创建 RPC 的 JWT。例如，可以使用以下命令模拟 CL `engine_forkchoiceUpdated` 调用：\n          \n          cast rpc --jwt-secret &lt;JWT_SECRET&gt; engine_forkchoiceUpdatedV2\n          '[\"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\",\n          \"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\",\n          \"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\"]'\n          \n          [env: ETH_RPC_JWT_SECRET=]\n\n  -h, --help\n          打印帮助信息（使用 '-h' 查看摘要）\n```"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-json">{
  "title": "获取区块的时间戳",
  "description": "获取一个区块的时间戳",
  "usage": "```bash\n$ cast age --help\nUsage: cast age [OPTIONS] [BLOCK]\n\nArguments:\n  [BLOCK]\n          The block height to query at.\n          \n          Can also be the tags earliest, finalized, safe, latest, or pending.\n\nOptions:\n  -r, --rpc-url &lt;URL&gt;\n          The RPC endpoint\n          \n          [env: ETH_RPC_URL=]\n\n      --flashbots\n          Use the Flashbots RPC URL with fast mode (&lt;https://rpc.flashbots.net/fast&gt;).\n          \n          This shares the transaction privately with all registered builders.\n          \n          See: &lt;https://docs.flashbots.net/flashbots-protect/quick-start#faster-transactions&gt;\n\n      --jwt-secret &lt;JWT_SECRET&gt;\n          JWT Secret for the RPC endpoint.\n          \n          The JWT secret will be used to create a JWT for a RPC. For example, the following can be\n          used to simulate a CL `engine_forkchoiceUpdated` call:\n          \n          cast rpc --jwt-secret &lt;JWT_SECRET&gt; engine_forkchoiceUpdatedV2\n          '[\"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\",\n          \"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\",\n          \"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\"]'\n          \n          [env: ETH_RPC_JWT_SECRET=]\n\n  -h, --help\n          Print help (see a summary with '-h')\n```"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-json">{
  "translation": "# 查询余额\n\n获取账户的余额，单位为 wei\n\n```bash\n$ cast balance --help\nUsage: cast balance [OPTIONS] &lt;WHO&gt;\n\nArguments:\n  &lt;WHO&gt;\n          要查询的账户\n\nOptions:\n  -B, --block &lt;BLOCK&gt;\n          查询的区块高度。\n          \n          也可以是标签 earliest, finalized, safe, latest, 或 pending。\n\n  -e, --ether\n          以 ether 格式显示余额\n\n  -r, --rpc-url &lt;URL&gt;\n           RPC 端点\n          \n          [env: ETH_RPC_URL=]\n\n      --flashbots\n          使用 Flashbots RPC URL 并启用快速模式（&lt;https://rpc.flashbots.net/fast&gt;）。\n          \n          这将私密地与所有注册的构建者共享交易。\n          \n          参见：&lt;https://docs.flashbots.net/flashbots-protect/quick-start#faster-transactions&gt;\n\n      --jwt-secret &lt;JWT_SECRET&gt;\n          RPC 端点的 JWT 密钥。\n          \n          JWT 密钥将用于创建 RPC 的 JWT。例如，可以使用以下命令模拟 CL `engine_forkchoiceUpdated` 调用：\n          \n          cast rpc --jwt-secret &lt;JWT_SECRET&gt; engine_forkchoiceUpdatedV2\n          '[\"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\",\n          \"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\",\n          \"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\"]'\n          \n          [env: ETH_RPC_JWT_SECRET=]\n\n      --erc20 &lt;ERC20&gt;\n          要查询的 erc20 地址，使用方法 `balanceOf(address) return (uint256)`，别名 '--erc721'\n\n  -h, --help\n          打印帮助信息（使用 '-h' 查看摘要）\n```"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-json">{
  "title": "获取基础费用",
  "description": "获取区块的基础费用",
  "usage": "```bash\n$ cast base-fee --help\nUsage: cast base-fee [OPTIONS] [BLOCK]\n\nArguments:\n  [BLOCK]\n          要查询的区块高度。\n          \n          也可以是标签 earliest, finalized, safe, latest, 或 pending。\n\nOptions:\n  -r, --rpc-url &lt;URL&gt;\n           RPC 端点\n          \n          [env: ETH_RPC_URL=]\n\n      --flashbots\n          使用 Flashbots RPC URL 并启用快速模式（&lt;https://rpc.flashbots.net/fast&gt;）。\n          \n          这将私密地与所有注册的构建者共享交易。\n          \n          参见：&lt;https://docs.flashbots.net/flashbots-protect/quick-start#faster-transactions&gt;\n\n      --jwt-secret &lt;JWT_SECRET&gt;\n          RPC 端点的 JWT 密钥。\n          \n          JWT 密钥将用于创建 RPC 的 JWT。例如，可以使用以下命令模拟 CL `engine_forkchoiceUpdated` 调用：\n          \n          cast rpc --jwt-secret &lt;JWT_SECRET&gt; engine_forkchoiceUpdatedV2\n          '[\"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\",\n          \"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\",\n          \"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\"]'\n          \n          [env: ETH_RPC_JWT_SECRET=]\n\n  -h, --help\n          打印帮助信息（使用 '-h' 查看摘要）\n```"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-json">{
  "translation": "# cast bind\n\n从给定的 ABI 生成 Rust 绑定\n\n```bash\n$ cast bind --help\nUsage: cast bind [OPTIONS] &lt;PATH_OR_ADDRESS&gt;\n\nArguments:\n  &lt;PATH_OR_ADDRESS&gt;\n          合约地址，或 ABI 目录的路径\n          \n          如果指定了地址，则从 Etherscan 获取 ABI。\n\nOptions:\n  -o, --output-dir &lt;PATH&gt;\n          绑定文件存储的路径\n\n      --crate-name &lt;NAME&gt;\n          Rust crate 的名称。\n          \n          这应该是一个有效的 crates.io crate 名称。然而，目前该命令不会验证这一点。\n          \n          [default: foundry-contracts]\n\n      --crate-version &lt;VERSION&gt;\n          Rust crate 的版本。\n          \n          这应该是一个标准的 semver 版本字符串。然而，目前该命令不会验证这一点。\n          \n          [default: 0.0.1]\n\n      --separate-files\n          生成单独的绑定文件\n\n  -e, --etherscan-api-key &lt;KEY&gt;\n          Etherscan（或类似的）API 密钥\n          \n          [env: ETHERSCAN_API_KEY=]\n\n  -c, --chain &lt;CHAIN&gt;\n          链名称或 EIP-155 链 ID\n          \n          [env: CHAIN=]\n\n  -h, --help\n          打印帮助信息（使用 '-h' 查看摘要）\n```"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># cast block

获取区块信息

```bash
$ cast block --help
Usage: cast block [OPTIONS] [BLOCK]

Arguments:
  [BLOCK]
          查询的区块高度。
          
          也可以是标签 earliest, finalized, safe, latest, 或 pending。

Options:
  -f, --field &lt;FIELD&gt;
          如果指定，仅获取区块的指定字段

      --full
          [env: CAST_FULL_BLOCK=]

  -r, --rpc-url &lt;URL&gt;
          RPC 端点
          
          [env: ETH_RPC_URL=]

      --flashbots
          使用 Flashbots RPC URL 并启用快速模式（&lt;https://rpc.flashbots.net/fast&gt;）。
          
          这将私密地与所有注册的构建者共享交易。
          
          参见：&lt;https://docs.flashbots.net/flashbots-protect/quick-start#faster-transactions&gt;

      --jwt-secret &lt;JWT_SECRET&gt;
          RPC 端点的 JWT 密钥。
          
          JWT 密钥将用于创建 RPC 的 JWT。例如，可以使用以下命令模拟 CL `engine_forkchoiceUpdated` 调用：
          
          cast rpc --jwt-secret &lt;JWT_SECRET&gt; engine_forkchoiceUpdatedV2
          '["0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc",
          "0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc",
          "0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc"]'
          
          [env: ETH_RPC_JWT_SECRET=]

  -h, --help
          打印帮助信息（使用 '-h' 查看摘要）

显示选项:
  -j, --json
          以 JSON 格式打印区块
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-json">{
  "translation": "# 获取最新区块号\n\n```bash\n$ cast block-number --help\nUsage: cast block-number [OPTIONS] [BLOCK]\n\nArguments:\n  [BLOCK]\n          要查询的哈希或标签。如果未指定，则返回最新的区块号\n\nOptions:\n  -r, --rpc-url &lt;URL&gt;\n           RPC 端点\n          \n          [env: ETH_RPC_URL=]\n\n      --flashbots\n          使用 Flashbots RPC URL 并启用快速模式（&lt;https://rpc.flashbots.net/fast&gt;）。\n          \n          这将私密地与所有注册的构建者共享交易。\n          \n          参见：&lt;https://docs.flashbots.net/flashbots-protect/quick-start#faster-transactions&gt;\n\n      --jwt-secret &lt;JWT_SECRET&gt;\n          RPC 端点的 JWT 密钥。\n          \n          JWT 密钥将用于创建 RPC 的 JWT。例如，可以使用以下命令模拟 CL `engine_forkchoiceUpdated` 调用：\n          \n          cast rpc --jwt-secret &lt;JWT_SECRET&gt; engine_forkchoiceUpdatedV2\n          '[\"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\",\n          \"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\",\n          \"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\"]'\n          \n          [env: ETH_RPC_JWT_SECRET=]\n\n  -h, --help\n          打印帮助信息（使用 '-h' 查看摘要）\n```"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># cast call

在不发布交易的情况下对账户执行调用

```bash
$ cast call --help
Usage: cast call [OPTIONS] [TO] [SIG] [ARGS]... [COMMAND]

Commands:
  --create  忽略地址字段并模拟创建合约
  help      打印此消息或给定子命令的帮助信息

Arguments:
  [TO]
          交易的接收方

  [SIG]
          要调用的函数的签名

  [ARGS]...
          要调用的函数的参数

Options:
      --data &lt;DATA&gt;
          交易的数据

      --trace
          分叉远程RPC，在本地执行交易并打印追踪信息

      --debug
          打开交互式调试器。只能与 `--trace` 一起使用

      --labels &lt;LABELS&gt;
          应用于追踪的标签；格式：`address:label`。只能与 `--trace` 一起使用

      --evm-version &lt;EVM_VERSION&gt;
          使用的EVM版本。只能与 `--trace` 一起使用

  -b, --block &lt;BLOCK&gt;
          查询的区块高度。
          
          也可以是标签 earliest, finalized, safe, latest, 或 pending。

  -h, --help
          打印帮助信息（使用 '-h' 查看摘要）

Transaction options:
      --gas-limit &lt;GAS_LIMIT&gt;
          交易的 gas 限制
          
          [env: ETH_GAS_LIMIT=]

      --gas-price &lt;PRICE&gt;
          传统交易的 gas 价格，或 EIP1559 交易的每 gas 最大费用
          
          [env: ETH_GAS_PRICE=]

      --priority-gas-price &lt;PRICE&gt;
          EIP1559 交易的每 gas 最大优先费用
          
          [env: ETH_PRIORITY_GAS_PRICE=]

      --value &lt;VALUE&gt;
          交易中发送的以太币，可以是以 wei 为单位指定，或以带单位的字符串指定。
          
          示例：1ether, 10gwei, 0.01ether

      --nonce &lt;NONCE&gt;
          交易的 nonce

      --legacy
          发送传统交易而不是 EIP1559 交易。
          
          对于没有 EIP1559 的常见网络会自动启用。

      --blob
          发送 EIP-4844 blob 交易

      --blob-gas-price &lt;BLOB_PRICE&gt;
          EIP-4844 blob 交易的 gas 价格
          
          [env: ETH_BLOB_GAS_PRICE=]

Ethereum options:
  -r, --rpc-url &lt;URL&gt;
          RPC 端点
          
          [env: ETH_RPC_URL=]

      --flashbots
          使用 Flashbots RPC URL 并启用快速模式（&lt;https://rpc.flashbots.net/fast&gt;）。
          
          这将私密地与所有注册的构建者共享交易。
          
          参见：&lt;https://docs.flashbots.net/flashbots-protect/quick-start#faster-transactions&gt;

      --jwt-secret &lt;JWT_SECRET&gt;
          RPC 端点的 JWT 密钥。
          
          JWT 密钥将用于创建 RPC 的 JWT。例如，以下可以用于模拟 CL `engine_forkchoiceUpdated` 调用：
          
          cast rpc --jwt-secret &lt;JWT_SECRET&gt; engine_forkchoiceUpdatedV2
          '["0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc",
          "0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc",
          "0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc"]'
          
          [env: ETH_RPC_JWT_SECRET=]

  -e, --etherscan-api-key &lt;KEY&gt;
          Etherscan（或等效）API 密钥
          
          [env: ETHERSCAN_API_KEY=]

  -c, --chain &lt;CHAIN&gt;
          链名称或 EIP-155 链 ID
          
          [env: CHAIN=]

Wallet options - raw:
  -f, --from &lt;ADDRESS&gt;
          发送方账户
          
          [env: ETH_FROM=]

  -i, --interactive
          打开交互式提示以输入您的私钥

      --private-key &lt;RAW_PRIVATE_KEY&gt;
          使用提供的私钥

      --mnemonic &lt;MNEMONIC&gt;
          使用指定路径的助记词文件的助记词短语

      --mnemonic-passphrase &lt;PASSPHRASE&gt;
          使用助记词的 BIP39 密码短语

      --mnemonic-derivation-path &lt;PATH&gt;
          钱包派生路径。
          
          适用于 --mnemonic-path 和硬件钱包。

      --mnemonic-index &lt;INDEX&gt;
          使用给定助记词索引的私钥。
          
          与 --mnemonic-path 一起使用。
          
          [default: 0]

Wallet options - keystore:
      --keystore &lt;PATH&gt;
          使用给定文件夹或文件中的 keystore
          
          [env: ETH_KEYSTORE=]

      --account &lt;ACCOUNT_NAME&gt;
          使用默认 keystores 文件夹（~/.foundry/keystores）中按文件名指定的 keystore
          
          [env: ETH_KEYSTORE_ACCOUNT=]

      --password &lt;PASSWORD&gt;
          keystore 密码。
          
          与 --keystore 一起使用。

      --password-file &lt;PASSWORD_FILE&gt;
          keystore 密码文件路径。
          
          与 --keystore 一起使用。
          
          [env: ETH_PASSWORD=]

Wallet options - hardware wallet:
  -l, --ledger
          使用 Ledger 硬件钱包

  -t, --trezor
          使用 Trezor 硬件钱包

Wallet options - remote:
      --aws
          使用 AWS 密钥管理服务
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># cast call --create

忽略地址字段并模拟创建合约

```bash
$ cast call --create --help
Usage: cast call --create [OPTIONS] &lt;CODE&gt; [SIG] [ARGS]...

Arguments:
  &lt;CODE&gt;
          合约的字节码

  [SIG]
          构造函数的签名

  [ARGS]...
          构造函数的参数

Options:
      --value &lt;VALUE&gt;
          交易中发送的以太币数量。
          
          可以以wei为单位指定，或以带单位类型的字符串指定。
          
          示例：1ether, 10gwei, 0.01ether

  -h, --help
          打印帮助信息（使用'-h'查看摘要）
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># 编码调用数据

ABI 编码带有参数的函数

```bash
$ cast calldata --help
Usage: cast calldata &lt;SIG&gt; [ARGS]...

Arguments:
  &lt;SIG&gt;      函数签名，格式为 `&lt;name&gt;(&lt;in-types&gt;)(&lt;out-types&gt;)`
  [ARGS]...  要编码的参数

Options:
  -h, --help  打印帮助信息
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># cast calldata-decode

解码 ABI 编码的输入数据。

```bash
$ cast calldata-decode --help
Usage: cast calldata-decode &lt;SIG&gt; &lt;CALLDATA&gt;

Arguments:
  &lt;SIG&gt;
          函数签名，格式为 `&lt;name&gt;(&lt;in-types&gt;)(&lt;out-types&gt;)`

  &lt;CALLDATA&gt;
          ABI 编码的 calldata

Options:
  -h, --help
          打印帮助信息（使用 '-h' 查看简要帮助）
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-json">{
  "translation": "# 获取当前链的符号名称\n\n```bash\n$ cast chain --help\nUsage: cast chain [OPTIONS]\n\nOptions:\n  -r, --rpc-url &lt;URL&gt;\n          指定 RPC 端点\n          \n          [env: ETH_RPC_URL=]\n\n      --flashbots\n          使用 Flashbots RPC URL 并启用快速模式（&lt;https://rpc.flashbots.net/fast&gt;）。\n          \n          这将私密地与所有注册的构建者共享交易。\n          \n          参见：&lt;https://docs.flashbots.net/flashbots-protect/quick-start#faster-transactions&gt;\n\n      --jwt-secret &lt;JWT_SECRET&gt;\n          RPC 端点的 JWT 密钥。\n          \n          JWT 密钥将用于创建 RPC 的 JWT。例如，可以使用以下命令模拟 CL `engine_forkchoiceUpdated` 调用：\n          \n          cast rpc --jwt-secret &lt;JWT_SECRET&gt; engine_forkchoiceUpdatedV2\n          '[\"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\",\n          \"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\",\n          \"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\"]'\n          \n          [env: ETH_RPC_JWT_SECRET=]\n\n  -h, --help\n          打印帮助信息（使用 '-h' 查看摘要）\n```"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># cast chain-id

获取以太坊链 ID

```bash
$ cast chain-id --help
Usage: cast chain-id [OPTIONS]

Options:
  -r, --rpc-url &lt;URL&gt;
          指定 RPC 端点
          
          [env: ETH_RPC_URL=]

      --flashbots
          使用 Flashbots RPC URL 并启用快速模式（&lt;https://rpc.flashbots.net/fast&gt;）。
          
          这将私密地与所有注册的构建者共享交易。
          
          参见：&lt;https://docs.flashbots.net/flashbots-protect/quick-start#faster-transactions&gt;

      --jwt-secret &lt;JWT_SECRET&gt;
          指定 RPC 端点的 JWT 密钥。
          
          JWT 密钥将用于创建 RPC 的 JWT。例如，可以使用以下命令模拟 CL `engine_forkchoiceUpdated` 调用：
          
          cast rpc --jwt-secret &lt;JWT_SECRET&gt; engine_forkchoiceUpdatedV2
          '["0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc",
          "0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc",
          "0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc"]'
          
          [env: ETH_RPC_JWT_SECRET=]

  -h, --help
          打印帮助信息（使用 '-h' 查看摘要）
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-json">{
  "translation": "# cast client\n\n获取当前客户端版本\n\n```bash\n$ cast client --help\nUsage: cast client [OPTIONS]\n\nOptions:\n  -r, --rpc-url &lt;URL&gt;\n          指定 RPC 端点\n          \n          [env: ETH_RPC_URL=]\n\n      --flashbots\n          使用 Flashbots RPC URL 并启用快速模式（&lt;https://rpc.flashbots.net/fast&gt;）。\n          \n          这将私密地与所有注册的构建者共享交易。\n          \n          参见：&lt;https://docs.flashbots.net/flashbots-protect/quick-start#faster-transactions&gt;\n\n      --jwt-secret &lt;JWT_SECRET&gt;\n          RPC 端点的 JWT 密钥。\n          \n          JWT 密钥将用于创建 RPC 的 JWT。例如，可以使用以下命令模拟 CL `engine_forkchoiceUpdated` 调用：\n          \n          cast rpc --jwt-secret &lt;JWT_SECRET&gt; engine_forkchoiceUpdatedV2\n          '[\"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\",\n          \"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\",\n          \"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\"]'\n          \n          [env: ETH_RPC_JWT_SECRET=]\n\n  -h, --help\n          打印帮助信息（使用 '-h' 查看摘要）\n```"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-json">{
  "translation": "# 获取合约代码"
}
</code></pre>
<pre><code class="language-json">{
  "translation": "获取合约的运行时字节码"
}
</code></pre>
<pre><code class="language-json">{
  "translation": "```bash\n$ cast code --help\nUsage: cast code [OPTIONS] &lt;WHO&gt;\n\nArguments:\n  &lt;WHO&gt;\n          合约地址\n\nOptions:\n  -B, --block &lt;BLOCK&gt;\n          查询的区块高度。\n          \n          也可以是 earliest, finalized, safe, latest, 或 pending 这些标签。\n\n  -d, --disassemble\n          将字节码反汇编为单个操作码\n\n  -r, --rpc-url &lt;URL&gt;\n           RPC 端点\n          \n          [env: ETH_RPC_URL=]\n\n      --flashbots\n          使用 Flashbots RPC URL 并启用快速模式（&lt;https://rpc.flashbots.net/fast&gt;）。\n          \n          这将私密地与所有注册的构建者共享交易。\n          \n          参见：&lt;https://docs.flashbots.net/flashbots-protect/quick-start#faster-transactions&gt;\n\n      --jwt-secret &lt;JWT_SECRET&gt;\n          RPC 端点的 JWT 密钥。\n          \n          JWT 密钥将用于创建 RPC 的 JWT。例如，可以使用以下命令模拟 CL `engine_forkchoiceUpdated` 调用：\n          \n          cast rpc --jwt-secret &lt;JWT_SECRET&gt; engine_forkchoiceUpdatedV2\n          '[\"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\",\n          \"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\",\n          \"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\"]'\n          \n          [env: ETH_RPC_JWT_SECRET=]\n\n  -h, --help\n          打印帮助信息（使用 '-h' 查看摘要）\n```"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-json">{
  "translation": "# cast codesize\n\n获取合约的运行时字节码大小\n\n```bash\n$ cast codesize --help\nUsage: cast codesize [OPTIONS] &lt;WHO&gt;\n\nArguments:\n  &lt;WHO&gt;\n          合约地址\n\nOptions:\n  -B, --block &lt;BLOCK&gt;\n          查询的区块高度。\n          \n          也可以是标签 earliest, finalized, safe, latest, 或 pending。\n\n  -r, --rpc-url &lt;URL&gt;\n          RPC 端点\n          \n          [env: ETH_RPC_URL=]\n\n      --flashbots\n          使用 Flashbots RPC URL 并启用快速模式（&lt;https://rpc.flashbots.net/fast&gt;）。\n          \n          这将私密地与所有注册的构建者共享交易。\n          \n          参见：&lt;https://docs.flashbots.net/flashbots-protect/quick-start#faster-transactions&gt;\n\n      --jwt-secret &lt;JWT_SECRET&gt;\n          RPC 端点的 JWT 密钥。\n          \n          JWT 密钥将用于创建 RPC 的 JWT。例如，可以使用以下命令模拟 CL `engine_forkchoiceUpdated` 调用：\n          \n          cast rpc --jwt-secret &lt;JWT_SECRET&gt; engine_forkchoiceUpdatedV2\n          '[\"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\",\n          \"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\",\n          \"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\"]'\n          \n          [env: ETH_RPC_JWT_SECRET=]\n\n  -h, --help\n          打印帮助信息（使用 '-h' 查看摘要）\n```"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-json">{
  "translation": "# 生成 shell 补全脚本\n\n```bash\n$ cast completions --help\nUsage: cast completions &lt;SHELL&gt;\n\nArguments:\n  &lt;SHELL&gt;  [possible values: bash, elvish, fish, powershell, zsh]\n\nOptions:\n  -h, --help  打印帮助信息\n```"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cast-compute-address"><a class="header" href="#cast-compute-address">cast compute-address</a></h1>
<p>计算给定nonce和部署者地址的合约地址</p>
<pre><code class="language-bash">$ cast compute-address --help
Usage: cast compute-address [OPTIONS] [ADDRESS]

Arguments:
  [ADDRESS]
          部署者地址

Options:
      --nonce &lt;NONCE&gt;
          部署者地址的nonce

  -r, --rpc-url &lt;URL&gt;
          RPC 端点
          
          [env: ETH_RPC_URL=]

      --flashbots
          使用Flashbots RPC URL并启用快速模式（&lt;https://rpc.flashbots.net/fast&gt;）。
          
          这将私密地与所有注册的构建者共享交易。
          
          参见：&lt;https://docs.flashbots.net/flashbots-protect/quick-start#faster-transactions&gt;

      --jwt-secret &lt;JWT_SECRET&gt;
          RPC 端点的JWT密钥。
          
          JWT密钥将用于创建RPC的JWT。例如，可以使用以下命令模拟CL `engine_forkchoiceUpdated`调用：
          
          cast rpc --jwt-secret &lt;JWT_SECRET&gt; engine_forkchoiceUpdatedV2
          '["0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc",
          "0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc",
          "0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc"]'
          
          [env: ETH_RPC_JWT_SECRET=]

  -h, --help
          打印帮助信息（使用'-h'查看摘要）
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cast-concat-hex"><a class="header" href="#cast-concat-hex">cast concat-hex</a></h1>
<p>连接十六进制字符串</p>
<pre><code class="language-bash">$ cast concat-hex --help
用法: cast concat-hex [数据]...

参数:
  [数据]...  要连接的数据

选项:
  -h, --help  打印帮助信息
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-json">{
  "translation": "# cast create2\n\n使用CREATE2生成一个确定性的合约地址\n\n```bash\n$ cast create2 --help\nUsage: cast create2 [OPTIONS]\n\nOptions:\n  -s, --starts-with &lt;HEX&gt;      合约地址的前缀\n  -e, --ends-with &lt;HEX&gt;        合约地址的后缀\n  -m, --matching &lt;HEX&gt;         地址必须匹配的序列\n  -c, --case-sensitive         区分大小写匹配\n  -d, --deployer &lt;ADDRESS&gt;     合约部署者的地址 [默认: 0x4e59b44847b379578588920ca78fbf26c0b4956c]\n  -i, --init-code &lt;HEX&gt;        要部署的合约的初始代码\n      --init-code-hash &lt;HASH&gt;  要部署的合约的初始代码哈希\n  -j, --jobs &lt;JOBS&gt;            使用的线程数。默认值和上限为逻辑核心数\n      --caller &lt;ADDRESS&gt;       调用者的地址。用于盐的前20个字节\n      --seed &lt;HEX&gt;             随机数生成器的种子，用于初始化盐\n      --no-random              不使用随机值初始化盐，而是使用默认值0\n  -h, --help                   打印帮助信息\n```"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># cast decode-transaction

解码原始的已签名 EIP 2718 类型交易

```bash
$ cast decode-transaction --help
Usage: cast decode-transaction [TX]

Arguments:
  [TX]  

Options:
  -h, --help  打印帮助信息
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># cast disassemble

将十六进制编码的字节码反汇编成单独的/人类可读的操作码

```bash
$ cast disassemble --help
Usage: cast disassemble &lt;BYTECODE&gt;

Arguments:
  &lt;BYTECODE&gt;  十六进制编码的字节码

Options:
  -h, --help  打印帮助信息
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># cast estimate

估算交易的 gas 成本

```bash
$ cast estimate --help
Usage: cast estimate [OPTIONS] [TO] [SIG] [ARGS]... [COMMAND]

Commands:
  --create  估算部署智能合约的 gas 成本
  help      打印此消息或给定子命令的帮助信息

Arguments:
  [TO]
          交易的接收地址

  [SIG]
          要调用的函数的签名

  [ARGS]...
          要调用的函数的参数

Options:
  -B, --block &lt;BLOCK&gt;
          查询的区块高度。
          
          也可以是 earliest、finalized、safe、latest 或 pending 等标签。

  -h, --help
          打印帮助信息（使用 '-h' 查看摘要）

Transaction options:
      --gas-limit &lt;GAS_LIMIT&gt;
          交易的 gas 限制
          
          [env: ETH_GAS_LIMIT=]

      --gas-price &lt;PRICE&gt;
          传统交易的 gas 价格，或 EIP1559 交易的每 gas 最大费用
          
          [env: ETH_GAS_PRICE=]

      --priority-gas-price &lt;PRICE&gt;
          EIP1559 交易的每 gas 最大优先费用
          
          [env: ETH_PRIORITY_GAS_PRICE=]

      --value &lt;VALUE&gt;
          交易中发送的以太币，可以是以 wei 为单位指定，或以带单位的字符串指定。
          
          示例：1ether、10gwei、0.01ether

      --nonce &lt;NONCE&gt;
          交易的 nonce

      --legacy
          发送传统交易而不是 EIP1559 交易。
          
          在没有 EIP1559 的常见网络上会自动启用。

      --blob
          发送 EIP-4844 blob 交易

      --blob-gas-price &lt;BLOB_PRICE&gt;
          EIP-4844 blob 交易的 gas 价格
          
          [env: ETH_BLOB_GAS_PRICE=]

Ethereum options:
  -r, --rpc-url &lt;URL&gt;
          RPC 端点
          
          [env: ETH_RPC_URL=]

      --flashbots
          使用 Flashbots RPC URL 并启用快速模式（&lt;https://rpc.flashbots.net/fast&gt;）。
          
          这将私密地与所有注册的构建者共享交易。
          
          参见：&lt;https://docs.flashbots.net/flashbots-protect/quick-start#faster-transactions&gt;

      --jwt-secret &lt;JWT_SECRET&gt;
          RPC 端点的 JWT 密钥。
          
          JWT 密钥将用于创建 RPC 的 JWT。例如，以下可以用于模拟 CL `engine_forkchoiceUpdated` 调用：
          
          cast rpc --jwt-secret &lt;JWT_SECRET&gt; engine_forkchoiceUpdatedV2
          '["0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc",
          "0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc",
          "0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc"]'
          
          [env: ETH_RPC_JWT_SECRET=]

  -e, --etherscan-api-key &lt;KEY&gt;
          Etherscan（或类似）API 密钥
          
          [env: ETHERSCAN_API_KEY=]

  -c, --chain &lt;CHAIN&gt;
          链名称或 EIP-155 链 ID
          
          [env: CHAIN=]

Wallet options - raw:
  -f, --from &lt;ADDRESS&gt;
          发送者账户
          
          [env: ETH_FROM=]

  -i, --interactive
          打开交互式提示以输入您的私钥

      --private-key &lt;RAW_PRIVATE_KEY&gt;
          使用提供的私钥

      --mnemonic &lt;MNEMONIC&gt;
          使用指定路径的助记词文件的助记词短语

      --mnemonic-passphrase &lt;PASSPHRASE&gt;
          使用助记词的 BIP39 密码

      --mnemonic-derivation-path &lt;PATH&gt;
          钱包派生路径。
          
          适用于 --mnemonic-path 和硬件钱包。

      --mnemonic-index &lt;INDEX&gt;
          使用给定助记词索引的私钥。
          
          与 --mnemonic-path 一起使用。
          
          [default: 0]

Wallet options - keystore:
      --keystore &lt;PATH&gt;
          使用给定文件夹或文件中的 keystore
          
          [env: ETH_KEYSTORE=]

      --account &lt;ACCOUNT_NAME&gt;
          通过其文件名从默认 keystores 文件夹（~/.foundry/keystores）中使用 keystore
          
          [env: ETH_KEYSTORE_ACCOUNT=]

      --password &lt;PASSWORD&gt;
          keystore 密码。
          
          与 --keystore 一起使用。

      --password-file &lt;PASSWORD_FILE&gt;
          keystore 密码文件路径。
          
          与 --keystore 一起使用。
          
          [env: ETH_PASSWORD=]

Wallet options - hardware wallet:
  -l, --ledger
          使用 Ledger 硬件钱包

  -t, --trezor
          使用 Trezor 硬件钱包

Wallet options - remote:
      --aws
          使用 AWS Key Management Service
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-json">{
  "translation": "# cast estimate --create\n\n估算部署智能合约的 gas 成本\n\n```bash\n$ cast estimate --create --help\nUsage: cast estimate --create [OPTIONS] &lt;CODE&gt; [SIG] [ARGS]...\n\nArguments:\n  &lt;CODE&gt;\n          合约的字节码\n\n  [SIG]\n          构造函数的签名\n\n  [ARGS]...\n          构造函数参数\n\nOptions:\n      --value &lt;VALUE&gt;\n          交易中发送的以太币\n          \n          可以以 wei 为单位指定，或以带单位类型的字符串指定：\n          \n          示例：1ether, 10gwei, 0.01ether\n\n  -h, --help\n          打印帮助信息（使用 '-h' 查看摘要）\n```"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># cast etherscan-source

从Etherscan获取合约的源代码

```bash
$ cast etherscan-source --help
Usage: cast etherscan-source [OPTIONS] &lt;ADDRESS&gt;

Arguments:
  &lt;ADDRESS&gt;  合约的地址

Options:
  -f, --flatten                  是否展平源代码
  -d &lt;DIRECTORY&gt;                 输出目录/文件以展开源代码树
  -e, --etherscan-api-key &lt;KEY&gt;  Etherscan（或等效）API密钥 [env: ETHERSCAN_API_KEY=]
  -c, --chain &lt;CHAIN&gt;            链名称或EIP-155链ID [env: CHAIN=]
  -h, --help                     打印帮助信息
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-json">{
  "title": "cast find-block",
  "description": "获取最接近提供的时间戳的区块号",
  "usage": "```bash\n$ cast find-block --help\nUsage: cast find-block [OPTIONS] &lt;TIMESTAMP&gt;\n\nArguments:\n  &lt;TIMESTAMP&gt;\n          要搜索的UNIX时间戳，以秒为单位\n\nOptions:\n  -r, --rpc-url &lt;URL&gt;\n           RPC端点\n          \n          [env: ETH_RPC_URL=]\n\n      --flashbots\n          使用Flashbots RPC URL并启用快速模式（&lt;https://rpc.flashbots.net/fast&gt;）。\n          \n          这将私密地与所有注册的构建者共享交易。\n          \n          参见：&lt;https://docs.flashbots.net/flashbots-protect/quick-start#faster-transactions&gt;\n\n      --jwt-secret &lt;JWT_SECRET&gt;\n          RPC端点的JWT密钥。\n          \n          JWT密钥将用于创建RPC的JWT。例如，可以使用以下命令模拟CL `engine_forkchoiceUpdated`调用：\n          \n          cast rpc --jwt-secret &lt;JWT_SECRET&gt; engine_forkchoiceUpdatedV2\n          '[\"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\",\n          \"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\",\n          \"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\"]'\n          \n          [env: ETH_RPC_JWT_SECRET=]\n\n  -h, --help\n          打印帮助信息（使用'-h'查看摘要）\n```"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># cast format-bytes32-string

将字符串格式化为 bytes32 编码

```bash
$ cast format-bytes32-string --help
Usage: cast format-bytes32-string [STRING]

Arguments:
  [STRING]  要格式化的字符串

Options:
  -h, --help  打印帮助信息
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-json">{
  "translation": "# cast from-bin\n\n将二进制数据转换为十六进制数据\n\n```bash\n$ cast from-bin --help\nUsage: cast from-bin\n\nOptions:\n  -h, --help  打印帮助信息\n```"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># cast from-fixed-point

将定点数转换为整数

```bash
$ cast from-fixed-point --help
Usage: cast from-fixed-point [DECIMALS] [VALUE]

Arguments:
  [DECIMALS]  使用的十进制位数
  [VALUE]     要转换的值

Options:
  -h, --help  打印帮助信息
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># cast from-rlp

解码RLP编码的数据。

```bash
$ cast from-rlp --help
Usage: cast from-rlp [VALUE]

Arguments:
  [VALUE]
          要转换的值

Options:
  -h, --help
          打印帮助信息（使用'-h'查看摘要）
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cast-from-utf8"><a class="header" href="#cast-from-utf8">cast from-utf8</a></h1>
<p>将 UTF8 文本转换为十六进制</p>
<pre><code class="language-bash">$ cast from-utf8 --help
用法: cast from-utf8 [文本]

参数:
  [文本]  要转换的文本

选项:
  -h, --help  打印帮助信息
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-json">{
  "translation": "# cast from-wei\n\n将 wei 转换为 ETH 金额。\n\n```bash\n$ cast from-wei --help\nUsage: cast from-wei [VALUE] [UNIT]\n\nArguments:\n  [VALUE]\n          要转换的值\n\n  [UNIT]\n          要转换的单位（ether、gwei、wei）\n          \n          [default: eth]\n\nOptions:\n  -h, --help\n          打印帮助信息（使用 '-h' 查看摘要）\n```"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-json">{
  "translation": "# 获取当前 gas 价格\n\n```bash\n$ cast gas-price --help\nUsage: cast gas-price [OPTIONS]\n\nOptions:\n  -r, --rpc-url &lt;URL&gt;\n          指定 RPC 端点\n          \n          [env: ETH_RPC_URL=]\n\n      --flashbots\n          使用 Flashbots RPC URL 并启用快速模式（&lt;https://rpc.flashbots.net/fast&gt;）。\n          \n          这将私密地与所有注册的构建者共享交易。\n          \n          参见：&lt;https://docs.flashbots.net/flashbots-protect/quick-start#faster-transactions&gt;\n\n      --jwt-secret &lt;JWT_SECRET&gt;\n          RPC 端点的 JWT 密钥。\n          \n          JWT 密钥将用于创建 RPC 的 JWT。例如，可以使用以下命令模拟 CL `engine_forkchoiceUpdated` 调用：\n          \n          cast rpc --jwt-secret &lt;JWT_SECRET&gt; engine_forkchoiceUpdatedV2\n          '[\"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\",\n          \"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\",\n          \"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\"]'\n          \n          [env: ETH_RPC_JWT_SECRET=]\n\n  -h, --help\n          打印帮助信息（使用 '-h' 查看摘要）\n```"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># cast generate-fig-spec

生成 Fig 自动补全规范

```bash
$ cast generate-fig-spec --help
Usage: cast generate-fig-spec

Options:
  -h, --help  打印帮助信息
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-json">{
  "translation": "# cast hash-zero\n\n打印零哈希\n\n```bash\n$ cast hash-zero --help\nUsage: cast hash-zero\n\nOptions:\n  -h, --help  打印帮助信息\n```"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-json">{
  "translation": "# cast 实现"
}
</code></pre>
<pre><code class="language-json">{
  "translation": "获取 EIP-1967 实现账户"
}
</code></pre>
<pre><code class="language-json">{
  "translation": "```bash\n$ cast implementation --help\nUsage: cast implementation [OPTIONS] &lt;WHO&gt;\n\nArguments:\n  &lt;WHO&gt;\n          要获取 nonce 的地址\n\nOptions:\n  -B, --block &lt;BLOCK&gt;\n          查询的区块高度。\n          \n          也可以是以下标签：earliest, finalized, safe, latest, 或 pending。\n\n  -r, --rpc-url &lt;URL&gt;\n           RPC 端点\n          \n          [env: ETH_RPC_URL=]\n\n      --flashbots\n          使用 Flashbots RPC URL 并启用快速模式（&lt;https://rpc.flashbots.net/fast&gt;）。\n          \n          这将私密地与所有注册的构建者共享交易。\n          \n          参见：&lt;https://docs.flashbots.net/flashbots-protect/quick-start#faster-transactions&gt;\n\n      --jwt-secret &lt;JWT_SECRET&gt;\n          RPC 端点的 JWT 密钥。\n          \n          JWT 密钥将用于创建 RPC 的 JWT。例如，可以使用以下命令模拟 CL `engine_forkchoiceUpdated` 调用：\n          \n          cast rpc --jwt-secret &lt;JWT_SECRET&gt; engine_forkchoiceUpdatedV2\n          '[\"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\",\n          \"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\",\n          \"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\"]'\n          \n          [env: ETH_RPC_JWT_SECRET=]\n\n  -h, --help\n          打印帮助信息（使用 '-h' 查看摘要）\n```"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># cast index

计算映射中条目的存储槽

```bash
$ cast index --help
Usage: cast index &lt;KEY_TYPE&gt; &lt;KEY&gt; &lt;SLOT_NUMBER&gt;

Arguments:
  &lt;KEY_TYPE&gt;     映射键类型
  &lt;KEY&gt;          映射键
  &lt;SLOT_NUMBER&gt;  映射的存储槽

Options:
  -h, --help  打印帮助信息
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># cast index-erc7201

根据 `ERC-7201: Namespaced Storage Layout` 规范计算存储槽

```bash
$ cast index-erc7201 --help
Usage: cast index-erc7201 [OPTIONS] [ID]

Arguments:
  [ID]  任意标识符

Options:
      --formula-id &lt;FORMULA_ID&gt;  公式ID。目前唯一支持的公式是 `erc7201`
                                 [default: erc7201]
  -h, --help                     打印帮助信息
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cast-接口"><a class="header" href="#cast-接口">cast 接口</a></h1>
<p>从给定的 ABI 生成一个 Solidity 接口。</p>
<pre><code class="language-bash">$ cast interface --help
用法: cast interface [选项] &lt;路径或地址&gt;

参数:
  &lt;路径或地址&gt;
          合约地址或 ABI 文件的路径。
          
          如果指定地址，则从 Etherscan 获取 ABI。

选项:
  -n, --name &lt;名称&gt;
          用于生成的接口的名称

  -p, --pragma &lt;版本&gt;
          Solidity 编译器版本
          
          [默认值: ^0.8.4]

  -o, --output &lt;路径&gt;
          输出文件的路径。
          
          如果未指定，接口将输出到标准输出。

  -j, --json
          如果指定，接口将以 JSON 格式输出，而不是 Solidity 格式

  -e, --etherscan-api-key &lt;密钥&gt;
          Etherscan（或类似）API 密钥
          
          [环境变量: ETHERSCAN_API_KEY=]

  -c, --chain &lt;链&gt;
          链名称或 EIP-155 链 ID
          
          [环境变量: CHAIN=]

  -h, --help
          打印帮助信息（使用 '-h' 查看简要帮助）
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># cast keccak

使用 Keccak-256 哈希任意数据

```bash
$ cast keccak --help
Usage: cast keccak [DATA]

Arguments:
  [DATA]  要哈希的数据

Options:
  -h, --help  打印帮助信息
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># 查询日志

通过签名或主题获取日志

```bash
$ cast logs --help
Usage: cast logs [OPTIONS] [SIG_OR_TOPIC] [TOPICS_OR_ARGS]...

Arguments:
  [SIG_OR_TOPIC]
          要过滤日志的事件签名，将转换为第一个主题，或是一个要过滤的主题

  [TOPICS_OR_ARGS]...
          如果与签名一起使用，则是要过滤的事件的索引字段。否则，是过滤器的剩余主题

Options:
      --from-block &lt;FROM_BLOCK&gt;
          开始查询的区块高度。
          
          也可以是 earliest, finalized, safe, latest, 或 pending 这些标签。

      --to-block &lt;TO_BLOCK&gt;
          停止查询的区块高度。
          
          也可以是 earliest, finalized, safe, latest, 或 pending 这些标签。

      --address &lt;ADDRESS&gt;
          要过滤的合约地址

      --subscribe
          如果 RPC 类型和端点支持 `eth_subscribe`，则流式传输日志而不是打印并退出。将继续直到中断或达到 TO_BLOCK

  -h, --help
          打印帮助信息（使用 '-h' 查看摘要）

Display options:
  -j, --json
          以 JSON 格式打印日志

Ethereum options:
  -r, --rpc-url &lt;URL&gt;
          RPC 端点
          
          [env: ETH_RPC_URL=]

      --flashbots
          使用 Flashbots RPC URL 并启用快速模式（&lt;https://rpc.flashbots.net/fast&gt;）。
          
          这将私密地与所有注册的构建者共享交易。
          
          参见：&lt;https://docs.flashbots.net/flashbots-protect/quick-start#faster-transactions&gt;

      --jwt-secret &lt;JWT_SECRET&gt;
          RPC 端点的 JWT 密钥。
          
          JWT 密钥将用于创建 RPC 的 JWT。例如，以下可以用于模拟 CL `engine_forkchoiceUpdated` 调用：
          
          cast rpc --jwt-secret &lt;JWT_SECRET&gt; engine_forkchoiceUpdatedV2
          '["0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc",
          "0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc",
          "0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc"]'
          
          [env: ETH_RPC_JWT_SECRET=]

  -e, --etherscan-api-key &lt;KEY&gt;
          Etherscan（或等效）API 密钥
          
          [env: ETHERSCAN_API_KEY=]

  -c, --chain &lt;CHAIN&gt;
          链名称或 EIP-155 链 ID
          
          [env: CHAIN=]

Wallet options - raw:
  -f, --from &lt;ADDRESS&gt;
          发送者账户
          
          [env: ETH_FROM=]

  -i, --interactive
          打开一个交互式提示以输入您的私钥

      --private-key &lt;RAW_PRIVATE_KEY&gt;
          使用提供的私钥

      --mnemonic &lt;MNEMONIC&gt;
          使用指定路径的助记词或助记词文件

      --mnemonic-passphrase &lt;PASSPHRASE&gt;
          使用 BIP39 助记词的密码

      --mnemonic-derivation-path &lt;PATH&gt;
          钱包派生路径。
          
          适用于 --mnemonic-path 和硬件钱包。

      --mnemonic-index &lt;INDEX&gt;
          使用给定助记词索引的私钥。
          
          与 --mnemonic-path 一起使用。
          
          [default: 0]

Wallet options - keystore:
      --keystore &lt;PATH&gt;
          使用给定文件夹或文件中的 keystore
          
          [env: ETH_KEYSTORE=]

      --account &lt;ACCOUNT_NAME&gt;
          通过文件名从默认 keystores 文件夹（~/.foundry/keystores）中使用 keystore
          
          [env: ETH_KEYSTORE_ACCOUNT=]

      --password &lt;PASSWORD&gt;
          keystore 密码。
          
          与 --keystore 一起使用。

      --password-file &lt;PASSWORD_FILE&gt;
          keystore 密码文件路径。
          
          与 --keystore 一起使用。
          
          [env: ETH_PASSWORD=]

Wallet options - hardware wallet:
  -l, --ledger
          使用 Ledger 硬件钱包

  -t, --trezor
          使用 Trezor 硬件钱包

Wallet options - remote:
      --aws
          使用 AWS 密钥管理服务
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-json">{
  "translation": "# cast lookup-address\n\n执行 ENS 反向查找\n\n```bash\n$ cast lookup-address --help\nUsage: cast lookup-address [OPTIONS] [WHO]\n\nArguments:\n  [WHO]\n          要执行查找的账户\n\nOptions:\n  -v, --verify\n          执行正常查找以验证地址是否正确\n\n  -r, --rpc-url &lt;URL&gt;\n           RPC 端点\n          \n          [env: ETH_RPC_URL=]\n\n      --flashbots\n          使用 Flashbots RPC URL 并启用快速模式（&lt;https://rpc.flashbots.net/fast&gt;）。\n          \n          这将私密地与所有注册的构建者共享交易。\n          \n          参见：&lt;https://docs.flashbots.net/flashbots-protect/quick-start#faster-transactions&gt;\n\n      --jwt-secret &lt;JWT_SECRET&gt;\n          RPC 端点的 JWT 密钥。\n          \n          JWT 密钥将用于创建 RPC 的 JWT。例如，可以使用以下命令模拟 CL `engine_forkchoiceUpdated` 调用：\n          \n          cast rpc --jwt-secret &lt;JWT_SECRET&gt; engine_forkchoiceUpdatedV2\n          '[\"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\",\n          \"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\",\n          \"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\"]'\n          \n          [env: ETH_RPC_JWT_SECRET=]\n\n  -h, --help\n          打印帮助信息（使用 '-h' 查看摘要）\n```"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-json">{
  "translation": "# cast max-int\n\n打印给定整数类型的最大值\n\n```bash\n$ cast max-int --help\nUsage: cast max-int [TYPE]\n\nArguments:\n  [TYPE]  要获取最大值的整数类型 [默认: int256]\n\nOptions:\n  -h, --help  打印帮助信息\n```"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># cast max-uint

打印给定整数类型的最大值

```bash
$ cast max-uint --help
Usage: cast max-uint [TYPE]

Arguments:
  [TYPE]  要获取最大值的无符号整数类型 [默认: uint256]

Options:
  -h, --help  打印帮助信息
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cast-min-int"><a class="header" href="#cast-min-int">cast min-int</a></h1>
<p>打印给定整数类型的最小值</p>
<pre><code class="language-bash">$ cast min-int --help
用法: cast min-int [类型]

参数:
  [类型]  要获取最小值的整数类型 [默认: int256]

选项:
  -h, --help  打印帮助信息
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># cast mktx

构建并签名交易

```bash
$ cast mktx --help
Usage: cast mktx [OPTIONS] [TO] [SIG] [ARGS]... [COMMAND]

Commands:
  --create  用于部署原始合约字节码
  help      打印此消息或给定子命令的帮助信息

Arguments:
  [TO]
          交易的接收地址。
          
          如果未提供，则必须使用 `cast mktx --create`。

  [SIG]
          要调用的函数的签名

  [ARGS]...
          要调用的函数的参数

Options:
  -h, --help
          打印帮助信息（使用 '-h' 查看摘要）

Transaction options:
      --gas-limit &lt;GAS_LIMIT&gt;
          交易的 gas 限制
          
          [env: ETH_GAS_LIMIT=]

      --gas-price &lt;PRICE&gt;
          传统交易的 gas 价格，或 EIP1559 交易的每 gas 最大费用
          
          [env: ETH_GAS_PRICE=]

      --priority-gas-price &lt;PRICE&gt;
          EIP1559 交易的每 gas 最大优先费用
          
          [env: ETH_PRIORITY_GAS_PRICE=]

      --value &lt;VALUE&gt;
          交易中发送的以太币，可以以 wei 为单位指定，或以带单位的字符串指定
          
          示例：1ether, 10gwei, 0.01ether

      --nonce &lt;NONCE&gt;
          交易的 nonce

      --legacy
          发送传统交易而不是 EIP1559 交易。
          
          在没有 EIP1559 的常见网络上会自动启用。

      --blob
          发送 EIP-4844 blob 交易

      --blob-gas-price &lt;BLOB_PRICE&gt;
          EIP-4844 blob 交易的 gas 价格
          
          [env: ETH_BLOB_GAS_PRICE=]

Ethereum options:
  -r, --rpc-url &lt;URL&gt;
          RPC 端点
          
          [env: ETH_RPC_URL=]

      --flashbots
          使用 Flashbots RPC URL 并启用快速模式（&lt;https://rpc.flashbots.net/fast&gt;）。
          
          这将私密地与所有注册的构建者共享交易。
          
          参见：&lt;https://docs.flashbots.net/flashbots-protect/quick-start#faster-transactions&gt;

      --jwt-secret &lt;JWT_SECRET&gt;
          RPC 端点的 JWT 密钥。
          
          JWT 密钥将用于创建 RPC 的 JWT。例如，以下内容可用于模拟 CL `engine_forkchoiceUpdated` 调用：
          
          cast rpc --jwt-secret &lt;JWT_SECRET&gt; engine_forkchoiceUpdatedV2
          '["0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc",
          "0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc",
          "0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc"]'
          
          [env: ETH_RPC_JWT_SECRET=]

  -e, --etherscan-api-key &lt;KEY&gt;
          Etherscan（或等效）API 密钥
          
          [env: ETHERSCAN_API_KEY=]

  -c, --chain &lt;CHAIN&gt;
          链名称或 EIP-155 链 ID
          
          [env: CHAIN=]

Wallet options - raw:
  -f, --from &lt;ADDRESS&gt;
          发送者账户
          
          [env: ETH_FROM=]

  -i, --interactive
          打开交互式提示以输入您的私钥

      --private-key &lt;RAW_PRIVATE_KEY&gt;
          使用提供的私钥

      --mnemonic &lt;MNEMONIC&gt;
          使用指定路径的助记词文件的助记词短语

      --mnemonic-passphrase &lt;PASSPHRASE&gt;
          使用助记词的 BIP39 密码短语

      --mnemonic-derivation-path &lt;PATH&gt;
          钱包派生路径。
          
          适用于 --mnemonic-path 和硬件钱包。

      --mnemonic-index &lt;INDEX&gt;
          使用给定助记词索引的私钥。
          
          与 --mnemonic-path 一起使用。
          
          [default: 0]

Wallet options - keystore:
      --keystore &lt;PATH&gt;
          使用给定文件夹或文件中的 keystore
          
          [env: ETH_KEYSTORE=]

      --account &lt;ACCOUNT_NAME&gt;
          通过其文件名从默认 keystore 文件夹（~/.foundry/keystores）中使用 keystore
          
          [env: ETH_KEYSTORE_ACCOUNT=]

      --password &lt;PASSWORD&gt;
          keystore 密码。
          
          与 --keystore 一起使用。

      --password-file &lt;PASSWORD_FILE&gt;
          keystore 密码文件路径。
          
          与 --keystore 一起使用。
          
          [env: ETH_PASSWORD=]

Wallet options - hardware wallet:
  -l, --ledger
          使用 Ledger 硬件钱包

  -t, --trezor
          使用 Trezor 硬件钱包

Wallet options - remote:
      --aws
          使用 AWS 密钥管理服务
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># cast mktx --create

用于部署原始合约字节码

```bash
$ cast mktx --create --help
Usage: cast mktx --create &lt;CODE&gt; [SIG] [ARGS]...

Arguments:
  &lt;CODE&gt;     要部署的合约的初始化字节码
  [SIG]      构造函数的签名
  [ARGS]...  构造函数的参数

Options:
  -h, --help  打印帮助信息
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># cast namehash

计算 ENS 名称的哈希值

```bash
$ cast namehash --help
Usage: cast namehash [NAME]

Arguments:
  [NAME]  

Options:
  -h, --help  打印帮助信息
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-json">{
  "title": "获取账户的nonce",
  "content": "```bash\n$ cast nonce --help\nUsage: cast nonce [OPTIONS] &lt;WHO&gt;\n\nArguments:\n  &lt;WHO&gt;\n          要获取nonce的地址\n\nOptions:\n  -B, --block &lt;BLOCK&gt;\n          查询的区块高度。\n          \n          也可以是以下标签：earliest, finalized, safe, latest, 或 pending。\n\n  -r, --rpc-url &lt;URL&gt;\n           RPC 端点\n          \n          [env: ETH_RPC_URL=]\n\n      --flashbots\n          使用 Flashbots RPC URL 并启用快速模式（&lt;https://rpc.flashbots.net/fast&gt;）。\n          \n          这将私密地与所有注册的构建者共享交易。\n          \n          参见：&lt;https://docs.flashbots.net/flashbots-protect/quick-start#faster-transactions&gt;\n\n      --jwt-secret &lt;JWT_SECRET&gt;\n          RPC 端点的 JWT 密钥。\n          \n          JWT 密钥将用于创建 RPC 的 JWT。例如，以下命令可以用于模拟 CL `engine_forkchoiceUpdated` 调用：\n          \n          cast rpc --jwt-secret &lt;JWT_SECRET&gt; engine_forkchoiceUpdatedV2\n          '[\"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\",\n          \"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\",\n          \"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\"]'\n          \n          [env: ETH_RPC_JWT_SECRET=]\n\n  -h, --help\n          打印帮助信息（使用 '-h' 查看摘要）\n```"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># cast parse-bytes32-address

从 bytes32 编码解析校验和地址。

```bash
$ cast parse-bytes32-address --help
Usage: cast parse-bytes32-address [BYTES]

Arguments:
  [BYTES]  

Options:
  -h, --help  打印帮助信息
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cast-parse-bytes32-string"><a class="header" href="#cast-parse-bytes32-string">cast parse-bytes32-string</a></h1>
<p>从 bytes32 编码解析字符串</p>
<pre><code class="language-bash">$ cast parse-bytes32-string --help
用法: cast parse-bytes32-string [BYTES]

参数:
  [BYTES]  要解析的字符串

选项:
  -h, --help  打印帮助信息
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-json">{
  "translation": "# cast pretty-calldata\n\n格式化打印 calldata。\n\n```bash\n$ cast pretty-calldata --help\nUsage: cast pretty-calldata [OPTIONS] [CALLDATA]\n\nArguments:\n  [CALLDATA]\n          要打印的 calldata\n\nOptions:\n  -o, --offline\n          跳过 https://openchain.xyz 的查找\n\n  -h, --help\n          打印帮助信息（使用 '-h' 查看简要帮助）\n```"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># 生成证明

为指定的存储槽生成存储证明

```bash
$ cast proof --help
Usage: cast proof [OPTIONS] &lt;ADDRESS&gt; [SLOTS]...

Arguments:
  &lt;ADDRESS&gt;
          合约地址

  [SLOTS]...
          存储槽编号（十六进制或十进制）

Options:
  -B, --block &lt;BLOCK&gt;
          查询的区块高度。
          
          也可以是标签 earliest, finalized, safe, latest, 或 pending。

  -r, --rpc-url &lt;URL&gt;
          RPC 端点
          
          [env: ETH_RPC_URL=]

      --flashbots
          使用 Flashbots RPC URL 并启用快速模式（&lt;https://rpc.flashbots.net/fast&gt;）。
          
          这将私密地与所有注册的构建者共享交易。
          
          参见：&lt;https://docs.flashbots.net/flashbots-protect/quick-start#faster-transactions&gt;

      --jwt-secret &lt;JWT_SECRET&gt;
          RPC 端点的 JWT 密钥。
          
          JWT 密钥将用于创建 RPC 的 JWT。例如，可以使用以下命令模拟 CL `engine_forkchoiceUpdated` 调用：
          
          cast rpc --jwt-secret &lt;JWT_SECRET&gt; engine_forkchoiceUpdatedV2
          '["0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc",
          "0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc",
          "0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc"]'
          
          [env: ETH_RPC_JWT_SECRET=]

  -h, --help
          打印帮助信息（使用 '-h' 查看摘要）
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-json">{
  "translation": "# cast publish\n\n将原始交易发布到网络\n\n```bash\n$ cast publish --help\nUsage: cast publish [OPTIONS] &lt;RAW_TX&gt;\n\nArguments:\n  &lt;RAW_TX&gt;\n          原始交易\n\nOptions:\n      --async\n          仅打印交易哈希并立即退出\n          \n          [env: CAST_ASYNC=]\n\n  -r, --rpc-url &lt;URL&gt;\n          RPC 端点\n          \n          [env: ETH_RPC_URL=]\n\n      --flashbots\n          使用 Flashbots RPC URL 并启用快速模式（&lt;https://rpc.flashbots.net/fast&gt;）。\n          \n          这将私密地与所有注册的构建者共享交易。\n          \n          参见：&lt;https://docs.flashbots.net/flashbots-protect/quick-start#faster-transactions&gt;\n\n      --jwt-secret &lt;JWT_SECRET&gt;\n          RPC 端点的 JWT 密钥。\n          \n          JWT 密钥将用于创建 RPC 的 JWT。例如，可以使用以下命令模拟 CL `engine_forkchoiceUpdated` 调用：\n          \n          cast rpc --jwt-secret &lt;JWT_SECRET&gt; engine_forkchoiceUpdatedV2\n          '[\"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\",\n          \"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\",\n          \"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\"]'\n          \n          [env: ETH_RPC_JWT_SECRET=]\n\n  -h, --help\n          打印帮助信息（使用 '-h' 查看摘要）\n```"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-json">{
  "translation": "# 交易收据\n\n获取交易的收据\n\n```bash\n$ cast receipt --help\nUsage: cast receipt [OPTIONS] &lt;TX_HASH&gt; [FIELD]\n\nArguments:\n  &lt;TX_HASH&gt;\n          交易哈希\n\n  [FIELD]\n          如果指定，仅获取交易的指定字段\n\nOptions:\n      --confirmations &lt;CONFIRMATIONS&gt;\n          获取收据所需的确认数\n          \n          [default: 1]\n\n      --async\n          如果交易未找到，立即退出\n          \n          [env: CAST_ASYNC=]\n\n  -r, --rpc-url &lt;URL&gt;\n          RPC 端点\n          \n          [env: ETH_RPC_URL=]\n\n      --flashbots\n          使用 Flashbots RPC URL 并启用快速模式（&lt;https://rpc.flashbots.net/fast&gt;）。\n          \n          这将私密地与所有注册的构建者共享交易。\n          \n          参见：&lt;https://docs.flashbots.net/flashbots-protect/quick-start#faster-transactions&gt;\n\n      --jwt-secret &lt;JWT_SECRET&gt;\n          RPC 端点的 JWT 密钥。\n          \n          JWT 密钥将用于创建 RPC 的 JWT。例如，以下可以用于模拟 CL `engine_forkchoiceUpdated` 调用：\n          \n          cast rpc --jwt-secret &lt;JWT_SECRET&gt; engine_forkchoiceUpdatedV2\n          '[\"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\",\n          \"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\",\n          \"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\"]'\n          \n          [env: ETH_RPC_JWT_SECRET=]\n\n  -h, --help\n          打印帮助信息（使用 '-h' 查看摘要）\n\n显示选项：\n  -j, --json\n          以 JSON 格式打印\n```"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># cast resolve-name

执行 ENS 查询

```bash
$ cast resolve-name --help
Usage: cast resolve-name [OPTIONS] [WHO]

Arguments:
  [WHO]
          要查询的名称

Options:
  -v, --verify
          执行反向查询以验证名称是否正确

  -r, --rpc-url &lt;URL&gt;
          RPC 端点
          
          [env: ETH_RPC_URL=]

      --flashbots
          使用 Flashbots RPC URL 并启用快速模式（&lt;https://rpc.flashbots.net/fast&gt;）。
          
          这将私密地与所有注册的构建者共享交易。
          
          参见：&lt;https://docs.flashbots.net/flashbots-protect/quick-start#faster-transactions&gt;

      --jwt-secret &lt;JWT_SECRET&gt;
          RPC 端点的 JWT 密钥。
          
          JWT 密钥将用于创建 RPC 的 JWT。例如，可以使用以下命令模拟 CL `engine_forkchoiceUpdated` 调用：
          
          cast rpc --jwt-secret &lt;JWT_SECRET&gt; engine_forkchoiceUpdatedV2
          '["0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc",
          "0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc",
          "0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc"]'
          
          [env: ETH_RPC_JWT_SECRET=]

  -h, --help
          打印帮助信息（使用 '-h' 查看摘要）
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-json">{
  "translation": "# cast rpc\n\n执行原始 JSON-RPC 请求\n\n```bash\n$ cast rpc --help\nUsage: cast rpc [OPTIONS] &lt;METHOD&gt; [PARAMS]...\n\nArguments:\n  &lt;METHOD&gt;\n           RPC 方法名称\n\n  [PARAMS]...\n           RPC 参数\n          \n          解释为 JSON:\n          \n          cast rpc eth_getBlockByNumber 0x123 false =&gt; {\"method\": \"eth_getBlockByNumber\", \"params\":\n          [\"0x123\", false] ... }\n\nOptions:\n  -w, --raw\n          发送原始 JSON 参数\n          \n          第一个参数将被解释为原始 JSON 参数数组。如果没有给出参数，\n          将使用标准输入。例如：\n          \n          cast rpc eth_getBlockByNumber '[\"0x123\", false]' --raw =&gt; {\"method\":\n          \"eth_getBlockByNumber\", \"params\": [\"0x123\", false] ... }\n\n  -r, --rpc-url &lt;URL&gt;\n           RPC 端点\n          \n          [env: ETH_RPC_URL=]\n\n      --flashbots\n          使用 Flashbots RPC URL 并启用快速模式（&lt;https://rpc.flashbots.net/fast&gt;）。\n          \n          这将私密地与所有注册的构建者共享交易。\n          \n          参见：&lt;https://docs.flashbots.net/flashbots-protect/quick-start#faster-transactions&gt;\n\n      --jwt-secret &lt;JWT_SECRET&gt;\n          RPC 端点的 JWT 密钥。\n          \n          JWT 密钥将用于创建 RPC 的 JWT。例如，可以使用以下命令\n          模拟 CL `engine_forkchoiceUpdated` 调用：\n          \n          cast rpc --jwt-secret &lt;JWT_SECRET&gt; engine_forkchoiceUpdatedV2\n          '[\"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\",\n          \"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\",\n          \"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\"]'\n          \n          [env: ETH_RPC_JWT_SECRET=]\n\n  -h, --help\n          打印帮助信息（使用 '-h' 查看摘要）\n```"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-json">{
  "translation": "# cast run\n\n在本地环境中运行已发布的交易并打印跟踪信息\n\n```bash\n$ cast run --help\nUsage: cast run [OPTIONS] &lt;TX_HASH&gt;\n\nArguments:\n  &lt;TX_HASH&gt;\n          交易哈希\n\nOptions:\n  -d, --debug\n          在调试器中打开交易\n\n  -t, --trace-printer\n          打印出操作码跟踪信息\n\n  -q, --quick\n          仅使用前一个区块的状态执行交易。\n          \n          可能会导致与实际执行结果不同的结果！\n\n  -v, --verbose\n          打印合约的完整地址\n\n  -l, --label &lt;LABEL&gt;\n          在跟踪信息中标记地址。\n          \n          示例: 0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045:vitalik.eth\n\n  -r, --rpc-url &lt;URL&gt;\n          RPC 端点\n          \n          [env: ETH_RPC_URL=]\n\n      --flashbots\n          使用 Flashbots RPC URL 并启用快速模式（&lt;https://rpc.flashbots.net/fast&gt;）。\n          \n          这将私密地与所有注册的构建者共享交易。\n          \n          参见: &lt;https://docs.flashbots.net/flashbots-protect/quick-start#faster-transactions&gt;\n\n      --jwt-secret &lt;JWT_SECRET&gt;\n          RPC 端点的 JWT 密钥。\n          \n          JWT 密钥将用于创建 RPC 的 JWT。例如，可以使用以下命令模拟 CL `engine_forkchoiceUpdated` 调用：\n          \n          cast rpc --jwt-secret &lt;JWT_SECRET&gt; engine_forkchoiceUpdatedV2\n          '[\"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\",\n          \"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\",\n          \"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\"]'\n          \n          [env: ETH_RPC_JWT_SECRET=]\n\n  -e, --evm-version &lt;EVM_VERSION&gt;\n          使用的 EVM 版本。\n          \n          覆盖配置中指定的版本。\n\n      --compute-units-per-second &lt;CUPS&gt;\n          设置此提供者每秒可用的计算单元数\n          \n          默认值: 330\n          \n          参见, \n          https://docs.alchemy.com/reference/compute-units#what-are-cups-compute-units-per-second\n\n      --no-rate-limit\n          禁用此节点提供者的速率限制。\n          \n          默认值: false\n          \n          参见, \n          https://docs.alchemy.com/reference/compute-units#what-are-cups-compute-units-per-second\n          \n          [aliases: no-rpc-rate-limit]\n\n  -h, --help\n          打印帮助信息（使用 '-h' 查看摘要）\n```"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-json">{
  "translation": "# 函数选择器\n\n从字节码中提取函数选择器和参数\n\n```bash\n$ cast selectors --help\nUsage: cast selectors [OPTIONS] &lt;BYTECODE&gt;\n\nArguments:\n  &lt;BYTECODE&gt;  十六进制编码的字节码\n\nOptions:\n  -r, --resolve  使用 https://openchain.xyz 解析提取的选择器的函数签名\n  -h, --help     打印帮助信息\n```"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-json">{
  "title": "cast send",
  "description": "签名并发布交易",
  "content": "```bash\n$ cast send --help\nUsage: cast send [OPTIONS] [TO] [SIG] [ARGS]... [COMMAND]\n\nCommands:\n  --create  用于部署原始合约字节码\n  help      打印此消息或给定子命令的帮助信息\n\nArguments:\n  [TO]\n          交易的接收地址。\n          \n          如果未提供，必须使用 cast send --create。\n\n  [SIG]\n          要调用的函数的签名\n\n  [ARGS]...\n          要调用的函数的参数\n\nOptions:\n      --async\n          仅打印交易哈希并立即退出\n          \n          [env: CAST_ASYNC=]\n\n      --confirmations &lt;CONFIRMATIONS&gt;\n          获取收据所需的确认数\n          \n          [default: 1]\n\n      --unlocked\n          通过 `eth_sendTransaction` 使用 `--from` 参数或 $ETH_FROM 作为发送者\n\n  -h, --help\n          打印帮助信息（使用 '-h' 查看摘要）\n\nDisplay options:\n  -j, --json\n          以 JSON 格式打印交易收据\n\nTransaction options:\n      --gas-limit &lt;GAS_LIMIT&gt;\n          交易的 gas 限制\n          \n          [env: ETH_GAS_LIMIT=]\n\n      --gas-price &lt;PRICE&gt;\n          传统交易的 gas 价格，或 EIP1559 交易的每 gas 最大费用\n          \n          [env: ETH_GAS_PRICE=]\n\n      --priority-gas-price &lt;PRICE&gt;\n          EIP1559 交易的每 gas 最大优先费用\n          \n          [env: ETH_PRIORITY_GAS_PRICE=]\n\n      --value &lt;VALUE&gt;\n          交易中发送的以太币，可以以 wei 为单位指定，或以带单位的字符串指定。\n          \n          示例: 1ether, 10gwei, 0.01ether\n\n      --nonce &lt;NONCE&gt;\n          交易的 nonce\n\n      --legacy\n          发送传统交易而不是 EIP1559 交易。\n          \n          对于没有 EIP1559 的常见网络会自动启用。\n\n      --blob\n          发送 EIP-4844 blob 交易\n\n      --blob-gas-price &lt;BLOB_PRICE&gt;\n          EIP-4844 blob 交易的 gas 价格\n          \n          [env: ETH_BLOB_GAS_PRICE=]\n\nEthereum options:\n  -r, --rpc-url &lt;URL&gt;\n          RPC 端点\n          \n          [env: ETH_RPC_URL=]\n\n      --flashbots\n          使用 Flashbots RPC URL 并启用快速模式 (&lt;https://rpc.flashbots.net/fast&gt;)。\n          \n          这将私密地与所有注册的构建者共享交易。\n          \n          参见: &lt;https://docs.flashbots.net/flashbots-protect/quick-start#faster-transactions&gt;\n\n      --jwt-secret &lt;JWT_SECRET&gt;\n          RPC 端点的 JWT 密钥。\n          \n          JWT 密钥将用于创建 RPC 的 JWT。例如，以下可以用于模拟 CL `engine_forkchoiceUpdated` 调用：\n          \n          cast rpc --jwt-secret &lt;JWT_SECRET&gt; engine_forkchoiceUpdatedV2\n          '[\"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\",\n          \"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\",\n          \"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\"]'\n          \n          [env: ETH_RPC_JWT_SECRET=]\n\n  -e, --etherscan-api-key &lt;KEY&gt;\n          Etherscan（或类似）API 密钥\n          \n          [env: ETHERSCAN_API_KEY=]\n\n  -c, --chain &lt;CHAIN&gt;\n          链名称或 EIP-155 链 ID\n          \n          [env: CHAIN=]\n\nWallet options - raw:\n  -f, --from &lt;ADDRESS&gt;\n          发送者账户\n          \n          [env: ETH_FROM=]\n\n  -i, --interactive\n          打开交互式提示以输入私钥\n\n      --private-key &lt;RAW_PRIVATE_KEY&gt;\n          使用提供的私钥\n\n      --mnemonic &lt;MNEMONIC&gt;\n          使用指定路径的助记词文件的助记词短语\n\n      --mnemonic-passphrase &lt;PASSPHRASE&gt;\n          为助记词使用 BIP39 密码短语\n\n      --mnemonic-derivation-path &lt;PATH&gt;\n          钱包派生路径。\n          \n          适用于 --mnemonic-path 和硬件钱包。\n\n      --mnemonic-index &lt;INDEX&gt;\n          使用给定助记词索引的私钥。\n          \n          与 --mnemonic-path 一起使用。\n          \n          [default: 0]\n\n      --path &lt;BLOB_DATA_PATH&gt;\n          要发送的 blob 数据路径\n\nWallet options - keystore:\n      --keystore &lt;PATH&gt;\n          使用给定文件夹或文件中的 keystore\n          \n          [env: ETH_KEYSTORE=]\n\n      --account &lt;ACCOUNT_NAME&gt;\n          通过文件名从默认 keystores 文件夹 (~/.foundry/keystores) 中使用 keystore\n          \n          [env: ETH_KEYSTORE_ACCOUNT=]\n\n      --password &lt;PASSWORD&gt;\n          keystore 密码。\n          \n          与 --keystore 一起使用。\n\n      --password-file &lt;PASSWORD_FILE&gt;\n          keystore 密码文件路径。\n          \n          与 --keystore 一起使用。\n          \n          [env: ETH_PASSWORD=]\n\nWallet options - hardware wallet:\n  -l, --ledger\n          使用 Ledger 硬件钱包\n\n  -t, --trezor\n          使用 Trezor 硬件钱包\n\nWallet options - remote:\n      --aws\n          使用 AWS 密钥管理服务\n```"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-json">{
  "translation": "# cast send --create\n\n用于部署原始合约字节码\n\n```bash\n$ cast send --create --help\nUsage: cast send --create &lt;CODE&gt; [SIG] [ARGS]...\n\nArguments:\n  &lt;CODE&gt;     要部署的合约的字节码\n  [SIG]      要调用的函数的签名\n  [ARGS]...  要调用的函数的参数\n\nOptions:\n  -h, --help  打印帮助信息\n```"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># cast shl

执行左移操作

```bash
$ cast shl --help
Usage: cast shl [OPTIONS] &lt;VALUE&gt; &lt;BITS&gt;

Arguments:
  &lt;VALUE&gt;  要移位的值
  &lt;BITS&gt;   要移位的位数

Options:
      --base-in &lt;BASE_IN&gt;    输入基数
      --base-out &lt;BASE_OUT&gt;  输出基数 [默认: 16]
  -h, --help                 打印帮助信息
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># cast shr

执行右移操作

```bash
$ cast shr --help
Usage: cast shr [OPTIONS] &lt;VALUE&gt; &lt;BITS&gt;

Arguments:
  &lt;VALUE&gt;  要移位的值
  &lt;BITS&gt;   要移位的位数

Options:
      --base-in &lt;BASE_IN&gt;    输入的基数，
      --base-out &lt;BASE_OUT&gt;  输出的基数，[default: 16]
  -h, --help                 打印帮助信息
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># cast sig

获取函数的selector

```bash
$ cast sig --help
Usage: cast sig [SIG] [OPTIMIZE]

Arguments:
  [SIG]       函数签名，例如 transfer(address,uint256)
  [OPTIMIZE]  优化签名，使其包含指定数量的前导零

Options:
  -h, --help  打印帮助信息
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># cast sig-event

从事件字符串生成事件签名

```bash
$ cast sig-event --help
Usage: cast sig-event [EVENT_STRING]

Arguments:
  [EVENT_STRING]  事件字符串

Options:
  -h, --help  打印帮助信息
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># cast storage

获取合约存储槽的原始值

```bash
$ cast storage --help
Usage: cast storage [OPTIONS] &lt;ADDRESS&gt; [SLOT]

Arguments:
  &lt;ADDRESS&gt;
          合约地址

  [SLOT]
          存储槽编号

Options:
  -b, --block &lt;BLOCK&gt;
          查询的区块高度。
          
          也可以是 earliest、finalized、safe、latest 或 pending 等标签。

  -r, --rpc-url &lt;URL&gt;
          RPC 端点
          
          [env: ETH_RPC_URL=]

      --flashbots
          使用 Flashbots RPC URL 并启用快速模式（&lt;https://rpc.flashbots.net/fast&gt;）。
          
          这将私密地与所有注册的构建者共享交易。
          
          参见：&lt;https://docs.flashbots.net/flashbots-protect/quick-start#faster-transactions&gt;

      --jwt-secret &lt;JWT_SECRET&gt;
          RPC 端点的 JWT 密钥。
          
          JWT 密钥将用于创建 RPC 的 JWT。例如，可以使用以下命令模拟 CL `engine_forkchoiceUpdated` 调用：
          
          cast rpc --jwt-secret &lt;JWT_SECRET&gt; engine_forkchoiceUpdatedV2
          '["0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc",
          "0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc",
          "0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc"]'
          
          [env: ETH_RPC_JWT_SECRET=]

  -e, --etherscan-api-key &lt;KEY&gt;
          Etherscan（或类似）API 密钥
          
          [env: ETHERSCAN_API_KEY=]

  -c, --chain &lt;CHAIN&gt;
          链名称或 EIP-155 链 ID
          
          [env: CHAIN=]

  -h, --help
          打印帮助信息（使用 '-h' 查看摘要）

Cache options:
      --force
          清除缓存和 artifacts 文件夹并重新编译

Build options:
      --no-cache
          禁用缓存

      --skip &lt;SKIP&gt;...
          跳过构建包含给定过滤器的文件。
          
          `test` 和 `script` 是 `.t.sol` 和 `.s.sol` 的别名。

Linker options:
      --libraries &lt;LIBRARIES&gt;
          设置预链接的库
          
          [env: DAPP_LIBRARIES=]

Compiler options:
      --ignored-error-codes &lt;ERROR_CODES&gt;
          忽略 solc 警告的错误代码

      --deny-warnings
          警告将触发编译器错误

      --no-auto-detect
          不自动检测 `solc` 版本

      --use &lt;SOLC_VERSION&gt;
          指定用于构建的 solc 版本或本地 solc 路径。
          
          有效值格式为 `x.y.z`、`solc:x.y.z` 或 `path/to/solc`。

      --offline
          不访问网络。
          
          缺失的 solc 版本将不会被安装。

      --via-ir
          使用 Yul 中间表示编译管道

      --no-metadata
          不在字节码中附加任何元数据。
          
          这等同于将 `bytecode_hash` 设置为 `none` 并将 `cbor_metadata` 设置为 `false`。

      --silent
          启动时不打印任何内容

      --ast
          在编译器输出中包含 AST 的 JSON

      --evm-version &lt;VERSION&gt;
          目标 EVM 版本

      --optimize
          激活 Solidity 优化器

      --optimizer-runs &lt;RUNS&gt;
          优化器运行次数

      --extra-output &lt;SELECTOR&gt;...
          在合约的 artifact 中包含的额外输出。
          
          示例键：evm.assembly、ewasm、ir、irOptimized、metadata
          
          完整描述请参见
          &lt;https://docs.soliditylang.org/en/v0.8.13/using-the-compiler.html#input-description&gt;

      --extra-output-files &lt;SELECTOR&gt;...
          写入单独文件的额外输出。
          
          有效值：metadata、ir、irOptimized、ewasm、evm.assembly

Project options:
  -o, --out &lt;PATH&gt;
          合约 artifacts 文件夹的路径

      --revert-strings &lt;REVERT&gt;
          回退字符串配置。
          
          可能的值为 "default"、"strip"（移除）、"debug"（Solidity 生成的回退字符串）和 "verboseDebug"

      --build-info
          生成构建信息文件

      --build-info-path &lt;PATH&gt;
          构建信息文件的输出路径目录

      --root &lt;PATH&gt;
          项目的根路径。
          
          默认情况下是 Git 仓库的根目录（如果在 Git 仓库中），或者当前工作目录。

  -C, --contracts &lt;PATH&gt;
          合约源目录

  -R, --remappings &lt;REMAPPINGS&gt;
          项目的 remappings

      --remappings-env &lt;ENV&gt;
          从环境获取项目的 remappings

      --cache-path &lt;PATH&gt;
          编译器缓存的路径

      --lib-paths &lt;PATH&gt;
          库文件夹的路径

      --hardhat
          使用 Hardhat 风格的项目布局。
          
          这等同于使用：`--contracts contracts --lib-paths node_modules`。
          
          [aliases: hh]

      --config-path &lt;FILE&gt;
          配置文件的路径
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># cast to-ascii

将十六进制数据转换为ASCII字符串

```bash
$ cast to-ascii --help
Usage: cast to-ascii [HEXDATA]

Arguments:
  [HEXDATA]  要转换的十六进制数据

Options:
  -h, --help  打印帮助信息
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># cast to-base

将一个基数的数字转换为另一个基数

```bash
$ cast to-base --help
Usage: cast to-base [OPTIONS] [VALUE] [BASE]

Arguments:
  [VALUE]  要转换的值
  [BASE]   输出基数

Options:
  -i, --base-in &lt;BASE_IN&gt;  输入基数
  -h, --help               打印帮助信息
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="转换为字节32"><a class="header" href="#转换为字节32">转换为字节32</a></h1>
<p>将十六进制数据右填充到32字节</p>
<pre><code class="language-bash">$ cast to-bytes32 --help
用法: cast to-bytes32 [BYTES]

参数:
  [BYTES]  要转换的十六进制数据

选项:
  -h, --help  打印帮助信息
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># cast to-check-sum-address

将地址转换为校验和格式（EIP-55）

```bash
$ cast to-check-sum-address --help
Usage: cast to-check-sum-address [ADDRESS]

Arguments:
  [ADDRESS]  要转换的地址

Options:
  -h, --help  打印帮助信息
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># cast to-dec

将一个基数的数字转换为十进制

```bash
$ cast to-dec --help
Usage: cast to-dec [OPTIONS] [VALUE]

Arguments:
  [VALUE]  要转换的值

Options:
  -i, --base-in &lt;BASE_IN&gt;  输入的基数
  -h, --help               打印帮助信息
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># cast to-fixed-point

将整数转换为定点数

```bash
$ cast to-fixed-point --help
Usage: cast to-fixed-point [DECIMALS] [VALUE]

Arguments:
  [DECIMALS]  使用的十进制位数
  [VALUE]     要转换的值

Options:
  -h, --help  打印帮助信息
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># cast to-hex

将一个基数的数字转换为另一个基数

```bash
$ cast to-hex --help
Usage: cast to-hex [OPTIONS] [VALUE]

Arguments:
  [VALUE]  要转换的值

Options:
  -i, --base-in &lt;BASE_IN&gt;  输入的基数
  -h, --help               打印帮助信息
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># cast to-hexdata

将输入规范化为小写、0x前缀的十六进制数据。

```bash
$ cast to-hexdata --help
Usage: cast to-hexdata [INPUT]

Arguments:
  [INPUT]
          要规范化的输入

Options:
  -h, --help
          打印帮助信息（使用 '-h' 查看摘要）
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># cast to-int256

将一个数字转换为十六进制编码的 int256

```bash
$ cast to-int256 --help
Usage: cast to-int256 [VALUE]

Arguments:
  [VALUE]  要转换的值

Options:
  -h, --help  打印帮助信息
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># cast to-rlp

RLP 编码十六进制数据，或一个十六进制数据数组

```bash
$ cast to-rlp --help
Usage: cast to-rlp [VALUE]

Arguments:
  [VALUE]  要转换的值

Options:
  -h, --help  打印帮助信息
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># cast to-uint256

将一个数字转换为十六进制编码的 uint256

```bash
$ cast to-uint256 --help
Usage: cast to-uint256 [VALUE]

Arguments:
  [VALUE]  要转换的值

Options:
  -h, --help  打印帮助信息
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># cast to-unit

将 ETH 金额转换为其他单位（ether、gwei 或 wei）。

```bash
$ cast to-unit --help
Usage: cast to-unit [VALUE] [UNIT]

Arguments:
  [VALUE]
          要转换的值

  [UNIT]
          要转换到的单位（ether、gwei、wei）
          
          [default: wei]

Options:
  -h, --help
          打印帮助信息（使用 '-h' 查看摘要）
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># cast to-utf8

将十六进制数据转换为 utf-8 字符串

```bash
$ cast to-utf8 --help
Usage: cast to-utf8 [HEXDATA]

Arguments:
  [HEXDATA]  要转换的十六进制数据

Options:
  -h, --help  打印帮助信息
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-json">{
  "translation": "# cast to-wei\n\n将 ETH 数量转换为 wei。\n\n```bash\n$ cast to-wei --help\nUsage: cast to-wei [VALUE] [UNIT]\n\nArguments:\n  [VALUE]\n          要转换的值\n\n  [UNIT]\n          要转换的单位（ether、gwei、wei）\n          \n          [default: eth]\n\nOptions:\n  -h, --help\n          打印帮助信息（使用 '-h' 查看摘要）\n```"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-json">{
  "title": "cast tx",
  "description": "获取交易信息",
  "usage": "```bash\n$ cast tx --help\nUsage: cast tx [OPTIONS] &lt;TX_HASH&gt; [FIELD]\n\nArguments:\n  &lt;TX_HASH&gt;\n          交易哈希\n\n  [FIELD]\n          如果指定，仅获取交易的指定字段。如果为“raw”，将打印RLP编码的交易\n\nOptions:\n      --raw\n          打印原始RLP编码的交易\n\n  -r, --rpc-url &lt;URL&gt;\n          RPC端点\n          \n          [env: ETH_RPC_URL=]\n\n      --flashbots\n          使用Flashbots RPC URL并启用快速模式（&lt;https://rpc.flashbots.net/fast&gt;）。\n          \n          这将私密地与所有注册的构建者共享交易。\n          \n          参见：&lt;https://docs.flashbots.net/flashbots-protect/quick-start#faster-transactions&gt;\n\n      --jwt-secret &lt;JWT_SECRET&gt;\n          RPC端点的JWT密钥。\n          \n          JWT密钥将用于创建RPC的JWT。例如，以下内容可用于模拟CL `engine_forkchoiceUpdated`调用：\n          \n          cast rpc --jwt-secret &lt;JWT_SECRET&gt; engine_forkchoiceUpdatedV2\n          '[\"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\",\n          \"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\",\n          \"0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59bc\"]'\n          \n          [env: ETH_RPC_JWT_SECRET=]\n\n  -h, --help\n          打印帮助信息（使用‘-h’查看摘要）\n\nDisplay options:\n  -j, --json\n          以JSON格式打印\n```"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-json">{
  "translation": {
    "title": "# cast upload-signature",
    "description": "将给定的签名上传到 https://openchain.xyz。",
    "usage": "```bash\n$ cast upload-signature --help\nUsage: cast upload-signature [SIGNATURES]...\n\nArguments:\n  [SIGNATURES]...\n          要上传的签名。\n          \n          前缀可以是 'function'、'event' 或 'error'。如果没有前缀，默认为 function。也可以接受合约 artifact JSON 的路径。\n\nOptions:\n  -h, --help\n          打印帮助信息（使用 '-h' 查看摘要）\n```"
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-json">{
  "translation": "# cast wallet\n\n钱包管理工具\n\n```bash\n$ cast wallet --help\nUsage: cast wallet &lt;COMMAND&gt;\n\nCommands:\n  new               创建一个新的随机密钥对 [aliases: n]\n  new-mnemonic      生成一个随机的 BIP39 助记词 [aliases: nm]\n  vanity            生成一个 vanity 地址 [aliases: va]\n  address           将私钥转换为地址 [aliases: a, addr]\n  sign              签名消息或类型化数据 [aliases: s]\n  verify            验证消息的签名 [aliases: v]\n  import            将私钥导入加密的 keystore [aliases: i]\n  list              列出 keystore 默认目录中的所有账户 [aliases: ls]\n  private-key       从助记词派生私钥 [aliases: pk]\n  decrypt-keystore  解密 keystore 文件以获取私钥 [aliases: dk]\n  help              打印此消息或给定子命令的帮助信息\n\nOptions:\n  -h, --help  打印帮助信息\n```"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-json">{
  "id": "cast-wallet-new",
  "title": "cast wallet new",
  "description": "创建一个新的随机密钥对"
}
</code></pre>
<pre><code class="language-bash">$ cast wallet new --help
用法: cast wallet new [选项] [路径]

参数:
  [路径]
          如果提供，则密钥对将写入加密的 JSON 密钥库

选项:
  -p, --password
          触发 JSON 密钥库的隐藏密码提示。
          
          已弃用: 现在默认提示隐藏密码。

      --unsafe-password &lt;PASSWORD&gt;
          JSON 密钥库的明文密码。
          
          这是不安全的用法，我们建议使用 --password。
          
          [env: CAST_PASSWORD=]

  -n, --number &lt;NUMBER&gt;
          要生成的钱包数量
          
          [默认值: 1]

  -j, --json
          以 JSON 格式输出生成的钱包

  -h, --help
          打印帮助信息（使用 '-h' 查看摘要）
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-json">{
  "translation": "# cast wallet new-mnemonic\n\n生成一个随机的 BIP39 助记词短语\n\n```bash\n$ cast wallet new-mnemonic --help\nUsage: cast wallet new-mnemonic [OPTIONS]\n\nOptions:\n  -w, --words &lt;WORDS&gt;        助记词的单词数量 [默认: 12]\n  -a, --accounts &lt;ACCOUNTS&gt;  显示的账户数量 [默认: 1]\n  -e, --entropy &lt;ENTROPY&gt;    用于生成助记词的熵\n  -h, --help                 打印帮助信息\n```"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-json">{
  "id": "cast-wallet-vanity",
  "title": "生成一个自定义地址",
  "content": "```bash\n$ cast wallet vanity --help\nUsage: cast wallet vanity [OPTIONS]\n\nOptions:\n      --starts-with &lt;HEX&gt;\n          前缀正则表达式模式或十六进制字符串\n\n      --ends-with &lt;HEX&gt;\n          后缀正则表达式模式或十六进制字符串\n\n      --nonce &lt;NONCE&gt;\n          使用指定的nonce生成由生成的密钥对创建的自定义合约地址\n\n      --save-path &lt;PATH&gt;\n          保存生成的自定义合约地址的路径。\n          \n          如果提供，生成的自定义地址将附加到指定文件中的JSON数组。\n\n  -h, --help\n          打印帮助信息（使用'-h'查看摘要）\n```"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-json">{
  "translation": "# 转换钱包地址\n\n将私钥转换为地址\n\n```bash\n$ cast wallet address --help\nUsage: cast wallet address [OPTIONS] [PRIVATE_KEY]\n\nArguments:\n  [PRIVATE_KEY]\n          如果提供，地址将从指定的私钥派生\n\nOptions:\n  -h, --help\n          打印帮助信息（使用 '-h' 查看摘要）\n\n钱包选项 - 原始:\n  -f, --from &lt;ADDRESS&gt;\n          发送者账户\n          \n          [env: ETH_FROM=]\n\n  -i, --interactive\n          打开一个交互式提示以输入您的私钥\n\n      --private-key &lt;RAW_PRIVATE_KEY&gt;\n          使用提供的私钥\n\n      --mnemonic &lt;MNEMONIC&gt;\n          使用指定路径的助记词文件或助记词短语\n\n      --mnemonic-passphrase &lt;PASSPHRASE&gt;\n          使用助记词的 BIP39 密码\n\n      --mnemonic-derivation-path &lt;PATH&gt;\n          钱包派生路径。\n          \n          适用于 --mnemonic-path 和硬件钱包。\n\n      --mnemonic-index &lt;INDEX&gt;\n          使用给定助记词索引的私钥。\n          \n          与 --mnemonic-path 一起使用。\n          \n          [default: 0]\n\n钱包选项 - 密钥库:\n      --keystore &lt;PATH&gt;\n          使用指定文件夹或文件中的密钥库\n          \n          [env: ETH_KEYSTORE=]\n\n      --account &lt;ACCOUNT_NAME&gt;\n          通过文件名从默认密钥库文件夹 (~/.foundry/keystores) 中使用密钥库\n          \n          [env: ETH_KEYSTORE_ACCOUNT=]\n\n      --password &lt;PASSWORD&gt;\n          密钥库密码。\n          \n          与 --keystore 一起使用。\n\n      --password-file &lt;PASSWORD_FILE&gt;\n          密钥库密码文件路径。\n          \n          与 --keystore 一起使用。\n          \n          [env: ETH_PASSWORD=]\n\n钱包选项 - 硬件钱包:\n  -l, --ledger\n          使用 Ledger 硬件钱包\n\n  -t, --trezor\n          使用 Trezor 硬件钱包\n\n钱包选项 - 远程:\n      --aws\n          使用 AWS 密钥管理服务\n```"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># cast wallet sign

签名消息或类型化数据

```bash
$ cast wallet sign --help
Usage: cast wallet sign [OPTIONS] &lt;MESSAGE&gt;

Arguments:
  &lt;MESSAGE&gt;
          要签名的消息、类型化数据或哈希。
          
          以0x开头的消息预期为十六进制编码，会在签名前进行解码。
          
          消息会在签名前加上以太坊签名消息头并进行哈希处理，除非提供了 `--no-hash`。
          
          类型化数据可以作为JSON字符串或文件名提供。使用 `--data` 标志表示消息是类型化数据的字符串。使用 `--data --from-file` 表示消息是包含类型化数据的文件名。数据将按照EIP712规范组合并进行哈希处理后再签名。数据应格式化为JSON。

Options:
      --data
          将消息视为JSON类型化数据

      --from-file
          将消息视为包含JSON类型化数据的文件。需要 `--data`

      --no-hash
          将消息视为原始的32字节哈希并直接签名，不再进行哈希处理

  -h, --help
          打印帮助信息（使用 `-h` 查看摘要）

Wallet options - raw:
  -f, --from &lt;ADDRESS&gt;
          发送者账户
          
          [env: ETH_FROM=]

  -i, --interactive
          打开一个交互式提示以输入您的私钥

      --private-key &lt;RAW_PRIVATE_KEY&gt;
          使用提供的私钥

      --mnemonic &lt;MNEMONIC&gt;
          使用指定路径的助记词或助记词文件

      --mnemonic-passphrase &lt;PASSPHRASE&gt;
          使用BIP39助记词的密码

      --mnemonic-derivation-path &lt;PATH&gt;
          钱包派生路径。
          
          适用于 --mnemonic-path 和硬件钱包。

      --mnemonic-index &lt;INDEX&gt;
          使用给定助记词索引的私钥。
          
          与 --mnemonic-path 一起使用。
          
          [default: 0]

Wallet options - keystore:
      --keystore &lt;PATH&gt;
          使用给定文件夹或文件中的keystore
          
          [env: ETH_KEYSTORE=]

      --account &lt;ACCOUNT_NAME&gt;
          通过文件名从默认keystore文件夹（~/.foundry/keystores）中使用keystore
          
          [env: ETH_KEYSTORE_ACCOUNT=]

      --password &lt;PASSWORD&gt;
          keystore密码。
          
          与 --keystore 一起使用。

      --password-file &lt;PASSWORD_FILE&gt;
          keystore密码文件路径。
          
          与 --keystore 一起使用。
          
          [env: ETH_PASSWORD=]

Wallet options - hardware wallet:
  -l, --ledger
          使用Ledger硬件钱包

  -t, --trezor
          使用Trezor硬件钱包

Wallet options - remote:
      --aws
          使用AWS Key Management Service
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># cast wallet verify

验证消息的签名

```bash
$ cast wallet verify --help
Usage: cast wallet verify --address &lt;ADDRESS&gt; &lt;MESSAGE&gt; &lt;SIGNATURE&gt;

Arguments:
  &lt;MESSAGE&gt;    原始消息
  &lt;SIGNATURE&gt;  要验证的签名

Options:
  -a, --address &lt;ADDRESS&gt;  消息签名者的地址
  -h, --help               打印帮助信息
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-json">{
  "translation": "# cast wallet import\n\n将私钥导入加密密钥库\n\n```bash\n$ cast wallet import --help\nUsage: cast wallet import [OPTIONS] &lt;ACCOUNT_NAME&gt;\n\nArguments:\n  &lt;ACCOUNT_NAME&gt;\n          密钥库中账户的名称\n\nOptions:\n  -k, --keystore-dir &lt;KEYSTORE_DIR&gt;\n          如果提供，密钥库将保存在这里，而不是默认的密钥库目录\n          (~/.foundry/keystores)\n\n      --unsafe-password &lt;PASSWORD&gt;\n          明文密码用于JSON密钥库。这是不安全的，我们建议使用默认的隐藏密码提示\n          \n          [env: CAST_UNSAFE_PASSWORD=]\n\n  -h, --help\n          打印帮助信息（使用'-h'查看摘要）\n\n钱包选项 - 原始:\n  -i, --interactive\n          打开一个交互式提示以输入您的私钥\n\n      --private-key &lt;RAW_PRIVATE_KEY&gt;\n          使用提供的私钥\n\n      --mnemonic &lt;MNEMONIC&gt;\n          使用指定路径的助记词短语或助记词文件\n\n      --mnemonic-passphrase &lt;PASSPHRASE&gt;\n          使用BIP39助记词的密码\n\n      --mnemonic-derivation-path &lt;PATH&gt;\n          钱包派生路径。\n          \n          适用于--mnemonic-path和硬件钱包。\n\n      --mnemonic-index &lt;INDEX&gt;\n          使用给定助记词索引的私钥。\n          \n          与--mnemonic-path一起使用。\n          \n          [default: 0]\n```"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># cast wallet list

列出密钥库默认目录中的所有账户

```bash
$ cast wallet list --help
Usage: cast wallet list [OPTIONS]

Options:
      --dir [&lt;DIR&gt;]                列出密钥库目录中的所有账户。如果没有提供路径，则使用默认密钥库目录
  -l, --ledger                      列出来自 Ledger 硬件钱包的账户
  -t, --trezor                      列出来自 Trezor 硬件钱包的账户
      --aws                         列出来自 AWS KMS 的账户
      --all                         列出所有已配置的账户
  -m, --max-senders &lt;MAX_SENDERS&gt;   从硬件钱包中显示的最大地址数量 [默认: 3]
  -h, --help                        打印帮助信息
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># cast wallet private-key

从助记词派生私钥

```bash
$ cast wallet private-key --help
Usage: cast wallet private-key [OPTIONS] [MNEMONIC] [MNEMONIC_INDEX_OR_DERIVATION_PATH]

Arguments:
  [MNEMONIC]
          如果提供，私钥将从指定的助记词短语派生

  [MNEMONIC_INDEX_OR_DERIVATION_PATH]
          如果提供，私钥将使用指定的助记词索引（如果是整数）或派生路径派生

Options:
  -v, --verbose
          详细模式，打印地址和私钥

  -h, --help
          打印帮助信息（使用 '-h' 查看摘要）

Wallet options - raw:
  -f, --from &lt;ADDRESS&gt;
          发送者账户
          
          [env: ETH_FROM=]

  -i, --interactive
          打开一个交互式提示以输入您的私钥

      --private-key &lt;RAW_PRIVATE_KEY&gt;
          使用提供的私钥

      --mnemonic &lt;MNEMONIC&gt;
          使用指定路径的助记词短语或助记词文件

      --mnemonic-passphrase &lt;PASSPHRASE&gt;
          使用 BIP39 助记词密码

      --mnemonic-derivation-path &lt;PATH&gt;
          钱包派生路径。
          
          适用于 --mnemonic-path 和硬件钱包。

      --mnemonic-index &lt;INDEX&gt;
          使用给定助记词索引的私钥。
          
          与 --mnemonic-path 一起使用。
          
          [default: 0]

Wallet options - keystore:
      --keystore &lt;PATH&gt;
          使用指定文件夹或文件中的 keystore
          
          [env: ETH_KEYSTORE=]

      --account &lt;ACCOUNT_NAME&gt;
          通过其文件名从默认 keystores 文件夹（~/.foundry/keystores）中使用 keystore
          
          [env: ETH_KEYSTORE_ACCOUNT=]

      --password &lt;PASSWORD&gt;
          keystore 密码。
          
          与 --keystore 一起使用。

      --password-file &lt;PASSWORD_FILE&gt;
          keystore 密码文件路径。
          
          与 --keystore 一起使用。
          
          [env: ETH_PASSWORD=]

Wallet options - hardware wallet:
  -l, --ledger
          使用 Ledger 硬件钱包

  -t, --trezor
          使用 Trezor 硬件钱包

Wallet options - remote:
      --aws
          使用 AWS Key Management Service
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># cast wallet decrypt-keystore

解密 keystore 文件以获取私钥

```bash
$ cast wallet decrypt-keystore --help
Usage: cast wallet decrypt-keystore [OPTIONS] &lt;ACCOUNT_NAME&gt;

Arguments:
  &lt;ACCOUNT_NAME&gt;  在 keystore 中的账户名称

Options:
  -k, --keystore-dir &lt;KEYSTORE_DIR&gt;  如果未提供，keystore 将尝试在默认的 keystores 目录（~/.foundry/keystores）中定位
      --unsafe-password &lt;PASSWORD&gt;   明文密码用于 JSON keystore。这是不安全的，我们建议使用默认的隐藏密码提示 [env: CAST_UNSAFE_PASSWORD=]
  -h, --help                         打印帮助信息
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-json">{
  "translation": "# anvil\n\n一个快速的本地以太坊开发节点\n\n```bash\n$ anvil --help\nUsage: anvil [OPTIONS] [COMMAND]\n\nCommands:\n  completions        生成 shell 自动补全脚本 [aliases: com]\n  generate-fig-spec  生成 Fig 自动补全规范 [aliases: fig]\n  help               打印此消息或给定子命令的帮助信息\n\nOptions:\n  -a, --accounts &lt;NUM&gt;\n          生成和配置的开发账户数量\n          \n          [default: 10]\n\n  -b, --block-time &lt;SECONDS&gt;\n          间隔挖矿的区块时间（秒）\n          \n          [aliases: blockTime]\n\n      --balance &lt;NUM&gt;\n          每个开发账户的余额（以太币）\n          \n          [default: 10000]\n\n      --config-out &lt;OUT_FILE&gt;\n          将 `anvil` 的输出以 json 格式写入用户指定的文件\n\n      --derivation-path &lt;DERIVATION_PATH&gt;\n          设置要派生的子密钥的派生路径。\n          \n          [default: m/44'/60'/0'/0/]\n\n      --dump-state &lt;PATH&gt;\n          在退出时将链的状态和区块环境转储到给定文件。\n          \n          如果值是目录，状态将写入 `&lt;VALUE&gt;/state.json`。\n\n  -h, --help\n          打印帮助信息（用 '-h' 查看摘要）\n\n      --hardfork &lt;HARDFORK&gt;\n          使用的 EVM 硬分叉。\n          \n          通过名称选择硬分叉，例如 `shanghai`, `paris`, `london` 等... [default: latest]\n\n      --init &lt;PATH&gt;\n          使用给定的 `genesis.json` 文件初始化创世区块\n\n      --ipc [&lt;PATH&gt;]\n          在给定路径或默认路径 = `/tmp/anvil.ipc` 启动一个 ipc 服务器\n          \n          [aliases: ipcpath]\n\n      --load-state &lt;PATH&gt;\n          从之前保存的状态快照初始化链\n\n  -m, --mnemonic &lt;MNEMONIC&gt;\n          用于生成账户的 BIP39 助记词短语。不能与 `mnemonic_random` 或 `mnemonic_seed` 一起使用\n\n      --mnemonic-random [&lt;MNEMONIC_RANDOM&gt;]\n          自动生成一个 BIP39 助记词短语，并从中派生账户。不能与其他 `mnemonic` 选项一起使用。你可以指定助记词中想要包含的单词数量。[default: 12]\n\n      --mnemonic-seed-unsafe &lt;MNEMONIC_SEED&gt;\n          从给定的种子生成一个 BIP39 助记词短语。不能与其他 `mnemonic` 选项一起使用。\n          \n          小心：这不安全，仅应用于测试。切勿在生产环境中使用生成的私钥。\n\n      --no-mining\n          禁用自动和间隔挖矿，改为按需挖矿\n          \n          [aliases: no-mine]\n\n      --order &lt;ORDER&gt;\n          交易在 mempool 中的排序方式\n          \n          [default: fees]\n\n  -p, --port &lt;NUM&gt;\n          监听的端口号\n          \n          [default: 8545]\n\n      --prune-history [&lt;PRUNE_HISTORY&gt;]\n          不保留完整的链历史记录。如果指定了一个数字参数，最多保留该数量的状态在内存中\n\n  -s, --state-interval &lt;SECONDS&gt;\n          状态和区块环境转储到磁盘的时间间隔（秒）。\n          \n          见 --state 和 --dump-state\n\n      --silent\n          启动时不打印任何内容，也不打印日志\n\n      --slots-in-an-epoch &lt;SLOTS_IN_AN_EPOCH&gt;\n          一个 epoch 中的 slots 数量\n          \n          [default: 32]\n\n      --state &lt;PATH&gt;\n          这是 --load-state 和 --dump-state 的别名。\n          \n          如果文件存在，使用存储在文件中的状态和区块环境初始化链，并在退出时转储链的状态。\n\n      --timestamp &lt;NUM&gt;\n          创世区块的时间戳\n\n      --transaction-block-keeper &lt;TRANSACTION_BLOCK_KEEPER&gt;\n          内存中保留的交易区块数量\n\n  -V, --version\n          打印版本信息\n\nServer options:\n      --allow-origin &lt;ALLOW_ORIGIN&gt;\n          cors `allow_origin` 头\n          \n          [default: *]\n\n      --host &lt;IP_ADDR&gt;\n          服务器将监听的主机\n          \n          [env: ANVIL_IP_ADDR=]\n          [default: 127.0.0.1]\n\n      --no-cors\n          禁用 CORS\n\n      --no-request-size-limit\n          禁用默认的请求体大小限制。目前默认限制为 2MB\n\nFork config:\n      --compute-units-per-second &lt;CUPS&gt;\n          设置此提供商假设可用的每秒计算单元数量\n          \n          默认值：330\n          \n          另见 --fork-url 和\n          &lt;https://docs.alchemy.com/reference/compute-units#what-are-cups-compute-units-per-second&gt;\n\n  -f, --fork-url &lt;URL&gt;\n          从远程端点获取状态，而不是从空状态开始。\n          \n          如果你想从特定的区块号获取状态，添加一个区块号，例如 `http://localhost:8545@1400000` 或使用 `--fork-block-number` 参数。\n          \n          [aliases: rpc-url]\n\n      --fork-block-number &lt;BLOCK&gt;\n          从远程端点获取特定区块号的状态。\n          \n          见 --fork-url。\n\n      --fork-chain-id &lt;CHAIN&gt;\n          指定链 ID 以跳过从远程端点获取。这启用了离线启动模式。\n          \n          你仍然必须传递 `--fork-url` 和 `--fork-block-number`，并且已经在磁盘上缓存了所需的状态，任何本地缺失的内容将从远程获取。\n\n      --fork-header &lt;HEADERS&gt;\n          用于 rpc 客户端的头信息，例如 \"User-Agent: test-agent\"\n          \n          见 --fork-url。\n\n      --fork-retry-backoff &lt;BACKOFF&gt;\n          遇到错误时的初始重试退避。\n          \n          见 --fork-url。\n\n      --fork-transaction-hash &lt;TRANSACTION&gt;\n          从远程端点获取特定交易哈希的状态。\n          \n          见 --fork-url。\n\n      --no-rate-limit\n          禁用此节点提供商的速率限制。\n          \n          默认值：false\n          \n          另见 --fork-url 和\n          &lt;https://docs.alchemy.com/reference/compute-units#what-are-cups-compute-units-per-second&gt;\n          \n          [aliases: no-rpc-rate-limit]\n\n      --no-storage-caching\n          明确禁用 RPC 缓存的使用。\n          \n          所有存储槽完全从端点读取。\n          \n          此标志覆盖项目的配置文件。\n          \n          见 --fork-url。\n\n      --retries &lt;retries&gt;\n          对不稳定网络的重试请求次数（超时请求）\n          \n          默认值 5\n\n      --timeout &lt;timeout&gt;\n          在分叉模式下发送给远程 JSON-RPC 服务器的请求的超时时间（毫秒）。\n          \n          默认值 45000\n\nEnvironment config:\n      --block-base-fee-per-gas &lt;FEE&gt;\n          区块中的基础费用\n          \n          [aliases: base-fee]\n\n      --chain-id &lt;CHAIN_ID&gt;\n          链 ID\n\n      --code-size-limit &lt;CODE_SIZE&gt;\n          EIP-170：合约代码大小限制（字节）。增加此值是因为测试。默认值为 0x6000（~25kb）\n\n      --disable-block-gas-limit\n          禁用 `call.gas_limit &lt;= block.gas_limit` 约束\n\n      --gas-limit &lt;GAS_LIMIT&gt;\n          区块 gas 限制\n\n      --gas-price &lt;GAS_PRICE&gt;\n          gas 价格\n\nEVM options:\n      --auto-impersonate\n          启动时启用 autoImpersonate\n          \n          [aliases: auto-impersonate]\n\n      --disable-default-create2-deployer\n          禁用默认的 create2 部署者\n          \n          [aliases: no-create2]\n\n      --memory-limit &lt;MEMORY_LIMIT&gt;\n          每个 EVM 执行的内存限制（字节）\n\n      --optimism\n          运行一个 Optimism 链\n          \n          [aliases: optimism]\n\n      --steps-tracing\n          启用用于调试调用返回 geth 风格 traces 的步骤跟踪\n          \n          [aliases: tracing]\n```"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-json">{
  "translation": "# anvil completions\n\n生成 shell 自动补全脚本\n\n```bash\n$ anvil completions --help\nUsage: anvil completions &lt;SHELL&gt;\n\nArguments:\n  &lt;SHELL&gt;  [possible values: bash, elvish, fish, powershell, zsh]\n\nOptions:\n  -h, --help  打印帮助信息\n```"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-json">{
  "translation": "# anvil generate-fig-spec\n\n生成 Fig 自动补全规范\n\n```bash\n$ anvil generate-fig-spec --help\nUsage: anvil generate-fig-spec\n\nOptions:\n  -h, --help  打印帮助信息\n```"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># chisel

快速、实用且详细的 Solidity REPL

```bash
$ chisel --help
Usage: chisel [OPTIONS] [COMMAND]

Commands:
  list         列出所有缓存的会话
  load         加载一个缓存的会话
  view         查看缓存会话的源代码
  clear-cache  清除缓存目录中的所有缓存 chisel 会话
  help         打印此消息或给定子命令的帮助信息

Options:
  -h, --help
          打印帮助信息（使用 '-h' 查看摘要）

  -V, --version
          打印版本信息

REPL 选项:
      --prelude &lt;PRELUDE&gt;
          指向包含 Solidity 文件的目录的路径，或单个 Solidity 文件的路径。
          
          这些文件将在 REPL 的顶层之前进行评估，因此可以作为 prelude 使用。

      --no-vm
          禁用默认的 `Vm` 导入。
          
          如果 Solc 版本小于 0.6.2，默认情况下会禁用此导入。

缓存选项:
      --force
          清除缓存和 artifacts 文件夹并重新编译

构建选项:
      --no-cache
          禁用缓存

      --skip &lt;SKIP&gt;...
          跳过构建名称包含给定过滤器的文件。
          
          `test` 和 `script` 是 `.t.sol` 和 `.s.sol` 的别名。

链接器选项:
      --libraries &lt;LIBRARIES&gt;
          设置预链接的库
          
          [env: DAPP_LIBRARIES=]

编译器选项:
      --ignored-error-codes &lt;ERROR_CODES&gt;
          忽略 solc 警告的错误代码

      --deny-warnings
          警告将触发编译器错误

      --no-auto-detect
          不要自动检测 `solc` 版本

      --use &lt;SOLC_VERSION&gt;
          指定用于构建的 solc 版本，或本地 solc 的路径。
          
          有效值格式为 `x.y.z`、`solc:x.y.z` 或 `path/to/solc`。

      --offline
          不要访问网络。
          
          缺失的 solc 版本将不会被安装。

      --via-ir
          使用 Yul 中间表示编译管道

      --no-metadata
          不要在字节码中附加任何元数据。
          
          这相当于将 `bytecode_hash` 设置为 `none` 并将 `cbor_metadata` 设置为 `false`。

      --silent
          启动时不打印任何内容

      --ast
          在编译器输出中包含 AST 的 JSON

      --evm-version &lt;VERSION&gt;
          目标 EVM 版本

      --optimize
          激活 Solidity 优化器

      --optimizer-runs &lt;RUNS&gt;
          优化器运行的次数

      --extra-output &lt;SELECTOR&gt;...
          在合约的 artifact 中包含的额外输出。
          
          示例键：evm.assembly、ewasm、ir、irOptimized、metadata
          
          完整描述请参见
          &lt;https://docs.soliditylang.org/en/v0.8.13/using-the-compiler.html#input-description&gt;

      --extra-output-files &lt;SELECTOR&gt;...
          写入单独文件的额外输出。
          
          有效值：metadata、ir、irOptimized、ewasm、evm.assembly

项目选项:
  -o, --out &lt;PATH&gt;
          合约 artifacts 文件夹的路径

      --revert-strings &lt;REVERT&gt;
          回退字符串配置。
          
          可能的值为 "default"、"strip"（移除）、"debug"（Solidity 生成的回退字符串）和 "verboseDebug"

      --build-info
          生成构建信息文件

      --build-info-path &lt;PATH&gt;
          构建信息文件将写入的目录的输出路径

      --root &lt;PATH&gt;
          项目的根路径。
          
          默认情况下是 Git 仓库的根目录（如果在仓库中），或当前工作目录。

  -C, --contracts &lt;PATH&gt;
          合约源目录

  -R, --remappings &lt;REMAPPINGS&gt;
          项目的 remappings

      --remappings-env &lt;ENV&gt;
          从环境获取项目的 remappings

      --cache-path &lt;PATH&gt;
          编译器缓存的路径

      --lib-paths &lt;PATH&gt;
          库文件夹的路径

      --hardhat
          使用 Hardhat 风格的项目布局。
          
          这相当于使用：`--contracts contracts --lib-paths node_modules`。
          
          [aliases: hh]

      --config-path &lt;FILE&gt;
          配置文件的路径

EVM 选项:
  -f, --fork-url &lt;URL&gt;
          通过远程端点获取状态，而不是从空状态开始。
          
          如果你想从特定区块号获取状态，请参见 --fork-block-number。
          
          [aliases: rpc-url]

      --fork-block-number &lt;BLOCK&gt;
          通过远程端点从特定区块号获取状态。
          
          请参见 --fork-url。

      --fork-retries &lt;RETRIES&gt;
          重试次数。
          
          请参见 --fork-url。

      --fork-retry-backoff &lt;BACKOFF&gt;
          遇到错误时的初始重试退避。
          
          请参见 --fork-url。

      --no-storage-caching
          显式禁用 RPC 缓存。
          
          所有存储槽完全从端点读取。
          
          此标志会覆盖项目的配置文件。
          
          请参见 --fork-url。

      --initial-balance &lt;BALANCE&gt;
          部署测试合约的初始余额

      --sender &lt;ADDRESS&gt;
          将执行测试的地址

      --ffi
          启用 FFI cheatcode

      --always-use-create-2-factory
          在所有情况下（包括测试和非广播脚本）使用 create 2 工厂

  -v, --verbosity...
          EVM 的详细程度。
          
          多次传递以增加详细程度（例如 -v、-vv、-vvv）。
          
          详细程度级别：
          - 2：打印所有测试的日志
          - 3：打印失败测试的执行 traces
          - 4：打印所有测试的执行 traces，以及失败测试的设置 traces
          - 5：打印所有测试的执行和设置 traces

Fork 配置:
      --compute-units-per-second &lt;CUPS&gt;
          设置此提供者假设可用的计算单元每秒数量
          
          默认值：330
          
          请参见 --fork-url 和
          &lt;https://docs.alchemy.com/reference/compute-units#what-are-cups-compute-units-per-second&gt;

      --no-rpc-rate-limit
          禁用此节点提供者的速率限制。
          
          请参见 --fork-url 和
          &lt;https://docs.alchemy.com/reference/compute-units#what-are-cups-compute-units-per-second&gt;
          
          [aliases: no-rate-limit]

执行环境配置:
      --gas-limit &lt;GAS_LIMIT&gt;
          区块 gas 限制

      --code-size-limit &lt;CODE_SIZE&gt;
          EIP-170：合约代码大小限制（字节）。增加此值有助于测试。默认值为 0x6000（~25kb）

      --chain &lt;CHAIN&gt;
          链名称或 EIP-155 链 ID
          
          [aliases: chain-id]

      --gas-price &lt;GAS_PRICE&gt;
          gas 价格

      --block-base-fee-per-gas &lt;FEE&gt;
          区块中的基础费用
          
          [aliases: base-fee]

      --tx-origin &lt;ADDRESS&gt;
          交易发起者

      --block-coinbase &lt;ADDRESS&gt;
          区块的 coinbase

      --block-timestamp &lt;TIMESTAMP&gt;
          区块的时间戳

      --block-number &lt;BLOCK&gt;
          区块号

      --block-difficulty &lt;DIFFICULTY&gt;
          区块难度

      --block-prevrandao &lt;PREVRANDAO&gt;
          区块的 prevrandao 值。注意：合并前此字段为 mix_hash

      --block-gas-limit &lt;GAS_LIMIT&gt;
          区块 gas 限制

      --memory-limit &lt;MEMORY_LIMIT&gt;
          EVM 执行的内存限制（字节）。如果超过此限制，将抛出 `MemoryLimitOOG` 结果。
          
          默认值为 128MiB。

      --disable-block-gas-limit
          是否禁用区块 gas 限制检查
          
          [aliases: no-gas-limit]

      --isolate
          是否启用调用的隔离。在隔离模式下，所有顶级调用都作为单独的交易在单独的 EVM 上下文中执行，从而实现更精确的 gas 计算和交易状态变化
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chisel-list"><a class="header" href="#chisel-list">chisel list</a></h1>
<p>列出所有缓存的会话</p>
<pre><code class="language-bash">$ chisel list --help
Usage: chisel list

Options:
  -h, --help  打印帮助信息
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chisel-load"><a class="header" href="#chisel-load">chisel load</a></h1>
<p>加载缓存的会话</p>
<pre><code class="language-bash">$ chisel load --help
Usage: chisel load &lt;ID&gt;

Arguments:
  &lt;ID&gt;  要加载的会话的ID

Options:
  -h, --help  打印帮助信息
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># chisel view

查看缓存会话的源代码

```bash
$ chisel view --help
Usage: chisel view &lt;ID&gt;

Arguments:
  &lt;ID&gt;  要加载的会话的ID

Options:
  -h, --help  打印帮助信息
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-json">{
  "translation": "# chisel clear-cache\n\n清除缓存目录中的所有缓存 chisel 会话\n\n```bash\n$ chisel clear-cache --help\nUsage: chisel clear-cache\n\nOptions:\n  -h, --help  打印帮助信息\n```"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="forge-命令"><a class="header" href="#forge-命令">forge 命令</a></h2>
<ul>
<li><a href="reference/forge/./general-commands.html">通用命令</a></li>
<li><a href="reference/forge/./project-commands.html">项目命令</a></li>
<li><a href="reference/forge/./build-commands.html">构建命令</a></li>
<li><a href="reference/forge/./test-commands.html">测试命令</a></li>
<li><a href="reference/forge/./deploy-commands.html">部署命令</a></li>
<li><a href="reference/forge/./utility-commands.html">实用工具命令</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="通用命令"><a class="header" href="#通用命令">通用命令</a></h2>
<ul>
<li><a href="reference/forge/./forge.html">forge</a></li>
<li><a href="reference/forge/./forge-help.html">forge help</a></li>
<li><a href="reference/forge/./forge-completions.html">forge completions</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="forge"><a class="header" href="#forge">forge</a></h2>
<h3 id="name"><a class="header" href="#name">NAME</a></h3>
<p>forge - 构建、测试、模糊测试、调试和部署 Solidity 合约。</p>
<h3 id="synopsis"><a class="header" href="#synopsis">SYNOPSIS</a></h3>
<p><code>forge</code> [<em>options</em>] <em>command</em> [<em>args</em>]<br />
<code>forge</code> [<em>options</em>] <code>--version</code><br />
<code>forge</code> [<em>options</em>] <code>--help</code></p>
<h3 id="description"><a class="header" href="#description">DESCRIPTION</a></h3>
<p>这个程序是一组工具，用于构建、测试、模糊测试、调试和部署 Solidity 智能合约。</p>
<h3 id="commands"><a class="header" href="#commands">COMMANDS</a></h3>
<h4 id="通用命令-1"><a class="header" href="#通用命令-1">通用命令</a></h4>
<p><a href="reference/forge/./forge-help.html">forge help</a><br />
    显示关于 Forge 的帮助信息。</p>
<p><a href="reference/forge/./forge-completions.html">forge completions</a><br />
    生成 Forge 的 shell 自动补全。</p>
<h4 id="项目命令"><a class="header" href="#项目命令">项目命令</a></h4>
<p><a href="reference/forge/./forge-init.html">forge init</a><br />
    创建一个新的 Forge 项目。</p>
<p><a href="reference/forge/./forge-clone.html">forge clone</a><br />
    将链上已验证的合约克隆为 Forge 项目。</p>
<p><a href="reference/forge/./forge-install.html">forge install</a><br />
    安装一个或多个依赖项。</p>
<p><a href="reference/forge/./forge-update.html">forge update</a><br />
    更新一个或多个依赖项。</p>
<p><a href="reference/forge/./forge-remove.html">forge remove</a><br />
    移除一个或多个依赖项。</p>
<p><a href="reference/forge/./forge-config.html">forge config</a><br />
    显示当前配置。</p>
<p><a href="reference/forge/./forge-remappings.html">forge remappings</a><br />
    获取项目自动推断的重映射。</p>
<p><a href="reference/forge/./forge-tree.html">forge tree</a><br />
    显示项目依赖图的树形可视化。</p>
<p><a href="reference/forge/./forge-geiger.html">forge geiger</a><br />
    检测 Foundry 项目及其依赖项中不安全作弊代码的使用情况。</p>
<h4 id="构建命令"><a class="header" href="#构建命令">构建命令</a></h4>
<p><a href="reference/forge/./forge-build.html">forge build</a><br />
    构建项目的智能合约。</p>
<p><a href="reference/forge/./forge-clean.html">forge clean</a><br />
    移除构建产物和缓存目录。</p>
<p><a href="reference/forge/./forge-inspect.html">forge inspect</a><br />
    获取智能合约的专用信息。</p>
<h4 id="测试命令"><a class="header" href="#测试命令">测试命令</a></h4>
<p><a href="reference/forge/./forge-test.html">forge test</a><br />
    运行项目的测试。</p>
<p><a href="reference/forge/./forge-snapshot.html">forge snapshot</a><br />
    创建每个测试的 gas 使用快照。</p>
<p><a href="reference/forge/./forge-coverage.html">forge coverage</a><br />
    生成覆盖率报告。</p>
<h4 id="部署命令"><a class="header" href="#部署命令">部署命令</a></h4>
<p><a href="reference/forge/./forge-create.html">forge create</a><br />
    部署智能合约。</p>
<p><a href="reference/forge/./forge-verify-contract.html">forge verify-contract</a><br />
    在 Etherscan 上验证智能合约。</p>
<p><a href="reference/forge/./forge-verify-check.html">forge verify-check</a><br />
    检查 Etherscan 上的验证状态。</p>
<p><a href="reference/forge/./forge-flatten.html">forge flatten</a><br />
    将源文件及其所有导入展平为一个文件。</p>
<h4 id="实用命令"><a class="header" href="#实用命令">实用命令</a></h4>
<p><a href="reference/forge/./forge-debug.html">forge debug</a><br />
    将单个智能合约作为脚本进行调试。</p>
<p><a href="reference/forge/./forge-bind.html">forge bind</a><br />
    为智能合约生成 Rust 绑定。</p>
<p><a href="reference/forge/./forge-cache.html">forge cache</a><br />
    管理 Foundry 缓存。</p>
<p><a href="reference/forge/./forge-cache-clean.html">forge cache clean</a><br />
    清除 <code>~/.foundry</code> 中的缓存数据。</p>
<p><a href="reference/forge/./forge-cache-ls.html">forge cache ls</a><br />
    显示 <code>~/.foundry</code> 中的缓存数据。</p>
<p><a href="reference/forge/./forge-script.html">forge script</a><br />
    将智能合约作为脚本运行，构建可以发送到链上的交易。</p>
<p><a href="reference/forge/./forge-upload-selectors.html">forge upload-selectors</a><br />
    将给定合约的 ABI 上传到 https://sig.eth.samczsun.com 函数选择器数据库。</p>
<p><a href="reference/forge/./forge-doc.html">forge doc</a><br />
    为 Solidity 源文件生成文档。</p>
<h3 id="options"><a class="header" href="#options">OPTIONS</a></h3>
<h4 id="特殊选项"><a class="header" href="#特殊选项">特殊选项</a></h4>
<p><code>-V</code><br />
<code>--version</code><br />
    打印版本信息并退出。</p>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="files"><a class="header" href="#files">FILES</a></h3>
<p><code>~/.foundry/</code><br />
    Foundry 的默认“主”目录位置，存储各种文件。</p>
<p><code>~/.foundry/bin/</code><br />
    使用 <code>foundryup</code> 安装的二进制文件将位于此处。</p>
<p><code>~/.foundry/cache/</code><br />
    Forge 的缓存目录，存储缓存的区块数据等。</p>
<p><code>~/.foundry/foundry.toml</code><br />
    全局 <a href="reference/forge/../config/overview.html">Foundry 配置</a>。</p>
<p><code>~/.svm</code><br />
    Forge 管理的 solc 二进制文件的位置。</p>
<h3 id="examples"><a class="header" href="#examples">EXAMPLES</a></h3>
<ol>
<li>
<p>创建一个新的 Forge 项目：</p>
<pre><code class="language-sh">forge init hello_foundry
</code></pre>
</li>
<li>
<p>构建项目：</p>
<pre><code class="language-sh">forge build
</code></pre>
</li>
<li>
<p>运行项目的测试：</p>
<pre><code class="language-sh">forge test
</code></pre>
</li>
</ol>
<h3 id="bugs"><a class="header" href="#bugs">BUGS</a></h3>
<p>查看 <a href="https://github.com/foundry-rs/foundry/issues" target="_blank">https://github.com/foundry-rs/foundry/issues</a> 获取问题。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="forge-help-1"><a class="header" href="#forge-help-1">forge help</a></h2>
<h3 id="名称"><a class="header" href="#名称">名称</a></h3>
<p>forge-help - 获取 Forge 命令的帮助信息</p>
<h3 id="概要"><a class="header" href="#概要">概要</a></h3>
<p><code>forge help</code> [<em>子命令</em>]</p>
<h3 id="描述"><a class="header" href="#描述">描述</a></h3>
<p>打印给定命令的帮助信息。</p>
<h3 id="示例-2"><a class="header" href="#示例-2">示例</a></h3>
<ol>
<li>
<p>获取命令的帮助信息：</p>
<pre><code class="language-sh">forge help build
</code></pre>
</li>
<li>
<p>也可以使用 <code>--help</code> 标志获取帮助信息：</p>
<pre><code class="language-sh">forge build --help
</code></pre>
</li>
</ol>
<h3 id="参见"><a class="header" href="#参见">参见</a></h3>
<p><a href="reference/forge/./forge.html">forge</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="forge-completions-1"><a class="header" href="#forge-completions-1">forge completions</a></h2>
<h3 id="name-1"><a class="header" href="#name-1">NAME</a></h3>
<p>forge-completions - 生成 shell 自动补全脚本</p>
<h3 id="synopsis-1"><a class="header" href="#synopsis-1">SYNOPSIS</a></h3>
<p><code>forge completions</code> <em>shell</em></p>
<h3 id="description-1"><a class="header" href="#description-1">DESCRIPTION</a></h3>
<p>为指定的 shell 生成自动补全脚本。</p>
<p>支持的 shell 有：</p>
<ul>
<li>bash</li>
<li>elvish</li>
<li>fish</li>
<li>powershell</li>
<li>zsh</li>
</ul>
<h3 id="options-1"><a class="header" href="#options-1">OPTIONS</a></h3>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-1"><a class="header" href="#examples-1">EXAMPLES</a></h3>
<ol>
<li>为 zsh 生成 shell 自动补全脚本：
<pre><code class="language-sh">forge completions zsh &gt; $HOME/.oh-my-zsh/completions/_forge
</code></pre>
</li>
</ol>
<h3 id="see-also"><a class="header" href="#see-also">SEE ALSO</a></h3>
<p><a href="reference/forge/./forge.html">forge</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="项目命令-1"><a class="header" href="#项目命令-1">项目命令</a></h2>
<ul>
<li><a href="reference/forge/./forge-init.html">forge init</a></li>
<li><a href="reference/forge/./forge-clone.html">forge clone</a></li>
<li><a href="reference/forge/./forge-install.html">forge install</a></li>
<li><a href="reference/forge/./forge-update.html">forge update</a></li>
<li><a href="reference/forge/./forge-remove.html">forge remove</a></li>
<li><a href="reference/forge/./forge-config.html">forge config</a></li>
<li><a href="reference/forge/./forge-remappings.html">forge remappings</a></li>
<li><a href="reference/forge/./forge-tree.html">forge tree</a></li>
<li><a href="reference/forge/./forge-geiger.html">forge geiger</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="forge-init-1"><a class="header" href="#forge-init-1">forge init</a></h2>
<h3 id="name-2"><a class="header" href="#name-2">NAME</a></h3>
<p>forge-init - 创建一个新的 Forge 项目。</p>
<h3 id="synopsis-2"><a class="header" href="#synopsis-2">SYNOPSIS</a></h3>
<p><code>forge init</code> [<em>options</em>] [<em>root</em>]</p>
<h3 id="description-2"><a class="header" href="#description-2">DESCRIPTION</a></h3>
<p>在目录 <em>root</em> 中创建一个新的 Forge 项目（默认情况下为当前工作目录）。</p>
<p>默认模板创建以下项目布局：</p>
<pre><code class="language-ignore">.
├── README.md
├── foundry.toml
├── lib
│   └── forge-std
│       ├── LICENSE-APACHE
│       ├── LICENSE-MIT
│       ├── README.md
│       ├── foundry.toml
│       ├── package.json
│       ├── scripts
│       ├── src
│       └── test
├── script
│   └── Counter.s.sol
├── src
│   └── Counter.sol
└── test
    └── Counter.t.sol

8 directories, 10 files
</code></pre>
<p>然而，可以使用 <code>--template</code> 从另一个模板创建项目。</p>
<p>默认情况下，<code>forge init</code> 还会初始化一个新的 git 仓库，安装一些子模块并创建一个初始提交消息。</p>
<p>如果你不希望这种行为，可以传递 <code>--no-git</code>。</p>
<h3 id="options-2"><a class="header" href="#options-2">OPTIONS</a></h3>
<h4 id="init-options"><a class="header" href="#init-options">Init Options</a></h4>
<p><code>--force</code><br />
    即使指定的根目录不为空，也创建项目。</p>
<p><code>-t</code> <em>template</em><br />
<code>--template</code> <em>template</em><br />
    从哪个模板开始。</p>
<p><code>--vscode</code><br />
    创建一个 <code>.vscode/settings.json</code> 文件，包含 Solidity 设置，并生成一个 <code>remappings.txt</code> 文件。</p>
<p><code>--offline</code><br />
    不从网络安装依赖项。</p>
<h4 id="vcs-options"><a class="header" href="#vcs-options">VCS Options</a></h4>
<p><code>--no-commit</code><br />
    不创建初始提交。</p>
<p><code>--no-git</code><br />
    不创建 git 仓库。</p>
<h4 id="display-options"><a class="header" href="#display-options">Display Options</a></h4>
<p><code>-q</code><br />
<code>--quiet</code><br />
    不打印任何消息。</p>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-2"><a class="header" href="#examples-2">EXAMPLES</a></h3>
<ol>
<li>
<p>创建一个新的项目：</p>
<pre><code class="language-sh">forge init hello_foundry
</code></pre>
</li>
<li>
<p>创建一个新的项目，但不创建 git 仓库：</p>
<pre><code class="language-sh">forge init --no-git hello_foundry
</code></pre>
</li>
<li>
<p>强制在非空目录中创建一个新的项目：</p>
<pre><code class="language-sh">forge init --force 
</code></pre>
</li>
</ol>
<h3 id="see-also-1"><a class="header" href="#see-also-1">SEE ALSO</a></h3>
<p><a href="reference/forge/./forge.html">forge</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="forge-clone"><a class="header" href="#forge-clone">forge clone</a></h2>
<h3 id="名称-1"><a class="header" href="#名称-1">名称</a></h3>
<p>forge-clone - 将链上已验证的合约克隆为 Forge 项目。</p>
<h3 id="概要-1"><a class="header" href="#概要-1">概要</a></h3>
<p><code>forge clone</code> [<em>选项</em>] <em>地址</em> [<em>根目录</em>]</p>
<h3 id="描述-1"><a class="header" href="#描述-1">描述</a></h3>
<p>通过克隆链上已验证合约的源代码，在 <em>根目录</em> 中创建一个新的 Forge 项目（默认情况下为当前工作目录）。</p>
<p>默认情况下，<code>forge clone</code> 从以太坊主网（通过 Etherscan）克隆合约，但也可以通过指定链 ID：<code>--chain &lt;ChainID&gt;</code> 从 Foundry 支持的其他 EVM 兼容区块链克隆合约，例如 BNB 智能链（BSC）。</p>
<p>从 Etherscan 获取数据受速率限制。<code>forge clone</code> 需要两次对 Etherscan 的 API 调用，分别用于收集源代码和部署信息。默认情况下，<code>forge clone</code> 会在两次 Etherscan 调用之间等待 <em>5</em> 秒，以避免速率限制错误。</p>
<p>通过 <code>--etherscan-api-key &lt;API_KEY&gt;</code> 指定 Etherscan API 密钥将增加 Etherscan API 速率限制，并避免 <code>forge clone</code> 中的 <em>5 秒</em> 等待时间。</p>
<p>与 <code>forge init</code> 一样，<code>forge clone</code> 默认会初始化一个新的 git 仓库，安装一些子模块并创建一个初始提交信息。</p>
<p>如果你不希望这种行为，请传递 <code>--no-git</code>。</p>
<h3 id="选项"><a class="header" href="#选项">选项</a></h3>
<h4 id="克隆选项"><a class="header" href="#克隆选项">克隆选项</a></h4>
<p><code>-c</code> <em>chain_id</em><br />
<code>--chain</code> <em>chain_id</em><br />
    指定要克隆合约的链名称或 EIP-155 ID。</p>
<p><code>-e</code> <em>api_key</em><br />
<code>--etherscan-api-key</code> <em>api_key</em><br />
    指定 Etherscan（或等效服务）的 API 密钥。</p>
<p><code>--no-remappings-txt</code><br />
    将重映射放在 <code>foundry.toml</code> 配置文件中，而不是生成单独的 <code>remappings.txt</code> 文件。</p>
<h4 id="vcs-选项"><a class="header" href="#vcs-选项">VCS 选项</a></h4>
<p><code>--no-commit</code><br />
    不要创建初始提交。</p>
<p><code>--no-git</code><br />
    不要创建 git 仓库。</p>
<h4 id="显示选项"><a class="header" href="#显示选项">显示选项</a></h4>
<p><code>-q</code><br />
<code>--quiet</code><br />
    不打印任何消息。</p>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="示例-3"><a class="header" href="#示例-3">示例</a></h3>
<ol>
<li>
<p>从以太坊主网克隆 UniswapV3Pool 合约：</p>
<pre><code class="language-sh">forge clone 0x8f8EF111B67C04Eb1641f5ff19EE54Cda062f163 UniswapV3Pool 
</code></pre>
</li>
<li>
<p>克隆合约，但不创建 git 仓库：</p>
<pre><code class="language-sh">forge clone --no-git 0x8f8EF111B67C04Eb1641f5ff19EE54Cda062f163 UniswapV3Pool
</code></pre>
</li>
<li>
<p>从 BNB 智能链（BSC）克隆合约：</p>
<pre><code class="language-sh">forge clone --chain bsc 0x7862D9B4bE2156B15d54F41ee4EDE2d5b0b455e4 UniswapV3Pool 
</code></pre>
</li>
</ol>
<h3 id="元数据"><a class="header" href="#元数据">元数据</a></h3>
<p>克隆的 Forge 项目在根目录中带有一个额外的 <code>.clone.meta</code> 元数据文件。
<code>clone.meta</code> 是一个紧凑的 JSON 数据文件，包含链上合约实例的信息。
元数据包括：</p>
<ul>
<li><code>path</code>：包含链上合约声明的源文件路径。</li>
<li><code>targetContract</code>：源文件中链上合约的名称。</li>
<li><code>address</code>：链上合约的地址。</li>
<li><code>chainId</code>：合约部署的链的 EIP-155 ID。</li>
<li><code>creationTransaction</code>：部署合约的交易哈希。</li>
<li><code>deployer</code>：<code>creationTransaction</code> 的发送者账户地址。</li>
<li><code>constructorArguments</code>：部署合约时使用的构造函数参数。</li>
<li><code>storageLayout</code>：链上合约的存储布局（如果相应的合约编译器版本支持导出存储布局）。</li>
</ul>
<h3 id="另请参阅"><a class="header" href="#另请参阅">另请参阅</a></h3>
<p><a href="reference/forge/./forge.html">forge</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="forge-install-1"><a class="header" href="#forge-install-1">forge install</a></h2>
<h3 id="name-3"><a class="header" href="#name-3">NAME</a></h3>
<p>forge-install - 安装一个或多个依赖项。</p>
<h3 id="synopsis-3"><a class="header" href="#synopsis-3">SYNOPSIS</a></h3>
<p><code>forge install</code> [<em>options</em>] [<em>deps…</em>]</p>
<h3 id="description-3"><a class="header" href="#description-3">DESCRIPTION</a></h3>
<p>安装一个或多个依赖项。</p>
<p>依赖项作为 git 子模块安装。如果你不希望这种行为，请传递 <code>--no-git</code>。</p>
<p>如果没有提供参数，则安装现有的依赖项。</p>
<p>依赖项可以是原始 URL（<code>https://foo.com/dep</code>）、SSH URL（<code>git@github.com:owner/repo</code>）或 GitHub 仓库的路径（<code>owner/repo</code>）。此外，可以在依赖路径中添加 ref 以安装特定版本的依赖项。</p>
<p>ref 可以是：</p>
<ul>
<li>分支：<code>owner/repo@master</code></li>
<li>标签：<code>owner/repo@v1.2.3</code></li>
<li>提交：<code>owner/repo@8e8128</code></li>
</ul>
<p>ref 默认为 <code>master</code>。</p>
<p>你还可以选择依赖项所在的文件夹名称。默认情况下，文件夹名称是仓库的名称。如果你想更改文件夹名称，请在依赖项前加上 <code>&lt;folder&gt;=</code>。</p>
<h3 id="options-3"><a class="header" href="#options-3">OPTIONS</a></h3>
<h4 id="项目选项"><a class="header" href="#项目选项">项目选项</a></h4>
<p><code>--root</code> <em>path</em><br />
    项目的根路径。默认情况下，这是当前 git 仓库的根目录，或当前工作目录。</p>
<h4 id="vcs-选项-1"><a class="header" href="#vcs-选项-1">VCS 选项</a></h4>
<p><code>--no-commit</code><br />
    不要创建提交。</p>
<p><code>--no-git</code><br />
    安装时不将依赖项添加为子模块。</p>
<h4 id="显示选项-1"><a class="header" href="#显示选项-1">显示选项</a></h4>
<p><code>-q</code><br />
<code>--quiet</code><br />
    不打印任何消息。</p>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-3"><a class="header" href="#examples-3">EXAMPLES</a></h3>
<ol>
<li>
<p>安装一个依赖项：</p>
<pre><code class="language-sh">forge install transmissions11/solmate
</code></pre>
</li>
<li>
<p>安装特定版本的依赖项：</p>
<pre><code class="language-sh">forge install transmissions11/solmate@v7
</code></pre>
</li>
<li>
<p>安装多个依赖项：</p>
<pre><code class="language-sh">forge install transmissions11/solmate@v7 OpenZeppelin/openzeppelin-contracts
</code></pre>
</li>
<li>
<p>安装依赖项但不创建子模块：</p>
<pre><code class="language-sh">forge install --no-git transmissions11/solmate
</code></pre>
</li>
<li>
<p>在特定文件夹中安装依赖项：</p>
<pre><code class="language-sh">forge install soulmate=transmissions11/solmate
</code></pre>
</li>
</ol>
<h3 id="see-also-2"><a class="header" href="#see-also-2">SEE ALSO</a></h3>
<p><a href="reference/forge/./forge.html">forge</a>, <a href="reference/forge/./forge-update.html">forge update</a>, <a href="reference/forge/./forge-remove.html">forge remove</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="forge-update-1"><a class="header" href="#forge-update-1">forge update</a></h2>
<h3 id="name-4"><a class="header" href="#name-4">NAME</a></h3>
<p>forge-update - 更新一个或多个依赖项。</p>
<h3 id="synopsis-4"><a class="header" href="#synopsis-4">SYNOPSIS</a></h3>
<p><code>forge update</code> [<em>options</em>] [<em>dep</em>]</p>
<h3 id="description-4"><a class="header" href="#description-4">DESCRIPTION</a></h3>
<p>更新一个或多个依赖项。</p>
<p>参数 <em>dep</em> 是要更新的依赖项的路径。
Forge 将更新到你在运行 <a href="reference/forge/./forge-install.html"><code>forge install</code></a> 时为该依赖项指定的 ref 上的最新版本。</p>
<p>如果没有提供参数，则更新所有依赖项。</p>
<h3 id="options-4"><a class="header" href="#options-4">OPTIONS</a></h3>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-4"><a class="header" href="#examples-4">EXAMPLES</a></h3>
<ol>
<li>
<p>更新一个依赖项：</p>
<pre><code class="language-sh">forge update lib/solmate
</code></pre>
</li>
<li>
<p>更新所有依赖项：</p>
<pre><code class="language-sh">forge update
</code></pre>
</li>
</ol>
<h3 id="see-also-3"><a class="header" href="#see-also-3">SEE ALSO</a></h3>
<p><a href="reference/forge/./forge.html">forge</a>, <a href="reference/forge/./forge-install.html">forge install</a>, <a href="reference/forge/./forge-remove.html">forge remove</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="forge-remove-1"><a class="header" href="#forge-remove-1">forge remove</a></h2>
<h3 id="name-5"><a class="header" href="#name-5">NAME</a></h3>
<p>forge-remove - 移除一个或多个依赖项。</p>
<h3 id="synopsis-5"><a class="header" href="#synopsis-5">SYNOPSIS</a></h3>
<p><code>forge remove</code> [<em>options</em>] [<em>deps…</em>]</p>
<h3 id="description-5"><a class="header" href="#description-5">DESCRIPTION</a></h3>
<p>移除一个或多个依赖项。</p>
<p>依赖项可以是原始 URL（<code>https://foo.com/dep</code>）、GitHub 仓库的路径（<code>owner/repo</code>）或项目树中依赖项的路径。</p>
<h3 id="options-5"><a class="header" href="#options-5">OPTIONS</a></h3>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-5"><a class="header" href="#examples-5">EXAMPLES</a></h3>
<ol>
<li>
<p>通过路径移除依赖项：</p>
<pre><code class="language-sh">forge remove lib/solmate
</code></pre>
</li>
<li>
<p>通过 GitHub 仓库名称移除依赖项：</p>
<pre><code class="language-sh">forge remove dapphub/solmate
</code></pre>
</li>
</ol>
<h3 id="see-also-4"><a class="header" href="#see-also-4">SEE ALSO</a></h3>
<p><a href="reference/forge/./forge.html">forge</a>, <a href="reference/forge/./forge-install.html">forge install</a>, <a href="reference/forge/./forge-update.html">forge update</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="forge-config-1"><a class="header" href="#forge-config-1">forge config</a></h2>
<h3 id="name-6"><a class="header" href="#name-6">NAME</a></h3>
<p>forge-config - 显示当前配置。</p>
<h3 id="synopsis-6"><a class="header" href="#synopsis-6">SYNOPSIS</a></h3>
<p><code>forge config</code> [<em>options</em>]</p>
<h3 id="description-6"><a class="header" href="#description-6">DESCRIPTION</a></h3>
<p>显示当前配置。</p>
<p>此命令可用于创建一个新的基本 <code>foundry.toml</code> 文件或查看当前设置的值，考虑环境变量和全局配置文件。</p>
<p>该命令支持 Forge 中几乎所有其他命令的标志，以允许覆盖显示的配置中的值。</p>
<h3 id="options-6"><a class="header" href="#options-6">OPTIONS</a></h3>
<h4 id="配置选项"><a class="header" href="#配置选项">配置选项</a></h4>
<p><code>--basic</code><br />
    打印一个基本配置文件。</p>
<p><code>--fix</code><br />
    尝试修复任何配置警告。</p>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-6"><a class="header" href="#examples-6">EXAMPLES</a></h3>
<ol>
<li>
<p>创建一个新的基本配置：</p>
<pre><code class="language-sh">forge config &gt; foundry.toml
</code></pre>
</li>
<li>
<p>在 <code>foundry.toml</code> 中启用 FFI：</p>
<pre><code class="language-sh">forge config --ffi &gt; foundry.toml
</code></pre>
</li>
</ol>
<h3 id="see-also-5"><a class="header" href="#see-also-5">SEE ALSO</a></h3>
<p><a href="reference/forge/./forge.html">forge</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="forge-remappings"><a class="header" href="#forge-remappings">forge remappings</a></h2>
<h3 id="name-7"><a class="header" href="#name-7">NAME</a></h3>
<p>forge-remappings - 获取项目自动推断的重映射。</p>
<h3 id="synopsis-7"><a class="header" href="#synopsis-7">SYNOPSIS</a></h3>
<p><code>forge remappings</code> [<em>options</em>]</p>
<h3 id="description-7"><a class="header" href="#description-7">DESCRIPTION</a></h3>
<p>获取项目自动推断的重映射。</p>
<h3 id="options-7"><a class="header" href="#options-7">OPTIONS</a></h3>
<h4 id="项目选项-1"><a class="header" href="#项目选项-1">项目选项</a></h4>
<p><code>--root</code> <em>path</em><br />
    项目的根路径。默认情况下，这是当前 git 仓库的根目录，或者当前工作目录。</p>
<p><code>--lib-path</code> <em>path</em><br />
    库文件夹的路径。</p>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-7"><a class="header" href="#examples-7">EXAMPLES</a></h3>
<ol>
<li>从推断的重映射创建一个 <code>remappings.txt</code> 文件：
<pre><code class="language-sh">forge remappings &gt; remappings.txt
</code></pre>
</li>
</ol>
<h3 id="see-also-6"><a class="header" href="#see-also-6">SEE ALSO</a></h3>
<p><a href="reference/forge/./forge.html">forge</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="forge-tree"><a class="header" href="#forge-tree">forge tree</a></h2>
<h3 id="名称-2"><a class="header" href="#名称-2">名称</a></h3>
<p>forge-tree - 显示项目依赖图的树形可视化。</p>
<h3 id="概要-2"><a class="header" href="#概要-2">概要</a></h3>
<p><code>forge tree</code> [<em>选项</em>]</p>
<h3 id="描述-2"><a class="header" href="#描述-2">描述</a></h3>
<p>显示项目依赖图的可视化。</p>
<pre><code class="language-ignore">$ forge tree
src/OpenZeppelinNft.sol =0.8.10
├── lib/openzeppelin-contracts/contracts/token/ERC721/ERC721.sol ^0.8.0
│   ├── lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol ^0.8.0
│   │   └── lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol ^0.8.0
│   ├── lib/openzeppelin-contracts/contracts/token/ERC721/IERC721Receiver.sol ^0.8.0
│   ├── lib/openzeppelin-contracts/contracts/token/ERC721/extensions/IERC721Metadata.sol ^0.8.0
│   │   └── lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol ^0.8.0 (*)
│   ├── lib/openzeppelin-contracts/contracts/utils/Address.sol ^0.8.1
│   ├── lib/openzeppelin-contracts/contracts/utils/Context.sol ^0.8.0
│   ├── lib/openzeppelin-contracts/contracts/utils/Strings.sol ^0.8.0
│   └── lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol ^0.8.0
│       └── lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol ^0.8.0
├── lib/openzeppelin-contracts/contracts/utils/Strings.sol ^0.8.0
├── lib/openzeppelin-contracts/contracts/security/PullPayment.sol ^0.8.0
│   └── lib/openzeppelin-contracts/contracts/utils/escrow/Escrow.sol ^0.8.0
│       ├── lib/openzeppelin-contracts/contracts/access/Ownable.sol ^0.8.0
│       │   └── lib/openzeppelin-contracts/contracts/utils/Context.sol ^0.8.0
│       └── lib/openzeppelin-contracts/contracts/utils/Address.sol ^0.8.1
└── lib/openzeppelin-contracts/contracts/access/Ownable.sol ^0.8.0 (*)
src/SolmateNft.sol =0.8.10
├── lib/solmate/src/tokens/ERC721.sol &gt;=0.8.0
├── lib/openzeppelin-contracts/contracts/utils/Strings.sol ^0.8.0
├── lib/openzeppelin-contracts/contracts/security/PullPayment.sol ^0.8.0 (*)
└── lib/openzeppelin-contracts/contracts/access/Ownable.sol ^0.8.0 (*)
test/OpenZeppelinNft.t.sol =0.8.10
├── lib/forge-std/src/Test.sol &gt;=0.6.0, &lt;0.9.0
│   ├── lib/forge-std/src/Script.sol &gt;=0.6.0, &lt;0.9.0
│   │   ├── lib/forge-std/src/Vm.sol &gt;=0.6.0
│   │   ├── lib/forge-std/src/console.sol &gt;=0.4.22, &lt;0.9.0
│   │   └── lib/forge-std/src/console2.sol &gt;=0.4.22, &lt;0.9.0
│   └── lib/solmate/lib/ds-test/src/test.sol &gt;=0.4.23
├── src/OpenZeppelinNft.sol =0.8.10 (*)
└── lib/openzeppelin-contracts/contracts/token/ERC721/IERC721Receiver.sol ^0.8.0
test/SolmateNft.sol =0.8.10
├── lib/forge-std/src/Test.sol &gt;=0.6.0, &lt;0.9.0 (*)
└── src/SolmateNft.sol =0.8.10 (*)
</code></pre>
<h3 id="选项-1"><a class="header" href="#选项-1">选项</a></h3>
<h4 id="扁平化选项"><a class="header" href="#扁平化选项">扁平化选项</a></h4>
<p><code>--charset</code> <em>字符集</em><br />
    在输出中使用的字符集：utf8, ascii。默认：utf8</p>
<p><code>--no-dedupe</code><br />
    不进行去重（重复所有共享依赖）</p>
<pre><code class="language-markdown">#### 项目选项

`--build-info`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;生成构建信息文件。

`--build-info-path` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;输出路径到构建信息文件将被写入的目录。

`--root` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;项目的根路径。默认情况下，这是当前 git 仓库的根目录，或者当前工作目录。

`-C` *路径*  
`--contracts` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;合约源目录。  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `DAPP_SRC`

`--lib-paths` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;库文件夹的路径。

`-R` *重映射*  
`--remappings` *重映射*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;项目的重映射。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;参数是以逗号分隔的重映射列表，格式为 `&lt;源&gt;=&lt;目标&gt;`。

`--cache-path` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;编译器缓存的路径。

`--config-path` *文件*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;配置文件的路径。

`--hh`  
`--hardhat`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这是一个便捷标志，等同于传递 `--contracts contracts --lib-paths node-modules`。
</code></pre>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="另见"><a class="header" href="#另见">另见</a></h3>
<p><a href="reference/forge/./forge.html">forge</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="forge-geiger-1"><a class="header" href="#forge-geiger-1">forge geiger</a></h2>
<h3 id="名称-3"><a class="header" href="#名称-3">名称</a></h3>
<p>forge-geiger - 检测 foundry 项目及其依赖项中不安全作弊代码的使用情况。</p>
<h3 id="概要-3"><a class="header" href="#概要-3">概要</a></h3>
<p><code>forge geiger</code> [<em>选项</em>] [<em>路径</em>]</p>
<h3 id="描述-3"><a class="header" href="#描述-3">描述</a></h3>
<p>检测 foundry 项目及其依赖项中不安全作弊代码的使用情况。</p>
<h3 id="选项-2"><a class="header" href="#选项-2">选项</a></h3>
<p><code>--root</code> <em>路径</em><br />
    项目的根路径。默认情况下，这是当前 git 仓库的根目录，或者当前工作目录。</p>
<p><code>--check</code><br />
    以 ‘check’ 模式运行。如果没有发现不安全的作弊代码，则退出代码为 0。如果检测到不安全的作弊代码，则退出代码为 1。</p>
<p><code>--full</code><br />
    打印所有文件的完整报告，即使没有发现不安全的函数。</p>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="参见-1"><a class="header" href="#参见-1">参见</a></h3>
<p><a href="reference/forge/./forge.html">forge</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="构建命令-1"><a class="header" href="#构建命令-1">构建命令</a></h2>
<ul>
<li><a href="reference/forge/./forge-build.html">forge build</a></li>
<li><a href="reference/forge/./forge-clean.html">forge clean</a></li>
<li><a href="reference/forge/./forge-inspect.html">forge inspect</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="forge-build-1"><a class="header" href="#forge-build-1">forge build</a></h2>
<h3 id="name-8"><a class="header" href="#name-8">NAME</a></h3>
<p>forge-build - 构建项目的智能合约。</p>
<h3 id="synopsis-8"><a class="header" href="#synopsis-8">SYNOPSIS</a></h3>
<p><code>forge build</code> 或 <code>forge b</code> [<em>options</em>]</p>
<h3 id="description-8"><a class="header" href="#description-8">DESCRIPTION</a></h3>
<p>构建项目的智能合约。</p>
<p>该命令将尝试通过查看所有合约和依赖项的版本要求来检测可以编译项目的最新版本。</p>
<p>你可以通过传递 <code>--no-auto-detect</code> 来覆盖此行为。或者，你可以传递 <code>--use &lt;SOLC_VERSION&gt;</code>。</p>
<p>如果该命令检测到它正在使用的 Solidity 编译器版本未安装，它将下载并安装在 <code>~/.svm</code> 中。你可以通过传递 <code>--offline</code> 来禁用此行为。</p>
<p>构建是增量的，构建缓存默认保存在项目根目录的 <code>cache/</code> 中。如果你想清除缓存，传递 <code>--force</code>，如果你想更改缓存目录，传递 <code>--cache-path &lt;PATH&gt;</code>。</p>
<p>可以通过指定多个路径选项（可以是源目录或文件的路径）来选择要构建的源。</p>
<h4 id="构建模式"><a class="header" href="#构建模式">构建模式</a></h4>
<p>有三种构建模式：</p>
<ul>
<li>仅编译（默认）：构建项目并将合约工件保存在 <code>out/</code> 中（或由 <code>--out &lt;PATH&gt;</code> 指定的路径）。</li>
<li>大小模式（<code>--sizes</code>）：构建项目，显示非测试合约的大小，如果任何合约超过大小限制，则退出并返回代码 1。</li>
<li>名称模式（<code>--names</code>）：构建项目，显示合约名称并退出。</li>
</ul>
<h4 id="优化器"><a class="header" href="#优化器">优化器</a></h4>
<p>你可以通过传递 <code>--optimize</code> 来启用优化器，并且可以通过传递 <code>--optimizer-runs &lt;RUNS&gt;</code> 来调整优化器运行的次数。</p>
<p>你还可以通过传递 <code>--via-ir</code> 选择加入 Solidity IR 编译管道。在 <a href="https://docs.soliditylang.org/en/latest/ir-breaking-changes.html" title="" target="_blank">Solidity 文档</a> 中阅读有关 IR 管道的更多信息。</p>
<p>默认情况下，优化器是启用的，运行 200 个周期。</p>
<h5 id="条件优化器使用"><a class="header" href="#条件优化器使用">条件优化器使用</a></h5>
<p>许多项目使用 solc 优化器，无论是通过标准编译管道还是 IR 管道。但在某些情况下，优化器可能会显著降低编译速度。</p>
<p>一个使用优化器的项目配置文件可能看起来像这样用于常规编译：</p>
<pre><code class="language-toml">[profile.default]
solc-version = "0.8.17"
optimizer = true
optimizer-runs = 10_000_000
</code></pre>
<p>或者像这样用于 <code>via-ir</code>：</p>
<pre><code class="language-toml">[profile.default]
solc-version = "0.8.17"
via_ir = true
</code></pre>
<p>为了在开发和测试期间减少编译速度，一种方法是有一个 <code>lite</code> 配置文件，该配置文件关闭优化器，并在开发/测试周期中使用。更新后的常规编译配置文件可能看起来像这样：</p>
<pre><code class="language-toml">[profile.default]
solc-version = "0.8.17"
optimizer = true
optimizer-runs = 10_000_000

[profile.lite]
optimizer = false
</code></pre>
<p>或者像这样用于 <code>via-ir</code>：</p>
<pre><code class="language-toml">[profile.default]
solc-version = "0.8.17"
via_ir = true

[profile.lite.optimizer_details.yulDetails]
optimizerSteps = ''
</code></pre>
<p>设置好后，<code>forge build</code>（或 <code>forge test</code> / <code>forge script</code>）仍然使用标准配置文件，因此默认情况下，<code>forge script</code> 调用将使用生产设置部署你的合约。运行 <code>FOUNDRY_PROFILE=lite forge build</code>（以及相同的测试和脚本命令）将使用 lite 配置文件来减少编译时间。</p>
<blockquote>
<p>你可以配置额外的优化器细节，请参见下面的 <a href="reference/forge/forge-build.html#additional-optimizer-settings">Additional Optimizer Settings</a> 部分了解更多信息。</p>
</blockquote>
<h4 id="工件"><a class="header" href="#工件">工件</a></h4>
<p>你可以通过传递 <code>--extra-output &lt;SELECTOR&gt;</code> 将 Solidity 编译器的额外输出添加到你的工件中。</p>
<p>选择器是 Solidity 编译器输出中的路径，你可以在 <a href="https://docs.soliditylang.org/en/latest/using-the-compiler.html#compiler-api" title="" target="_blank">Solidity 文档</a> 中阅读更多相关信息。</p>
<p>你还可以通过传递 <code>--extra-output-files &lt;SELECTOR&gt;</code> 将一些编译器输出写入单独的文件。</p>
<p><code>--extra-output-files</code> 的有效选择器是：</p>
<ul>
<li><code>metadata</code>：作为 <code>metadata.json</code> 文件写入工件目录</li>
<li><code>ir</code>：作为 <code>.ir</code> 文件写入工件目录</li>
<li><code>irOptimized</code>：作为 <code>.iropt</code> 文件写入工件目录</li>
<li><code>ewasm</code>：作为 <code>.ewasm</code> 文件写入工件目录</li>
<li><code>evm.assembly</code>：作为 <code>.asm</code> 文件写入工件目录</li>
</ul>
<h4 id="监视模式-1"><a class="header" href="#监视模式-1">监视模式</a></h4>
<p>可以通过传递 <code>--watch [PATH...]</code> 以监视模式运行该命令，每当监视的文件或目录发生变化时，它将重新构建。默认情况下会监视源目录。</p>
<h4 id="稀疏模式实验性"><a class="header" href="#稀疏模式实验性">稀疏模式（实验性）</a></h4>
<p>稀疏模式仅编译符合某些标准的文件。</p>
<p>默认情况下，此过滤器适用于自上次构建以来未更改的文件，但对于接受文件过滤器的命令（例如 <a href="reference/forge/./forge-test.html">forge test</a>），稀疏模式将仅重新编译与过滤器匹配的文件。</p>
<p>稀疏模式是可选的，直到该功能稳定。要选择加入稀疏模式并试用，请在你的配置文件中设置 <a href="reference/forge/../config/solidity-compiler.html#sparse_mode"><code>sparse_mode</code></a>。</p>
<h4 id="额外的优化器设置"><a class="header" href="#额外的优化器设置">额外的优化器设置</a></h4>
<p>优化器可以通过额外的设置进行微调。只需在你的配置文件中设置 <code>optimizer_details</code> 表。例如：</p>
<pre><code class="language-toml">[profile.default.optimizer_details]
constantOptimizer = true
yul = true

[profile.default.optimizer_details.yulDetails]
stackAllocation = true
optimizerSteps = 'dhfoDgvulfnTUtnIf'
</code></pre>
<p>有关可用设置的更多信息，请参见 <a href="https://docs.soliditylang.org/en/latest/using-the-compiler.html#compiler-input-and-output-json-description" title="" target="_blank">编译器输入描述文档</a>（特别是 <code>settings.optimizer.details</code>）。</p>
<h4 id="回退字符串"><a class="header" href="#回退字符串">回退字符串</a></h4>
<p>你可以通过编译器控制回退字符串的生成方式。默认情况下，只有用户提供的回退字符串包含在字节码中，但还有其他选项：</p>
<ul>
<li><code>strip</code>：删除所有回退字符串（如果可能，即如果使用字面量），保持副作用。</li>
<li><code>debug</code>：注入编译器生成的内部回退字符串，目前为 ABI 编码器 V1 和 V2 实现。</li>
<li><code>verboseDebug</code>：将更多信息附加到用户提供的回退字符串（尚未实现）。</li>
</ul>
<h4 id="额外的模型检查器设置"><a class="header" href="#额外的模型检查器设置">额外的模型检查器设置</a></h4>
<p><a href="https://docs.soliditylang.org/en/latest/smtchecker.html#tutorial" title="" target="_blank">Solidity 内置的模型检查器</a> 是一个可选模块，可以通过 <code>ModelChecker</code> 对象启用。</p>
<p>参见 <a href="https://docs.soliditylang.org/en/latest/using-the-compiler.html#compiler-input-and-output-json-description" title="" target="_blank">编译器输入描述 <code>settings.modelChecker</code></a> 和 <a href="https://docs.soliditylang.org/en/latest/smtchecker.html#smtchecker-options-and-tuning" title="" target="_blank">模型检查器的选项</a>。</p>
<p>该模块在 <code>solc</code> 发布二进制文件中适用于 OSX 和 Linux。后者需要系统中安装 z3 库版本 [4.8.8, 4.8.14]（SO 版本 4.8）。</p>
<p>与上述优化器设置类似，<code>model_checker</code> 设置必须以前缀为它们对应的配置文件：<code>[profile.default.model_checker]</code> 属于 <code>[profile.default]</code>。</p>
<pre><code class="language-toml">## foundry.toml
[profile.default.model_checker]
contracts = { '/path/to/project/src/Contract.sol' = [ 'Contract' ] }
engine = 'chc'
timeout = 10000
targets = [ 'assert' ]
</code></pre>
<p>以上字段在使用模型检查器时是推荐的。
设置要验证的合约非常重要，否则将验证所有可用的合约，这可能会消耗大量时间。
推荐的引擎是 <code>chc</code>，但也接受 <code>bmc</code> 和 <code>all</code>（运行两者）。
设置适当的超时时间（以毫秒为单位）也很重要，因为给底层求解器的时间可能不够。
如果没有给出验证目标，则只会检查断言。</p>
<p>调用 <code>forge build</code> 时，模型检查器将运行，如果有任何发现，将显示为警告。</p>
<h3 id="options-8"><a class="header" href="#options-8">OPTIONS</a></h3>
<h4 id="构建选项"><a class="header" href="#构建选项">构建选项</a></h4>
<p><code>--names</code>
    打印编译的合约名称。</p>
<p><code>--sizes</code>
    打印编译的非测试合约大小，如果任何合约超过大小限制，则退出并返回代码 1。</p>
<p><code>--skip</code>
    跳过编译非必要的合约目录，如测试或脚本（用法 <code>--skip test</code>）。</p>
<p><code>[PATHS]...</code>    从指定路径构建源文件。</p>
<h4 id="缓存选项"><a class="header" href="#缓存选项">缓存选项</a></h4>
<p><code>--force</code><br />
    清除缓存和 artifacts 文件夹并重新编译。</p>
<h4 id="链接器选项"><a class="header" href="#链接器选项">链接器选项</a></h4>
<p><code>--libraries</code> <em>libraries</em><br />
    设置预链接的库。</p>
<p>    参数必须采用 <code>&lt;重映射的库路径&gt;:&lt;库名称&gt;:&lt;地址&gt;</code> 格式，例如 <code>src/Contract.sol:Library:0x...</code>。</p>
<p>    也可以在配置文件中设置为 <code>libraries = ["&lt;路径&gt;:&lt;库名称&gt;:&lt;地址&gt;"]</code>。</p>
<pre><code class="language-markdown">#### 编译器选项

`--optimize`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;激活 Solidity 优化器。

`--optimizer-runs` *runs*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;优化器运行的次数。

`--via-ir`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;使用 Yul 中间表示编译管道。

`--revert-strings`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如何处理 revert 和 require 原因字符串。

`--use` *solc_version*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;指定 solc 版本或本地 solc 的路径进行构建。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;有效值格式为 `x.y.z`、`solc:x.y.z` 或 `path/to/solc`。

`--offline`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;不访问网络。缺失的 solc 版本不会被安装。

`--no-auto-detect`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;不自动检测 solc。

`--ignored-error-codes` *error_codes*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;通过错误代码忽略 solc 警告。参数是以逗号分隔的错误代码列表。

`--extra-output` *selector*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在合约的构件中包含的额外输出。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;示例键：`abi`、`storageLayout`、`evm.assembly`、`ewasm`、`ir`、`ir-optimized`、`metadata`。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;完整描述请参见 [Solidity 文档][output-desc]。

`--extra-output-files` *selector*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;写入单独文件的额外输出。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;示例键：`abi`、`storageLayout`、`evm.assembly`、`ewasm`、`ir`、`ir-optimized`、`metadata`。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;完整描述请参见 [Solidity 文档][output-desc]。

`--evm-version` *version*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;目标 EVM 版本。

[output-desc]: https://docs.soliditylang.org/en/latest/using-the-compiler.html#compiler-api
</code></pre>
<pre><code class="language-markdown">#### 项目选项

`--build-info`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;生成构建信息文件。

`--build-info-path` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;输出路径到构建信息文件将被写入的目录。

`--root` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;项目的根路径。默认情况下，这是当前 git 仓库的根目录，或者当前工作目录。

`-C` *路径*  
`--contracts` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;合约源目录。  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `DAPP_SRC`

`--lib-paths` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;库文件夹的路径。

`-R` *重映射*  
`--remappings` *重映射*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;项目的重映射。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;参数是以逗号分隔的重映射列表，格式为 `&lt;源&gt;=&lt;目标&gt;`。

`--cache-path` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;编译器缓存的路径。

`--config-path` *文件*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;配置文件的路径。

`--hh`  
`--hardhat`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这是一个便捷标志，等同于传递 `--contracts contracts --lib-paths node-modules`。
</code></pre>
<p><code>-o</code> <em>path</em><br />
<code>--out</code> <em>path</em><br />
    项目的 artifacts 目录。</p>
<p><code>--silent</code><br />
    抑制所有输出。</p>
<pre><code class="language-metadata">id: watch-options
</code></pre>
<h4 id="监视选项"><a class="header" href="#监视选项">监视选项</a></h4>
<p><code>-w</code> [<em>路径...</em>]<br />
<code>--watch</code> [<em>路径...</em>]<br />
    监视特定的文件或文件夹。</p>
<p>    默认情况下，监视项目的源目录。</p>
<p><code>-d</code> <em>延迟</em><br />
<code>--delay</code> <em>延迟</em><br />
    文件更新防抖延迟。</p>
<p>    在延迟期间，传入的更改事件会被累积，只有在延迟结束后才会采取行动。<br />
    注意，这并不意味着命令会启动：如果给出了 <code>--no-restart</code>，并且命令已经在运行，行动的结果将是什么都不做。</p>
<p>    默认值为 50 毫秒。默认情况下解析为十进制秒，但使用带有 <code>ms</code> 后缀的整数可能更方便。</p>
<p>    在使用 <code>--poll</code> 模式时，你可能需要更大的持续时间，以避免过度占用磁盘 I/O。</p>
<p><code>--no-restart</code><br />
    在命令运行时不重启。</p>
<p><code>--run-all</code><br />
    当发生更改时，显式地重新运行所有文件的命令。</p>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-8"><a class="header" href="#examples-8">EXAMPLES</a></h3>
<ol>
<li>
<p>构建项目：</p>
<pre><code class="language-sh">forge build
</code></pre>
</li>
<li>
<p>使用 solc 0.6.0 构建项目：</p>
<pre><code class="language-sh">forge build --use solc:0.6.0
</code></pre>
</li>
<li>
<p>使用额外的工件输出构建项目：</p>
<pre><code class="language-sh">forge build --extra-output evm.assembly
</code></pre>
</li>
<li>
<p>以监视模式构建项目：</p>
<pre><code class="language-sh">forge build --watch
</code></pre>
</li>
<li>
<p>从 <code>test/invariant</code> 目录和 <code>test/RegressionTest.sol</code> 构建源文件：</p>
<pre><code class="language-sh">forge build test/invariant test/RegressionTest.sol
</code></pre>
</li>
</ol>
<h3 id="see-also-7"><a class="header" href="#see-also-7">SEE ALSO</a></h3>
<p><a href="reference/forge/./forge.html">forge</a>, <a href="reference/forge/./forge-clean.html">forge clean</a>, <a href="reference/forge/./forge-inspect.html">forge inspect</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="forge-clean-1"><a class="header" href="#forge-clean-1">forge clean</a></h2>
<h3 id="名称-4"><a class="header" href="#名称-4">名称</a></h3>
<p>forge-clean - 删除构建产物和缓存目录。</p>
<h3 id="概要-4"><a class="header" href="#概要-4">概要</a></h3>
<p><code>forge clean</code> [<em>选项</em>]</p>
<h3 id="描述-4"><a class="header" href="#描述-4">描述</a></h3>
<p>删除构建产物和缓存目录。</p>
<h3 id="选项-3"><a class="header" href="#选项-3">选项</a></h3>
<h4 id="清理选项"><a class="header" href="#清理选项">清理选项</a></h4>
<p><code>--root</code> <em>路径</em><br />
    项目的根路径。默认为当前工作目录。</p>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="示例-4"><a class="header" href="#示例-4">示例</a></h3>
<ol>
<li>清理项目中的构建产物和缓存：
<pre><code class="language-sh">forge clean
</code></pre>
</li>
</ol>
<h3 id="另请参阅-1"><a class="header" href="#另请参阅-1">另请参阅</a></h3>
<p><a href="reference/forge/./forge.html">forge</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="forge-inspect-1"><a class="header" href="#forge-inspect-1">forge inspect</a></h2>
<h3 id="name-9"><a class="header" href="#name-9">NAME</a></h3>
<p>forge-inspect - 获取智能合约的专门信息</p>
<h3 id="synopsis-9"><a class="header" href="#synopsis-9">SYNOPSIS</a></h3>
<p><code>forge inspect</code> [<em>options</em>] <em>contract_name</em> <em>field</em></p>
<h3 id="description-9"><a class="header" href="#description-9">DESCRIPTION</a></h3>
<p>获取智能合约的专门信息。</p>
<p>要检查的字段（<em>field</em>）可以是以下任意一项：</p>
<ul>
<li><code>abi</code></li>
<li><code>b</code>/<code>bytes</code>/<code>bytecode</code></li>
<li><code>deployedBytecode</code>/<code>deployed_bytecode</code>/<code>deployed-bytecode</code>/<code>deployedbytecode</code>/<code>deployed</code></li>
<li><code>assembly</code>/<code>asm</code></li>
<li><code>asmOptimized</code>/<code>assemblyOptimized</code>/<code>assemblyoptimized</code>/<code>assembly_optimized</code>/<code>asmopt</code>/<code>assembly-optimized</code>/<code>asmo</code>/<code>asm-optimized</code>/<code>asmoptimized</code>/<code>asm_optimized</code></li>
<li><code>methods</code>/<code>methodidentifiers</code>/<code>methodIdentifiers</code>/<code>method_identifiers</code>/<code>method-identifiers</code>/<code>mi</code></li>
<li><code>gasEstimates</code>/<code>gas</code>/<code>gas_estimates</code>/<code>gas-estimates</code>/<code>gasestimates</code></li>
<li><code>storageLayout</code>/<code>storage_layout</code>/<code>storage-layout</code>/<code>storagelayout</code>/<code>storage</code></li>
<li><code>devdoc</code>/<code>dev-doc</code>/<code>devDoc</code></li>
<li><code>ir</code></li>
<li><code>ir-optimized</code>/<code>irOptimized</code>/<code>iroptimized</code>/<code>iro</code>/<code>iropt</code></li>
<li><code>metadata</code>/<code>meta</code></li>
<li><code>userdoc</code>/<code>userDoc</code>/<code>user-doc</code></li>
<li><code>ewasm</code>/<code>e-wasm</code></li>
<li><code>errors</code></li>
<li><code>events</code></li>
</ul>
<h3 id="options-9"><a class="header" href="#options-9">OPTIONS</a></h3>
<p><code>--pretty</code><br />
    如果支持，以漂亮的格式打印选定的字段。</p>
<h4 id="缓存选项-1"><a class="header" href="#缓存选项-1">缓存选项</a></h4>
<p><code>--force</code><br />
    清除缓存和 artifacts 文件夹并重新编译。</p>
<h4 id="链接器选项-1"><a class="header" href="#链接器选项-1">链接器选项</a></h4>
<p><code>--libraries</code> <em>libraries</em><br />
    设置预链接的库。</p>
<p>    参数必须采用 <code>&lt;重映射的库路径&gt;:&lt;库名称&gt;:&lt;地址&gt;</code> 格式，例如 <code>src/Contract.sol:Library:0x...</code>。</p>
<p>    也可以在配置文件中设置为 <code>libraries = ["&lt;路径&gt;:&lt;库名称&gt;:&lt;地址&gt;"]</code>。</p>
<pre><code class="language-markdown">#### 编译器选项

`--optimize`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;激活 Solidity 优化器。

`--optimizer-runs` *runs*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;优化器运行的次数。

`--via-ir`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;使用 Yul 中间表示编译管道。

`--revert-strings`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如何处理 revert 和 require 原因字符串。

`--use` *solc_version*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;指定 solc 版本或本地 solc 的路径进行构建。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;有效值格式为 `x.y.z`、`solc:x.y.z` 或 `path/to/solc`。

`--offline`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;不访问网络。缺失的 solc 版本不会被安装。

`--no-auto-detect`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;不自动检测 solc。

`--ignored-error-codes` *error_codes*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;通过错误代码忽略 solc 警告。参数是以逗号分隔的错误代码列表。

`--extra-output` *selector*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在合约的构件中包含的额外输出。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;示例键：`abi`、`storageLayout`、`evm.assembly`、`ewasm`、`ir`、`ir-optimized`、`metadata`。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;完整描述请参见 [Solidity 文档][output-desc]。

`--extra-output-files` *selector*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;写入单独文件的额外输出。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;示例键：`abi`、`storageLayout`、`evm.assembly`、`ewasm`、`ir`、`ir-optimized`、`metadata`。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;完整描述请参见 [Solidity 文档][output-desc]。

`--evm-version` *version*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;目标 EVM 版本。

[output-desc]: https://docs.soliditylang.org/en/latest/using-the-compiler.html#compiler-api
</code></pre>
<pre><code class="language-markdown">#### 项目选项

`--build-info`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;生成构建信息文件。

`--build-info-path` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;输出路径到构建信息文件将被写入的目录。

`--root` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;项目的根路径。默认情况下，这是当前 git 仓库的根目录，或者当前工作目录。

`-C` *路径*  
`--contracts` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;合约源目录。  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `DAPP_SRC`

`--lib-paths` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;库文件夹的路径。

`-R` *重映射*  
`--remappings` *重映射*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;项目的重映射。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;参数是以逗号分隔的重映射列表，格式为 `&lt;源&gt;=&lt;目标&gt;`。

`--cache-path` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;编译器缓存的路径。

`--config-path` *文件*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;配置文件的路径。

`--hh`  
`--hardhat`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这是一个便捷标志，等同于传递 `--contracts contracts --lib-paths node-modules`。
</code></pre>
<p><code>-o</code> <em>path</em><br />
<code>--out</code> <em>path</em><br />
    项目的 artifacts 目录。</p>
<p><code>--silent</code><br />
    抑制所有输出。</p>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-9"><a class="header" href="#examples-9">EXAMPLES</a></h3>
<ol>
<li>
<p>检查合约的字节码：</p>
<pre><code class="language-sh">forge inspect MyContract bytecode
</code></pre>
</li>
<li>
<p>检查合约的存储布局：</p>
<pre><code class="language-sh">forge inspect MyContract storage
</code></pre>
</li>
<li>
<p>以漂亮的格式检查合约的 ABI：</p>
<pre><code class="language-sh">forge inspect --pretty MyContract abi
</code></pre>
</li>
</ol>
<h3 id="see-also-8"><a class="header" href="#see-also-8">SEE ALSO</a></h3>
<p><a href="reference/forge/./forge.html">forge</a>, <a href="reference/forge/./forge-build.html">forge build</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="测试命令-1"><a class="header" href="#测试命令-1">测试命令</a></h2>
<ul>
<li><a href="reference/forge/./forge-test.html">forge test</a></li>
<li><a href="reference/forge/./forge-snapshot.html">forge snapshot</a></li>
<li><a href="reference/forge/./forge-coverage.html">forge coverage</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="forge-test-2"><a class="header" href="#forge-test-2">forge test</a></h2>
<h3 id="名称-5"><a class="header" href="#名称-5">名称</a></h3>
<p>forge-test - 运行项目的测试。</p>
<h3 id="概要-5"><a class="header" href="#概要-5">概要</a></h3>
<p><code>forge test</code> [<em>选项</em>]</p>
<h3 id="描述-5"><a class="header" href="#描述-5">描述</a></h3>
<p>运行项目的测试。</p>
<h4 id="分叉"><a class="header" href="#分叉">分叉</a></h4>
<p>可以通过传递 <code>--fork-url &lt;URL&gt;</code> 在分叉环境中运行测试。</p>
<p>当测试在分叉环境中运行时，你可以访问分叉链的所有状态，就像你部署了合约一样。<a href="reference/forge/../../cheatcodes/">作弊码</a> 仍然可用。</p>
<p>你还可以通过传递 <code>--fork-block-number &lt;BLOCK&gt;</code> 指定从某个区块分叉。当从特定区块分叉时，链数据会缓存到 <code>~/.foundry/cache</code>。如果你不想缓存链数据，可以传递 <code>--no-storage-caching</code>。</p>
<p>在分叉环境中运行时，无法由本地合约解码的跟踪（例如对主网上存在的合约的调用，如代币）可以选择使用 Etherscan 解码。要使用 Etherscan 进行跟踪解码，请设置 <code>ETHERSCAN_API_KEY</code> 或传递 <code>--etherscan-api-key &lt;KEY&gt;</code>。</p>
<h4 id="调试"><a class="header" href="#调试">调试</a></h4>
<p>可以在交互式调试器中运行测试。要启动调试器，请传递 <code>--debug &lt;TEST&gt;</code>。</p>
<p>如果多个测试匹配指定的模式，你必须使用其他测试过滤器以将匹配的测试数量减少到恰好 1。</p>
<p>如果测试是单元测试，它会立即在调试器中打开。</p>
<p>如果测试是模糊测试，模糊测试会运行，调试器会在第一个失败的场景中打开。如果没有失败的场景，调试器会在最后一个场景中打开。</p>
<p>有关调试器的更多信息，请参见 <a href="reference/forge/../../forge/debugger.html">调试器章节</a>。</p>
<h4 id="气体报告"><a class="header" href="#气体报告">气体报告</a></h4>
<p>可以通过传递 <code>--gas-report</code> 生成气体报告。</p>
<p>有关气体报告的更多信息，请参见 <a href="reference/forge/../../forge/gas-reports.html">气体报告章节</a>。</p>
<h4 id="列表"><a class="header" href="#列表">列表</a></h4>
<p>可以列出测试而不运行它们。
你可以传递 <code>--json</code> 以便外部扩展更容易解析结构化内容。</p>
<h3 id="选项-4"><a class="header" href="#选项-4">选项</a></h3>
<pre><code class="language-markdown">#### 测试选项

`-m` *regex*  
`--match` *regex*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;仅运行匹配指定正则表达式的测试函数。  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;**已弃用：请参见 `--match-test`。**

`--match-test` *regex*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;仅运行匹配指定正则表达式的测试函数。

`--no-match-test` *regex*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;仅运行不匹配指定正则表达式的测试函数。

`--match-contract` *regex*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;仅运行匹配指定正则表达式的合约中的测试。

`--no-match-contract` *regex*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;仅运行不匹配指定正则表达式的合约中的测试。

`--match-path` *glob*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;仅运行匹配指定 glob 模式的源文件中的测试。

`--no-match-path` *glob*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;仅运行不匹配指定 glob 模式的源文件中的测试。

`--debug` *regex*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在调试器中运行测试。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;传递给此标志的参数是您要运行的测试函数的名称，其工作方式与 `--match-test` 相同。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如果多个测试匹配您指定的条件，您必须添加额外的过滤器，直到找到一个测试（参见 `--match-contract` 和 `--match-path`）。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;匹配的测试将在调试器中打开，无论测试结果如何。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如果匹配的测试是模糊测试，则它将在第一个失败案例中打开调试器。如果模糊测试没有失败，它将在最后一个模糊案例中打开调试器。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;有关更精细的模糊案例控制，请参见 [`forge debug`](./forge-debug.md)。

`--gas-report`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印 gas 报告。

`--allow-failure`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;即使测试失败也以代码 0 退出。

`--fail-fast`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在第一次失败后停止运行测试。

`--etherscan-api-key` *key*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Etherscan API 密钥。如果设置，且同时设置了 `--fork-url`，则使用 Etherscan 解码 traces。  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量：`ETHERSCAN_API_KEY`
</code></pre>
<pre><code class="language-json">{
  "title": "EVM 选项",
  "options": [
    {
      "name": "-f",
      "alias": ["--rpc-url", "--fork-url"],
      "description": "从远程端点获取状态，而不是从空状态开始。",
      "note": "如果要从特定区块号获取状态，请参见 `--fork-block-number`。"
    },
    {
      "name": "--fork-block-number",
      "description": "从远程端点获取特定区块号的状态。请参见 `--fork-url`。"
    },
    {
      "name": "--fork-retry-backoff",
      "description": "遇到错误时的初始重试退避时间。"
    },
    {
      "name": "--no-storage-caching",
      "description": "显式禁用 RPC 缓存的使用。",
      "note": "所有存储槽完全从端点读取。请参见 `--fork-url`。"
    },
    {
      "name": "-v",
      "alias": "--verbosity",
      "description": "EVM 的详细程度。",
      "note": "多次传递以增加详细程度（例如 `-v`, `-vv`, `-vvv`）。",
      "levels": [
        {
          "level": 2,
          "description": "打印所有测试的日志"
        },
        {
          "level": 3,
          "description": "打印失败测试的执行 traces"
        },
        {
          "level": 4,
          "description": "打印所有测试的执行 traces，以及失败测试的设置 traces"
        },
        {
          "level": 5,
          "description": "打印所有测试的执行和设置 traces"
        }
      ]
    },
    {
      "name": "--sender",
      "description": "将执行测试的地址"
    },
    {
      "name": "--initial-balance",
      "description": "已部署合约的初始余额"
    },
    {
      "name": "--ffi",
      "description": "启用 [FFI cheatcode][ffi-cheatcode]"
    }
  ],
  "links": {
    "ffi-cheatcode": "../../cheatcodes/ffi.md"
  }
}
</code></pre>
<pre><code class="language-markdown">#### 执行器选项

`--base-fee &lt;FEE&gt;`  
`--block-base-fee-per-gas &lt;FEE&gt;`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;区块中的基础费用（以 wei 为单位）。

`--block-coinbase` *address*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;区块的 coinbase 地址。

`--block-difficulty` *difficulty*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;区块的难度。

`--block-gas-limit` *gas_limit*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;区块的 gas 限制。

`--block-number` *block*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;区块编号。

`--block-timestamp` *timestamp*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;区块的时间戳（以秒为单位）。

`--chain-id` *chain_id*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;链 ID。

`--gas-limit` *gas_limit*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;区块的 gas 限制。

`--gas-price` *gas_price*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;gas 价格（以 wei 为单位）。

`--tx-origin` *address*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;交易的发起方地址。
</code></pre>
<h4 id="缓存选项-2"><a class="header" href="#缓存选项-2">缓存选项</a></h4>
<p><code>--force</code><br />
    清除缓存和 artifacts 文件夹并重新编译。</p>
<h4 id="链接器选项-2"><a class="header" href="#链接器选项-2">链接器选项</a></h4>
<p><code>--libraries</code> <em>libraries</em><br />
    设置预链接的库。</p>
<p>    参数必须采用 <code>&lt;重映射的库路径&gt;:&lt;库名称&gt;:&lt;地址&gt;</code> 格式，例如 <code>src/Contract.sol:Library:0x...</code>。</p>
<p>    也可以在配置文件中设置为 <code>libraries = ["&lt;路径&gt;:&lt;库名称&gt;:&lt;地址&gt;"]</code>。</p>
<pre><code class="language-markdown">#### 编译器选项

`--optimize`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;激活 Solidity 优化器。

`--optimizer-runs` *runs*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;优化器运行的次数。

`--via-ir`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;使用 Yul 中间表示编译管道。

`--revert-strings`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如何处理 revert 和 require 原因字符串。

`--use` *solc_version*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;指定 solc 版本或本地 solc 的路径进行构建。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;有效值格式为 `x.y.z`、`solc:x.y.z` 或 `path/to/solc`。

`--offline`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;不访问网络。缺失的 solc 版本不会被安装。

`--no-auto-detect`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;不自动检测 solc。

`--ignored-error-codes` *error_codes*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;通过错误代码忽略 solc 警告。参数是以逗号分隔的错误代码列表。

`--extra-output` *selector*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在合约的构件中包含的额外输出。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;示例键：`abi`、`storageLayout`、`evm.assembly`、`ewasm`、`ir`、`ir-optimized`、`metadata`。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;完整描述请参见 [Solidity 文档][output-desc]。

`--extra-output-files` *selector*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;写入单独文件的额外输出。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;示例键：`abi`、`storageLayout`、`evm.assembly`、`ewasm`、`ir`、`ir-optimized`、`metadata`。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;完整描述请参见 [Solidity 文档][output-desc]。

`--evm-version` *version*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;目标 EVM 版本。

[output-desc]: https://docs.soliditylang.org/en/latest/using-the-compiler.html#compiler-api
</code></pre>
<pre><code class="language-markdown">#### 项目选项

`--build-info`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;生成构建信息文件。

`--build-info-path` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;输出路径到构建信息文件将被写入的目录。

`--root` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;项目的根路径。默认情况下，这是当前 git 仓库的根目录，或者当前工作目录。

`-C` *路径*  
`--contracts` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;合约源目录。  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `DAPP_SRC`

`--lib-paths` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;库文件夹的路径。

`-R` *重映射*  
`--remappings` *重映射*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;项目的重映射。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;参数是以逗号分隔的重映射列表，格式为 `&lt;源&gt;=&lt;目标&gt;`。

`--cache-path` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;编译器缓存的路径。

`--config-path` *文件*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;配置文件的路径。

`--hh`  
`--hardhat`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这是一个便捷标志，等同于传递 `--contracts contracts --lib-paths node-modules`。
</code></pre>
<p><code>-o</code> <em>path</em><br />
<code>--out</code> <em>path</em><br />
    项目的 artifacts 目录。</p>
<p><code>--silent</code><br />
    抑制所有输出。</p>
<pre><code class="language-metadata">id: watch-options
</code></pre>
<h4 id="监视选项-1"><a class="header" href="#监视选项-1">监视选项</a></h4>
<p><code>-w</code> [<em>路径...</em>]<br />
<code>--watch</code> [<em>路径...</em>]<br />
    监视特定的文件或文件夹。</p>
<p>    默认情况下，监视项目的源目录。</p>
<p><code>-d</code> <em>延迟</em><br />
<code>--delay</code> <em>延迟</em><br />
    文件更新防抖延迟。</p>
<p>    在延迟期间，传入的更改事件会被累积，只有在延迟结束后才会采取行动。<br />
    注意，这并不意味着命令会启动：如果给出了 <code>--no-restart</code>，并且命令已经在运行，行动的结果将是什么都不做。</p>
<p>    默认值为 50 毫秒。默认情况下解析为十进制秒，但使用带有 <code>ms</code> 后缀的整数可能更方便。</p>
<p>    在使用 <code>--poll</code> 模式时，你可能需要更大的持续时间，以避免过度占用磁盘 I/O。</p>
<p><code>--no-restart</code><br />
    在命令运行时不重启。</p>
<p><code>--run-all</code><br />
    当发生更改时，显式地重新运行所有文件的命令。</p>
<pre><code class="language-json">{
  "id": "display-options",
  "title": "显示选项"
}
</code></pre>
<h4 id="显示选项-2"><a class="header" href="#显示选项-2">显示选项</a></h4>
<p><code>-j</code><br />
<code>--json</code><br />
     以 JSON 格式打印部署信息。</p>
<p><code>--list</code><br />
    列出测试而不是运行它们。</p>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="示例-5"><a class="header" href="#示例-5">示例</a></h3>
<ol>
<li>
<p>运行测试：</p>
<pre><code class="language-sh">forge test
</code></pre>
</li>
<li>
<p>在调试器中打开测试：</p>
<pre><code class="language-sh">forge test --debug testSomething
</code></pre>
</li>
<li>
<p>生成气体报告：</p>
<pre><code class="language-sh">forge test --gas-report
</code></pre>
</li>
<li>
<p>仅在 <code>test/Contract.t.sol</code> 中的 <code>BigTest</code> 合约中运行以 <code>testFail</code> 开头的测试：</p>
<pre><code class="language-sh">forge test --match-path test/Contract.t.sol --match-contract BigTest \
  --match-test "testFail*"
</code></pre>
</li>
<li>
<p>以所需格式列出测试</p>
<pre><code class="language-sh">forge test --list
forge test --list --json
forge test --list --json --match-test "testFail*" | tail -n 1 | json_pp
</code></pre>
</li>
</ol>
<h3 id="另请参阅-2"><a class="header" href="#另请参阅-2">另请参阅</a></h3>
<p><a href="reference/forge/./forge.html">forge</a>, <a href="reference/forge/./forge-build.html">forge build</a>, <a href="reference/forge/./forge-snapshot.html">forge snapshot</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="forge-snapshot-1"><a class="header" href="#forge-snapshot-1">forge snapshot</a></h2>
<h3 id="name-10"><a class="header" href="#name-10">NAME</a></h3>
<p>forge-snapshot - 创建每个测试的 gas 使用情况快照。</p>
<h3 id="synopsis-10"><a class="header" href="#synopsis-10">SYNOPSIS</a></h3>
<p><code>forge snapshot</code> [<em>options</em>]</p>
<h3 id="description-10"><a class="header" href="#description-10">DESCRIPTION</a></h3>
<p>创建每个测试的 gas 使用情况快照。</p>
<p>结果会写入一个名为 <code>.gas-snapshot</code> 的文件。你可以通过传递 <code>--snap &lt;PATH&gt;</code> 来更改文件名。</p>
<p>默认情况下，快照中包含 fuzz 测试。它们使用静态种子以实现确定性结果。</p>
<p>可以使用 <code>--diff</code> 和 <code>--check</code> 来比较快照。第一个标志会输出差异，第二个标志会输出差异并如果快照不匹配则退出并返回代码 1。</p>
<h3 id="options-10"><a class="header" href="#options-10">OPTIONS</a></h3>
<h4 id="snapshot-options"><a class="header" href="#snapshot-options">Snapshot Options</a></h4>
<p><code>--asc</code><br />
按 gas 使用量升序排序结果。</p>
<p><code>--desc</code><br />
    按 gas 使用量降序排序结果。</p>
<p><code>--min</code> <em>min_gas</em><br />
    仅包含使用 gas 量超过给定数量的测试。</p>
<p><code>--max</code> <em>max_gas</em><br />
    仅包含使用 gas 量少于给定数量的测试。</p>
<p><code>--tolerance</code> <em>threshold</em><br />
    容忍 gas 偏差高达指定百分比（0-100）。</p>
<p><code>--diff</code> <em>path</em><br />
    与预先存在的快照输出差异。</p>
<p>    默认情况下，比较使用 <code>.gas-snapshot</code>。</p>
<p><code>--check</code> <em>path</em><br />
    与预先存在的快照进行比较，如果不匹配则退出并返回代码 1。</p>
<p>    如果快照不匹配，则输出差异。</p>
<p>    默认情况下，比较使用 <code>.gas-snapshot</code>。</p>
<p><code>--snap</code> <em>path</em><br />
    快照的输出文件。默认：<code>.gas-snapshot</code>。</p>
<pre><code class="language-markdown">#### 测试选项

`-m` *regex*  
`--match` *regex*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;仅运行匹配指定正则表达式的测试函数。  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;**已弃用：请参见 `--match-test`。**

`--match-test` *regex*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;仅运行匹配指定正则表达式的测试函数。

`--no-match-test` *regex*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;仅运行不匹配指定正则表达式的测试函数。

`--match-contract` *regex*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;仅运行匹配指定正则表达式的合约中的测试。

`--no-match-contract` *regex*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;仅运行不匹配指定正则表达式的合约中的测试。

`--match-path` *glob*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;仅运行匹配指定 glob 模式的源文件中的测试。

`--no-match-path` *glob*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;仅运行不匹配指定 glob 模式的源文件中的测试。

`--debug` *regex*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在调试器中运行测试。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;传递给此标志的参数是您要运行的测试函数的名称，其工作方式与 `--match-test` 相同。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如果多个测试匹配您指定的条件，您必须添加额外的过滤器，直到找到一个测试（参见 `--match-contract` 和 `--match-path`）。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;匹配的测试将在调试器中打开，无论测试结果如何。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如果匹配的测试是模糊测试，则它将在第一个失败案例中打开调试器。如果模糊测试没有失败，它将在最后一个模糊案例中打开调试器。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;有关更精细的模糊案例控制，请参见 [`forge debug`](./forge-debug.md)。

`--gas-report`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印 gas 报告。

`--allow-failure`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;即使测试失败也以代码 0 退出。

`--fail-fast`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在第一次失败后停止运行测试。

`--etherscan-api-key` *key*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Etherscan API 密钥。如果设置，且同时设置了 `--fork-url`，则使用 Etherscan 解码 traces。  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量：`ETHERSCAN_API_KEY`
</code></pre>
<pre><code class="language-json">{
  "title": "EVM 选项",
  "options": [
    {
      "name": "-f",
      "alias": ["--rpc-url", "--fork-url"],
      "description": "从远程端点获取状态，而不是从空状态开始。",
      "note": "如果要从特定区块号获取状态，请参见 `--fork-block-number`。"
    },
    {
      "name": "--fork-block-number",
      "description": "从远程端点获取特定区块号的状态。请参见 `--fork-url`。"
    },
    {
      "name": "--fork-retry-backoff",
      "description": "遇到错误时的初始重试退避时间。"
    },
    {
      "name": "--no-storage-caching",
      "description": "显式禁用 RPC 缓存的使用。",
      "note": "所有存储槽完全从端点读取。请参见 `--fork-url`。"
    },
    {
      "name": "-v",
      "alias": "--verbosity",
      "description": "EVM 的详细程度。",
      "note": "多次传递以增加详细程度（例如 `-v`, `-vv`, `-vvv`）。",
      "levels": [
        {
          "level": 2,
          "description": "打印所有测试的日志"
        },
        {
          "level": 3,
          "description": "打印失败测试的执行 traces"
        },
        {
          "level": 4,
          "description": "打印所有测试的执行 traces，以及失败测试的设置 traces"
        },
        {
          "level": 5,
          "description": "打印所有测试的执行和设置 traces"
        }
      ]
    },
    {
      "name": "--sender",
      "description": "将执行测试的地址"
    },
    {
      "name": "--initial-balance",
      "description": "已部署合约的初始余额"
    },
    {
      "name": "--ffi",
      "description": "启用 [FFI cheatcode][ffi-cheatcode]"
    }
  ],
  "links": {
    "ffi-cheatcode": "../../cheatcodes/ffi.md"
  }
}
</code></pre>
<pre><code class="language-markdown">#### 执行器选项

`--base-fee &lt;FEE&gt;`  
`--block-base-fee-per-gas &lt;FEE&gt;`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;区块中的基础费用（以 wei 为单位）。

`--block-coinbase` *address*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;区块的 coinbase 地址。

`--block-difficulty` *difficulty*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;区块的难度。

`--block-gas-limit` *gas_limit*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;区块的 gas 限制。

`--block-number` *block*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;区块编号。

`--block-timestamp` *timestamp*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;区块的时间戳（以秒为单位）。

`--chain-id` *chain_id*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;链 ID。

`--gas-limit` *gas_limit*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;区块的 gas 限制。

`--gas-price` *gas_price*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;gas 价格（以 wei 为单位）。

`--tx-origin` *address*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;交易的发起方地址。
</code></pre>
<h4 id="缓存选项-3"><a class="header" href="#缓存选项-3">缓存选项</a></h4>
<p><code>--force</code><br />
    清除缓存和 artifacts 文件夹并重新编译。</p>
<h4 id="链接器选项-3"><a class="header" href="#链接器选项-3">链接器选项</a></h4>
<p><code>--libraries</code> <em>libraries</em><br />
    设置预链接的库。</p>
<p>    参数必须采用 <code>&lt;重映射的库路径&gt;:&lt;库名称&gt;:&lt;地址&gt;</code> 格式，例如 <code>src/Contract.sol:Library:0x...</code>。</p>
<p>    也可以在配置文件中设置为 <code>libraries = ["&lt;路径&gt;:&lt;库名称&gt;:&lt;地址&gt;"]</code>。</p>
<pre><code class="language-markdown">#### 编译器选项

`--optimize`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;激活 Solidity 优化器。

`--optimizer-runs` *runs*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;优化器运行的次数。

`--via-ir`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;使用 Yul 中间表示编译管道。

`--revert-strings`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如何处理 revert 和 require 原因字符串。

`--use` *solc_version*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;指定 solc 版本或本地 solc 的路径进行构建。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;有效值格式为 `x.y.z`、`solc:x.y.z` 或 `path/to/solc`。

`--offline`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;不访问网络。缺失的 solc 版本不会被安装。

`--no-auto-detect`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;不自动检测 solc。

`--ignored-error-codes` *error_codes*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;通过错误代码忽略 solc 警告。参数是以逗号分隔的错误代码列表。

`--extra-output` *selector*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在合约的构件中包含的额外输出。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;示例键：`abi`、`storageLayout`、`evm.assembly`、`ewasm`、`ir`、`ir-optimized`、`metadata`。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;完整描述请参见 [Solidity 文档][output-desc]。

`--extra-output-files` *selector*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;写入单独文件的额外输出。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;示例键：`abi`、`storageLayout`、`evm.assembly`、`ewasm`、`ir`、`ir-optimized`、`metadata`。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;完整描述请参见 [Solidity 文档][output-desc]。

`--evm-version` *version*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;目标 EVM 版本。

[output-desc]: https://docs.soliditylang.org/en/latest/using-the-compiler.html#compiler-api
</code></pre>
<pre><code class="language-markdown">#### 项目选项

`--build-info`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;生成构建信息文件。

`--build-info-path` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;输出路径到构建信息文件将被写入的目录。

`--root` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;项目的根路径。默认情况下，这是当前 git 仓库的根目录，或者当前工作目录。

`-C` *路径*  
`--contracts` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;合约源目录。  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `DAPP_SRC`

`--lib-paths` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;库文件夹的路径。

`-R` *重映射*  
`--remappings` *重映射*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;项目的重映射。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;参数是以逗号分隔的重映射列表，格式为 `&lt;源&gt;=&lt;目标&gt;`。

`--cache-path` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;编译器缓存的路径。

`--config-path` *文件*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;配置文件的路径。

`--hh`  
`--hardhat`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这是一个便捷标志，等同于传递 `--contracts contracts --lib-paths node-modules`。
</code></pre>
<p><code>-o</code> <em>path</em><br />
<code>--out</code> <em>path</em><br />
    项目的 artifacts 目录。</p>
<p><code>--silent</code><br />
    抑制所有输出。</p>
<pre><code class="language-json">{
  "id": "display-options",
  "title": "显示选项"
}
</code></pre>
<h4 id="显示选项-3"><a class="header" href="#显示选项-3">显示选项</a></h4>
<p><code>-j</code><br />
<code>--json</code><br />
     以 JSON 格式打印部署信息。</p>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-10"><a class="header" href="#examples-10">EXAMPLES</a></h3>
<ol>
<li>
<p>创建快照：</p>
<pre><code class="language-sh">forge snapshot
</code></pre>
</li>
<li>
<p>生成差异：</p>
<pre><code class="language-sh">forge snapshot --diff
</code></pre>
</li>
<li>
<p>检查快照是否匹配：</p>
<pre><code class="language-sh">forge snapshot --check
</code></pre>
</li>
</ol>
<h3 id="see-also-9"><a class="header" href="#see-also-9">SEE ALSO</a></h3>
<p><a href="reference/forge/./forge.html">forge</a>, <a href="reference/forge/./forge-test.html">forge test</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="forge-coverage-1"><a class="header" href="#forge-coverage-1">forge coverage</a></h2>
<h3 id="名称-6"><a class="header" href="#名称-6">名称</a></h3>
<p>forge-coverage - 显示代码中哪些部分被测试覆盖。</p>
<h3 id="概要-6"><a class="header" href="#概要-6">概要</a></h3>
<p><code>forge coverage</code> [<em>选项</em>]</p>
<h3 id="描述-6"><a class="header" href="#描述-6">描述</a></h3>
<p>显示代码中哪些部分被测试覆盖。</p>
<h3 id="选项-5"><a class="header" href="#选项-5">选项</a></h3>
<h4 id="报告选项"><a class="header" href="#报告选项">报告选项</a></h4>
<p><code>--report</code> 允许你指定用于覆盖率的报告类型。此标志可以多次使用。</p>
<p>它有三种不同的选项，默认设置为 <code>summary</code>。</p>
<p><code>summary</code><br />
    输出一个图表，显示你的代码被测试覆盖的百分比。</p>
<p><code>lcov</code><br />
    在项目的根目录中创建一个包含覆盖数据的 lcov.info 文件。</p>
<p><code>debug</code><br />
    输出描述未覆盖代码位置的行。</p>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h4 id="优化选项"><a class="header" href="#优化选项">优化选项</a></h4>
<p><code>--ir-minimum</code> 允许你使用 <code>via-ir</code> 启用以进行“最少量的优化”（<a href="https://github.com/ethereum/solidity/issues/12533#issuecomment-1013073350" title="" target="_blank">minimum amount of optimization</a>）。</p>
<h3 id="示例-6"><a class="header" href="#示例-6">示例</a></h3>
<ol>
<li>
<p>查看汇总覆盖率：</p>
<pre><code class="language-sh">forge coverage
</code></pre>
</li>
<li>
<p>创建包含覆盖数据的 lcov 文件：</p>
<pre><code class="language-sh">forge coverage --report lcov
</code></pre>
</li>
<li>
<p>输出未覆盖代码的位置：</p>
<pre><code class="language-sh">forge coverage --report debug
</code></pre>
</li>
</ol>
<h3 id="另请参阅-3"><a class="header" href="#另请参阅-3">另请参阅</a></h3>
<p><a href="reference/forge/./forge.html">forge</a>, <a href="reference/forge/./forge-test.html">forge test</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="部署命令-1"><a class="header" href="#部署命令-1">部署命令</a></h2>
<ul>
<li><a href="reference/forge/./forge-create.html">forge create</a></li>
<li><a href="reference/forge/./forge-verify-contract.html">forge verify-contract</a></li>
<li><a href="reference/forge/./forge-verify-check.html">forge verify-check</a></li>
<li><a href="reference/forge/./forge-flatten.html">forge flatten</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="forge-create-1"><a class="header" href="#forge-create-1">forge create</a></h2>
<h3 id="name-11"><a class="header" href="#name-11">NAME</a></h3>
<p>forge-create - 部署智能合约。</p>
<h3 id="synopsis-11"><a class="header" href="#synopsis-11">SYNOPSIS</a></h3>
<p><code>forge create</code> [<em>options</em>] <em>contract</em></p>
<h3 id="description-11"><a class="header" href="#description-11">DESCRIPTION</a></h3>
<p>部署智能合约。</p>
<p>合约路径的格式为 <code>&lt;path&gt;:&lt;contract&gt;</code>，例如 <code>src/Contract.sol:Contract</code>。</p>
<p>你可以使用 <code>--constructor-args</code> 指定构造函数参数。或者，你可以使用 <code>--constructor-args-path</code> 指定包含空格分隔的构造函数参数的文件。</p>
<p>不支持动态链接：你应该预先部署你的库，并手动指定它们的地址（见 <code>--libraries</code>）。</p>
<blockquote>
<p>ℹ️ <strong>注意</strong></p>
<p><code>--constructor-args</code> 标志必须放在命令的最后，因为它接受多个值。</p>
</blockquote>
<h3 id="options-11"><a class="header" href="#options-11">OPTIONS</a></h3>
<h4 id="build-options"><a class="header" href="#build-options">Build Options</a></h4>
<p><code>--constructor-args</code> <em>args…</em><br />
    构造函数参数。</p>
<p><code>--constructor-args-path</code> <em>file</em><br />
    包含构造函数参数的文件路径。</p>
<p><code>--verify</code><br />
    创建后验证合约。运行 <code>forge verify-contract</code> 并带有适当的参数。</p>
<pre><code class="language-markdown">`--verifier` *name*   
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;验证提供者。可用选项：`etherscan`、`sourcify` 和 `blockscout`。默认：`etherscan`。注意：确保在 Blockscout 主页浏览器 URL 的末尾添加 "/api?"。

`--verifier-url` *url*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;可选的验证器 URL，用于提交验证请求。  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量：`VERIFIER_URL`
</code></pre>
<p><code>--unlocked</code><br />
    通过 <code>eth_sendTransaction</code> 发送，使用 <code>--from</code> 参数或 <code>$ETH_FROM</code> 作为发送者。</p>
<pre><code class="language-markdown">#### 交易选项

`--gas-limit` *gas_limit*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;交易的 gas 限制。

`--gas-price` *price*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;交易的 gas 价格，或 EIP1559 交易的每 gas 最大费用。

`--priority-gas-price` *price*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;EIP1559 交易的每 gas 最大优先费用。

`--value` *值*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在交易中发送的以太币。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;可以指定为整数（wei），或指定为带有单位的字符串，例如：  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;- `1ether`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;- `10gwei`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;- `0.01ether`

`--nonce` *nonce*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;交易的 nonce。

`--legacy`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;发送一个传统交易，而不是 [EIP1559][eip1559] 交易。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;对于没有 EIP1559 的常见网络，这会自动启用。

[eip1559]: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1559.md
</code></pre>
<pre><code class="language-markdown"># 钱包选项

Foundry 支持多种钱包选项，包括原始私钥、密钥库文件、硬件钱包和远程签名者。

## 原始私钥

你可以使用 `PRIVATE_KEY` 环境变量来指定一个原始私钥。

```sh
export PRIVATE_KEY=&lt;your_private_key&gt;
</code></pre>
<p>你也可以在 <code>foundry.toml</code> 文件中配置它：</p>
<pre><code class="language-toml">[profile.default]
private_key = "&lt;your_private_key&gt;"
</code></pre>
<h2 id="密钥库文件"><a class="header" href="#密钥库文件">密钥库文件</a></h2>
<p>Foundry 支持使用密钥库文件进行签名。你可以通过 <code>ETH_KEYSTORE</code> 环境变量指定密钥库文件的路径，并通过 <code>ETH_PASSWORD</code> 环境变量提供密码。</p>
<pre><code class="language-sh">export ETH_KEYSTORE=&lt;path_to_keystore&gt;
export ETH_PASSWORD=&lt;your_keystore_password&gt;
</code></pre>
<p>你也可以在 <code>foundry.toml</code> 文件中配置它：</p>
<pre><code class="language-toml">[profile.default]
keystore = "&lt;path_to_keystore&gt;"
password = "&lt;your_keystore_password&gt;"
</code></pre>
<h2 id="硬件钱包"><a class="header" href="#硬件钱包">硬件钱包</a></h2>
<p>Foundry 支持使用硬件钱包进行签名。你可以通过 <code>ETH_HW_WALLET</code> 环境变量指定硬件钱包的类型。</p>
<pre><code class="language-sh">export ETH_HW_WALLET=&lt;hardware_wallet_type&gt;
</code></pre>
<p>你也可以在 <code>foundry.toml</code> 文件中配置它：</p>
<pre><code class="language-toml">[profile.default]
hardware_wallet = "&lt;hardware_wallet_type&gt;"
</code></pre>
<h2 id="远程签名者"><a class="header" href="#远程签名者">远程签名者</a></h2>
<p>Foundry 支持使用远程签名者进行签名。你可以通过 <code>ETH_RPC_URL</code> 环境变量指定远程签名者的 RPC URL。</p>
<pre><code class="language-sh">export ETH_RPC_URL=&lt;remote_signer_rpc_url&gt;
</code></pre>
<p>你也可以在 <code>foundry.toml</code> 文件中配置它：</p>
<pre><code class="language-toml">[profile.default]
rpc_url = "&lt;remote_signer_rpc_url&gt;"
</code></pre>
<pre><code>
#### RPC 选项

```markdown
`--rpc-url` *url*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;RPC 端点。接受一个 URL 或 [rpc_endpoints] 表中已有的别名，例如 `mainnet`。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `ETH_RPC_URL`
</code></pre>
<p><code>--flashbots</code><br />
    使用 Flashbots RPC URL（<a href="https://rpc.flashbots.net">https://rpc.flashbots.net</a>）。</p>
<pre><code class="language-markdown">#### Etherscan 选项

`--chain` *chain_name*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Etherscan 链。

`--etherscan-api-key` *key*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Etherscan API 密钥，或 [Etherscan 配置表](../config/etherscan.md#etherscan) 中的密钥。  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `ETHERSCAN_API_KEY`
</code></pre>
<h4 id="缓存选项-4"><a class="header" href="#缓存选项-4">缓存选项</a></h4>
<p><code>--force</code><br />
    清除缓存和 artifacts 文件夹并重新编译。</p>
<h4 id="链接器选项-4"><a class="header" href="#链接器选项-4">链接器选项</a></h4>
<p><code>--libraries</code> <em>libraries</em><br />
    设置预链接的库。</p>
<p>    参数必须采用 <code>&lt;重映射的库路径&gt;:&lt;库名称&gt;:&lt;地址&gt;</code> 格式，例如 <code>src/Contract.sol:Library:0x...</code>。</p>
<p>    也可以在配置文件中设置为 <code>libraries = ["&lt;路径&gt;:&lt;库名称&gt;:&lt;地址&gt;"]</code>。</p>
<pre><code class="language-markdown">#### 编译器选项

`--optimize`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;激活 Solidity 优化器。

`--optimizer-runs` *runs*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;优化器运行的次数。

`--via-ir`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;使用 Yul 中间表示编译管道。

`--revert-strings`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如何处理 revert 和 require 原因字符串。

`--use` *solc_version*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;指定 solc 版本或本地 solc 的路径进行构建。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;有效值格式为 `x.y.z`、`solc:x.y.z` 或 `path/to/solc`。

`--offline`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;不访问网络。缺失的 solc 版本不会被安装。

`--no-auto-detect`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;不自动检测 solc。

`--ignored-error-codes` *error_codes*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;通过错误代码忽略 solc 警告。参数是以逗号分隔的错误代码列表。

`--extra-output` *selector*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在合约的构件中包含的额外输出。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;示例键：`abi`、`storageLayout`、`evm.assembly`、`ewasm`、`ir`、`ir-optimized`、`metadata`。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;完整描述请参见 [Solidity 文档][output-desc]。

`--extra-output-files` *selector*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;写入单独文件的额外输出。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;示例键：`abi`、`storageLayout`、`evm.assembly`、`ewasm`、`ir`、`ir-optimized`、`metadata`。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;完整描述请参见 [Solidity 文档][output-desc]。

`--evm-version` *version*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;目标 EVM 版本。

[output-desc]: https://docs.soliditylang.org/en/latest/using-the-compiler.html#compiler-api
</code></pre>
<pre><code class="language-markdown">#### 项目选项

`--build-info`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;生成构建信息文件。

`--build-info-path` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;输出路径到构建信息文件将被写入的目录。

`--root` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;项目的根路径。默认情况下，这是当前 git 仓库的根目录，或者当前工作目录。

`-C` *路径*  
`--contracts` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;合约源目录。  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `DAPP_SRC`

`--lib-paths` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;库文件夹的路径。

`-R` *重映射*  
`--remappings` *重映射*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;项目的重映射。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;参数是以逗号分隔的重映射列表，格式为 `&lt;源&gt;=&lt;目标&gt;`。

`--cache-path` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;编译器缓存的路径。

`--config-path` *文件*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;配置文件的路径。

`--hh`  
`--hardhat`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这是一个便捷标志，等同于传递 `--contracts contracts --lib-paths node-modules`。
</code></pre>
<p><code>-o</code> <em>path</em><br />
<code>--out</code> <em>path</em><br />
    项目的 artifacts 目录。</p>
<p><code>--silent</code><br />
    抑制所有输出。</p>
<pre><code class="language-json">{
  "id": "display-options",
  "title": "显示选项"
}
</code></pre>
<h4 id="显示选项-4"><a class="header" href="#显示选项-4">显示选项</a></h4>
<p><code>-j</code><br />
<code>--json</code><br />
     以 JSON 格式打印部署信息。</p>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-11"><a class="header" href="#examples-11">EXAMPLES</a></h3>
<ol>
<li>
<p>部署没有构造函数参数的合约：</p>
<pre><code class="language-sh">forge create src/Contract.sol:ContractWithNoConstructor
</code></pre>
</li>
<li>
<p>部署带有两个构造函数参数的合约：</p>
<pre><code class="language-sh">forge create src/Contract.sol:MyToken --constructor-args "My Token" "MT"
</code></pre>
</li>
</ol>
<h3 id="see-also-10"><a class="header" href="#see-also-10">SEE ALSO</a></h3>
<p><a href="reference/forge/./forge.html">forge</a>, <a href="reference/forge/./forge-build.html">forge build</a>, <a href="reference/forge/./forge-verify-contract.html">forge verify-contract</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="forge-verify-contract-2"><a class="header" href="#forge-verify-contract-2">forge verify-contract</a></h2>
<h3 id="name-12"><a class="header" href="#name-12">NAME</a></h3>
<p>forge-verify-contract - 在选定的验证提供商上验证智能合约。</p>
<h3 id="synopsis-12"><a class="header" href="#synopsis-12">SYNOPSIS</a></h3>
<p><code>forge verify-contract</code> [<em>options</em>] <em>address</em> <em>contract</em></p>
<h3 id="description-12"><a class="header" href="#description-12">DESCRIPTION</a></h3>
<p>在选定的验证提供商上验证智能合约。</p>
<p>你必须提供：</p>
<ul>
<li>合约地址</li>
<li>合约名称或合约路径（详见下文）
如果是 Etherscan 验证，你还必须提供：</li>
<li>你的 Etherscan API 密钥，可以通过参数传递或设置 <code>ETHERSCAN_API_KEY</code></li>
</ul>
<p>要找到确切的编译器版本，运行 <code>~/.svm/x.y.z/solc-x.y.z --version</code> 并在<a href="https://etherscan.io/solcversions" title="" target="_blank">这里</a>搜索版本字符串中的 8 位十六进制数字。</p>
<p>合约路径的格式为 <code>&lt;path&gt;:&lt;contract&gt;</code>，例如 <code>src/Contract.sol:Contract</code>。</p>
<p>默认情况下，智能合约以多文件方式验证。如果你想在验证前展平合约，请传递 <code>--flatten</code>。</p>
<p>如果传递了 <code>--flatten</code>，此命令将尝试编译展平合约的源代码。如果你不想这样做，请传递 <code>--force</code>。</p>
<p>你可以使用 <code>--constructor-args</code> 指定 <strong>ABI 编码</strong>的构造函数参数。或者，你可以使用 <code>--constructor-args-path</code> 指定包含 <strong>空格分隔</strong>的构造函数参数的文件。（注意，为了后者工作，配置中必须启用<a href="reference/forge/../config/project.html#cache">缓存</a>。）</p>
<h3 id="options-12"><a class="header" href="#options-12">OPTIONS</a></h3>
<h4 id="verify-contract-options"><a class="header" href="#verify-contract-options">Verify Contract Options</a></h4>
<pre><code class="language-markdown">`--verifier` *name*   
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;验证提供者。可用选项：`etherscan`、`sourcify` 和 `blockscout`。默认：`etherscan`。注意：确保在 Blockscout 主页浏览器 URL 的末尾添加 "/api?"。

`--verifier-url` *url*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;可选的验证器 URL，用于提交验证请求。  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量：`VERIFIER_URL`
</code></pre>
<p><code>--skip-is-verified-check</code>
    即使合约已经验证，也发送验证请求。</p>
<p><code>--compiler-version</code> <em>version</em><br />
    用于构建智能合约的编译器版本。</p>
<p>    要找到确切的编译器版本，运行 <code>~/.svm/x.y.z/solc-x.y.z --version</code>，其中 <code>x</code> 和 <code>y</code> 分别是主版本号和次版本号，然后在<a href="https://etherscan.io/solcversions" title="" target="_blank">这里</a>搜索版本字符串中的 8 位十六进制数字。</p>
<p><code>--num-of-optimizations</code> <em>num</em><br />
<code>--optimizer-runs</code> <em>num</em><br />
    用于构建智能合约的优化运行次数。</p>
<p><code>--constructor-args</code> <em>args</em><br />
    ABI 编码的构造函数参数。与 <code>--constructor-args-path</code> 冲突。</p>
<p><code>--constructor-args-path</code> <em>file</em><br />
    包含构造函数参数的文件路径。与 <code>--constructor-args</code> 冲突。</p>
<p><code>--chain-id</code> <em>chain</em><br />
<code>--chain</code> <em>chain</em><br />
    合约部署到的链的 ID 或名称。<br />
    默认：mainnet</p>
<p><code>--flatten</code><br />
    指示是否在验证前展平源代码的标志。</p>
<p>    如果未提供此标志，将使用 JSON 标准输入。</p>
<p><code>-f</code><br />
<code>--force</code><br />
    在验证前不编译展平的智能合约。</p>
<pre><code class="language-markdown">`--delay` *delay*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;可选的超时时间，以秒为单位，在每次尝试之间应用。默认为 3。

`--retries` *retries*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;重试的尝试次数。默认为 15。
</code></pre>
<p><code>--show-standard-json-input</code><br />
    命令输出适合保存到文件并上传到区块浏览器进行验证的 JSON。</p>
<p><code>--watch</code><br />
    提交后等待验证结果。<br />
    自动运行 <code>forge verify-check</code> 直到验证失败或成功。</p>
<pre><code class="language-markdown">#### 项目选项

`--build-info`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;生成构建信息文件。

`--build-info-path` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;输出路径到构建信息文件将被写入的目录。

`--root` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;项目的根路径。默认情况下，这是当前 git 仓库的根目录，或者当前工作目录。

`-C` *路径*  
`--contracts` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;合约源目录。  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `DAPP_SRC`

`--lib-paths` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;库文件夹的路径。

`-R` *重映射*  
`--remappings` *重映射*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;项目的重映射。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;参数是以逗号分隔的重映射列表，格式为 `&lt;源&gt;=&lt;目标&gt;`。

`--cache-path` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;编译器缓存的路径。

`--config-path` *文件*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;配置文件的路径。

`--hh`  
`--hardhat`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这是一个便捷标志，等同于传递 `--contracts contracts --lib-paths node-modules`。
</code></pre>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-12"><a class="header" href="#examples-12">EXAMPLES</a></h3>
<ol>
<li>
<p>使用 JSON 标准输入在 Etherscan 上验证合约</p>
<pre><code class="language-sh">forge verify-contract &lt;address&gt; SomeContract --watch
</code></pre>
</li>
<li>
<p>在自定义 Sourcify 实例上验证合约</p>
<pre><code class="language-sh">forge verify-contract --verifier sourcify \
  --verifier-url http://localhost:5000 &lt;address&gt; SomeContract
</code></pre>
</li>
<li>
<p>验证使用 solc v0.8.11+commit.d7f03943 构建的展平合约</p>
<pre><code class="language-sh">forge verify-contract --flatten --watch --compiler-version "v0.8.11+commit.d7f03943" \
  --constructor-args $(cast abi-encode "constructor(string,string,uint256,uint256)" "ForgeUSD" "FUSD" 18 1000000000000000000000) \
  &lt;address&gt; MyToken
</code></pre>
</li>
<li>
<p>通过指定文件中的构造函数参数验证展平合约</p>
<pre><code class="language-sh">forge verify-contract --flatten --watch --compiler-version "v0.8.11+commit.d7f03943" \
  --constructor-args-path constructor-args.txt &lt;address&gt; src/Token.sol:MyToken
</code></pre>
<p>其中 <code>constructor-args.txt</code> 包含以下内容：</p>
<pre><code class="language-text">ForgeUSD FUSD 18 1000000000000000000000
</code></pre>
</li>
<li>
<p>在部署后立即使用 Blockscout 验证合约（确保在 Blockscout 主页浏览器 URL 末尾添加 “/api?”）</p>
<pre><code class="language-sh">forge create --rpc-url &lt;rpc_https_endpoint&gt; --private-key $devTestnetPrivateKey src/Contract.sol:SimpleStorage --verify --verifier blockscout --verifier-url &lt;blockscout_homepage_explorer_url&gt;/api? 
</code></pre>
</li>
<li>
<p>使用 Oklink 验证合约</p>
<pre><code class="language-sh">forge verify-contract 0x8CDDE82cFB4555D6ca21B5b28F97630265DA94c4 Counter --verifier oklink --verifier-url https://www.oklink.com/api/v5/explorer/contract/verify-source-code-plugin/XLAYER  --api-key $OKLINK_API_KEY
</code></pre>
</li>
<li>
<p>在部署时使用 Oklink 验证合约</p>
<pre><code class="language-sh">forge create Counter --rpc-url &lt;rpc_https_endpoint&gt; --verify --verifier oklink --verifier-url https://www.oklink.com/api/v5/explorer/contract/verify-source-code-plugin/XLAYER --etherscan-api-key $OKLINK_API_KEY --private-key $PRIVATE_KEY --legacy
</code></pre>
</li>
</ol>
<h3 id="see-also-11"><a class="header" href="#see-also-11">SEE ALSO</a></h3>
<p><a href="reference/forge/./forge.html">forge</a>, <a href="reference/forge/./forge-create.html">forge create</a>, <a href="reference/forge/./forge-flatten.html">forge flatten</a>, <a href="reference/forge/./forge-verify-check.html">forge verify-check</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="forge-verify-check"><a class="header" href="#forge-verify-check">forge verify-check</a></h2>
<h3 id="name-13"><a class="header" href="#name-13">NAME</a></h3>
<p>forge-verify-check - 检查所选验证提供商的验证状态。</p>
<h3 id="synopsis-13"><a class="header" href="#synopsis-13">SYNOPSIS</a></h3>
<p><code>forge verify-check</code> [<em>options</em>] <em>id</em> [<em>etherscan_key</em>]</p>
<p><em>id</em> 是验证标识符。对于 Etherscan 和 Bloxroute - 它是提交 GUID，对于 Sourcify - 它是合约地址。</p>
<h3 id="description-13"><a class="header" href="#description-13">DESCRIPTION</a></h3>
<p>检查所选验证提供商的验证状态。</p>
<p>对于 Etherscan，您必须提供一个 Etherscan API 密钥，可以通过作为参数传递或设置 <code>ETHERSCAN_API_KEY</code>。</p>
<h3 id="options-13"><a class="header" href="#options-13">OPTIONS</a></h3>
<h4 id="验证合约选项"><a class="header" href="#验证合约选项">验证合约选项</a></h4>
<pre><code class="language-markdown">`--verifier` *name*   
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;验证提供者。可用选项：`etherscan`、`sourcify` 和 `blockscout`。默认：`etherscan`。注意：确保在 Blockscout 主页浏览器 URL 的末尾添加 "/api?"。

`--verifier-url` *url*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;可选的验证器 URL，用于提交验证请求。  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量：`VERIFIER_URL`
</code></pre>
<p><code>--chain-id</code> <em>chain_id</em><br />
    合约部署到的链 ID（可以是数字或链名称）。<br />
    默认值：mainnet</p>
<pre><code class="language-markdown">`--delay` *delay*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;可选的超时时间，以秒为单位，在每次尝试之间应用。默认为 3。

`--retries` *retries*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;重试的尝试次数。默认为 15。
</code></pre>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="see-also-12"><a class="header" href="#see-also-12">SEE ALSO</a></h3>
<p><a href="reference/forge/./forge.html">forge</a>, <a href="reference/forge/./forge-create.html">forge create</a>, <a href="reference/forge/./forge-verify-contract.html">forge verify-contract</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="forge-flatten-1"><a class="header" href="#forge-flatten-1">forge flatten</a></h2>
<h3 id="名称-7"><a class="header" href="#名称-7">名称</a></h3>
<p>forge-flatten - 将一个源文件及其所有导入合并到一个文件中。</p>
<h3 id="概要-7"><a class="header" href="#概要-7">概要</a></h3>
<p><code>forge flatten</code> [<em>选项</em>] <em>文件</em></p>
<h3 id="描述-7"><a class="header" href="#描述-7">描述</a></h3>
<p>将一个源文件及其所有导入合并到一个文件中。</p>
<p>如果未设置 <code>--output &lt;FILE&gt;</code>，则合并后的合约将输出到标准输出。</p>
<h3 id="选项-6"><a class="header" href="#选项-6">选项</a></h3>
<h4 id="合并选项"><a class="header" href="#合并选项">合并选项</a></h4>
<p><code>-o</code> <em>文件</em><br />
<code>--output</code> <em>文件</em><br />
    输出合并后合约的路径。如果未指定，合并后的合约将输出到标准输出。</p>
<pre><code class="language-markdown">#### 项目选项

`--build-info`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;生成构建信息文件。

`--build-info-path` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;输出路径到构建信息文件将被写入的目录。

`--root` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;项目的根路径。默认情况下，这是当前 git 仓库的根目录，或者当前工作目录。

`-C` *路径*  
`--contracts` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;合约源目录。  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `DAPP_SRC`

`--lib-paths` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;库文件夹的路径。

`-R` *重映射*  
`--remappings` *重映射*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;项目的重映射。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;参数是以逗号分隔的重映射列表，格式为 `&lt;源&gt;=&lt;目标&gt;`。

`--cache-path` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;编译器缓存的路径。

`--config-path` *文件*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;配置文件的路径。

`--hh`  
`--hardhat`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这是一个便捷标志，等同于传递 `--contracts contracts --lib-paths node-modules`。
</code></pre>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="示例-7"><a class="header" href="#示例-7">示例</a></h3>
<ol>
<li>
<p>合并 <code>src/Contract.sol</code>：</p>
<pre><code class="language-sh">forge flatten src/Contract.sol
</code></pre>
</li>
<li>
<p>合并 <code>src/Contract.sol</code> 并将结果写入 <code>src/Contract.flattened.sol</code>：</p>
<pre><code class="language-sh">forge flatten --output src/Contract.flattened.sol src/Contract.sol
</code></pre>
</li>
</ol>
<h3 id="另请参阅-4"><a class="header" href="#另请参阅-4">另请参阅</a></h3>
<p><a href="reference/forge/./forge.html">forge</a>, <a href="reference/forge/./forge-verify-contract.html">forge verify-contract</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="实用命令-1"><a class="header" href="#实用命令-1">实用命令</a></h2>
<ul>
<li><a href="reference/forge/./forge-debug.html">forge debug</a></li>
<li><a href="reference/forge/./forge-bind.html">forge bind</a></li>
<li><a href="reference/forge/./forge-cache.html">forge cache</a></li>
<li><a href="reference/forge/./forge-cache-clean.html">forge cache clean</a></li>
<li><a href="reference/forge/./forge-cache-ls.html">forge cache ls</a></li>
<li><a href="reference/forge/./forge-script.html">forge script</a></li>
<li><a href="reference/forge/./forge-upload-selectors.html">forge upload-selectors</a></li>
<li><a href="reference/forge/./forge-doc.html">forge doc</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="forge-debug"><a class="header" href="#forge-debug">forge debug</a></h2>
<h3 id="name-14"><a class="header" href="#name-14">NAME</a></h3>
<p>forge-debug - 将单个智能合约作为脚本进行调试。</p>
<h3 id="synopsis-14"><a class="header" href="#synopsis-14">SYNOPSIS</a></h3>
<p><code>forge debug</code> [<em>options</em>] <em>path</em> [<em>args…</em>]</p>
<h3 id="description-14"><a class="header" href="#description-14">DESCRIPTION</a></h3>
<p>将位于源文件（<em>path</em>）中的单个智能合约作为脚本进行调试。</p>
<p>如果指定的源文件中有多个合约，则必须传递 <code>--target-contract</code> 来指定要运行的合约。</p>
<h4 id="调用"><a class="header" href="#调用">调用</a></h4>
<p>在脚本部署到内部 EVM 后，如果存在，会调用一个带有 <code>setUp()</code> 签名的函数。</p>
<p>默认情况下，假定脚本包含在一个带有 <code>run()</code> 签名的函数中。如果希望运行不同的函数，请传递 <code>--sig &lt;SIGNATURE&gt;</code>。</p>
<p>签名可以是片段（<code>&lt;function name&gt;(&lt;types&gt;)</code>），或原始调用数据。</p>
<p>如果传递片段，并且函数有参数，可以将调用参数添加到命令末尾（<em>args</em>）。</p>
<h4 id="分叉-1"><a class="header" href="#分叉-1">分叉</a></h4>
<p>可以通过传递 <code>--fork-url &lt;URL&gt;</code> 在分叉环境中运行脚本。</p>
<p>当脚本在分叉环境中运行时，可以访问分叉链的所有状态，就像部署了脚本一样。<a href="reference/forge/../../cheatcodes/">作弊码</a> 仍然可用。</p>
<p>还可以通过传递 <code>--fork-block-number &lt;BLOCK&gt;</code> 指定从某个区块分叉。当从特定区块分叉时，链数据会缓存到 <code>~/.foundry/cache</code>。如果不希望缓存链数据，请传递 <code>--no-storage-caching</code>。</p>
<h4 id="调试-1"><a class="header" href="#调试-1">调试</a></h4>
<p>可以在交互式调试器中运行脚本。要启动调试器，请传递 <code>--debug</code>。</p>
<p>有关调试器的更多信息，请参见 <a href="reference/forge/../../forge/debugger.html">调试器章节</a>。</p>
<h3 id="options-14"><a class="header" href="#options-14">OPTIONS</a></h3>
<h4 id="调试选项"><a class="header" href="#调试选项">调试选项</a></h4>
<p><code>--target-contract</code> <em>contract_name</em><br />
    要运行的合约名称</p>
<p><code>-s</code> <em>signature</em><br />
<code>--sig</code> <em>signature</em><br />
    要在合约中调用的函数签名或原始调用数据。默认值：<code>run()</code></p>
<p><code>--debug</code><br />
    在 <a href="reference/forge/../../forge/debugger.html">调试器</a> 中打开脚本。</p>
<pre><code class="language-json">{
  "title": "EVM 选项",
  "options": [
    {
      "name": "-f",
      "alias": ["--rpc-url", "--fork-url"],
      "description": "从远程端点获取状态，而不是从空状态开始。",
      "note": "如果要从特定区块号获取状态，请参见 `--fork-block-number`。"
    },
    {
      "name": "--fork-block-number",
      "description": "从远程端点获取特定区块号的状态。请参见 `--fork-url`。"
    },
    {
      "name": "--fork-retry-backoff",
      "description": "遇到错误时的初始重试退避时间。"
    },
    {
      "name": "--no-storage-caching",
      "description": "显式禁用 RPC 缓存的使用。",
      "note": "所有存储槽完全从端点读取。请参见 `--fork-url`。"
    },
    {
      "name": "-v",
      "alias": "--verbosity",
      "description": "EVM 的详细程度。",
      "note": "多次传递以增加详细程度（例如 `-v`, `-vv`, `-vvv`）。",
      "levels": [
        {
          "level": 2,
          "description": "打印所有测试的日志"
        },
        {
          "level": 3,
          "description": "打印失败测试的执行 traces"
        },
        {
          "level": 4,
          "description": "打印所有测试的执行 traces，以及失败测试的设置 traces"
        },
        {
          "level": 5,
          "description": "打印所有测试的执行和设置 traces"
        }
      ]
    },
    {
      "name": "--sender",
      "description": "将执行测试的地址"
    },
    {
      "name": "--initial-balance",
      "description": "已部署合约的初始余额"
    },
    {
      "name": "--ffi",
      "description": "启用 [FFI cheatcode][ffi-cheatcode]"
    }
  ],
  "links": {
    "ffi-cheatcode": "../../cheatcodes/ffi.md"
  }
}
</code></pre>
<pre><code class="language-markdown">#### 执行器选项

`--base-fee &lt;FEE&gt;`  
`--block-base-fee-per-gas &lt;FEE&gt;`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;区块中的基础费用（以 wei 为单位）。

`--block-coinbase` *address*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;区块的 coinbase 地址。

`--block-difficulty` *difficulty*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;区块的难度。

`--block-gas-limit` *gas_limit*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;区块的 gas 限制。

`--block-number` *block*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;区块编号。

`--block-timestamp` *timestamp*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;区块的时间戳（以秒为单位）。

`--chain-id` *chain_id*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;链 ID。

`--gas-limit` *gas_limit*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;区块的 gas 限制。

`--gas-price` *gas_price*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;gas 价格（以 wei 为单位）。

`--tx-origin` *address*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;交易的发起方地址。
</code></pre>
<h4 id="缓存选项-5"><a class="header" href="#缓存选项-5">缓存选项</a></h4>
<p><code>--force</code><br />
    清除缓存和 artifacts 文件夹并重新编译。</p>
<h4 id="链接器选项-5"><a class="header" href="#链接器选项-5">链接器选项</a></h4>
<p><code>--libraries</code> <em>libraries</em><br />
    设置预链接的库。</p>
<p>    参数必须采用 <code>&lt;重映射的库路径&gt;:&lt;库名称&gt;:&lt;地址&gt;</code> 格式，例如 <code>src/Contract.sol:Library:0x...</code>。</p>
<p>    也可以在配置文件中设置为 <code>libraries = ["&lt;路径&gt;:&lt;库名称&gt;:&lt;地址&gt;"]</code>。</p>
<pre><code class="language-markdown">#### 编译器选项

`--optimize`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;激活 Solidity 优化器。

`--optimizer-runs` *runs*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;优化器运行的次数。

`--via-ir`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;使用 Yul 中间表示编译管道。

`--revert-strings`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如何处理 revert 和 require 原因字符串。

`--use` *solc_version*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;指定 solc 版本或本地 solc 的路径进行构建。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;有效值格式为 `x.y.z`、`solc:x.y.z` 或 `path/to/solc`。

`--offline`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;不访问网络。缺失的 solc 版本不会被安装。

`--no-auto-detect`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;不自动检测 solc。

`--ignored-error-codes` *error_codes*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;通过错误代码忽略 solc 警告。参数是以逗号分隔的错误代码列表。

`--extra-output` *selector*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在合约的构件中包含的额外输出。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;示例键：`abi`、`storageLayout`、`evm.assembly`、`ewasm`、`ir`、`ir-optimized`、`metadata`。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;完整描述请参见 [Solidity 文档][output-desc]。

`--extra-output-files` *selector*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;写入单独文件的额外输出。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;示例键：`abi`、`storageLayout`、`evm.assembly`、`ewasm`、`ir`、`ir-optimized`、`metadata`。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;完整描述请参见 [Solidity 文档][output-desc]。

`--evm-version` *version*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;目标 EVM 版本。

[output-desc]: https://docs.soliditylang.org/en/latest/using-the-compiler.html#compiler-api
</code></pre>
<pre><code class="language-markdown">#### 项目选项

`--build-info`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;生成构建信息文件。

`--build-info-path` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;输出路径到构建信息文件将被写入的目录。

`--root` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;项目的根路径。默认情况下，这是当前 git 仓库的根目录，或者当前工作目录。

`-C` *路径*  
`--contracts` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;合约源目录。  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `DAPP_SRC`

`--lib-paths` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;库文件夹的路径。

`-R` *重映射*  
`--remappings` *重映射*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;项目的重映射。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;参数是以逗号分隔的重映射列表，格式为 `&lt;源&gt;=&lt;目标&gt;`。

`--cache-path` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;编译器缓存的路径。

`--config-path` *文件*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;配置文件的路径。

`--hh`  
`--hardhat`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这是一个便捷标志，等同于传递 `--contracts contracts --lib-paths node-modules`。
</code></pre>
<p><code>-o</code> <em>path</em><br />
<code>--out</code> <em>path</em><br />
    项目的 artifacts 目录。</p>
<p><code>--silent</code><br />
    抑制所有输出。</p>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-13"><a class="header" href="#examples-13">EXAMPLES</a></h3>
<ol>
<li>
<p>执行合约中的 <code>run()</code> 函数：</p>
<pre><code class="language-sh">forge debug src/Contract.sol
</code></pre>
</li>
<li>
<p>在调试器中打开脚本：</p>
<pre><code class="language-sh">forge debug src/Contract.sol --debug
</code></pre>
</li>
<li>
<p>执行合约中的 <code>foo()</code> 函数：</p>
<pre><code class="language-sh">forge debug src/Contract.sol --sig "foo()"
</code></pre>
</li>
<li>
<p>执行带有参数的合约函数：</p>
<pre><code class="language-sh">forge debug src/Contract.sol --sig "foo(string,uint256)" "hello" 100
</code></pre>
</li>
<li>
<p>使用原始调用数据执行合约：</p>
<pre><code class="language-sh">forge debug src/Contract.sol --sig "0x..."
</code></pre>
</li>
</ol>
<h3 id="see-also-13"><a class="header" href="#see-also-13">SEE ALSO</a></h3>
<p><a href="reference/forge/./forge.html">forge</a>, <a href="reference/forge/./forge-test.html">forge test</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="forge-bind-1"><a class="header" href="#forge-bind-1">forge bind</a></h2>
<h3 id="name-15"><a class="header" href="#name-15">NAME</a></h3>
<p>forge-bind - 生成智能合约的 Rust 绑定。</p>
<h3 id="synopsis-15"><a class="header" href="#synopsis-15">SYNOPSIS</a></h3>
<p><code>forge bind</code> [<em>options</em>]</p>
<h3 id="description-15"><a class="header" href="#description-15">DESCRIPTION</a></h3>
<p>使用 <a href="https://github.com/gakonst/ethers-rs" title="" target="_blank">ethers-rs</a> 生成智能合约的 Rust 绑定。</p>
<p>绑定是从项目的构件生成的，默认路径是 <code>./out/</code>。如果你想为不同目录中的构件生成绑定，可以传递 <code>--bindings-path &lt;PATH&gt;</code>。</p>
<p>有三种输出选项：</p>
<ul>
<li>在 crate 中生成绑定（默认）</li>
<li>通过传递 <code>--module</code> 在模块中生成绑定</li>
<li>通过传递 <code>--single-file</code> 在单个文件中生成绑定</li>
</ul>
<p>默认情况下，命令会检查现有绑定是否正确并相应退出。你可以通过传递 <code>--overwrite</code> 覆盖现有绑定。</p>
<h3 id="options-15"><a class="header" href="#options-15">OPTIONS</a></h3>
<h4 id="project-options"><a class="header" href="#project-options">Project Options</a></h4>
<p><code>-b</code> <em>path</em><br />
<code>--bindings-path</code> <em>path</em><br />
    项目的根路径。默认情况下，这是当前 git 仓库的根目录或当前工作目录。</p>
<p><code>--crate-name</code> <em>name</em><br />
    要生成的 Rust crate 的名称，如果你正在生成一个 crate（默认）。<br />
    这应该是一个有效的 crates.io crate 名称。</p>
<p>    默认值：foundry-contracts</p>
<p><code>--crate-version</code> <em>semver</em><br />
    要生成的 Rust crate 的版本，如果你正在生成一个 crate（默认）。<br />
    这应该是一个标准的 semver 版本字符串。</p>
<p>    默认值：0.0.1</p>
<p><code>--module</code><br />
    将绑定生成为模块而不是 crate。</p>
<p><code>--single-file</code><br />
    将绑定生成为单个文件。</p>
<p><code>--overwrite</code><br />
    覆盖现有的生成绑定。默认情况下，命令会检查绑定是否正确，然后退出。<br />
    如果传递了 <code>--overwrite</code>，则会删除并覆盖绑定。</p>
<p><code>--root</code> <em>path</em><br />
    项目的根路径。默认情况下，这是当前 git 仓库的根目录或当前工作目录。</p>
<p><code>--skip-cargo-toml</code><br />
    跳过 Cargo.toml 一致性检查。<br />
    这允许你在不放弃一致性检查的情况下管理 <a href="https://github.com/gakonst/ethers-rs" title="" target="_blank">ethers</a> 版本。<br />
    例如，如果你使用 ethers 的额外功能，如 <code>ws</code>、<code>ipc</code> 或 <code>rustls</code>，并且出现 <code>ethers-providers</code> 版本不匹配的情况。</p>
<p><code>--skip-build</code><br />
    在生成绑定之前跳过运行 forge build。<br />
    这允许你跳过默认的 <code>forge build</code> 步骤，而是使用已经存在的构件生成绑定。</p>
<p><code>--select-all</code><br />
    默认情况下，所有以 <code>Test</code> 或 <code>Script</code> 结尾的合约都会被排除。这将显式地为所有合约生成绑定。与 <code>--select</code> 和 <code>--skip</code> 冲突。</p>
<p><code>--select</code> <em>regex+</em><br />
    仅为名称匹配指定过滤器的合约生成绑定。与 <code>--skip</code> 冲突。</p>
<p><code>--skip</code> <em>regex+</em><br />
    仅为名称不匹配指定过滤器的合约生成绑定。与 <code>--select</code> 冲突。</p>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h4 id="缓存选项-6"><a class="header" href="#缓存选项-6">缓存选项</a></h4>
<p><code>--force</code><br />
    清除缓存和 artifacts 文件夹并重新编译。</p>
<h4 id="链接器选项-6"><a class="header" href="#链接器选项-6">链接器选项</a></h4>
<p><code>--libraries</code> <em>libraries</em><br />
    设置预链接的库。</p>
<p>    参数必须采用 <code>&lt;重映射的库路径&gt;:&lt;库名称&gt;:&lt;地址&gt;</code> 格式，例如 <code>src/Contract.sol:Library:0x...</code>。</p>
<p>    也可以在配置文件中设置为 <code>libraries = ["&lt;路径&gt;:&lt;库名称&gt;:&lt;地址&gt;"]</code>。</p>
<pre><code class="language-markdown">#### 编译器选项

`--optimize`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;激活 Solidity 优化器。

`--optimizer-runs` *runs*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;优化器运行的次数。

`--via-ir`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;使用 Yul 中间表示编译管道。

`--revert-strings`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如何处理 revert 和 require 原因字符串。

`--use` *solc_version*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;指定 solc 版本或本地 solc 的路径进行构建。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;有效值格式为 `x.y.z`、`solc:x.y.z` 或 `path/to/solc`。

`--offline`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;不访问网络。缺失的 solc 版本不会被安装。

`--no-auto-detect`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;不自动检测 solc。

`--ignored-error-codes` *error_codes*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;通过错误代码忽略 solc 警告。参数是以逗号分隔的错误代码列表。

`--extra-output` *selector*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在合约的构件中包含的额外输出。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;示例键：`abi`、`storageLayout`、`evm.assembly`、`ewasm`、`ir`、`ir-optimized`、`metadata`。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;完整描述请参见 [Solidity 文档][output-desc]。

`--extra-output-files` *selector*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;写入单独文件的额外输出。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;示例键：`abi`、`storageLayout`、`evm.assembly`、`ewasm`、`ir`、`ir-optimized`、`metadata`。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;完整描述请参见 [Solidity 文档][output-desc]。

`--evm-version` *version*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;目标 EVM 版本。

[output-desc]: https://docs.soliditylang.org/en/latest/using-the-compiler.html#compiler-api
</code></pre>
<pre><code class="language-markdown">#### 项目选项

`--build-info`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;生成构建信息文件。

`--build-info-path` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;输出路径到构建信息文件将被写入的目录。

`--root` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;项目的根路径。默认情况下，这是当前 git 仓库的根目录，或者当前工作目录。

`-C` *路径*  
`--contracts` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;合约源目录。  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `DAPP_SRC`

`--lib-paths` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;库文件夹的路径。

`-R` *重映射*  
`--remappings` *重映射*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;项目的重映射。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;参数是以逗号分隔的重映射列表，格式为 `&lt;源&gt;=&lt;目标&gt;`。

`--cache-path` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;编译器缓存的路径。

`--config-path` *文件*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;配置文件的路径。

`--hh`  
`--hardhat`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这是一个便捷标志，等同于传递 `--contracts contracts --lib-paths node-modules`。
</code></pre>
<p><code>-o</code> <em>path</em><br />
<code>--out</code> <em>path</em><br />
    项目的 artifacts 目录。</p>
<p><code>--silent</code><br />
    抑制所有输出。</p>
<h3 id="see-also-14"><a class="header" href="#see-also-14">SEE ALSO</a></h3>
<p><a href="reference/forge/./forge.html">forge</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="forge-cache-1"><a class="header" href="#forge-cache-1"><code>forge cache</code></a></h2>
<h3 id="名称-8"><a class="header" href="#名称-8">名称</a></h3>
<p>forge-cache - 管理 Foundry 缓存。</p>
<h3 id="概要-8"><a class="header" href="#概要-8">概要</a></h3>
<p><code>forge cache</code> [<em>选项</em>] <em>命令</em> [<em>参数</em>]<br />
<code>forge cache</code> [<em>选项</em>] <code>--version</code><br />
<code>forge cache</code> [<em>选项</em>] <code>--help</code></p>
<h3 id="描述-8"><a class="header" href="#描述-8">描述</a></h3>
<p>这个程序是一组管理 Foundry 缓存的工具。</p>
<h3 id="命令"><a class="header" href="#命令">命令</a></h3>
<p><a href="reference/forge/./forge-cache-clean.html">forge cache clean</a><br />
    清除 <code>~/.foundry</code> 中的缓存数据。</p>
<p><a href="reference/forge/./forge-cache-ls.html">forge cache ls</a><br />
    显示 <code>~/.foundry</code> 中的缓存数据。</p>
<h3 id="选项-7"><a class="header" href="#选项-7">选项</a></h3>
<h4 id="特殊选项-1"><a class="header" href="#特殊选项-1">特殊选项</a></h4>
<p><code>-V</code><br />
<code>--version</code><br />
    打印版本信息并退出。</p>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="forge-cache-clean"><a class="header" href="#forge-cache-clean"><code>forge cache clean</code></a></h2>
<h3 id="名称-9"><a class="header" href="#名称-9">名称</a></h3>
<p>forge-cache-clean - 清除 <code>~/.foundry</code> 中的缓存数据。</p>
<h3 id="概要-9"><a class="header" href="#概要-9">概要</a></h3>
<p><code>forge cache clean</code> [<em>选项</em>] [<em>–</em>] [<em>链..</em>]</p>
<h3 id="描述-9"><a class="header" href="#描述-9">描述</a></h3>
<p>删除 <code>~/.foundry/cache</code> 文件夹中的文件，该文件夹用于缓存 Etherscan 验证状态和区块数据。</p>
<h3 id="选项-8"><a class="header" href="#选项-8">选项</a></h3>
<p><code>-b</code><br />
<code>--blocks</code><br />
    一个或多个区块号，用逗号分隔，无空格</p>
<p><code>--etherscan</code>
    一个布尔标志，指定仅删除缓存中的区块浏览器部分</p>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="示例-8"><a class="header" href="#示例-8">示例</a></h3>
<ol>
<li>
<p>删除整个缓存（也是 <code>forge cache clean</code> 的别名）</p>
<pre><code class="language-sh">forge cache clean all
</code></pre>
</li>
<li>
<p>删除整个区块浏览器缓存</p>
<pre><code class="language-sh">forge cache clean all --etherscan
</code></pre>
</li>
<li>
<p>删除特定链的缓存数据，按名称</p>
<pre><code class="language-sh">forge cache clean rinkeby
</code></pre>
</li>
<li>
<p>删除特定链上特定区块号的缓存数据。如果 <code>chain</code> 是 <code>all</code>，则不适用</p>
<pre><code class="language-sh">forge cache clean rinkeby -b 150000
</code></pre>
</li>
<li>
<p>删除特定链的区块浏览器缓存数据。如果指定了 <code>--blocks</code>，则不适用</p>
<pre><code class="language-sh">forge cache clean rinkeby --etherscan
</code></pre>
</li>
<li>
<p>指定多条链</p>
<pre><code class="language-sh">forge cache clean rinkeby mainnet
</code></pre>
</li>
<li>
<p>指定多个区块</p>
<pre><code class="language-sh">forge cache clean rinkeby --blocks 530000,9000000,9200000
</code></pre>
</li>
</ol>
<h3 id="另见-1"><a class="header" href="#另见-1">另见</a></h3>
<p><a href="reference/forge/./forge.html">forge</a>, <a href="reference/forge/./forge-cache.html">forge cache</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="forge-cache-ls"><a class="header" href="#forge-cache-ls"><code>forge cache ls</code></a></h2>
<h3 id="name-16"><a class="header" href="#name-16">NAME</a></h3>
<p>forge-cache-ls - 显示从 <code>~/.foundry</code> 缓存的数据。</p>
<h3 id="synopsis-16"><a class="header" href="#synopsis-16">SYNOPSIS</a></h3>
<p><code>forge cache ls</code> [<em>chains..</em>]</p>
<h3 id="description-16"><a class="header" href="#description-16">DESCRIPTION</a></h3>
<p>列出当前 <code>~/.foundry/cache</code> 文件夹中的内容。</p>
<h3 id="options-16"><a class="header" href="#options-16">OPTIONS</a></h3>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-14"><a class="header" href="#examples-14">EXAMPLES</a></h3>
<ol>
<li>
<p>显示整个缓存（也是 <code>forge cache ls</code> 的别名）</p>
<pre><code class="language-sh">forge cache ls all
</code></pre>
</li>
<li>
<p>显示特定链的缓存数据，通过名称</p>
<pre><code class="language-sh">forge cache ls rinkeby
</code></pre>
</li>
<li>
<p>指定多个链</p>
<pre><code class="language-sh">forge cache ls rinkeby mainnet
</code></pre>
</li>
</ol>
<h3 id="see-also-15"><a class="header" href="#see-also-15">SEE ALSO</a></h3>
<p><a href="reference/forge/./forge.html">forge</a>, <a href="reference/forge/./forge-cache.html">forge cache</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="forge-script"><a class="header" href="#forge-script">forge script</a></h2>
<h3 id="名称-10"><a class="header" href="#名称-10">名称</a></h3>
<p>forge-script - 将智能合约作为脚本运行，构建可以发送到链上的交易。</p>
<h3 id="概要-10"><a class="header" href="#概要-10">概要</a></h3>
<p><code>forge script</code> [<em>选项</em>] <em>路径</em> [<em>参数…</em>]</p>
<h3 id="描述-10"><a class="header" href="#描述-10">描述</a></h3>
<p>将智能合约作为脚本运行，构建可以发送到链上的交易。</p>
<p>脚本可以用于在实时合约上应用状态转换，或者使用 Solidity 部署和初始化一组复杂的智能合约。</p>
<h3 id="选项-9"><a class="header" href="#选项-9">选项</a></h3>
<p><code>--broadcast</code><br />
    广播交易。</p>
<p><code>--debug</code><br />
    在 <a href="reference/forge/../../forge/debugger.html">调试器</a> 中打开脚本。优先于广播。</p>
<p><code>-g</code><br />
<code>--gas-estimate-multiplier</code> <em>乘数</em><br />
    按相对百分比乘以所有 gas 估计值。（例如，设置为 200 以加倍它们）
    默认值：130</p>
<p><code>--json</code><br />
    以 JSON 格式输出结果。<br />
    注意：输出正在开发中，容易发生变化。</p>
<p><code>--legacy</code><br />
    使用传统交易而不是 EIP1559 交易。对于没有 EIP1559 的常见网络会自动启用。</p>
<p><code>--resume</code><br />
    恢复提交之前失败或超时的交易。</p>
<p><code>-s</code><br />
<code>--sig</code> <em>签名</em><br />
    你想要在合约中调用的函数的签名，或原始 calldata。<br />
    默认值：<code>run()</code></p>
<p><code>--skip-simulation</code><br />
    跳过链上模拟。</p>
<p><code>--skip</code><br />
    跳过非必要合约目录的编译，如 test 或 script（用法 <code>--skip test</code>）。</p>
<p><code>--non-interactive</code><br />
    移除如果合约接近 <a href="https://eips.ethereum.org/EIPS/eip-170" title="" target="_blank">EIP-170</a> 大小限制时出现的交互提示。</p>
<p><code>--slow</code><br />
    确保交易在之前的交易被确认并成功后才发送。</p>
<p><code>--target-contract</code> <em>合约名称</em><br />
    你想要运行的合约的名称。</p>
<p><code>--priority-gas-price</code><br />
    设置 EIP1559 交易的优先 gas 价格。在 gas 价格波动时，用于确保交易被包含。</p>
<p><code>--with-gas-price</code> <em>价格</em><br />
    设置 <strong>广播</strong> 传统交易的 gas 价格，或广播 EIP1559 交易的最大费用。<br />
    注意：要在脚本执行环境中设置 gas 价格，请使用 <code>--gas-price</code> 代替（见下文）。</p>
<pre><code class="language-markdown">#### Etherscan 选项

`--chain` *chain_name*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Etherscan 链。

`--etherscan-api-key` *key*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Etherscan API 密钥，或 [Etherscan 配置表](../config/etherscan.md#etherscan) 中的密钥。  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `ETHERSCAN_API_KEY`
</code></pre>
<h4 id="验证选项"><a class="header" href="#验证选项">验证选项</a></h4>
<p><code>--verify</code><br />
    如果找到匹配的广播日志，尝试验证收据中找到的每个合约。</p>
<pre><code class="language-markdown">`--verifier` *name*   
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;验证提供者。可用选项：`etherscan`、`sourcify` 和 `blockscout`。默认：`etherscan`。注意：确保在 Blockscout 主页浏览器 URL 的末尾添加 "/api?"。

`--verifier-url` *url*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;可选的验证器 URL，用于提交验证请求。  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量：`VERIFIER_URL`
</code></pre>
<pre><code class="language-markdown">`--delay` *delay*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;可选的超时时间，以秒为单位，在每次尝试之间应用。默认为 3。

`--retries` *retries*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;重试的尝试次数。默认为 15。
</code></pre>
<h4 id="缓存选项-7"><a class="header" href="#缓存选项-7">缓存选项</a></h4>
<p><code>--force</code><br />
    清除缓存和 artifacts 文件夹并重新编译。</p>
<h4 id="链接器选项-7"><a class="header" href="#链接器选项-7">链接器选项</a></h4>
<p><code>--libraries</code> <em>libraries</em><br />
    设置预链接的库。</p>
<p>    参数必须采用 <code>&lt;重映射的库路径&gt;:&lt;库名称&gt;:&lt;地址&gt;</code> 格式，例如 <code>src/Contract.sol:Library:0x...</code>。</p>
<p>    也可以在配置文件中设置为 <code>libraries = ["&lt;路径&gt;:&lt;库名称&gt;:&lt;地址&gt;"]</code>。</p>
<pre><code class="language-markdown">#### 编译器选项

`--optimize`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;激活 Solidity 优化器。

`--optimizer-runs` *runs*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;优化器运行的次数。

`--via-ir`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;使用 Yul 中间表示编译管道。

`--revert-strings`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如何处理 revert 和 require 原因字符串。

`--use` *solc_version*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;指定 solc 版本或本地 solc 的路径进行构建。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;有效值格式为 `x.y.z`、`solc:x.y.z` 或 `path/to/solc`。

`--offline`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;不访问网络。缺失的 solc 版本不会被安装。

`--no-auto-detect`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;不自动检测 solc。

`--ignored-error-codes` *error_codes*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;通过错误代码忽略 solc 警告。参数是以逗号分隔的错误代码列表。

`--extra-output` *selector*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在合约的构件中包含的额外输出。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;示例键：`abi`、`storageLayout`、`evm.assembly`、`ewasm`、`ir`、`ir-optimized`、`metadata`。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;完整描述请参见 [Solidity 文档][output-desc]。

`--extra-output-files` *selector*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;写入单独文件的额外输出。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;示例键：`abi`、`storageLayout`、`evm.assembly`、`ewasm`、`ir`、`ir-optimized`、`metadata`。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;完整描述请参见 [Solidity 文档][output-desc]。

`--evm-version` *version*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;目标 EVM 版本。

[output-desc]: https://docs.soliditylang.org/en/latest/using-the-compiler.html#compiler-api
</code></pre>
<pre><code class="language-markdown">#### 项目选项

`--build-info`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;生成构建信息文件。

`--build-info-path` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;输出路径到构建信息文件将被写入的目录。

`--root` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;项目的根路径。默认情况下，这是当前 git 仓库的根目录，或者当前工作目录。

`-C` *路径*  
`--contracts` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;合约源目录。  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `DAPP_SRC`

`--lib-paths` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;库文件夹的路径。

`-R` *重映射*  
`--remappings` *重映射*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;项目的重映射。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;参数是以逗号分隔的重映射列表，格式为 `&lt;源&gt;=&lt;目标&gt;`。

`--cache-path` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;编译器缓存的路径。

`--config-path` *文件*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;配置文件的路径。

`--hh`  
`--hardhat`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这是一个便捷标志，等同于传递 `--contracts contracts --lib-paths node-modules`。
</code></pre>
<p><code>-o</code> <em>path</em><br />
<code>--out</code> <em>path</em><br />
    项目的 artifacts 目录。</p>
<p><code>--silent</code><br />
    抑制所有输出。</p>
<h4 id="构建选项-1"><a class="header" href="#构建选项-1">构建选项</a></h4>
<p><code>--names</code><br />
    打印编译的合约名称。</p>
<p><code>--sizes</code><br />
    打印编译的非测试合约大小，如果任何合约超过大小限制，则退出并返回代码 1。</p>
<pre><code class="language-metadata">id: watch-options
</code></pre>
<h4 id="监视选项-2"><a class="header" href="#监视选项-2">监视选项</a></h4>
<p><code>-w</code> [<em>路径...</em>]<br />
<code>--watch</code> [<em>路径...</em>]<br />
    监视特定的文件或文件夹。</p>
<p>    默认情况下，监视项目的源目录。</p>
<p><code>-d</code> <em>延迟</em><br />
<code>--delay</code> <em>延迟</em><br />
    文件更新防抖延迟。</p>
<p>    在延迟期间，传入的更改事件会被累积，只有在延迟结束后才会采取行动。<br />
    注意，这并不意味着命令会启动：如果给出了 <code>--no-restart</code>，并且命令已经在运行，行动的结果将是什么都不做。</p>
<p>    默认值为 50 毫秒。默认情况下解析为十进制秒，但使用带有 <code>ms</code> 后缀的整数可能更方便。</p>
<p>    在使用 <code>--poll</code> 模式时，你可能需要更大的持续时间，以避免过度占用磁盘 I/O。</p>
<p><code>--no-restart</code><br />
    在命令运行时不重启。</p>
<p><code>--run-all</code><br />
    当发生更改时，显式地重新运行所有文件的命令。</p>
<pre><code class="language-markdown"># 多钱包选项

Foundry 支持多种钱包选项，包括本地密钥库、硬件钱包和远程签名者。

## 本地密钥库

Foundry 支持使用本地密钥库文件进行签名。你可以通过以下方式配置密钥库文件：

```toml
[profile.default.wallet]
keystore = "path/to/keystore"
password = "path/to/password"
</code></pre>
<h2 id="硬件钱包-1"><a class="header" href="#硬件钱包-1">硬件钱包</a></h2>
<p>Foundry 支持使用硬件钱包进行签名。你可以通过以下方式配置硬件钱包：</p>
<pre><code class="language-toml">[profile.default.wallet]
hardware = "ledger"
</code></pre>
<h2 id="远程签名者-1"><a class="header" href="#远程签名者-1">远程签名者</a></h2>
<p>Foundry 支持使用远程签名者进行签名。你可以通过以下方式配置远程签名者：</p>
<pre><code class="language-toml">[profile.default.wallet]
remote = "http://localhost:8545"
</code></pre>
<pre><code>
```json
{
  "title": "EVM 选项",
  "options": [
    {
      "name": "-f",
      "alias": ["--rpc-url", "--fork-url"],
      "description": "从远程端点获取状态，而不是从空状态开始。",
      "note": "如果要从特定区块号获取状态，请参见 `--fork-block-number`。"
    },
    {
      "name": "--fork-block-number",
      "description": "从远程端点获取特定区块号的状态。请参见 `--fork-url`。"
    },
    {
      "name": "--fork-retry-backoff",
      "description": "遇到错误时的初始重试退避时间。"
    },
    {
      "name": "--no-storage-caching",
      "description": "显式禁用 RPC 缓存的使用。",
      "note": "所有存储槽完全从端点读取。请参见 `--fork-url`。"
    },
    {
      "name": "-v",
      "alias": "--verbosity",
      "description": "EVM 的详细程度。",
      "note": "多次传递以增加详细程度（例如 `-v`, `-vv`, `-vvv`）。",
      "levels": [
        {
          "level": 2,
          "description": "打印所有测试的日志"
        },
        {
          "level": 3,
          "description": "打印失败测试的执行 traces"
        },
        {
          "level": 4,
          "description": "打印所有测试的执行 traces，以及失败测试的设置 traces"
        },
        {
          "level": 5,
          "description": "打印所有测试的执行和设置 traces"
        }
      ]
    },
    {
      "name": "--sender",
      "description": "将执行测试的地址"
    },
    {
      "name": "--initial-balance",
      "description": "已部署合约的初始余额"
    },
    {
      "name": "--ffi",
      "description": "启用 [FFI cheatcode][ffi-cheatcode]"
    }
  ],
  "links": {
    "ffi-cheatcode": "../../cheatcodes/ffi.md"
  }
}
</code></pre>
<pre><code class="language-markdown">#### 执行器选项

`--base-fee &lt;FEE&gt;`  
`--block-base-fee-per-gas &lt;FEE&gt;`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;区块中的基础费用（以 wei 为单位）。

`--block-coinbase` *address*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;区块的 coinbase 地址。

`--block-difficulty` *difficulty*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;区块的难度。

`--block-gas-limit` *gas_limit*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;区块的 gas 限制。

`--block-number` *block*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;区块编号。

`--block-timestamp` *timestamp*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;区块的时间戳（以秒为单位）。

`--chain-id` *chain_id*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;链 ID。

`--gas-limit` *gas_limit*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;区块的 gas 限制。

`--gas-price` *gas_price*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;gas 价格（以 wei 为单位）。

`--tx-origin` *address*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;交易的发起方地址。
</code></pre>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="示例-9"><a class="header" href="#示例-9">示例</a></h3>
<ol>
<li>
<p>将 <code>BroadcastTest</code> 作为脚本运行，在链上广播生成的交易</p>
<pre><code class="language-sh">forge script ./test/Broadcast.t.sol --tc BroadcastTest --sig "deploy()" \
    -vvv --fork-url $SEPOLIA_RPC_URL
</code></pre>
</li>
<li>
<p>在 Polygon 上部署合约（<a href="reference/forge/../../tutorials/solidity-scripting.html">参见脚本教程中的示例脚本</a>）。<em>每个网络的验证器 URL 不同。</em></p>
<pre><code class="language-sh">forge script script/NFT.s.sol:MyScript --chain-id 137 --rpc-url $RPC_URL \
    --etherscan-api-key $POLYGONSCAN_API_KEY --verifier-url https://api.polygonscan.com/api \
    --broadcast --verify -vvvv
</code></pre>
</li>
<li>
<p>恢复失败的脚本。以上述为例，移除 <code>--broadcast</code> 添加 <code>--resume</code></p>
<pre><code class="language-sh">forge script script/NFT.s.sol:MyScript --chain-id 137 --rpc-url $RPC_URL \
    --etherscan-api-key $POLYGONSCAN_API_KEY --verifier-url https://api.polygonscan.com/api \
    --verify -vvvv --resume
</code></pre>
</li>
<li>
<p>验证刚刚使用脚本部署的合约</p>
<pre><code class="language-sh">forge script script/NFT.s.sol --rpc-url $RPC_URL --verify --resume
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h2 id="forge-upload-selectors-1"><a class="header" href="#forge-upload-selectors-1">forge upload-selectors</a></h2>
<h3 id="name-17"><a class="header" href="#name-17">NAME</a></h3>
<p>forge-upload-selectors - 将给定合约的 ABI 上传到 https://sig.eth.samczsun.com 函数选择器数据库。</p>
<h3 id="synopsis-17"><a class="header" href="#synopsis-17">SYNOPSIS</a></h3>
<p><code>forge upload-selectors</code> [<em>options</em>] <em>contract</em></p>
<h3 id="description-17"><a class="header" href="#description-17">DESCRIPTION</a></h3>
<p>将给定合约的 ABI 上传到 https://sig.eth.samczsun.com 函数选择器数据库。</p>
<h3 id="options-17"><a class="header" href="#options-17">OPTIONS</a></h3>
<pre><code class="language-markdown">#### 项目选项

`--build-info`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;生成构建信息文件。

`--build-info-path` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;输出路径到构建信息文件将被写入的目录。

`--root` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;项目的根路径。默认情况下，这是当前 git 仓库的根目录，或者当前工作目录。

`-C` *路径*  
`--contracts` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;合约源目录。  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `DAPP_SRC`

`--lib-paths` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;库文件夹的路径。

`-R` *重映射*  
`--remappings` *重映射*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;项目的重映射。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;参数是以逗号分隔的重映射列表，格式为 `&lt;源&gt;=&lt;目标&gt;`。

`--cache-path` *路径*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;编译器缓存的路径。

`--config-path` *文件*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;配置文件的路径。

`--hh`  
`--hardhat`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这是一个便捷标志，等同于传递 `--contracts contracts --lib-paths node-modules`。
</code></pre>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-15"><a class="header" href="#examples-15">EXAMPLES</a></h3>
<ol>
<li>上传 ABI 到选择器数据库
<pre><code class="language-sh">forge upload-selectors LinearVestingVault
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h2 id="forge-doc"><a class="header" href="#forge-doc">forge doc</a></h2>
<h3 id="名称-11"><a class="header" href="#名称-11">名称</a></h3>
<p>forge-doc - 生成 Solidity 源文件的文档。</p>
<h3 id="概要-11"><a class="header" href="#概要-11">概要</a></h3>
<p><code>forge doc</code> [<em>选项</em>]</p>
<h3 id="描述-11"><a class="header" href="#描述-11">描述</a></h3>
<p>从 Solidity 源文件生成并构建一个 mdbook。</p>
<h3 id="选项-10"><a class="header" href="#选项-10">选项</a></h3>
<p><code>--root</code> <em>路径</em><br />
    项目的根路径。默认情况下，这是当前 git 仓库的根目录，或者当前工作目录。</p>
<p><code>--out</code> <em>路径</em>
    生成 mdbook 的输出路径。默认情况下，它是项目根目录下的 <code>docs/</code>。</p>
<p><code>--build</code>
    从生成的文件构建 <code>mdbook</code>。</p>
<p><code>--serve</code>
    在本地提供文档服务。</p>
<p><code>--hostname</code> <em>主机名</em>
    用于提供文档的主机名。需要 <code>--serve</code>。</p>
<p><code>--port</code> <em>端口</em>
    用于提供文档的端口。需要 <code>--serve</code>。</p>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="示例-10"><a class="header" href="#示例-10">示例</a></h3>
<ol>
<li>
<p>生成文档。</p>
<pre><code class="language-sh">forge doc
</code></pre>
</li>
<li>
<p>生成并构建文档，指定输出目录。</p>
<pre><code class="language-sh">forge doc --build --out ./documentation
</code></pre>
</li>
<li>
<p>生成并在本地端口 4000 上提供文档服务。</p>
<pre><code class="language-sh">forge doc --serve --port 4000
</code></pre>
</li>
</ol>
<h3 id="另请参阅-5"><a class="header" href="#另请参阅-5">另请参阅</a></h3>
<p><a href="reference/forge/../config/doc-generator.html">文档配置</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-命令"><a class="header" href="#cast-命令">cast 命令</a></h2>
<ul>
<li><a href="reference/cast/./general-commands.html">通用命令</a></li>
<li><a href="reference/cast/./chain-commands.html">链命令</a></li>
<li><a href="reference/cast/./transaction-commands.html">交易命令</a></li>
<li><a href="reference/cast/./block-commands.html">区块命令</a></li>
<li><a href="reference/cast/./account-commands.html">账户命令</a></li>
<li><a href="reference/cast/./ens-commands.html">ENS 命令</a></li>
<li><a href="reference/cast/./etherscan-commands.html">Etherscan 命令</a></li>
<li><a href="reference/cast/./abi-commands.html">ABI 命令</a></li>
<li><a href="reference/cast/./conversion-commands.html">转换命令</a></li>
<li><a href="reference/cast/./utility-commands.html">实用工具命令</a></li>
<li><a href="reference/cast/./wallet-commands.html">钱包命令</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="通用命令-2"><a class="header" href="#通用命令-2">通用命令</a></h2>
<ul>
<li><a href="reference/cast/./cast.html">cast</a></li>
<li><a href="reference/cast/./cast-help.html">cast help</a></li>
<li><a href="reference/cast/./cast-completions.html">cast completions</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast"><a class="header" href="#cast">cast</a></h2>
<h3 id="name-18"><a class="header" href="#name-18">NAME</a></h3>
<p>cast - 从命令行舒适地执行以太坊RPC调用。</p>
<h3 id="synopsis-18"><a class="header" href="#synopsis-18">SYNOPSIS</a></h3>
<p><code>cast</code> [<em>options</em>] <em>command</em> [<em>args</em>]
<code>cast</code> [<em>options</em>] <code>--version</code>
<code>cast</code> [<em>options</em>] <code>--help</code></p>
<h3 id="description-18"><a class="header" href="#description-18">DESCRIPTION</a></h3>
<p>这个程序是一组工具，用于与以太坊交互并执行转换。</p>
<h3 id="commands-1"><a class="header" href="#commands-1">COMMANDS</a></h3>
<h4 id="general-commands"><a class="header" href="#general-commands">General Commands</a></h4>
<p><a href="reference/cast/./cast-help.html">cast help</a>
    显示关于Cast的帮助信息。</p>
<p><a href="reference/cast/./cast-completions.html">cast completions</a>
    为Cast生成Shell自动补全。</p>
<h4 id="chain-commands"><a class="header" href="#chain-commands">Chain Commands</a></h4>
<p><a href="reference/cast/./cast-chain-id.html">cast chain-id</a>
    获取以太坊链ID。</p>
<p><a href="reference/cast/./cast-chain.html">cast chain</a>
    获取当前链的符号名称。</p>
<p><a href="reference/cast/./cast-client.html">cast client</a>
    获取当前客户端版本。</p>
<h4 id="transaction-commands"><a class="header" href="#transaction-commands">Transaction Commands</a></h4>
<p><a href="reference/cast/./cast-publish.html">cast publish</a>
    将原始交易发布到网络。</p>
<p><a href="reference/cast/./cast-receipt.html">cast receipt</a>
    获取交易的收据。</p>
<p><a href="reference/cast/./cast-send.html">cast send</a>
    签名并发布交易。</p>
<p><a href="reference/cast/./cast-call.html">cast call</a>
    在不发布交易的情况下对账户进行调用。</p>
<p><a href="reference/cast/./cast-rpc.html">cast rpc</a>
    执行原始JSON-RPC请求 [aliases: rp]</p>
<p><a href="reference/cast/./cast-tx.html">cast tx</a>
    获取交易信息。</p>
<p><a href="reference/cast/./cast-run.html">cast run</a>
    在本地环境中运行已发布的交易并打印追踪信息。</p>
<p><a href="reference/cast/./cast-estimate.html">cast estimate</a>
    估算交易的 gas 成本。</p>
<p><a href="reference/cast/./cast-access-list.html">cast access-list</a>
    为交易创建访问列表。</p>
<p><a href="reference/cast/./cast-logs.html">cast logs</a>
    通过签名或主题获取日志。</p>
<h4 id="block-commands"><a class="header" href="#block-commands">Block Commands</a></h4>
<p><a href="reference/cast/./cast-find-block.html">cast find-block</a>
    获取最接近提供时间戳的区块号。</p>
<p><a href="reference/cast/./cast-gas-price.html">cast gas-price</a>
    获取当前 gas 价格。</p>
<p><a href="reference/cast/./cast-block-number.html">cast block-number</a>
    获取最新区块号。</p>
<p><a href="reference/cast/./cast-basefee.html">cast basefee</a>
    获取区块的 basefee。</p>
<p><a href="reference/cast/./cast-block.html">cast block</a>
    获取区块信息。</p>
<p><a href="reference/cast/./cast-age.html">cast age</a>
    获取区块的时间戳。</p>
<h4 id="account-commands"><a class="header" href="#account-commands">Account Commands</a></h4>
<p><a href="reference/cast/./cast-balance.html">cast balance</a>
    获取账户的余额（以 wei 为单位）。</p>
<p><a href="reference/cast/./cast-storage.html">cast storage</a>
    获取合约存储槽的原始值。</p>
<p><a href="reference/cast/./cast-proof.html">cast proof</a>
    为给定的存储槽生成存储证明。</p>
<p><a href="reference/cast/./cast-nonce.html">cast nonce</a>
    获取账户的 nonce。</p>
<p><a href="reference/cast/./cast-code.html">cast code</a>
    获取合约的字节码。</p>
<p><a href="reference/cast/./cast-codesize.html">cast codesize</a>
    获取合约的运行时字节码大小。</p>
<h4 id="ens-commands"><a class="header" href="#ens-commands">ENS Commands</a></h4>
<p><a href="reference/cast/./cast-lookup-address.html">cast lookup-address</a>
    执行 ENS 反向查找。</p>
<p><a href="reference/cast/./cast-resolve-name.html">cast resolve-name</a>
    执行 ENS 查找。</p>
<p><a href="reference/cast/./cast-namehash.html">cast namehash</a>
    计算 ENS 名称的 namehash。</p>
<h4 id="etherscan-commands"><a class="header" href="#etherscan-commands">Etherscan Commands</a></h4>
<p><a href="reference/cast/./cast-etherscan-source.html">cast etherscan-source</a>
    从 Etherscan 获取合约的源代码。</p>
<h4 id="abi-commands"><a class="header" href="#abi-commands">ABI Commands</a></h4>
<p><a href="reference/cast/./cast-abi-decode.html">cast abi-decode</a>
    解码 ABI 编码的输入或输出数据。</p>
<p><a href="reference/cast/./cast-abi-encode.html">cast abi-encode</a>
    ABI 编码给定的函数参数，不包括选择器。</p>
<p><a href="reference/cast/./cast-4byte.html">cast 4byte</a>
    从 <a href="https://sig.eth.samczsun.com" target="_blank">https://sig.eth.samczsun.com</a> 获取给定选择器的函数签名。</p>
<p><a href="reference/cast/./cast-4byte-decode.html">cast 4byte-decode</a>
    使用 <a href="https://sig.eth.samczsun.com" target="_blank">https://sig.eth.samczsun.com</a> 解码 ABI 编码的 calldata。</p>
<p><a href="reference/cast/./cast-4byte-event.html">cast 4byte-event</a>
    从 <a href="https://sig.eth.samczsun.com" target="_blank">https://sig.eth.samczsun.com</a> 获取给定 topic 0 的事件签名。</p>
<p><a href="reference/cast/./cast-calldata.html">cast calldata</a>
    ABI 编码带有参数的函数。</p>
<p><a href="reference/cast/./cast-calldata-decode.html">cast calldata-decode</a>
    解码 ABI 编码的输入数据。</p>
<p><a href="reference/cast/./cast-pretty-calldata.html">cast pretty-calldata</a>
    美化打印 calldata。</p>
<p><a href="reference/cast/./cast-selectors.html">cast selectors</a>
    从字节码中提取函数选择器和参数。</p>
<p><a href="reference/cast/./cast-upload-signature.html">cast upload-signature</a>
    将给定的签名上传到 https://sig.eth.samczsun.com。</p>
<h4 id="conversion-commands"><a class="header" href="#conversion-commands">Conversion Commands</a></h4>
<p><a href="reference/cast/./cast-format-bytes32-string.html">cast format-bytes32-string</a>
    将字符串格式化为 bytes32 编码。</p>
<p><a href="reference/cast/./cast-from-bin.html">cast from-bin</a>
    将二进制数据转换为十六进制数据。</p>
<p><a href="reference/cast/./cast-from-fixed-point.html">cast from-fixed-point</a>
    将定点数转换为整数。</p>
<p><a href="reference/cast/./cast-from-utf8.html">cast from-utf8</a>
    将 UTF8 转换为十六进制。</p>
<p><a href="reference/cast/./cast-from-wei.html">cast from-wei</a>
    将 wei 转换为 ETH 金额。</p>
<p><a href="reference/cast/./cast-parse-bytes32-address.html">cast parse-bytes32-address</a>
    从 bytes32 编码解析校验和地址。</p>
<p><a href="reference/cast/./cast-parse-bytes32-string.html">cast parse-bytes32-string</a>
    从 bytes32 编码解析字符串。</p>
<p><a href="reference/cast/./cast-to-ascii.html">cast to-ascii</a>
    将十六进制数据转换为 ASCII 字符串。</p>
<p><a href="reference/cast/./cast-to-base.html">cast to-base</a>
    将一个基数的数转换为另一个基数。</p>
<p><a href="reference/cast/./cast-to-bytes32.html">cast to-bytes32</a>
    将十六进制数据右填充到 32 字节。</p>
<p><a href="reference/cast/./cast-to-dec.html">cast to-dec</a>
    将一个基数的数转换为十进制。</p>
<p><a href="reference/cast/./cast-to-fixed-point.html">cast to-fixed-point</a>
    将整数转换为定点数。</p>
<p><a href="reference/cast/./cast-to-hex.html">cast to-hex</a>
    将一个基数的数转换为另一个基数。</p>
<p><a href="reference/cast/./cast-to-hexdata.html">cast to-hexdata</a>
    将输入规范化为小写、0x 前缀的十六进制。</p>
<p><a href="reference/cast/./cast-to-int256.html">cast to-int256</a>
    将一个数转换为十六进制编码的 int256。</p>
<p><a href="reference/cast/./cast-to-rlp.html">cast to-rlp</a>
    RLP 编码十六进制数据，或十六进制数据的数组。</p>
<p><a href="reference/cast/./cast-to-uint256.html">cast to-uint256</a>
    将一个数转换为十六进制编码的 uint256。</p>
<p><a href="reference/cast/./cast-to-unit.html">cast to-unit</a>
    将 ETH 金额转换为另一个单位（ether、gwei、wei）。</p>
<p><a href="reference/cast/./cast-to-wei.html">cast to-wei</a>
    将 ETH 金额转换为 wei。</p>
<p><a href="reference/cast/./cast-shl.html">cast shl</a>
    执行左移操作。</p>
<p><a href="reference/cast/./cast-shr.html">cast shr</a>
    执行右移操作。</p>
<h4 id="utility-commands"><a class="header" href="#utility-commands">Utility Commands</a></h4>
<p><a href="reference/cast/./cast-address-zero.html">cast address-zero</a>
    打印零地址。</p>
<p><a href="reference/cast/./cast-sig.html">cast sig</a>
    获取函数的 selector。</p>
<p><a href="reference/cast/./cast-sig-event.html">cast sig-event</a>
    从事件字符串生成事件签名。</p>
<p><a href="reference/cast/./cast-keccak.html">cast keccak</a>
    使用 keccak-256 哈希任意数据。</p>
<p><a href="reference/cast/./cast-compute-address.html">cast compute-address</a>
    根据给定的 nonce 和部署者地址计算合约地址。</p>
<p><a href="reference/cast/./cast-create2.html">cast create2</a>
    使用 CREATE2 生成确定性合约地址。</p>
<p><a href="reference/cast/./cast-interface.html">cast interface</a>
    根据给定的 ABI 生成 Solidity 接口。</p>
<p><a href="reference/cast/./cast-index.html">cast index</a>
    计算映射中条目的存储槽。</p>
<p><a href="reference/cast/./cast-concat-hex.html">cast concat-hex</a>
    连接十六进制字符串。</p>
<p><a href="reference/cast/./cast-max-int.html">cast max-int</a>
    获取最大 i256 值。</p>
<p><a href="reference/cast/./cast-min-int.html">cast min-int</a>
    获取最小 i256 值。</p>
<p><a href="reference/cast/./cast-max-uint.html">cast max-uint</a>
    获取最大 u256 值。</p>
<p><a href="reference/cast/./cast-to-check-sum-address.html">cast to-check-sum-address</a>
    将地址转换为校验和格式（EIP-55）。</p>
<h4 id="wallet-commands"><a class="header" href="#wallet-commands">Wallet Commands</a></h4>
<p><a href="reference/cast/./cast-wallet.html">cast wallet</a>
    钱包管理工具。</p>
<p><a href="reference/cast/./cast-wallet-new.html">cast wallet new</a>
    创建一个新的随机密钥对。</p>
<p><a href="reference/cast/./cast-wallet-address.html">cast wallet address</a>
    将私钥转换为地址。</p>
<p><a href="reference/cast/./cast-wallet-sign.html">cast wallet sign</a>
    签名消息。</p>
<p><a href="reference/cast/./cast-wallet-vanity.html">cast wallet vanity</a>
    生成 vanity 地址。</p>
<p><a href="reference/cast/./cast-wallet-verify.html">cast wallet verify</a>
    验证消息的签名。</p>
<h3 id="options-18"><a class="header" href="#options-18">OPTIONS</a></h3>
<h4 id="special-options"><a class="header" href="#special-options">Special Options</a></h4>
<p><code>-V</code>
<code>--version</code>
    打印版本信息并退出。</p>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-16"><a class="header" href="#examples-16">EXAMPLES</a></h3>
<ol>
<li>
<p>调用合约上的函数：</p>
<pre><code class="language-sh">cast call 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2 \
  "balanceOf(address)(uint256)" 0x...
</code></pre>
</li>
<li>
<p>解码原始 calldata：</p>
<pre><code class="language-sh">cast calldata-decode "transfer(address,uint256)" \
  0xa9059cbb000000000000000000000000e78388b4ce79068e89bf8aa7f218ef6b9ab0e9d0000000000000000000000000000000000000000000000000008a8e4b1a3d8000
</code></pre>
</li>
<li>
<p>编码 calldata：</p>
<pre><code class="language-sh">cast calldata "someFunc(address,uint256)" 0x... 1
</code></pre>
</li>
</ol>
<h3 id="bugs-1"><a class="header" href="#bugs-1">BUGS</a></h3>
<p>请参见 <a href="https://github.com/foundry-rs/foundry/issues" target="_blank">https://github.com/foundry-rs/foundry/issues</a> 获取问题列表。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-help"><a class="header" href="#cast-help">cast help</a></h2>
<h3 id="name-19"><a class="header" href="#name-19">NAME</a></h3>
<p>cast-help - 获取 Cast 命令的帮助信息</p>
<h3 id="synopsis-19"><a class="header" href="#synopsis-19">SYNOPSIS</a></h3>
<p><code>cast help</code> [<em>子命令</em>]</p>
<h3 id="description-19"><a class="header" href="#description-19">DESCRIPTION</a></h3>
<p>打印给定命令的帮助信息。</p>
<h3 id="examples-17"><a class="header" href="#examples-17">EXAMPLES</a></h3>
<ol>
<li>
<p>获取某个命令的帮助信息：</p>
<pre><code class="language-sh">cast help call
</code></pre>
</li>
<li>
<p>也可以使用 <code>--help</code> 标志获取帮助信息：</p>
<pre><code class="language-sh">cast call --help
</code></pre>
</li>
</ol>
<h3 id="see-also-16"><a class="header" href="#see-also-16">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-completions"><a class="header" href="#cast-completions">cast completions</a></h2>
<h3 id="name-20"><a class="header" href="#name-20">NAME</a></h3>
<p>cast-completions - 生成 shell 自动补全脚本</p>
<h3 id="synopsis-20"><a class="header" href="#synopsis-20">SYNOPSIS</a></h3>
<p><code>cast completions</code> <em>shell</em></p>
<h3 id="description-20"><a class="header" href="#description-20">DESCRIPTION</a></h3>
<p>为指定的 shell 生成自动补全脚本。</p>
<p>支持的 shell 有：</p>
<ul>
<li>bash</li>
<li>elvish</li>
<li>fish</li>
<li>powershell</li>
<li>zsh</li>
</ul>
<h3 id="options-19"><a class="header" href="#options-19">OPTIONS</a></h3>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-18"><a class="header" href="#examples-18">EXAMPLES</a></h3>
<ol>
<li>为 zsh 生成 shell 自动补全脚本：
<pre><code class="language-sh">cast completions zsh &gt; $HOME/.oh-my-zsh/completions/_cast
</code></pre>
</li>
</ol>
<h3 id="see-also-17"><a class="header" href="#see-also-17">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="链命令"><a class="header" href="#链命令">链命令</a></h2>
<ul>
<li><a href="reference/cast/./cast-chain-id.html">cast chain-id</a></li>
<li><a href="reference/cast/./cast-chain.html">cast chain</a></li>
<li><a href="reference/cast/./cast-client.html">cast client</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-chain-id"><a class="header" href="#cast-chain-id">cast chain-id</a></h2>
<h3 id="name-21"><a class="header" href="#name-21">NAME</a></h3>
<p>cast-chain-id - 获取以太坊链 ID。</p>
<h3 id="synopsis-21"><a class="header" href="#synopsis-21">SYNOPSIS</a></h3>
<p><code>cast chain-id</code> [<em>options</em>]</p>
<h3 id="description-21"><a class="header" href="#description-21">DESCRIPTION</a></h3>
<p>从我们连接的 RPC 端点获取以太坊 <a href="https://chainlist.org/" title="" target="_blank">链 ID</a>。</p>
<h3 id="options-20"><a class="header" href="#options-20">OPTIONS</a></h3>
<h4 id="rpc-选项"><a class="header" href="#rpc-选项">RPC 选项</a></h4>
<pre><code class="language-markdown">`--rpc-url` *url*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;RPC 端点。接受一个 URL 或 [rpc_endpoints] 表中已有的别名，例如 `mainnet`。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `ETH_RPC_URL`
</code></pre>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-19"><a class="header" href="#examples-19">EXAMPLES</a></h3>
<ol>
<li>
<p>在与 <code>$RPC</code> 通信时获取链 ID：</p>
<pre><code class="language-sh">cast chain-id --rpc-url $RPC
</code></pre>
</li>
<li>
<p>当 <code>$ETH_RPC_URL</code> 已设置时获取链 ID：</p>
<pre><code class="language-sh">cast chain-id
</code></pre>
</li>
</ol>
<h3 id="see-also-18"><a class="header" href="#see-also-18">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a>, <a href="reference/cast/./cast-chain.html">cast chain</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-chain"><a class="header" href="#cast-chain">cast chain</a></h2>
<h3 id="名称-12"><a class="header" href="#名称-12">名称</a></h3>
<p>cast-chain - 获取当前链的符号名称。</p>
<h3 id="概要-12"><a class="header" href="#概要-12">概要</a></h3>
<p><code>cast chain</code> [<em>选项</em>]</p>
<h3 id="描述-12"><a class="header" href="#描述-12">描述</a></h3>
<p>从我们连接的 RPC 端点获取符号链名称。</p>
<h3 id="选项-11"><a class="header" href="#选项-11">选项</a></h3>
<h4 id="rpc-选项-1"><a class="header" href="#rpc-选项-1">RPC 选项</a></h4>
<pre><code class="language-markdown">`--rpc-url` *url*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;RPC 端点。接受一个 URL 或 [rpc_endpoints] 表中已有的别名，例如 `mainnet`。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `ETH_RPC_URL`
</code></pre>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="示例-11"><a class="header" href="#示例-11">示例</a></h3>
<ol>
<li>
<p>在与 <code>$RPC</code> 通信时获取链名称：</p>
<pre><code class="language-sh">cast chain --rpc-url $RPC
</code></pre>
</li>
<li>
<p>当 <code>$ETH_RPC_URL</code> 已设置时获取链名称：</p>
<pre><code class="language-sh">cast chain
</code></pre>
</li>
</ol>
<h3 id="另请参阅-6"><a class="header" href="#另请参阅-6">另请参阅</a></h3>
<p><a href="reference/cast/./cast.html">cast</a>, <a href="reference/cast/./cast-chain-id.html">cast chain-id</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-client"><a class="header" href="#cast-client">cast client</a></h2>
<h3 id="name-22"><a class="header" href="#name-22">NAME</a></h3>
<p>cast-client - 获取当前客户端版本。</p>
<h3 id="synopsis-22"><a class="header" href="#synopsis-22">SYNOPSIS</a></h3>
<p><code>cast client</code> [<em>options</em>]</p>
<h3 id="description-22"><a class="header" href="#description-22">DESCRIPTION</a></h3>
<p>获取当前客户端版本。</p>
<h3 id="options-21"><a class="header" href="#options-21">OPTIONS</a></h3>
<h4 id="rpc-选项-2"><a class="header" href="#rpc-选项-2">RPC 选项</a></h4>
<pre><code class="language-markdown">`--rpc-url` *url*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;RPC 端点。接受一个 URL 或 [rpc_endpoints] 表中已有的别名，例如 `mainnet`。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `ETH_RPC_URL`
</code></pre>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-20"><a class="header" href="#examples-20">EXAMPLES</a></h3>
<ol>
<li>获取当前客户端版本：
<pre><code class="language-sh">cast client
</code></pre>
</li>
</ol>
<h3 id="see-also-19"><a class="header" href="#see-also-19">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="交易命令"><a class="header" href="#交易命令">交易命令</a></h2>
<ul>
<li><a href="reference/cast/./cast-publish.html">cast publish</a></li>
<li><a href="reference/cast/./cast-receipt.html">cast receipt</a></li>
<li><a href="reference/cast/./cast-send.html">cast send</a></li>
<li><a href="reference/cast/./cast-mktx.html">cast mktx</a></li>
<li><a href="reference/cast/./cast-call.html">cast call</a></li>
<li><a href="reference/cast/./cast-rpc.html">cast rpc</a></li>
<li><a href="reference/cast/./cast-tx.html">cast tx</a></li>
<li><a href="reference/cast/./cast-run.html">cast run</a></li>
<li><a href="reference/cast/./cast-estimate.html">cast estimate</a></li>
<li><a href="reference/cast/./cast-access-list.html">cast access-list</a></li>
<li><a href="reference/cast/./cast-logs.html">cast logs</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-publish"><a class="header" href="#cast-publish">cast publish</a></h2>
<h3 id="name-23"><a class="header" href="#name-23">NAME</a></h3>
<p>cast-publish - 将原始交易发布到网络。</p>
<h3 id="synopsis-23"><a class="header" href="#synopsis-23">SYNOPSIS</a></h3>
<p><code>cast publish</code> [<em>options</em>] <em>tx</em></p>
<h3 id="description-23"><a class="header" href="#description-23">DESCRIPTION</a></h3>
<p>将预先签名的原始交易发布到网络。</p>
<h3 id="options-22"><a class="header" href="#options-22">OPTIONS</a></h3>
<h4 id="publish-options"><a class="header" href="#publish-options">Publish Options</a></h4>
<p><code>--async</code><br />
<code>--cast-async</code><br />
    不等待交易收据。<br />
    环境变量: <code>CAST_ASYNC</code></p>
<h4 id="rpc-选项-3"><a class="header" href="#rpc-选项-3">RPC 选项</a></h4>
<pre><code class="language-markdown">`--rpc-url` *url*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;RPC 端点。接受一个 URL 或 [rpc_endpoints] 表中已有的别名，例如 `mainnet`。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `ETH_RPC_URL`
</code></pre>
<p><code>--flashbots</code><br />
    使用 Flashbots RPC URL（<a href="https://rpc.flashbots.net">https://rpc.flashbots.net</a>）。</p>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-21"><a class="header" href="#examples-21">EXAMPLES</a></h3>
<ol>
<li>
<p>发布预签名的交易：</p>
<pre><code class="language-sh">cast publish --rpc-url $RPC $TX
</code></pre>
</li>
<li>
<p>使用 flashbots 发布预签名的交易：</p>
<pre><code class="language-sh">cast publish --flashbots $TX
</code></pre>
</li>
</ol>
<h3 id="see-also-20"><a class="header" href="#see-also-20">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a>, <a href="reference/cast/./cast-call.html">cast call</a>, <a href="reference/cast/./cast-send.html">cast send</a>, <a href="reference/cast/./cast-receipt.html">cast receipt</a>, <a href="reference/cast/./cast-mktx.html">cast mktx</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-receipt"><a class="header" href="#cast-receipt">cast receipt</a></h2>
<h3 id="name-24"><a class="header" href="#name-24">NAME</a></h3>
<p>cast-receipt - 获取交易的收据。</p>
<h3 id="synopsis-24"><a class="header" href="#synopsis-24">SYNOPSIS</a></h3>
<p><code>cast receipt</code> [<em>options</em>] <em>tx_hash</em> [<em>field</em>]</p>
<h3 id="description-24"><a class="header" href="#description-24">DESCRIPTION</a></h3>
<p>获取交易的收据。</p>
<p>如果指定了 <em>field</em>，则仅显示收据的指定字段。</p>
<h3 id="options-23"><a class="header" href="#options-23">OPTIONS</a></h3>
<h4 id="receipt-options"><a class="header" href="#receipt-options">Receipt Options</a></h4>
<p><code>--async</code><br />
<code>--cast-async</code><br />
    如果收据尚不存在，则不等待交易收据。<br />
    环境变量: <code>CAST_ASYNC</code></p>
<p><code>-c</code> <em>confirmations</em><br />
<code>--confirmations</code> <em>confirmations</em><br />
    在退出前等待一定数量的确认。默认值: <code>1</code>。</p>
<h4 id="rpc-options"><a class="header" href="#rpc-options">RPC Options</a></h4>
<pre><code class="language-markdown">`--rpc-url` *url*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;RPC 端点。接受一个 URL 或 [rpc_endpoints] 表中已有的别名，例如 `mainnet`。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `ETH_RPC_URL`
</code></pre>
<pre><code class="language-json">{
  "id": "display-options",
  "title": "显示选项"
}
</code></pre>
<h4 id="显示选项-5"><a class="header" href="#显示选项-5">显示选项</a></h4>
<p><code>-j</code><br />
<code>--json</code><br />
     以 JSON 格式打印部署信息。</p>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-22"><a class="header" href="#examples-22">EXAMPLES</a></h3>
<ol>
<li>
<p>获取交易收据:</p>
<pre><code class="language-sh">cast receipt $TX_HASH
</code></pre>
</li>
<li>
<p>获取交易被包含的区块号:</p>
<pre><code class="language-sh">cast receipt $TX_HASH blockNumber
</code></pre>
</li>
</ol>
<h3 id="see-also-21"><a class="header" href="#see-also-21">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a>, <a href="reference/cast/./cast-call.html">cast call</a>, <a href="reference/cast/./cast-send.html">cast send</a>, <a href="reference/cast/./cast-publish.html">cast publish</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-send"><a class="header" href="#cast-send">cast send</a></h2>
<h3 id="name-25"><a class="header" href="#name-25">NAME</a></h3>
<p>cast-send - 签名并发布交易。</p>
<h3 id="synopsis-25"><a class="header" href="#synopsis-25">SYNOPSIS</a></h3>
<p><code>cast send</code> [<em>options</em>] <em>to</em> [<em>sig</em>] [<em>args…</em>]</p>
<h3 id="description-25"><a class="header" href="#description-25">DESCRIPTION</a></h3>
<p>签名并发布交易。</p>
<p>目标地址（<em>to</em>）可以是 ENS 名称或地址。</p>
<p>签名（<em>sig</em>）可以是：</p>
<ul>
<li>一个片段：<code>someFunction(uint256,bytes32)</code></li>
<li>一个选择器和编码的调用数据：<code>0xcdba2fd40000000000000000000000000000000000000000000000000000000000007a69</code></li>
<li>仅函数名称：在这种情况下，Cast 将尝试从 Etherscan 获取函数签名</li>
</ul>
<h3 id="options-24"><a class="header" href="#options-24">OPTIONS</a></h3>
<pre><code class="language-markdown">#### 交易选项

`--gas-limit` *gas_limit*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;交易的 gas 限制。

`--gas-price` *price*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;交易的 gas 价格，或 EIP1559 交易的每 gas 最大费用。

`--priority-gas-price` *price*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;EIP1559 交易的每 gas 最大优先费用。

`--value` *值*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在交易中发送的以太币。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;可以指定为整数（wei），或指定为带有单位的字符串，例如：  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;- `1ether`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;- `10gwei`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;- `0.01ether`

`--nonce` *nonce*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;交易的 nonce。

`--legacy`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;发送一个传统交易，而不是 [EIP1559][eip1559] 交易。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;对于没有 EIP1559 的常见网络，这会自动启用。

[eip1559]: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1559.md
</code></pre>
<p><code>--resend</code><br />
    重用发送账户的最新 nonce。</p>
<p><code>--create</code> <em>code</em> [<em>sig</em> <em>args…</em>]<br />
    通过指定原始字节码来部署合约，而不是指定 <em>to</em> 地址。</p>
<h4 id="receipt-options-1"><a class="header" href="#receipt-options-1">Receipt Options</a></h4>
<p><code>--async</code><br />
<code>--cast-async</code><br />
    如果交易收据尚不存在，则不等待交易收据。<br />
    环境变量: <code>CAST_ASYNC</code></p>
<p><code>-c</code> <em>confirmations</em><br />
<code>--confirmations</code> <em>confirmations</em><br />
    在退出前等待一定数量的确认。默认: <code>1</code>。</p>
<pre><code class="language-markdown"># 钱包选项

Foundry 支持多种钱包选项，包括原始私钥、密钥库文件、硬件钱包和远程签名者。

## 原始私钥

你可以使用 `PRIVATE_KEY` 环境变量来指定一个原始私钥。

```sh
export PRIVATE_KEY=&lt;your_private_key&gt;
</code></pre>
<p>你也可以在 <code>foundry.toml</code> 文件中配置它：</p>
<pre><code class="language-toml">[profile.default]
private_key = "&lt;your_private_key&gt;"
</code></pre>
<h2 id="密钥库文件-1"><a class="header" href="#密钥库文件-1">密钥库文件</a></h2>
<p>Foundry 支持使用密钥库文件进行签名。你可以通过 <code>ETH_KEYSTORE</code> 环境变量指定密钥库文件的路径，并通过 <code>ETH_PASSWORD</code> 环境变量提供密码。</p>
<pre><code class="language-sh">export ETH_KEYSTORE=&lt;path_to_keystore&gt;
export ETH_PASSWORD=&lt;your_keystore_password&gt;
</code></pre>
<p>你也可以在 <code>foundry.toml</code> 文件中配置它：</p>
<pre><code class="language-toml">[profile.default]
keystore = "&lt;path_to_keystore&gt;"
password = "&lt;your_keystore_password&gt;"
</code></pre>
<h2 id="硬件钱包-2"><a class="header" href="#硬件钱包-2">硬件钱包</a></h2>
<p>Foundry 支持使用硬件钱包进行签名。你可以通过 <code>ETH_HW_WALLET</code> 环境变量指定硬件钱包的类型。</p>
<pre><code class="language-sh">export ETH_HW_WALLET=&lt;hardware_wallet_type&gt;
</code></pre>
<p>你也可以在 <code>foundry.toml</code> 文件中配置它：</p>
<pre><code class="language-toml">[profile.default]
hardware_wallet = "&lt;hardware_wallet_type&gt;"
</code></pre>
<h2 id="远程签名者-2"><a class="header" href="#远程签名者-2">远程签名者</a></h2>
<p>Foundry 支持使用远程签名者进行签名。你可以通过 <code>ETH_RPC_URL</code> 环境变量指定远程签名者的 RPC URL。</p>
<pre><code class="language-sh">export ETH_RPC_URL=&lt;remote_signer_rpc_url&gt;
</code></pre>
<p>你也可以在 <code>foundry.toml</code> 文件中配置它：</p>
<pre><code class="language-toml">[profile.default]
rpc_url = "&lt;remote_signer_rpc_url&gt;"
</code></pre>
<pre><code>
`--unlocked`  
    通过 `eth_sendTransaction` 使用 `--from` 参数或 `$ETH_FROM` 作为发送者。

#### RPC 选项

```markdown
`--rpc-url` *url*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;RPC 端点。接受一个 URL 或 [rpc_endpoints] 表中已有的别名，例如 `mainnet`。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `ETH_RPC_URL`
</code></pre>
<p><code>--flashbots</code><br />
    使用 Flashbots RPC URL（<a href="https://rpc.flashbots.net">https://rpc.flashbots.net</a>）。</p>
<pre><code class="language-markdown">#### Etherscan 选项

`--chain` *chain_name*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Etherscan 链。

`--etherscan-api-key` *key*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Etherscan API 密钥，或 [Etherscan 配置表](../config/etherscan.md#etherscan) 中的密钥。  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `ETHERSCAN_API_KEY`
</code></pre>
<pre><code class="language-json">{
  "id": "display-options",
  "title": "显示选项"
}
</code></pre>
<h4 id="显示选项-6"><a class="header" href="#显示选项-6">显示选项</a></h4>
<p><code>-j</code><br />
<code>--json</code><br />
     以 JSON 格式打印部署信息。</p>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-23"><a class="header" href="#examples-23">EXAMPLES</a></h3>
<ol>
<li>
<p>使用 Ledger 向 Vitalik 发送一些以太币：</p>
<pre><code class="language-sh">cast send --ledger vitalik.eth --value 0.1ether
</code></pre>
</li>
<li>
<p>在合约上调用 <code>deposit(address token, uint256 amount)</code> 函数：</p>
<pre><code class="language-sh">cast send --ledger 0x... "deposit(address,uint256)" 0x... 1
</code></pre>
</li>
<li>
<p>调用一个期望 <code>struct</code> 的函数：</p>
<pre><code class="language-solidity">contract Test {
    struct MyStruct {
        address addr;
        uint256 amount;
    }
    function myfunction(MyStruct memory t) public pure {}
}
</code></pre>
<p>结构体被编码为元组（参见 <a href="reference/cast/../../misc/struct-encoding.html">struct encoding</a>）</p>
<pre><code class="language-sh">cast send 0x... "myfunction((address,uint256))" "(0x...,1)"
</code></pre>
</li>
<li>
<p>在交易的 <code>input</code> 字段中发送带有十六进制数据的交易：</p>
<pre><code class="language-sh">cast send 0x... 0x68656c6c6f20776f726c64
</code></pre>
</li>
</ol>
<h3 id="see-also-22"><a class="header" href="#see-also-22">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a>, <a href="reference/cast/./cast-call.html">cast call</a>, <a href="reference/cast/./cast-publish.html">cast publish</a>, <a href="reference/cast/./cast-receipt.html">cast receipt</a>, <a href="reference/cast/./cast-mktx.html">cast mktx</a>, <a href="reference/cast/../../misc/struct-encoding.html">struct encoding</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-mktx"><a class="header" href="#cast-mktx">cast mktx</a></h2>
<h3 id="名称-13"><a class="header" href="#名称-13">名称</a></h3>
<p>cast-mktx - 构建并签署交易。</p>
<h3 id="概要-13"><a class="header" href="#概要-13">概要</a></h3>
<p><code>cast mktx</code> [<em>选项</em>] <em>to</em> [<em>sig</em>] [<em>args…</em>]</p>
<h3 id="描述-13"><a class="header" href="#描述-13">描述</a></h3>
<p>构建并签署交易，但不发布它。</p>
<p>目标地址（<em>to</em>）可以是 ENS 名称或地址。</p>
<p>签名（<em>sig</em>）可以是：</p>
<ul>
<li>一个片段：<code>someFunction(uint256,bytes32)</code></li>
<li>一个选择器和编码的调用数据：<code>0xcdba2fd40000000000000000000000000000000000000000000000000000000000007a69</code></li>
<li>仅函数名称：在这种情况下，Cast 将尝试从 Etherscan 获取函数签名</li>
</ul>
<h3 id="选项-12"><a class="header" href="#选项-12">选项</a></h3>
<pre><code class="language-markdown">#### 交易选项

`--gas-limit` *gas_limit*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;交易的 gas 限制。

`--gas-price` *price*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;交易的 gas 价格，或 EIP1559 交易的每 gas 最大费用。

`--priority-gas-price` *price*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;EIP1559 交易的每 gas 最大优先费用。

`--value` *值*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在交易中发送的以太币。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;可以指定为整数（wei），或指定为带有单位的字符串，例如：  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;- `1ether`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;- `10gwei`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;- `0.01ether`

`--nonce` *nonce*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;交易的 nonce。

`--legacy`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;发送一个传统交易，而不是 [EIP1559][eip1559] 交易。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;对于没有 EIP1559 的常见网络，这会自动启用。

[eip1559]: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1559.md
</code></pre>
<p><code>--create</code> <em>code</em> [<em>sig</em> <em>args…</em>]<br />
    通过指定原始字节码而不是指定 <em>to</em> 地址来部署合约。</p>
<pre><code class="language-markdown">#### 钱包选项 - 原始:
`-i`  
`--interactive &lt;NUM&gt;`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 打开一个交互式提示符以输入您的私钥。接受一个值，表示要输入的私钥数量。  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 默认为 `0`。  

`--mnemonic-derivation-path &lt;PATHS&gt;`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 钱包派生路径。适用于 `--mnemonic-path` 和硬件钱包。  

`--mnemonic-indexes &lt;INDEXES&gt;`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 使用给定助记词索引的私钥。与 `--mnemonic-paths` 一起使用。  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 默认为 `0`。

`--mnemonic-passphrase &lt;PASSPHRASE&gt;`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 使用 BIP39 密码短语。  

`--mnemonic &lt;PATHS&gt;`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 使用指定路径的助记词短语或助记词文件。  

`--private-key &lt;RAW_PRIVATE_KEY&gt;`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 使用提供的私钥。

`--private-keys &lt;RAW_PRIVATE_KEYS&gt;`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 使用提供的私钥。
</code></pre>
<pre><code class="language-markdown">#### 钱包选项 - Keystore

`--keystore` _路径_  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;使用指定文件夹或文件中的 keystore。  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `ETH_KEYSTORE`

`--account` _账户名称_  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;通过文件名从默认 keystores 文件夹（~/.foundry/keystores）中使用 keystore。  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `ETH_KEYSTORE_ACCOUNT`

`--interactive`

`--password` _密码_  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;keystore 密码。与 `--keystore` 一起使用。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `ETH_PASSWORD`
</code></pre>
<pre><code class="language-markdown">#### 钱包选项 - 硬件钱包

`-t`  
`--trezor`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;使用 Trezor 硬件钱包。

`-l`  
`--ledger`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;使用 Ledger 硬件钱包。
</code></pre>
<h4 id="rpc-选项-4"><a class="header" href="#rpc-选项-4">RPC 选项</a></h4>
<pre><code class="language-markdown">`--rpc-url` *url*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;RPC 端点。接受一个 URL 或 [rpc_endpoints] 表中已有的别名，例如 `mainnet`。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `ETH_RPC_URL`
</code></pre>
<p><code>--flashbots</code><br />
    使用 Flashbots RPC URL（<a href="https://rpc.flashbots.net">https://rpc.flashbots.net</a>）。</p>
<pre><code class="language-markdown">#### Etherscan 选项

`--chain` *chain_name*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Etherscan 链。

`--etherscan-api-key` *key*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Etherscan API 密钥，或 [Etherscan 配置表](../config/etherscan.md#etherscan) 中的密钥。  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `ETHERSCAN_API_KEY`
</code></pre>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="示例-12"><a class="header" href="#示例-12">示例</a></h3>
<ol>
<li>
<p>使用 Ledger 签署向 Vitalik 发送一些以太币的交易：</p>
<pre><code class="language-sh">cast mktx --ledger vitalik.eth --value 0.1ether
</code></pre>
</li>
<li>
<p>签署调用合约上 <code>deposit(address token, uint256 amount)</code> 函数的交易：</p>
<pre><code class="language-sh">cast mktx --ledger 0x... "deposit(address,uint256)" 0x... 1
</code></pre>
</li>
<li>
<p>签署调用期望 <code>struct</code> 的函数的交易：</p>
<pre><code class="language-solidity">contract Test {
    struct MyStruct {
        address addr;
        uint256 amount;
    }
    function myfunction(MyStruct memory t) public pure {}
}
</code></pre>
<p>结构体被编码为元组（参见 <a href="reference/cast/../../misc/struct-encoding.html">struct encoding</a>）</p>
<pre><code class="language-sh">cast mktx 0x... "myfunction((address,uint256))" "(0x...,1)"
</code></pre>
</li>
<li>
<p>在交易的 <code>input</code> 字段中使用十六进制数据签署交易：</p>
<pre><code class="language-sh">cast mktx 0x... 0x68656c6c6f20776f726c64
</code></pre>
</li>
</ol>
<h3 id="参见-2"><a class="header" href="#参见-2">参见</a></h3>
<p><a href="reference/cast/./cast.html">cast</a>, <a href="reference/cast/./cast-publish.html">cast publish</a>, <a href="reference/cast/./cast-send.html">cast send</a>, <a href="reference/cast/../../misc/struct-encoding.html">struct encoding</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-call"><a class="header" href="#cast-call">cast call</a></h2>
<h3 id="name-26"><a class="header" href="#name-26">NAME</a></h3>
<p>cast-call - 在不发布交易的情况下对账户执行调用。</p>
<h3 id="synopsis-26"><a class="header" href="#synopsis-26">SYNOPSIS</a></h3>
<p><code>cast call</code> [<em>options</em>] <em>to</em> <em>sig</em> [<em>args…</em>]</p>
<h3 id="description-26"><a class="header" href="#description-26">DESCRIPTION</a></h3>
<p>在不发布交易的情况下对账户执行调用。</p>
<p>目标（<em>to</em>）可以是 ENS 名称或地址。</p>
<p>签名（<em>sig</em>）可以是：</p>
<ul>
<li>一个片段：<code>someFunction(uint256,bytes32)</code></li>
<li>一个选择器和编码的调用数据：<code>0xcdba2fd40000000000000000000000000000000000000000000000000000000000007a69</code></li>
<li>仅函数名称：在这种情况下，Cast 将尝试从 Etherscan 获取函数签名</li>
</ul>
<h3 id="options-25"><a class="header" href="#options-25">OPTIONS</a></h3>
<p><code>--trace</code><br />
    打印交易的跟踪信息。</p>
<p><code>--debug</code><br />
    使用交易打开交互式调试器。需要 <code>--trace</code>。</p>
<p><code>--labels &lt;address:label&gt;</code><br />
    应用于跟踪的标签，格式为 <code>address:label</code>。需要 <code>--trace</code>。</p>
<p><code>--evm-version</code><br />
    要使用的 EVM 版本。需要 <code>--trace</code>。</p>
<h4 id="查询选项"><a class="header" href="#查询选项">查询选项</a></h4>
<p><code>-B</code> <em>block</em><br />
<code>--block</code> <em>block</em><br />
    你想要查询的区块高度。</p>
<p>    可以是区块号，或任何标签：<code>earliest</code>、<code>finalized</code>、<code>safe</code>、<code>latest</code> 或 <code>pending</code>。</p>
<pre><code class="language-markdown"># 钱包选项

Foundry 支持多种钱包选项，包括原始私钥、密钥库文件、硬件钱包和远程签名者。

## 原始私钥

你可以使用 `PRIVATE_KEY` 环境变量来指定一个原始私钥。

```sh
export PRIVATE_KEY=&lt;your_private_key&gt;
</code></pre>
<p>你也可以在 <code>foundry.toml</code> 文件中配置它：</p>
<pre><code class="language-toml">[profile.default]
private_key = "&lt;your_private_key&gt;"
</code></pre>
<h2 id="密钥库文件-2"><a class="header" href="#密钥库文件-2">密钥库文件</a></h2>
<p>Foundry 支持使用密钥库文件进行签名。你可以通过 <code>ETH_KEYSTORE</code> 环境变量指定密钥库文件的路径，并通过 <code>ETH_PASSWORD</code> 环境变量提供密码。</p>
<pre><code class="language-sh">export ETH_KEYSTORE=&lt;path_to_keystore&gt;
export ETH_PASSWORD=&lt;your_keystore_password&gt;
</code></pre>
<p>你也可以在 <code>foundry.toml</code> 文件中配置它：</p>
<pre><code class="language-toml">[profile.default]
keystore = "&lt;path_to_keystore&gt;"
password = "&lt;your_keystore_password&gt;"
</code></pre>
<h2 id="硬件钱包-3"><a class="header" href="#硬件钱包-3">硬件钱包</a></h2>
<p>Foundry 支持使用硬件钱包进行签名。你可以通过 <code>ETH_HW_WALLET</code> 环境变量指定硬件钱包的类型。</p>
<pre><code class="language-sh">export ETH_HW_WALLET=&lt;hardware_wallet_type&gt;
</code></pre>
<p>你也可以在 <code>foundry.toml</code> 文件中配置它：</p>
<pre><code class="language-toml">[profile.default]
hardware_wallet = "&lt;hardware_wallet_type&gt;"
</code></pre>
<h2 id="远程签名者-3"><a class="header" href="#远程签名者-3">远程签名者</a></h2>
<p>Foundry 支持使用远程签名者进行签名。你可以通过 <code>ETH_RPC_URL</code> 环境变量指定远程签名者的 RPC URL。</p>
<pre><code class="language-sh">export ETH_RPC_URL=&lt;remote_signer_rpc_url&gt;
</code></pre>
<p>你也可以在 <code>foundry.toml</code> 文件中配置它：</p>
<pre><code class="language-toml">[profile.default]
rpc_url = "&lt;remote_signer_rpc_url&gt;"
</code></pre>
<pre><code>
#### RPC 选项

```markdown
`--rpc-url` *url*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;RPC 端点。接受一个 URL 或 [rpc_endpoints] 表中已有的别名，例如 `mainnet`。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `ETH_RPC_URL`
</code></pre>
<p><code>--flashbots</code><br />
    使用 Flashbots RPC URL（<a href="https://rpc.flashbots.net">https://rpc.flashbots.net</a>）。</p>
<pre><code class="language-markdown">#### Etherscan 选项

`--chain` *chain_name*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Etherscan 链。

`--etherscan-api-key` *key*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Etherscan API 密钥，或 [Etherscan 配置表](../config/etherscan.md#etherscan) 中的密钥。  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `ETHERSCAN_API_KEY`
</code></pre>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-24"><a class="header" href="#examples-24">EXAMPLES</a></h3>
<ol>
<li>
<p>在 WETH 合约上调用 <code>balanceOf(address)</code>：</p>
<pre><code class="language-sh">cast call 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2 \
  "balanceOf(address)(uint256)" 0x...
</code></pre>
</li>
<li>
<p>在 Tubby Cats NFT 合约上调用 <code>tokenURI(uint256)(string)</code>：</p>
<pre><code class="language-sh">export CONTRACT=0xca7ca7bcc765f77339be2d648ba53ce9c8a262bd
export TOKEN_ID=19938
cast call $CONTRACT "tokenURI(uint256)(string)" $TOKEN_ID
</code></pre>
</li>
<li>
<p>在 Uniswap v2 路由合约上调用 <code>getAmountsOut(uint,address[])</code>：</p>
<pre><code class="language-sh">cast call 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D \
 "getAmountsOut(uint,address[])" 1 "[0x6b...0f,0xc0...c2]"
</code></pre>
</li>
</ol>
<h3 id="see-also-23"><a class="header" href="#see-also-23">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a>, <a href="reference/cast/./cast-send.html">cast send</a>, <a href="reference/cast/./cast-publish.html">cast publish</a>, <a href="reference/cast/./cast-receipt.html">cast receipt</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-rpc"><a class="header" href="#cast-rpc">cast rpc</a></h2>
<h3 id="name-27"><a class="header" href="#name-27">NAME</a></h3>
<p>cast-rpc - 执行原始 JSON-RPC 请求</p>
<h3 id="概要-14"><a class="header" href="#概要-14">概要</a></h3>
<p><code>cast rpc</code> [<em>选项</em>] <em>方法</em> [<em>参数…</em>]</p>
<h3 id="描述-14"><a class="header" href="#描述-14">描述</a></h3>
<p>对给定的方法和参数执行简单的 JSON-RPC POST 请求。</p>
<h3 id="选项-13"><a class="header" href="#选项-13">选项</a></h3>
<h4 id="查询选项-1"><a class="header" href="#查询选项-1">查询选项</a></h4>
<p><code>-r</code> <em>url</em><br />
<code>--rpc-url</code> <em>url</em><br />
    提供者的 URL</p>
<p><code>-w</code><br />
<code>--raw</code><br />
    按原样传递“参数”
    如果传递了 –raw，第一个参数将被视为“参数”的值。如果没有给出参数，将使用标准输入。例如：
     rpc eth_getBlockByNumber ‘[“0x123”, false]’ –raw
       =&gt; {“method”: “eth_getBlockByNumber”, “params”: [“0x123”, false] … }</p>
<h3 id="示例-13"><a class="header" href="#示例-13">示例</a></h3>
<ol>
<li>
<p>在本地获取最新的 <code>eth_getBlockByNumber</code>：</p>
<pre><code class="language-sh">cast rpc eth_getBlockByNumber "latest" "false"
</code></pre>
</li>
<li>
<p>在本地获取 <code>eth_getTransactionByHash</code>：</p>
<pre><code class="language-sh">cast rpc eth_getTransactionByHash 0x2642e960d3150244e298d52b5b0f024782253e6d0b2c9a01dd4858f7b4665a3f
</code></pre>
</li>
<li>
<p>在以太坊主网获取最新的 <code>eth_getBlockByNumber</code>：</p>
<pre><code class="language-sh">cast rpc --rpc-url https://mainnet.infura.io/v3/ eth_getBlockByNumber "latest" "false"
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-tx"><a class="header" href="#cast-tx">cast tx</a></h2>
<h3 id="name-28"><a class="header" href="#name-28">NAME</a></h3>
<p>cast-tx - 获取交易信息。</p>
<h3 id="synopsis-27"><a class="header" href="#synopsis-27">SYNOPSIS</a></h3>
<p><code>cast tx</code> [<em>options</em>] <em>tx_hash</em> [<em>field</em>]</p>
<h3 id="description-27"><a class="header" href="#description-27">DESCRIPTION</a></h3>
<p>获取交易信息。</p>
<p>如果指定了 <em>field</em>，则仅显示交易的指定字段。</p>
<h3 id="options-26"><a class="header" href="#options-26">OPTIONS</a></h3>
<h4 id="rpc-选项-5"><a class="header" href="#rpc-选项-5">RPC 选项</a></h4>
<pre><code class="language-markdown">`--rpc-url` *url*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;RPC 端点。接受一个 URL 或 [rpc_endpoints] 表中已有的别名，例如 `mainnet`。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `ETH_RPC_URL`
</code></pre>
<pre><code class="language-json">{
  "id": "display-options",
  "title": "显示选项"
}
</code></pre>
<h4 id="显示选项-7"><a class="header" href="#显示选项-7">显示选项</a></h4>
<p><code>-j</code><br />
<code>--json</code><br />
     以 JSON 格式打印部署信息。</p>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-25"><a class="header" href="#examples-25">EXAMPLES</a></h3>
<ol>
<li>
<p>获取交易信息：</p>
<pre><code class="language-sh">cast tx $TX_HASH
</code></pre>
</li>
<li>
<p>获取交易的 sender：</p>
<pre><code class="language-sh">cast tx $TX_HASH from
</code></pre>
</li>
</ol>
<h3 id="see-also-24"><a class="header" href="#see-also-24">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a>, <a href="reference/cast/./cast-receipt.html">cast receipt</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-run"><a class="header" href="#cast-run">cast run</a></h2>
<h3 id="name-29"><a class="header" href="#name-29">NAME</a></h3>
<p>cast-run - 在本地环境中运行已发布的交易并打印追踪信息。</p>
<h3 id="synopsis-28"><a class="header" href="#synopsis-28">SYNOPSIS</a></h3>
<p><code>cast run</code> [<em>options</em>] <code>--rpc-url</code> <em>url</em> <em>tx_hash</em></p>
<h3 id="description-28"><a class="header" href="#description-28">DESCRIPTION</a></h3>
<p>在本地环境中运行已发布的交易并打印追踪信息。</p>
<p>默认情况下，在您想要重放的交易之前的区块中的所有交易也会被重放。如果您想要更快的结果，可以使用 <code>--quick</code>，但是结果可能与实际执行不同。</p>
<p>您还可以通过传递 <code>--debug</code> 在调试器中打开交易。</p>
<h3 id="options-27"><a class="header" href="#options-27">OPTIONS</a></h3>
<h4 id="运行选项"><a class="header" href="#运行选项">运行选项</a></h4>
<p><code>--label</code> <em>label</em><br />
    在追踪信息中标记一个地址。<br />
    格式为 <code>&lt;address&gt;:&lt;label&gt;</code>。可以多次传递。</p>
<p><code>-q</code><br />
<code>--quick</code><br />
    仅使用前一个区块的状态执行交易。<br />
    可能导致与实际执行不同的结果！</p>
<p><code>-v</code><br />
<code>--verbose</code><br />
    地址完全显示，而不是被截断。</p>
<p><code>-d</code><br />
<code>--debug</code><br />
    在 <a href="reference/cast/../../forge/debugger.html">调试器</a> 中打开脚本。</p>
<h4 id="rpc-选项-6"><a class="header" href="#rpc-选项-6">RPC 选项</a></h4>
<pre><code class="language-markdown">`--rpc-url` *url*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;RPC 端点。接受一个 URL 或 [rpc_endpoints] 表中已有的别名，例如 `mainnet`。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `ETH_RPC_URL`
</code></pre>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-26"><a class="header" href="#examples-26">EXAMPLES</a></h3>
<ol>
<li>
<p>重放一个交易（一个简单的转账）：</p>
<pre><code class="language-sh">cast run 0xd15e0237413d7b824b784e1bbc3926e52f4726e5e5af30418803b8b327b4f8ca
</code></pre>
</li>
<li>
<p>重放一个交易，应用在前一个区块的状态之上：</p>
<pre><code class="language-sh">cast run --quick \
  0xd15e0237413d7b824b784e1bbc3926e52f4726e5e5af30418803b8b327b4f8ca
</code></pre>
</li>
<li>
<p>重放一个交易并标记地址：</p>
<pre><code class="language-sh">cast run \
  --label 0xc564ee9f21ed8a2d8e7e76c085740d5e4c5fafbe:sender \
  --label 0x40950267d12e979ad42974be5ac9a7e452f9505e:recipient \
  --label 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2:weth \
  0xd15e0237413d7b824b784e1bbc3926e52f4726e5e5af30418803b8b327b4f8ca
</code></pre>
</li>
<li>
<p>在调试器中重放一个交易：</p>
<pre><code class="language-sh">cast run --debug \
  0xd15e0237413d7b824b784e1bbc3926e52f4726e5e5af30418803b8b327b4f8ca
</code></pre>
</li>
</ol>
<h3 id="see-also-25"><a class="header" href="#see-also-25">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-estimate"><a class="header" href="#cast-estimate">cast estimate</a></h2>
<h3 id="name-30"><a class="header" href="#name-30">NAME</a></h3>
<p>cast-estimate - 估算交易所需的 gas 费用。</p>
<h3 id="synopsis-29"><a class="header" href="#synopsis-29">SYNOPSIS</a></h3>
<p><code>cast estimate</code> [<em>options</em>] <em>to</em> <em>sig</em> [<em>args…</em>]</p>
<h3 id="description-29"><a class="header" href="#description-29">DESCRIPTION</a></h3>
<p>估算交易所需的 gas 费用。</p>
<p>目标地址（<em>to</em>）可以是 ENS 名称或地址。</p>
<p>签名（<em>sig</em>）可以是：</p>
<ul>
<li>一个片段：<code>someFunction(uint256,bytes32)</code></li>
<li>一个选择器和编码的调用数据：<code>0xcdba2fd40000000000000000000000000000000000000000000000000000000000007a69</code></li>
<li>仅函数名称：在这种情况下，Cast 将尝试从 Etherscan 获取函数签名</li>
</ul>
<h3 id="options-28"><a class="header" href="#options-28">OPTIONS</a></h3>
<h4 id="交易选项"><a class="header" href="#交易选项">交易选项</a></h4>
<p><code>--value</code> <em>值</em><br />
    在交易中发送的以太币。</p>
<p>    可以指定为整数（wei），或指定为带有单位的字符串，例如：<br />
    - <code>1ether</code><br />
    - <code>10gwei</code><br />
    - <code>0.01ether</code></p>
<h4 id="rpc-选项-7"><a class="header" href="#rpc-选项-7">RPC 选项</a></h4>
<pre><code class="language-markdown">`--rpc-url` *url*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;RPC 端点。接受一个 URL 或 [rpc_endpoints] 表中已有的别名，例如 `mainnet`。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `ETH_RPC_URL`
</code></pre>
<p><code>--flashbots</code><br />
    使用 Flashbots RPC URL（<a href="https://rpc.flashbots.net">https://rpc.flashbots.net</a>）。</p>
<pre><code class="language-markdown">#### Etherscan 选项

`--chain` *chain_name*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Etherscan 链。

`--etherscan-api-key` *key*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Etherscan API 密钥，或 [Etherscan 配置表](../config/etherscan.md#etherscan) 中的密钥。  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `ETHERSCAN_API_KEY`
</code></pre>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-27"><a class="header" href="#examples-27">EXAMPLES</a></h3>
<ol>
<li>估算调用 WETH 合约上的 <code>deposit()</code> 方法所需的 gas 费用：
<pre><code class="language-sh">cast estimate 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2 \
  --value 0.1ether "deposit()"
</code></pre>
</li>
</ol>
<h3 id="see-also-26"><a class="header" href="#see-also-26">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a>, <a href="reference/cast/./cast-send.html">cast send</a>, <a href="reference/cast/./cast-publish.html">cast publish</a>, <a href="reference/cast/./cast-receipt.html">cast receipt</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-access-list"><a class="header" href="#cast-access-list">cast access-list</a></h2>
<h3 id="name-31"><a class="header" href="#name-31">NAME</a></h3>
<p>cast-access-list - 创建一个交易访问列表。</p>
<h3 id="synopsis-30"><a class="header" href="#synopsis-30">SYNOPSIS</a></h3>
<p><code>cast access-list</code> [<em>options</em>] <em>to</em> <em>sig</em> [<em>args…</em>]</p>
<h3 id="description-30"><a class="header" href="#description-30">DESCRIPTION</a></h3>
<p>创建一个交易访问列表。</p>
<p>目标地址（<em>to</em>）可以是 ENS 名称或地址。</p>
<p>签名（<em>sig</em>）可以是：</p>
<ul>
<li>一个片段：<code>someFunction(uint256,bytes32)</code></li>
<li>一个选择器和编码的调用数据：<code>0xcdba2fd40000000000000000000000000000000000000000000000000000000000007a69</code></li>
<li>仅函数名称：在这种情况下，Cast 将尝试从 Etherscan 获取函数签名</li>
</ul>
<h3 id="options-29"><a class="header" href="#options-29">OPTIONS</a></h3>
<h4 id="查询选项-2"><a class="header" href="#查询选项-2">查询选项</a></h4>
<p><code>-B</code> <em>block</em><br />
<code>--block</code> <em>block</em><br />
    你想要查询的区块高度。</p>
<p>    可以是区块号，或以下任何标签：<code>earliest</code>、<code>finalized</code>、<code>safe</code>、<code>latest</code> 或 <code>pending</code>。</p>
<pre><code class="language-markdown"># 钱包选项

Foundry 支持多种钱包选项，包括原始私钥、密钥库文件、硬件钱包和远程签名者。

## 原始私钥

你可以使用 `PRIVATE_KEY` 环境变量来指定一个原始私钥。

```sh
export PRIVATE_KEY=&lt;your_private_key&gt;
</code></pre>
<p>你也可以在 <code>foundry.toml</code> 文件中配置它：</p>
<pre><code class="language-toml">[profile.default]
private_key = "&lt;your_private_key&gt;"
</code></pre>
<h2 id="密钥库文件-3"><a class="header" href="#密钥库文件-3">密钥库文件</a></h2>
<p>Foundry 支持使用密钥库文件进行签名。你可以通过 <code>ETH_KEYSTORE</code> 环境变量指定密钥库文件的路径，并通过 <code>ETH_PASSWORD</code> 环境变量提供密码。</p>
<pre><code class="language-sh">export ETH_KEYSTORE=&lt;path_to_keystore&gt;
export ETH_PASSWORD=&lt;your_keystore_password&gt;
</code></pre>
<p>你也可以在 <code>foundry.toml</code> 文件中配置它：</p>
<pre><code class="language-toml">[profile.default]
keystore = "&lt;path_to_keystore&gt;"
password = "&lt;your_keystore_password&gt;"
</code></pre>
<h2 id="硬件钱包-4"><a class="header" href="#硬件钱包-4">硬件钱包</a></h2>
<p>Foundry 支持使用硬件钱包进行签名。你可以通过 <code>ETH_HW_WALLET</code> 环境变量指定硬件钱包的类型。</p>
<pre><code class="language-sh">export ETH_HW_WALLET=&lt;hardware_wallet_type&gt;
</code></pre>
<p>你也可以在 <code>foundry.toml</code> 文件中配置它：</p>
<pre><code class="language-toml">[profile.default]
hardware_wallet = "&lt;hardware_wallet_type&gt;"
</code></pre>
<h2 id="远程签名者-4"><a class="header" href="#远程签名者-4">远程签名者</a></h2>
<p>Foundry 支持使用远程签名者进行签名。你可以通过 <code>ETH_RPC_URL</code> 环境变量指定远程签名者的 RPC URL。</p>
<pre><code class="language-sh">export ETH_RPC_URL=&lt;remote_signer_rpc_url&gt;
</code></pre>
<p>你也可以在 <code>foundry.toml</code> 文件中配置它：</p>
<pre><code class="language-toml">[profile.default]
rpc_url = "&lt;remote_signer_rpc_url&gt;"
</code></pre>
<pre><code>
#### RPC 选项

```markdown
`--rpc-url` *url*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;RPC 端点。接受一个 URL 或 [rpc_endpoints] 表中已有的别名，例如 `mainnet`。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `ETH_RPC_URL`
</code></pre>
<p><code>--flashbots</code><br />
    使用 Flashbots RPC URL（<a href="https://rpc.flashbots.net">https://rpc.flashbots.net</a>）。</p>
<pre><code class="language-markdown">#### Etherscan 选项

`--chain` *chain_name*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Etherscan 链。

`--etherscan-api-key` *key*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Etherscan API 密钥，或 [Etherscan 配置表](../config/etherscan.md#etherscan) 中的密钥。  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `ETHERSCAN_API_KEY`
</code></pre>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="see-also-27"><a class="header" href="#see-also-27">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a>, <a href="reference/cast/./cast-send.html">cast send</a>, <a href="reference/cast/./cast-publish.html">cast publish</a>, <a href="reference/cast/./cast-call.html">cast call</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-logs"><a class="header" href="#cast-logs">cast logs</a></h2>
<h3 id="name-32"><a class="header" href="#name-32">NAME</a></h3>
<p>cast logs - 通过签名或主题获取日志。</p>
<h3 id="synopsis-31"><a class="header" href="#synopsis-31">SYNOPSIS</a></h3>
<p><code>cast logs</code> [<em>options</em>] <em>sig_or_topic</em> [<em>topics_or_args…</em>]</p>
<h3 id="description-31"><a class="header" href="#description-31">DESCRIPTION</a></h3>
<p>通过签名或主题获取日志。</p>
<p>(<em>sig_or_topic</em>) 可以是事件签名或其哈希主题（位于 topics[0]）。</p>
<p>如果使用签名，剩余参数必须是普通形式。如果使用主题，参数必须与它们自身作为主题的形式一致。</p>
<h3 id="options-30"><a class="header" href="#options-30">OPTIONS</a></h3>
<h3 id="查询选项-3"><a class="header" href="#查询选项-3">查询选项</a></h3>
<p><code>--from-block</code> <em>from_block</em>
    开始查询的区块高度。</p>
<p>    也可以是以下标签：<code>earliest</code>, <code>finalized</code>, <code>safe</code>, <code>latest</code>, 或 <code>pending</code>。</p>
<p><code>--to-block</code> <em>to_block</em>
    停止查询的区块高度。</p>
<p>    也可以是以下标签：<code>earliest</code>, <code>finalized</code>, <code>safe</code>, <code>latest</code>, 或 <code>pending</code>。</p>
<p><code>--address</code> <em>address</em>
    过滤的合约地址</p>
<pre><code class="language-markdown"># 钱包选项

Foundry 支持多种钱包选项，包括原始私钥、密钥库文件、硬件钱包和远程签名者。

## 原始私钥

你可以使用 `PRIVATE_KEY` 环境变量来指定一个原始私钥。

```sh
export PRIVATE_KEY=&lt;your_private_key&gt;
</code></pre>
<p>你也可以在 <code>foundry.toml</code> 文件中配置它：</p>
<pre><code class="language-toml">[profile.default]
private_key = "&lt;your_private_key&gt;"
</code></pre>
<h2 id="密钥库文件-4"><a class="header" href="#密钥库文件-4">密钥库文件</a></h2>
<p>Foundry 支持使用密钥库文件进行签名。你可以通过 <code>ETH_KEYSTORE</code> 环境变量指定密钥库文件的路径，并通过 <code>ETH_PASSWORD</code> 环境变量提供密码。</p>
<pre><code class="language-sh">export ETH_KEYSTORE=&lt;path_to_keystore&gt;
export ETH_PASSWORD=&lt;your_keystore_password&gt;
</code></pre>
<p>你也可以在 <code>foundry.toml</code> 文件中配置它：</p>
<pre><code class="language-toml">[profile.default]
keystore = "&lt;path_to_keystore&gt;"
password = "&lt;your_keystore_password&gt;"
</code></pre>
<h2 id="硬件钱包-5"><a class="header" href="#硬件钱包-5">硬件钱包</a></h2>
<p>Foundry 支持使用硬件钱包进行签名。你可以通过 <code>ETH_HW_WALLET</code> 环境变量指定硬件钱包的类型。</p>
<pre><code class="language-sh">export ETH_HW_WALLET=&lt;hardware_wallet_type&gt;
</code></pre>
<p>你也可以在 <code>foundry.toml</code> 文件中配置它：</p>
<pre><code class="language-toml">[profile.default]
hardware_wallet = "&lt;hardware_wallet_type&gt;"
</code></pre>
<h2 id="远程签名者-5"><a class="header" href="#远程签名者-5">远程签名者</a></h2>
<p>Foundry 支持使用远程签名者进行签名。你可以通过 <code>ETH_RPC_URL</code> 环境变量指定远程签名者的 RPC URL。</p>
<pre><code class="language-sh">export ETH_RPC_URL=&lt;remote_signer_rpc_url&gt;
</code></pre>
<p>你也可以在 <code>foundry.toml</code> 文件中配置它：</p>
<pre><code class="language-toml">[profile.default]
rpc_url = "&lt;remote_signer_rpc_url&gt;"
</code></pre>
<pre><code>
#### RPC 选项

```markdown
`--rpc-url` *url*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;RPC 端点。接受一个 URL 或 [rpc_endpoints] 表中已有的别名，例如 `mainnet`。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `ETH_RPC_URL`
</code></pre>
<p><code>--flashbots</code><br />
    使用 Flashbots RPC URL（<a href="https://rpc.flashbots.net">https://rpc.flashbots.net</a>）。</p>
<pre><code class="language-markdown">#### Etherscan 选项

`--chain` *chain_name*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Etherscan 链。

`--etherscan-api-key` *key*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Etherscan API 密钥，或 [Etherscan 配置表](../config/etherscan.md#etherscan) 中的密钥。  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `ETHERSCAN_API_KEY`
</code></pre>
<h3 id="examples-28"><a class="header" href="#examples-28">EXAMPLES</a></h3>
<ol>
<li>
<p>使用签名获取日志：</p>
<pre><code class="language-sh">cast logs --from-block 15537393 --to-block latest 'Transfer (address indexed from, address indexed to, uint256 value)' 0x2e8ABfE042886E4938201101A63730D04F160A82
</code></pre>
</li>
<li>
<p>使用主题获取日志：</p>
<pre><code class="language-sh">cast logs --from-block 15537393 --to-block latest 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef 0x0000000000000000000000002e8abfe042886e4938201101a63730d04f160a82
</code></pre>
</li>
</ol>
<h3 id="see-also-28"><a class="header" href="#see-also-28">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="区块命令"><a class="header" href="#区块命令">区块命令</a></h2>
<ul>
<li><a href="reference/cast/./cast-find-block.html">cast find-block</a></li>
<li><a href="reference/cast/./cast-gas-price.html">cast gas-price</a></li>
<li><a href="reference/cast/./cast-block-number.html">cast block-number</a></li>
<li><a href="reference/cast/./cast-basefee.html">cast basefee</a></li>
<li><a href="reference/cast/./cast-block.html">cast block</a></li>
<li><a href="reference/cast/./cast-age.html">cast age</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-find-block"><a class="header" href="#cast-find-block">cast find-block</a></h2>
<h3 id="name-33"><a class="header" href="#name-33">NAME</a></h3>
<p>cast-find-block - 获取最接近提供时间戳的区块号。</p>
<h3 id="synopsis-32"><a class="header" href="#synopsis-32">SYNOPSIS</a></h3>
<p><code>cast find-block</code> [<em>options</em>] <em>timestamp</em></p>
<h3 id="description-32"><a class="header" href="#description-32">DESCRIPTION</a></h3>
<p>获取最接近提供时间戳的区块号。</p>
<h3 id="options-31"><a class="header" href="#options-31">OPTIONS</a></h3>
<h4 id="rpc-选项-8"><a class="header" href="#rpc-选项-8">RPC 选项</a></h4>
<pre><code class="language-markdown">`--rpc-url` *url*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;RPC 端点。接受一个 URL 或 [rpc_endpoints] 表中已有的别名，例如 `mainnet`。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `ETH_RPC_URL`
</code></pre>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-29"><a class="header" href="#examples-29">EXAMPLES</a></h3>
<ol>
<li>获取最接近2021年新年的区块号
<pre><code class="language-sh">cast find-block 1609459200
</code></pre>
</li>
</ol>
<h3 id="see-also-29"><a class="header" href="#see-also-29">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-gas-price"><a class="header" href="#cast-gas-price">cast gas-price</a></h2>
<h3 id="名称-14"><a class="header" href="#名称-14">名称</a></h3>
<p>cast-gas-price - 获取当前的 gas 价格。</p>
<h3 id="概要-15"><a class="header" href="#概要-15">概要</a></h3>
<p><code>cast gas-price</code> [<em>选项</em>]</p>
<h3 id="描述-15"><a class="header" href="#描述-15">描述</a></h3>
<p>获取当前的 gas 价格。</p>
<h3 id="选项-14"><a class="header" href="#选项-14">选项</a></h3>
<h4 id="rpc-选项-9"><a class="header" href="#rpc-选项-9">RPC 选项</a></h4>
<pre><code class="language-markdown">`--rpc-url` *url*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;RPC 端点。接受一个 URL 或 [rpc_endpoints] 表中已有的别名，例如 `mainnet`。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `ETH_RPC_URL`
</code></pre>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="示例-14"><a class="header" href="#示例-14">示例</a></h3>
<ol>
<li>获取当前的 gas 价格：
<pre><code class="language-sh">cast gas-price
</code></pre>
</li>
</ol>
<h3 id="另请参阅-7"><a class="header" href="#另请参阅-7">另请参阅</a></h3>
<p><a href="reference/cast/./cast.html">cast</a>, <a href="reference/cast/./cast-basefee.html">cast basefee</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-block-number"><a class="header" href="#cast-block-number">cast block-number</a></h2>
<h3 id="name-34"><a class="header" href="#name-34">NAME</a></h3>
<p>cast-block-number - 获取最新的区块号。</p>
<h3 id="synopsis-33"><a class="header" href="#synopsis-33">SYNOPSIS</a></h3>
<p><code>cast block-number</code> [<em>options</em>]</p>
<h3 id="description-33"><a class="header" href="#description-33">DESCRIPTION</a></h3>
<p>获取最新的区块号。</p>
<h3 id="options-32"><a class="header" href="#options-32">OPTIONS</a></h3>
<h4 id="rpc-选项-10"><a class="header" href="#rpc-选项-10">RPC 选项</a></h4>
<pre><code class="language-markdown">`--rpc-url` *url*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;RPC 端点。接受一个 URL 或 [rpc_endpoints] 表中已有的别名，例如 `mainnet`。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `ETH_RPC_URL`
</code></pre>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-30"><a class="header" href="#examples-30">EXAMPLES</a></h3>
<ol>
<li>获取最新的区块号：
<pre><code class="language-sh">cast block-number
</code></pre>
</li>
</ol>
<h3 id="see-also-30"><a class="header" href="#see-also-30">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a>, <a href="reference/cast/./cast-block.html">cast block</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-basefee"><a class="header" href="#cast-basefee">cast basefee</a></h2>
<h3 id="name-35"><a class="header" href="#name-35">NAME</a></h3>
<p>cast-base-fee - 获取区块的基本费用。</p>
<h3 id="synopsis-34"><a class="header" href="#synopsis-34">SYNOPSIS</a></h3>
<p><code>cast base-fee</code> [<em>options</em>] [<em>block</em>]</p>
<h3 id="description-34"><a class="header" href="#description-34">DESCRIPTION</a></h3>
<p>获取区块的基本费用。</p>
<p>指定的 <em>block</em> 可以是区块号，或者是以下标签之一：<code>earliest</code>、<code>finalized</code>、<code>safe</code>、<code>latest</code> 或 <code>pending</code>。默认为 <code>latest</code>。</p>
<h3 id="options-33"><a class="header" href="#options-33">OPTIONS</a></h3>
<h4 id="rpc-选项-11"><a class="header" href="#rpc-选项-11">RPC 选项</a></h4>
<pre><code class="language-markdown">`--rpc-url` *url*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;RPC 端点。接受一个 URL 或 [rpc_endpoints] 表中已有的别名，例如 `mainnet`。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `ETH_RPC_URL`
</code></pre>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-31"><a class="header" href="#examples-31">EXAMPLES</a></h3>
<ol>
<li>
<p>获取最新区块的基本费用：</p>
<pre><code class="language-sh">cast base-fee
</code></pre>
</li>
<li>
<p>获取创世区块的基本费用：</p>
<pre><code class="language-sh">cast base-fee 1
</code></pre>
</li>
</ol>
<h3 id="see-also-31"><a class="header" href="#see-also-31">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a>, <a href="reference/cast/./cast-block.html">cast block</a>, <a href="reference/cast/./cast-age.html">cast age</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-block"><a class="header" href="#cast-block">cast block</a></h2>
<h3 id="name-36"><a class="header" href="#name-36">NAME</a></h3>
<p>cast-block - 获取区块信息。</p>
<h3 id="synopsis-35"><a class="header" href="#synopsis-35">SYNOPSIS</a></h3>
<p><code>cast block</code> [<em>options</em>] [<em>block</em>]</p>
<h3 id="description-35"><a class="header" href="#description-35">DESCRIPTION</a></h3>
<p>获取区块信息。</p>
<p>指定的 <em>block</em> 可以是区块号，或者是以下标签之一：<code>earliest</code>、<code>finalized</code>、<code>safe</code>、<code>latest</code> 或 <code>pending</code>。默认为 <code>latest</code>。</p>
<h3 id="options-34"><a class="header" href="#options-34">OPTIONS</a></h3>
<p><code>-f</code> <em>field</em><br />
<code>--field</code> <em>field</em><br />
     如果指定，仅获取区块的指定字段。</p>
<pre><code class="language-json">{
  "id": "display-options",
  "title": "显示选项"
}
</code></pre>
<h4 id="显示选项-8"><a class="header" href="#显示选项-8">显示选项</a></h4>
<p><code>-j</code><br />
<code>--json</code><br />
     以 JSON 格式打印部署信息。</p>
<h4 id="rpc-options-1"><a class="header" href="#rpc-options-1">RPC Options</a></h4>
<pre><code class="language-markdown">`--rpc-url` *url*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;RPC 端点。接受一个 URL 或 [rpc_endpoints] 表中已有的别名，例如 `mainnet`。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `ETH_RPC_URL`
</code></pre>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-32"><a class="header" href="#examples-32">EXAMPLES</a></h3>
<ol>
<li>
<p>获取最新区块：</p>
<pre><code class="language-sh">cast block
</code></pre>
</li>
<li>
<p>获取 <code>finalized</code> 区块：</p>
<pre><code class="language-sh">cast block finalized
</code></pre>
</li>
<li>
<p>获取最新区块的哈希：</p>
<pre><code class="language-sh">cast block latest -f hash
</code></pre>
</li>
</ol>
<h3 id="see-also-32"><a class="header" href="#see-also-32">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a>, <a href="reference/cast/./cast-basefee.html">cast basefee</a>, <a href="reference/cast/./cast-age.html">cast age</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-age"><a class="header" href="#cast-age">cast age</a></h2>
<h3 id="name-37"><a class="header" href="#name-37">NAME</a></h3>
<p>cast-age - 获取区块的时间戳。</p>
<h3 id="synopsis-36"><a class="header" href="#synopsis-36">SYNOPSIS</a></h3>
<p><code>cast age</code> [<em>options</em>] [<em>block</em>]</p>
<h3 id="description-36"><a class="header" href="#description-36">DESCRIPTION</a></h3>
<p>获取区块的时间戳。</p>
<p>指定的 <em>block</em> 可以是区块号，或者是以下标签之一：<code>earliest</code>、<code>finalized</code>、<code>safe</code>、<code>latest</code> 或 <code>pending</code>。默认为 <code>latest</code>。</p>
<h3 id="options-35"><a class="header" href="#options-35">OPTIONS</a></h3>
<h4 id="rpc-选项-12"><a class="header" href="#rpc-选项-12">RPC 选项</a></h4>
<pre><code class="language-markdown">`--rpc-url` *url*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;RPC 端点。接受一个 URL 或 [rpc_endpoints] 表中已有的别名，例如 `mainnet`。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `ETH_RPC_URL`
</code></pre>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-33"><a class="header" href="#examples-33">EXAMPLES</a></h3>
<ol>
<li>
<p>获取最新区块的时间戳：</p>
<pre><code class="language-sh">cast age
</code></pre>
</li>
<li>
<p>获取创世区块的时间戳：</p>
<pre><code class="language-sh">cast age 1
</code></pre>
</li>
</ol>
<h3 id="see-also-33"><a class="header" href="#see-also-33">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a>, <a href="reference/cast/./cast-block.html">cast block</a>, <a href="reference/cast/./cast-basefee.html">cast basefee</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="账户命令"><a class="header" href="#账户命令">账户命令</a></h2>
<ul>
<li><a href="reference/cast/./cast-balance.html">cast balance</a></li>
<li><a href="reference/cast/./cast-storage.html">cast storage</a></li>
<li><a href="reference/cast/./cast-proof.html">cast proof</a></li>
<li><a href="reference/cast/./cast-nonce.html">cast nonce</a></li>
<li><a href="reference/cast/./cast-code.html">cast code</a></li>
<li><a href="reference/cast/./cast-codesize.html">cast codesize</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-balance"><a class="header" href="#cast-balance">cast balance</a></h2>
<h3 id="name-38"><a class="header" href="#name-38">NAME</a></h3>
<p>cast-balance - 获取账户余额（以 wei 为单位）。</p>
<h3 id="synopsis-37"><a class="header" href="#synopsis-37">SYNOPSIS</a></h3>
<p><code>cast balance</code> [<em>options</em>] <em>who</em></p>
<h3 id="description-37"><a class="header" href="#description-37">DESCRIPTION</a></h3>
<p>获取账户余额。</p>
<p>参数 <em>who</em> 可以是 ENS 名称或地址。</p>
<h3 id="options-36"><a class="header" href="#options-36">OPTIONS</a></h3>
<h4 id="查询选项-4"><a class="header" href="#查询选项-4">查询选项</a></h4>
<p><code>-B</code> <em>block</em><br />
<code>--block</code> <em>block</em><br />
    你想查询的区块高度。</p>
<p>    可以是区块号，或任何标签：<code>earliest</code>、<code>finalized</code>、<code>safe</code>、<code>latest</code> 或 <code>pending</code>。</p>
<p><code>-e</code> <em>ether</em><br />
<code>--ether</code> <em>ether</em><br />
    如果使用此标志，则余额将以 ether 显示。</p>
<h4 id="rpc-选项-13"><a class="header" href="#rpc-选项-13">RPC 选项</a></h4>
<pre><code class="language-markdown">`--rpc-url` *url*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;RPC 端点。接受一个 URL 或 [rpc_endpoints] 表中已有的别名，例如 `mainnet`。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `ETH_RPC_URL`
</code></pre>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-34"><a class="header" href="#examples-34">EXAMPLES</a></h3>
<ol>
<li>
<p>获取 beer.eth 的余额</p>
<pre><code class="language-sh">cast balance beer.eth
</code></pre>
</li>
<li>
<p>使用 RPC URL 获取任何地址的 ERC20 余额</p>
<pre><code class="language-sh"># 加载 .env 文件中的变量
source .env

# 获取 Binance 的 USDT 余额
cast balance --erc20 0xdAC17F958D2ee523a2206206994597C13D831ec7 0xF977814e90dA44bFA03b6295A0616a897441aceC --rpc-url $MAINNET_RPC_URL
</code></pre>
</li>
</ol>
<h3 id="see-also-34"><a class="header" href="#see-also-34">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a>, <a href="reference/cast/./cast-nonce.html">cast nonce</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-storage"><a class="header" href="#cast-storage">cast storage</a></h2>
<h3 id="name-39"><a class="header" href="#name-39">NAME</a></h3>
<p>cast-storage - 获取合约存储槽的原始值或其完整的存储布局。</p>
<h3 id="synopsis-38"><a class="header" href="#synopsis-38">SYNOPSIS</a></h3>
<p><code>cast storage</code> [<em>options</em>] <em>address</em> <em>slot</em></p>
<h3 id="description-38"><a class="header" href="#description-38">DESCRIPTION</a></h3>
<p>获取合约存储槽的原始值。（槽位置大于 18446744073709551615 (u64::MAX) 的应使用十六进制表示。使用 <code>cast index</code> 计算映射槽。）</p>
<p>发出槽号以获取完整的存储布局（要求合约在 Etherscan 上验证且 Solidity 版本 &gt; 0.6.5，或者你必须在一个包含与部署字节码匹配的本地合约的 Forge 项目中）。</p>
<p>地址 (<em>address</em>) 可以是 ENS 名称或地址。</p>
<h3 id="options-37"><a class="header" href="#options-37">OPTIONS</a></h3>
<h4 id="查询选项-5"><a class="header" href="#查询选项-5">查询选项</a></h4>
<p><code>-B</code> <em>block</em>
<code>--block</code> <em>block</em>
    你想要查询的区块高度。</p>
<p>    可以是区块号，或任何标签：<code>earliest</code>、<code>finalized</code>、<code>safe</code>、<code>latest</code> 或 <code>pending</code>。</p>
<h4 id="rpc-选项-14"><a class="header" href="#rpc-选项-14">RPC 选项</a></h4>
<pre><code class="language-markdown">`--rpc-url` *url*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;RPC 端点。接受一个 URL 或 [rpc_endpoints] 表中已有的别名，例如 `mainnet`。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `ETH_RPC_URL`
</code></pre>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-35"><a class="header" href="#examples-35">EXAMPLES</a></h3>
<ol>
<li>
<p>获取 WETH 合约槽 0 的值。</p>
<pre><code class="language-sh">cast storage 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2 0
</code></pre>
</li>
<li>
<p>获取 Milady 合约的完整存储布局。</p>
<pre><code class="language-sh">cast storage 0x5Af0D9827E0c53E4799BB226655A1de152A425a5
</code></pre>
</li>
</ol>
<h3 id="see-also-35"><a class="header" href="#see-also-35">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a>, <a href="reference/cast/./cast-proof.html">cast proof</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-proof"><a class="header" href="#cast-proof">cast proof</a></h2>
<h3 id="name-40"><a class="header" href="#name-40">NAME</a></h3>
<p>cast-proof - 生成给定存储槽的存储证明。</p>
<h3 id="synopsis-39"><a class="header" href="#synopsis-39">SYNOPSIS</a></h3>
<p><code>cast proof</code> [<em>options</em>] <em>address</em> [<em>slots…</em>]</p>
<h3 id="description-39"><a class="header" href="#description-39">DESCRIPTION</a></h3>
<p>生成给定存储槽的存储证明。</p>
<p>地址（<em>address</em>）可以是 ENS 名称或地址。</p>
<p>显示的输出是一个 JSON 对象，包含以下键：</p>
<ul>
<li><code>accountProof</code>：账户本身的证明</li>
<li><code>address</code>：账户地址</li>
<li><code>balance</code>：账户余额</li>
<li><code>codeHash</code>：账户代码的哈希</li>
<li><code>nonce</code>：账户的 nonce</li>
<li><code>storageHash</code>：账户存储的哈希</li>
<li><code>storageProof</code>：存储证明的数组，每个请求的槽一个</li>
<li><code>storageProof.key</code>：槽</li>
<li><code>storageProof.proof</code>：槽的证明</li>
<li><code>storageProof.value</code>：槽的值</li>
</ul>
<h3 id="options-38"><a class="header" href="#options-38">OPTIONS</a></h3>
<h4 id="查询选项-6"><a class="header" href="#查询选项-6">查询选项</a></h4>
<p><code>-B</code> <em>block</em><br />
<code>--block</code> <em>block</em><br />
    你想要查询的区块高度。</p>
<p>    可以是区块号，或任何标签：<code>earliest</code>、<code>finalized</code>、<code>safe</code>、<code>latest</code> 或 <code>pending</code>。</p>
<h4 id="rpc-选项-15"><a class="header" href="#rpc-选项-15">RPC 选项</a></h4>
<pre><code class="language-markdown">`--rpc-url` *url*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;RPC 端点。接受一个 URL 或 [rpc_endpoints] 表中已有的别名，例如 `mainnet`。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `ETH_RPC_URL`
</code></pre>
<pre><code class="language-json">{
  "id": "display-options",
  "title": "显示选项"
}
</code></pre>
<h4 id="显示选项-9"><a class="header" href="#显示选项-9">显示选项</a></h4>
<p><code>-j</code><br />
<code>--json</code><br />
     以 JSON 格式打印部署信息。</p>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-36"><a class="header" href="#examples-36">EXAMPLES</a></h3>
<ol>
<li>获取 WETH 合约存储槽 0 的证明：
<pre><code class="language-sh">cast proof 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2 0
</code></pre>
</li>
</ol>
<h3 id="see-also-36"><a class="header" href="#see-also-36">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a>, <a href="reference/cast/./cast-storage.html">cast storage</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-nonce"><a class="header" href="#cast-nonce">cast nonce</a></h2>
<h3 id="name-41"><a class="header" href="#name-41">NAME</a></h3>
<p>cast-nonce - 获取账户的nonce值。</p>
<h3 id="synopsis-40"><a class="header" href="#synopsis-40">SYNOPSIS</a></h3>
<p><code>cast nonce</code> [<em>options</em>] <em>who</em></p>
<h3 id="description-40"><a class="header" href="#description-40">DESCRIPTION</a></h3>
<p>获取账户的nonce值。</p>
<p>参数 <em>who</em> 可以是ENS名称或地址。</p>
<h3 id="options-39"><a class="header" href="#options-39">OPTIONS</a></h3>
<h4 id="查询选项-7"><a class="header" href="#查询选项-7">查询选项</a></h4>
<p><code>-B</code> <em>block</em><br />
<code>--block</code> <em>block</em><br />
    你想查询的区块高度。</p>
<p>    可以是区块号，或以下任一标签：<code>earliest</code>、<code>finalized</code>、<code>safe</code>、<code>latest</code> 或 <code>pending</code>。</p>
<h4 id="rpc选项"><a class="header" href="#rpc选项">RPC选项</a></h4>
<pre><code class="language-markdown">`--rpc-url` *url*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;RPC 端点。接受一个 URL 或 [rpc_endpoints] 表中已有的别名，例如 `mainnet`。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `ETH_RPC_URL`
</code></pre>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-37"><a class="header" href="#examples-37">EXAMPLES</a></h3>
<ol>
<li>获取 beer.eth 的nonce值
<pre><code class="language-sh">cast nonce beer.eth
</code></pre>
</li>
</ol>
<h3 id="see-also-37"><a class="header" href="#see-also-37">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a>, <a href="reference/cast/./cast-balance.html">cast balance</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-code"><a class="header" href="#cast-code">cast code</a></h2>
<h3 id="name-42"><a class="header" href="#name-42">NAME</a></h3>
<p>cast-code - 获取合约的字节码。</p>
<h3 id="synopsis-41"><a class="header" href="#synopsis-41">SYNOPSIS</a></h3>
<p><code>cast code</code> [<em>options</em>] <em>address</em></p>
<h3 id="description-41"><a class="header" href="#description-41">DESCRIPTION</a></h3>
<p>获取合约的字节码。</p>
<p>合约（<em>address</em>）可以是 ENS 名称或地址。</p>
<h3 id="options-40"><a class="header" href="#options-40">OPTIONS</a></h3>
<h4 id="查询选项-8"><a class="header" href="#查询选项-8">查询选项</a></h4>
<p><code>-B</code> <em>block</em><br />
<code>--block</code> <em>block</em><br />
    你想查询的区块高度。</p>
<p>    可以是区块号，或以下任一标签：<code>earliest</code>、<code>finalized</code>、<code>safe</code>、<code>latest</code> 或 <code>pending</code>。</p>
<h4 id="rpc-选项-16"><a class="header" href="#rpc-选项-16">RPC 选项</a></h4>
<pre><code class="language-markdown">`--rpc-url` *url*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;RPC 端点。接受一个 URL 或 [rpc_endpoints] 表中已有的别名，例如 `mainnet`。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `ETH_RPC_URL`
</code></pre>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-38"><a class="header" href="#examples-38">EXAMPLES</a></h3>
<ol>
<li>获取 WETH 合约的字节码。
<pre><code class="language-sh">cast code 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2
</code></pre>
</li>
</ol>
<h3 id="see-also-38"><a class="header" href="#see-also-38">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a>, <a href="reference/cast/./cast-proof.html">cast proof</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-codesize"><a class="header" href="#cast-codesize">cast codesize</a></h2>
<h3 id="name-43"><a class="header" href="#name-43">NAME</a></h3>
<p>cast-codesize - 获取合约的运行时代码大小。</p>
<h3 id="synopsis-42"><a class="header" href="#synopsis-42">SYNOPSIS</a></h3>
<p><code>cast codesize</code> [<em>options</em>] <em>address</em></p>
<h3 id="description-42"><a class="header" href="#description-42">DESCRIPTION</a></h3>
<p>获取合约的运行时代码大小。</p>
<p>合约（<em>address</em>）可以是 ENS 名称或地址。</p>
<h3 id="options-41"><a class="header" href="#options-41">OPTIONS</a></h3>
<h4 id="查询选项-9"><a class="header" href="#查询选项-9">查询选项</a></h4>
<p><code>-B</code> <em>block</em><br />
<code>--block</code> <em>block</em><br />
    你想查询的区块高度。</p>
<p>    可以是区块号，或以下任一标签：<code>earliest</code>、<code>finalized</code>、<code>safe</code>、<code>latest</code> 或 <code>pending</code>。</p>
<h4 id="rpc-选项-17"><a class="header" href="#rpc-选项-17">RPC 选项</a></h4>
<pre><code class="language-markdown">`--rpc-url` *url*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;RPC 端点。接受一个 URL 或 [rpc_endpoints] 表中已有的别名，例如 `mainnet`。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `ETH_RPC_URL`
</code></pre>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-39"><a class="header" href="#examples-39">EXAMPLES</a></h3>
<ol>
<li>获取 WETH 合约的运行时代码大小。</li>
</ol>
<pre><code class="language-sh">cast codesize 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2
</code></pre>
<h3 id="see-also-39"><a class="header" href="#see-also-39">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a>, <a href="reference/cast/./cast-code.html">cast code</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ens-命令"><a class="header" href="#ens-命令">ENS 命令</a></h2>
<ul>
<li><a href="reference/cast/./cast-lookup-address.html">cast lookup-address</a></li>
<li><a href="reference/cast/./cast-resolve-name.html">cast resolve-name</a></li>
<li><a href="reference/cast/./cast-namehash.html">cast namehash</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-lookup-address"><a class="header" href="#cast-lookup-address">cast lookup-address</a></h2>
<h3 id="name-44"><a class="header" href="#name-44">NAME</a></h3>
<p>cast-lookup-address - 执行 ENS 反向查找。</p>
<h3 id="synopsis-43"><a class="header" href="#synopsis-43">SYNOPSIS</a></h3>
<p><code>cast lookup-address</code> [<em>options</em>] <em>who</em></p>
<h3 id="description-43"><a class="header" href="#description-43">DESCRIPTION</a></h3>
<p>执行 ENS 反向查找。</p>
<p>如果传递 <code>--verify</code>，则在反向查找之后执行正常查找以验证地址是否正确。</p>
<h3 id="options-42"><a class="header" href="#options-42">OPTIONS</a></h3>
<h4 id="查找选项"><a class="header" href="#查找选项">查找选项</a></h4>
<p><code>-v</code><br />
<code>--verify</code><br />
    执行正常查找以验证地址是否正确。</p>
<h4 id="rpc-选项-18"><a class="header" href="#rpc-选项-18">RPC 选项</a></h4>
<pre><code class="language-markdown">`--rpc-url` *url*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;RPC 端点。接受一个 URL 或 [rpc_endpoints] 表中已有的别名，例如 `mainnet`。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `ETH_RPC_URL`
</code></pre>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-40"><a class="header" href="#examples-40">EXAMPLES</a></h3>
<ol>
<li>
<p>获取地址的 ENS 名称。</p>
<pre><code class="language-sh">cast lookup-address $ADDRESS
</code></pre>
</li>
<li>
<p>执行反向查找和正常查找：</p>
<pre><code class="language-sh">cast lookup-address --verify $ADDRESS
</code></pre>
</li>
</ol>
<h3 id="see-also-40"><a class="header" href="#see-also-40">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a>, <a href="reference/cast/./cast-resolve-name.html">cast resolve-name</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-resolve-name"><a class="header" href="#cast-resolve-name">cast resolve-name</a></h2>
<h3 id="name-45"><a class="header" href="#name-45">NAME</a></h3>
<p>cast-resolve-name - 执行 ENS 查询。</p>
<h3 id="synopsis-44"><a class="header" href="#synopsis-44">SYNOPSIS</a></h3>
<p><code>cast resolve-name</code> [<em>options</em>] <em>who</em></p>
<h3 id="description-44"><a class="header" href="#description-44">DESCRIPTION</a></h3>
<p>执行 ENS 查询。</p>
<p>如果传递 <code>--verify</code>，则在正常查询之后执行反向查询以验证名称是否正确。</p>
<h3 id="options-43"><a class="header" href="#options-43">OPTIONS</a></h3>
<h4 id="查询选项-10"><a class="header" href="#查询选项-10">查询选项</a></h4>
<p><code>-v</code><br />
<code>--verify</code><br />
    执行反向查询以验证名称是否正确。</p>
<h4 id="rpc-选项-19"><a class="header" href="#rpc-选项-19">RPC 选项</a></h4>
<pre><code class="language-markdown">`--rpc-url` *url*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;RPC 端点。接受一个 URL 或 [rpc_endpoints] 表中已有的别名，例如 `mainnet`。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `ETH_RPC_URL`
</code></pre>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-41"><a class="header" href="#examples-41">EXAMPLES</a></h3>
<ol>
<li>
<p>获取 ENS 名称的地址。</p>
<pre><code class="language-sh">cast resolve-name vitalik.eth
</code></pre>
</li>
<li>
<p>执行正常查询和反向查询：</p>
<pre><code class="language-sh">cast resolve-name --verify vitalik.eth
</code></pre>
</li>
</ol>
<h3 id="see-also-41"><a class="header" href="#see-also-41">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a>, <a href="reference/cast/./cast-lookup-address.html">cast lookup-address</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-namehash"><a class="header" href="#cast-namehash">cast namehash</a></h2>
<h3 id="name-46"><a class="header" href="#name-46">NAME</a></h3>
<p>cast-namehash - 计算 ENS 名称的 namehash。</p>
<h3 id="synopsis-45"><a class="header" href="#synopsis-45">SYNOPSIS</a></h3>
<p><code>cast namehash</code> [<em>options</em>] <em>name</em></p>
<h3 id="description-45"><a class="header" href="#description-45">DESCRIPTION</a></h3>
<p>计算 ENS 名称的 namehash。</p>
<h3 id="options-44"><a class="header" href="#options-44">OPTIONS</a></h3>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-42"><a class="header" href="#examples-42">EXAMPLES</a></h3>
<ol>
<li>计算 ENS 名称的 namehash。
<pre><code class="language-sh">cast namehash vitalik.eth
</code></pre>
</li>
</ol>
<h3 id="see-also-42"><a class="header" href="#see-also-42">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a>, <a href="reference/cast/./cast-lookup-address.html">cast lookup-address</a>, <a href="reference/cast/./cast-resolve-name.html">cast resolve-name</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="etherscan-命令"><a class="header" href="#etherscan-命令">Etherscan 命令</a></h2>
<ul>
<li><a href="reference/cast/./cast-etherscan-source.html">cast etherscan-source</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-etherscan-source"><a class="header" href="#cast-etherscan-source">cast etherscan-source</a></h2>
<h3 id="name-47"><a class="header" href="#name-47">NAME</a></h3>
<p>cast-etherscan-source - 从Etherscan获取合约的源代码。</p>
<h3 id="synopsis-46"><a class="header" href="#synopsis-46">SYNOPSIS</a></h3>
<p><code>cast etherscan-source</code> [<em>options</em>] <em>address</em></p>
<h3 id="description-46"><a class="header" href="#description-46">DESCRIPTION</a></h3>
<p>从Etherscan获取合约的源代码。</p>
<p>目标地址（<em>to</em>）可以是ENS名称或地址。</p>
<h3 id="options-45"><a class="header" href="#options-45">OPTIONS</a></h3>
<h4 id="输出选项"><a class="header" href="#输出选项">输出选项</a></h4>
<p><code>-d</code> <em>directory</em><br />
    将源代码树展开到的输出目录。
    如果未提供，源代码将输出到标准输出。</p>
<pre><code class="language-markdown">#### Etherscan 选项

`--chain` *chain_name*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Etherscan 链。

`--etherscan-api-key` *key*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Etherscan API 密钥，或 [Etherscan 配置表](../config/etherscan.md#etherscan) 中的密钥。  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `ETHERSCAN_API_KEY`
</code></pre>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-43"><a class="header" href="#examples-43">EXAMPLES</a></h3>
<ol>
<li>
<p>获取WETH合约的源代码：</p>
<pre><code class="language-sh">cast etherscan-source 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2
</code></pre>
</li>
<li>
<p>将WETH合约的源代码展开到一个名为<code>weth</code>的目录中：</p>
<pre><code class="language-sh">cast etherscan-source -d weth 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2
</code></pre>
</li>
</ol>
<h3 id="see-also-43"><a class="header" href="#see-also-43">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="abi-命令"><a class="header" href="#abi-命令">ABI 命令</a></h2>
<ul>
<li><a href="reference/cast/./cast-abi-decode.html">cast abi-decode</a></li>
<li><a href="reference/cast/./cast-abi-encode.html">cast abi-encode</a></li>
<li><a href="reference/cast/./cast-4byte.html">cast 4byte</a></li>
<li><a href="reference/cast/./cast-4byte-decode.html">cast 4byte-decode</a></li>
<li><a href="reference/cast/./cast-4byte-event.html">cast 4byte-event</a></li>
<li><a href="reference/cast/./cast-calldata.html">cast calldata</a></li>
<li><a href="reference/cast/./cast-calldata-decode.html">cast calldata-decode</a></li>
<li><a href="reference/cast/./cast-pretty-calldata.html">cast pretty-calldata</a></li>
<li><a href="reference/cast/./cast-selectors.html">cast selectors</a></li>
<li><a href="reference/cast/./cast-upload-signature.html">cast upload-signature</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-abi-decode"><a class="header" href="#cast-abi-decode">cast abi-decode</a></h2>
<h3 id="name-48"><a class="header" href="#name-48">NAME</a></h3>
<p>cast-abi-decode - 解码 ABI 编码的输入或输出数据。</p>
<h3 id="synopsis-47"><a class="header" href="#synopsis-47">SYNOPSIS</a></h3>
<p><code>cast abi-decode</code> [<em>options</em>] <em>sig</em> <em>calldata</em></p>
<h3 id="description-47"><a class="header" href="#description-47">DESCRIPTION</a></h3>
<p>解码 ABI 编码的输入或输出数据。</p>
<p>默认情况下，该命令将解码输出数据。要解码输入数据，请传递 <code>--input</code> 或使用 <a href="reference/cast/./cast-calldata-decode.html"><code>cast calldata-decode</code></a>。</p>
<p>签名 (<em>sig</em>) 是形式为 <code>&lt;function name&gt;(&lt;types...&gt;)(&lt;types...&gt;)</code> 的片段。</p>
<h3 id="options-46"><a class="header" href="#options-46">OPTIONS</a></h3>
<h4 id="解码器选项"><a class="header" href="#解码器选项">解码器选项</a></h4>
<p><code>-i</code><br />
<code>--input</code><br />
    解码输入数据。</p>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-44"><a class="header" href="#examples-44">EXAMPLES</a></h3>
<ol>
<li>
<p>解码 <code>balanceOf</code> 调用的输出数据：</p>
<pre><code class="language-sh">cast abi-decode "balanceOf(address)(uint256)" \
  0x000000000000000000000000000000000000000000000000000000000000000a
</code></pre>
</li>
<li>
<p>解码 <code>transfer</code> 调用的输入数据：</p>
<pre><code class="language-sh">cast abi-decode --input "transfer(address,uint256)" \
  0xa9059cbb000000000000000000000000e78388b4ce79068e89bf8aa7f218ef6b9ab0e9d0000000000000000000000000000000000000000000000000008a8e4b1a3d8000
</code></pre>
</li>
</ol>
<h3 id="see-also-44"><a class="header" href="#see-also-44">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a>, <a href="reference/cast/./cast-calldata-decode.html">cast calldata-decode</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-abi-encode"><a class="header" href="#cast-abi-encode">cast abi-encode</a></h2>
<h3 id="name-49"><a class="header" href="#name-49">NAME</a></h3>
<p>cast-abi-encode - ABI 编码给定的函数参数，不包括选择器。</p>
<h3 id="synopsis-48"><a class="header" href="#synopsis-48">SYNOPSIS</a></h3>
<p><code>cast abi-encode</code> [<em>options</em>] <em>sig</em> [<em>args…</em>]</p>
<h3 id="description-48"><a class="header" href="#description-48">DESCRIPTION</a></h3>
<p>ABI 编码给定的函数，不包括选择器。</p>
<p>签名 (<em>sig</em>) 是一个形式为 <code>&lt;function name&gt;(&lt;types...&gt;)</code> 的片段。</p>
<h3 id="options-47"><a class="header" href="#options-47">OPTIONS</a></h3>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-45"><a class="header" href="#examples-45">EXAMPLES</a></h3>
<ol>
<li>
<p>ABI 编码调用 <code>someFunc(address,uint256)</code> 的参数：</p>
<pre><code class="language-sh">cast abi-encode "someFunc(address,uint256)" 0x... 1
</code></pre>
</li>
<li>
<p>对于编码包含组件的类型（如元组或自定义结构体）：</p>
<pre><code class="language-sh">cast abi-encode "someFunc((string,uint256))" "(myString,1)"
</code></pre>
</li>
</ol>
<h3 id="see-also-45"><a class="header" href="#see-also-45">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a>, <a href="reference/cast/./cast-calldata.html">cast calldata</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-4byte"><a class="header" href="#cast-4byte">cast 4byte</a></h2>
<h3 id="name-50"><a class="header" href="#name-50">NAME</a></h3>
<p>cast-4byte - 从 <a href="https://sig.eth.samczsun.com" target="_blank">https://sig.eth.samczsun.com</a> 获取给定选择器的函数签名。</p>
<h3 id="synopsis-49"><a class="header" href="#synopsis-49">SYNOPSIS</a></h3>
<p><code>cast 4byte</code> [<em>options</em>] <em>sig</em></p>
<h3 id="description-49"><a class="header" href="#description-49">DESCRIPTION</a></h3>
<p>从 <a href="https://sig.eth.samczsun.com" target="_blank">https://sig.eth.samczsun.com</a> 获取给定选择器的函数签名。</p>
<h3 id="options-48"><a class="header" href="#options-48">OPTIONS</a></h3>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-46"><a class="header" href="#examples-46">EXAMPLES</a></h3>
<ol>
<li>获取选择器 <code>0x8cc5ce99</code> 的函数签名：
<pre><code class="language-sh">cast 4byte 0x8cc5ce99
</code></pre>
</li>
</ol>
<h3 id="see-also-46"><a class="header" href="#see-also-46">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a>, <a href="reference/cast/./cast-4byte-decode.html">cast 4byte-decode</a>, <a href="reference/cast/./cast-4byte-event.html">cast 4byte-event</a>, <a href="reference/cast/./cast-selectors.html">cast selectors</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-4byte-decode"><a class="header" href="#cast-4byte-decode">cast 4byte-decode</a></h2>
<h3 id="name-51"><a class="header" href="#name-51">NAME</a></h3>
<p>cast-4byte-decode - 使用 <a href="https://sig.eth.samczsun.com" target="_blank">https://sig.eth.samczsun.com</a> 解码 ABI 编码的调用数据。</p>
<h3 id="synopsis-50"><a class="header" href="#synopsis-50">SYNOPSIS</a></h3>
<p><code>cast 4byte-decode</code> [<em>options</em>] <em>calldata</em></p>
<h3 id="description-50"><a class="header" href="#description-50">DESCRIPTION</a></h3>
<p>使用 <a href="https://sig.eth.samczsun.com" target="_blank">https://sig.eth.samczsun.com</a> 解码 ABI 编码的调用数据。</p>
<h3 id="options-49"><a class="header" href="#options-49">OPTIONS</a></h3>
<h4 id="4byte-选项"><a class="header" href="#4byte-选项">4byte 选项</a></h4>
<p><code>--id</code> <em>id</em><br />
    要使用的解析签名的索引。
    <br />
    <a href="https://sig.eth.samczsun.com" target="_blank">https://sig.eth.samczsun.com</a> 可以为给定的选择器提供多个可能的签名。<br />
    索引可以是整数，或者是标签 “earliest” 和 “latest”。</p>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-47"><a class="header" href="#examples-47">EXAMPLES</a></h3>
<ol>
<li>解码 <code>transfer</code> 调用的调用数据：
<pre><code class="language-sh">cast 4byte-decode 0xa9059cbb000000000000000000000000e78388b4ce79068e89bf8aa7f218ef6b9ab0e9d00000000000000000000000000000000000000000000000000174b37380cea000
</code></pre>
</li>
</ol>
<h3 id="see-also-47"><a class="header" href="#see-also-47">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a>, <a href="reference/cast/./cast-4byte.html">cast 4byte</a>, <a href="reference/cast/./cast-4byte-event.html">cast 4byte-event</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-4byte-event"><a class="header" href="#cast-4byte-event">cast 4byte-event</a></h2>
<h3 id="name-52"><a class="header" href="#name-52">NAME</a></h3>
<p>cast-4byte-event - 从 <a href="https://sig.eth.samczsun.com" target="_blank">https://sig.eth.samczsun.com</a> 获取给定 topic 0 的事件签名。</p>
<h3 id="synopsis-51"><a class="header" href="#synopsis-51">SYNOPSIS</a></h3>
<p><code>cast 4byte-event</code> [<em>options</em>] <em>topic_0</em></p>
<h3 id="description-51"><a class="header" href="#description-51">DESCRIPTION</a></h3>
<p>从 <a href="https://sig.eth.samczsun.com" target="_blank">https://sig.eth.samczsun.com</a> 获取给定 topic 0 的事件签名。</p>
<h3 id="options-50"><a class="header" href="#options-50">OPTIONS</a></h3>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-48"><a class="header" href="#examples-48">EXAMPLES</a></h3>
<ol>
<li>获取 topic 0 为 <code>0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef</code> 的事件签名：
<pre><code class="language-sh">cast 4byte-event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef
</code></pre>
</li>
</ol>
<h3 id="see-also-48"><a class="header" href="#see-also-48">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a>, <a href="reference/cast/./cast-4byte.html">cast 4byte</a>, <a href="reference/cast/./cast-4byte-decode.html">cast 4byte-decode</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-calldata"><a class="header" href="#cast-calldata">cast calldata</a></h2>
<h3 id="name-53"><a class="header" href="#name-53">NAME</a></h3>
<p>cast-calldata - ABI 编码带有参数的函数。</p>
<h3 id="synopsis-52"><a class="header" href="#synopsis-52">SYNOPSIS</a></h3>
<p><code>cast calldata</code> [<em>options</em>] <em>sig</em> [<em>args…</em>]</p>
<h3 id="description-52"><a class="header" href="#description-52">DESCRIPTION</a></h3>
<p>ABI 编码带有参数的函数。</p>
<p>签名 (<em>sig</em>) 是一个形式为 <code>&lt;function name&gt;(&lt;types...&gt;)</code> 的片段。</p>
<h3 id="options-51"><a class="header" href="#options-51">OPTIONS</a></h3>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-49"><a class="header" href="#examples-49">EXAMPLES</a></h3>
<ol>
<li>ABI 编码调用 <code>someFunc(address,uint256)</code> 的参数：
<pre><code class="language-sh">cast calldata "someFunc(address,uint256)" 0x... 1
</code></pre>
</li>
</ol>
<h3 id="see-also-49"><a class="header" href="#see-also-49">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a>, <a href="reference/cast/./cast-abi-encode.html">cast abi-encode</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-calldata-decode"><a class="header" href="#cast-calldata-decode">cast calldata-decode</a></h2>
<h3 id="name-54"><a class="header" href="#name-54">NAME</a></h3>
<p>cast-calldata-decode - 解码 ABI 编码的输入数据。</p>
<h3 id="synopsis-53"><a class="header" href="#synopsis-53">SYNOPSIS</a></h3>
<p><code>cast calldata-decode</code> [<em>options</em>] <em>sig</em> <em>calldata</em></p>
<h3 id="description-53"><a class="header" href="#description-53">DESCRIPTION</a></h3>
<p>解码 ABI 编码的输入数据。</p>
<p>签名（<em>sig</em>）是一个形式为 <code>&lt;function name&gt;(&lt;types...&gt;)</code> 的片段。</p>
<h3 id="options-52"><a class="header" href="#options-52">OPTIONS</a></h3>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-50"><a class="header" href="#examples-50">EXAMPLES</a></h3>
<ol>
<li>解码 <code>transfer</code> 调用的输入数据：
<pre><code class="language-sh">cast calldata-decode "transfer(address,uint256)" \
  0xa9059cbb000000000000000000000000e78388b4ce79068e89bf8aa7f218ef6b9ab0e9d0000000000000000000000000000000000000000000000000008a8e4b1a3d8000
</code></pre>
</li>
</ol>
<h3 id="see-also-50"><a class="header" href="#see-also-50">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a>, <a href="reference/cast/./cast-abi-decode.html">cast abi-decode</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-pretty-calldata"><a class="header" href="#cast-pretty-calldata">cast pretty-calldata</a></h2>
<h3 id="name-55"><a class="header" href="#name-55">NAME</a></h3>
<p>cast-pretty-calldata - 美化打印 calldata。</p>
<h3 id="synopsis-54"><a class="header" href="#synopsis-54">SYNOPSIS</a></h3>
<p><code>cast pretty-calldata</code> [<em>options</em>] <em>calldata</em></p>
<h3 id="description-54"><a class="header" href="#description-54">DESCRIPTION</a></h3>
<p>美化打印 calldata。</p>
<p>除非传递 <code>--offline</code>，否则会尝试使用 <a href="https://sig.eth.samczsun.com" target="_blank">https://sig.eth.samczsun.com</a> 解码 calldata。</p>
<h3 id="options-53"><a class="header" href="#options-53">OPTIONS</a></h3>
<h4 id="4byte-选项-1"><a class="header" href="#4byte-选项-1">4byte 选项</a></h4>
<p><code>-o</code><br />
<code>--offline</code><br />
    跳过 <a href="https://sig.eth.samczsun.com" target="_blank">https://sig.eth.samczsun.com</a> 的查找。</p>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-51"><a class="header" href="#examples-51">EXAMPLES</a></h3>
<ol>
<li>解码 <code>transfer</code> 调用的 calldata：
<pre><code class="language-sh">cast pretty-calldata 0xa9059cbb000000000000000000000000e78388b4ce79068e89bf8aa7f218ef6b9ab0e9d00000000000000000000000000000000000000000000000000174b37380cea000
</code></pre>
</li>
</ol>
<h3 id="see-also-51"><a class="header" href="#see-also-51">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a>, <a href="reference/cast/./cast-4byte-decode.html">cast 4byte-decode</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-selectors"><a class="header" href="#cast-selectors">cast selectors</a></h2>
<h3 id="name-56"><a class="header" href="#name-56">NAME</a></h3>
<p>cast-selectors - 从字节码中提取函数选择器和参数</p>
<h3 id="synopsis-55"><a class="header" href="#synopsis-55">SYNOPSIS</a></h3>
<p><code>cast selectors</code> [<em>options</em>] <em>bytecode</em></p>
<h3 id="description-55"><a class="header" href="#description-55">DESCRIPTION</a></h3>
<p>使用 <a href="https://github.com/cdump/evmole" title="" target="_blank">EVMole 库</a> 从字节码中提取函数选择器和参数</p>
<h3 id="options-54"><a class="header" href="#options-54">OPTIONS</a></h3>
<p><code>-r</code><br />
<code>--resolve</code><br />
    使用 https://openchain.xyz 解析提取的选择器的函数签名</p>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-52"><a class="header" href="#examples-52">EXAMPLES</a></h3>
<ol>
<li>获取 WETH 合约的函数签名和参数：
<pre><code class="language-sh">cast selectors $(cast code 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)
</code></pre>
</li>
</ol>
<h3 id="see-also-52"><a class="header" href="#see-also-52">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a>, <a href="reference/cast/./cast-4byte.html">cast 4byte</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-upload-signature"><a class="header" href="#cast-upload-signature">cast upload-signature</a></h2>
<h3 id="name-57"><a class="header" href="#name-57">NAME</a></h3>
<p>cast-upload-signature</p>
<h3 id="synopsis-56"><a class="header" href="#synopsis-56">SYNOPSIS</a></h3>
<p><code>cast upload-signature</code> [<em>signatures…</em>]</p>
<h3 id="description-56"><a class="header" href="#description-56">DESCRIPTION</a></h3>
<p>将给定的签名上传到 <a href="https://sig.eth.samczsun.com" title="" target="_blank">https://sig.eth.samczsun.com</a>。</p>
<h3 id="options-55"><a class="header" href="#options-55">OPTIONS</a></h3>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-53"><a class="header" href="#examples-53">EXAMPLES</a></h3>
<ol>
<li>上传签名
<pre><code class="language-sh">cast upload-signature 'function approve(address,uint256)' \
'transfer(uint256)' 'event Transfer(uint256,address)'
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h2 id="转换命令"><a class="header" href="#转换命令">转换命令</a></h2>
<ul>
<li><a href="reference/cast/./cast-format-bytes32-string.html">cast format-bytes32-string</a></li>
<li><a href="reference/cast/./cast-from-bin.html">cast from-bin</a></li>
<li><a href="reference/cast/./cast-from-fixed-point.html">cast from-fixed-point</a></li>
<li><a href="reference/cast/./cast-from-rlp.html">cast from-rlp</a></li>
<li><a href="reference/cast/./cast-from-utf8.html">cast from-utf8</a></li>
<li><a href="reference/cast/./cast-from-wei.html">cast from-wei</a></li>
<li><a href="reference/cast/./cast-parse-bytes32-address.html">cast parse-bytes32-address</a></li>
<li><a href="reference/cast/./cast-parse-bytes32-string.html">cast parse-bytes32-string</a></li>
<li><a href="reference/cast/./cast-to-ascii.html">cast to-ascii</a></li>
<li><a href="reference/cast/./cast-to-base.html">cast to-base</a></li>
<li><a href="reference/cast/./cast-to-bytes32.html">cast to-bytes32</a></li>
<li><a href="reference/cast/./cast-to-dec.html">cast to-dec</a></li>
<li><a href="reference/cast/./cast-to-fixed-point.html">cast to-fixed-point</a></li>
<li><a href="reference/cast/./cast-to-hex.html">cast to-hex</a></li>
<li><a href="reference/cast/./cast-to-hexdata.html">cast to-hexdata</a></li>
<li><a href="reference/cast/./cast-to-int256.html">cast to-int256</a></li>
<li><a href="reference/cast/./cast-to-rlp.html">cast to-rlp</a></li>
<li><a href="reference/cast/./cast-to-uint256.html">cast to-uint256</a></li>
<li><a href="reference/cast/./cast-to-unit.html">cast to-unit</a></li>
<li><a href="reference/cast/./cast-to-wei.html">cast to-wei</a></li>
<li><a href="reference/cast/./cast-shl.html">cast shl</a></li>
<li><a href="reference/cast/./cast-shr.html">cast shr</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-format-bytes32-string"><a class="header" href="#cast-format-bytes32-string">cast format-bytes32-string</a></h2>
<h3 id="name-58"><a class="header" href="#name-58">NAME</a></h3>
<p>cast-format-bytes32-string - 将字符串格式化为 bytes32 编码。</p>
<h3 id="synopsis-57"><a class="header" href="#synopsis-57">SYNOPSIS</a></h3>
<p><code>cast format-bytes32-string</code> [<em>options</em>] <em>string</em></p>
<h3 id="description-57"><a class="header" href="#description-57">DESCRIPTION</a></h3>
<p>将字符串格式化为 bytes32 编码。</p>
<p>请注意，此命令仅用于将 <a href="https://docs.soliditylang.org/en/v0.8.16/types.html#string-literals-and-types" title="" target="_blank">Solidity 字符串字面量</a> 格式化为 <code>bytes32</code>。如果您需要填充字节字符串，请使用 <a href="reference/cast/./cast-to-bytes32.html">to-bytes32</a>。</p>
<h3 id="options-56"><a class="header" href="#options-56">OPTIONS</a></h3>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-54"><a class="header" href="#examples-54">EXAMPLES</a></h3>
<ol>
<li>将字符串 “hello” 转换为 bytes32 十六进制：
<pre><code class="language-sh">cast format-bytes32-string "hello"
</code></pre>
</li>
</ol>
<h3 id="see-also-53"><a class="header" href="#see-also-53">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-from-bin"><a class="header" href="#cast-from-bin">cast from-bin</a></h2>
<h3 id="name-59"><a class="header" href="#name-59">NAME</a></h3>
<p>cast-from-bin - 将二进制数据转换为十六进制数据。</p>
<h3 id="synopsis-58"><a class="header" href="#synopsis-58">SYNOPSIS</a></h3>
<p><code>cast from-bin</code> [<em>options</em>]</p>
<h3 id="description-58"><a class="header" href="#description-58">DESCRIPTION</a></h3>
<p>将二进制数据转换为十六进制数据。</p>
<p>输入从标准输入读取。</p>
<h3 id="options-57"><a class="header" href="#options-57">OPTIONS</a></h3>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="see-also-54"><a class="header" href="#see-also-54">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-from-fixed-point"><a class="header" href="#cast-from-fixed-point">cast from-fixed-point</a></h2>
<h3 id="name-60"><a class="header" href="#name-60">NAME</a></h3>
<p>cast-from-fixed-point - 将定点数转换为整数。</p>
<h3 id="synopsis-59"><a class="header" href="#synopsis-59">SYNOPSIS</a></h3>
<p><code>cast from-fixed-point</code> [<em>options</em>] <em>decimals</em> <em>value</em></p>
<h3 id="description-59"><a class="header" href="#description-59">DESCRIPTION</a></h3>
<p>将定点数转换为整数。</p>
<h3 id="options-58"><a class="header" href="#options-58">OPTIONS</a></h3>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-55"><a class="header" href="#examples-55">EXAMPLES</a></h3>
<ol>
<li>将 10.55 转换为整数：
<pre><code class="language-sh">cast from-fixed-point 2 10.55
</code></pre>
</li>
</ol>
<h3 id="see-also-55"><a class="header" href="#see-also-55">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-from-rlp"><a class="header" href="#cast-from-rlp">cast from-rlp</a></h2>
<h3 id="name-61"><a class="header" href="#name-61">NAME</a></h3>
<p>cast-from-rlp - 解码RLP编码的数据。</p>
<h3 id="synopsis-60"><a class="header" href="#synopsis-60">SYNOPSIS</a></h3>
<p><code>cast from-rlp</code> <em>data</em></p>
<h3 id="description-60"><a class="header" href="#description-60">DESCRIPTION</a></h3>
<p>解码RLP编码的数据。</p>
<p><em>data</em> 是一个带有可选0x前缀的十六进制字符串。</p>
<h3 id="options-59"><a class="header" href="#options-59">OPTIONS</a></h3>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-56"><a class="header" href="#examples-56">EXAMPLES</a></h3>
<ol>
<li>解码RLP数据：
<pre><code class="language-sh">cast from-rlp 0xc481f181f2

cast from-rlp c481f181f2
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-from-utf8-1"><a class="header" href="#cast-from-utf8-1">cast from-utf8</a></h2>
<h3 id="name-62"><a class="header" href="#name-62">NAME</a></h3>
<p>cast-from-utf8 - 将 UTF8 文本转换为十六进制。</p>
<h3 id="synopsis-61"><a class="header" href="#synopsis-61">SYNOPSIS</a></h3>
<p><code>cast from-utf8</code> [<em>options</em>] <em>text</em></p>
<h3 id="description-61"><a class="header" href="#description-61">DESCRIPTION</a></h3>
<p>将 UTF8 文本转换为十六进制。</p>
<h3 id="options-60"><a class="header" href="#options-60">OPTIONS</a></h3>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-57"><a class="header" href="#examples-57">EXAMPLES</a></h3>
<ol>
<li>将 UTF8 文本转换为十六进制：
<pre><code class="language-sh">cast from-utf8 "hello"
</code></pre>
</li>
</ol>
<h3 id="see-also-56"><a class="header" href="#see-also-56">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-from-wei"><a class="header" href="#cast-from-wei">cast from-wei</a></h2>
<h3 id="name-63"><a class="header" href="#name-63">NAME</a></h3>
<p>cast-from-wei - 将 wei 转换为 ETH 金额。</p>
<h3 id="synopsis-62"><a class="header" href="#synopsis-62">SYNOPSIS</a></h3>
<p><code>cast from-wei</code> [<em>options</em>] <em>value</em> [<em>unit</em>]</p>
<h3 id="description-62"><a class="header" href="#description-62">DESCRIPTION</a></h3>
<p>将 wei 转换为 ETH 金额。</p>
<p>建议使用 <a href="reference/cast/./cast-to-unit.html"><code>cast to-unit</code></a>。</p>
<h3 id="options-61"><a class="header" href="#options-61">OPTIONS</a></h3>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="see-also-57"><a class="header" href="#see-also-57">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a>, <a href="reference/cast/./cast-to-unit.html">cast calldata</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-parse-bytes32-address"><a class="header" href="#cast-parse-bytes32-address">cast parse-bytes32-address</a></h2>
<h3 id="name-64"><a class="header" href="#name-64">NAME</a></h3>
<p>cast-parse-bytes32-address - 从 bytes32 编码中解析出校验和地址。</p>
<h3 id="synopsis-63"><a class="header" href="#synopsis-63">SYNOPSIS</a></h3>
<p><code>cast parse-bytes32-address</code> [<em>options</em>] <em>bytes</em></p>
<h3 id="description-63"><a class="header" href="#description-63">DESCRIPTION</a></h3>
<p>从其 bytes32 编码表示中解析出校验和地址。</p>
<h3 id="options-62"><a class="header" href="#options-62">OPTIONS</a></h3>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-58"><a class="header" href="#examples-58">EXAMPLES</a></h3>
<ol>
<li>将 WETH9 合约地址的 bytes32 编码解析为其地址表示：
<pre><code class="language-sh">cast parse-bytes32-address 0x000000000000000000000000C02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2
</code></pre>
</li>
</ol>
<h3 id="see-also-58"><a class="header" href="#see-also-58">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-parse-bytes32-string-1"><a class="header" href="#cast-parse-bytes32-string-1">cast parse-bytes32-string</a></h2>
<h3 id="name-65"><a class="header" href="#name-65">NAME</a></h3>
<p>cast-parse-bytes32-string - 从 bytes32 编码解析字符串。</p>
<h3 id="synopsis-64"><a class="header" href="#synopsis-64">SYNOPSIS</a></h3>
<p><code>cast parse-bytes32-string</code> [<em>options</em>] <em>bytes</em></p>
<h3 id="description-64"><a class="header" href="#description-64">DESCRIPTION</a></h3>
<p>从其 bytes32 编码表示中解析 <a href="https://docs.soliditylang.org/en/v0.8.16/types.html#string-literals-and-types" title="" target="_blank">Solidity 字符串字面量</a>，主要通过将字节解释为 ASCII 字符。此命令撤销 <a href="reference/cast/./cast-format-bytes32-string.html">–format-bytes32-string</a> 中的编码。</p>
<h3 id="options-63"><a class="header" href="#options-63">OPTIONS</a></h3>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-59"><a class="header" href="#examples-59">EXAMPLES</a></h3>
<ol>
<li>将 “hello” 的 bytes32 字符串编码解析回字符串表示：
<pre><code class="language-sh">cast parse-bytes32-string "0x68656c6c6f000000000000000000000000000000000000000000000000000000"
</code></pre>
</li>
</ol>
<h3 id="see-also-59"><a class="header" href="#see-also-59">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-to-ascii"><a class="header" href="#cast-to-ascii">cast to-ascii</a></h2>
<h3 id="name-66"><a class="header" href="#name-66">NAME</a></h3>
<p>cast-to-ascii - 将十六进制数据转换为 ASCII 字符串。</p>
<h3 id="synopsis-65"><a class="header" href="#synopsis-65">SYNOPSIS</a></h3>
<p><code>cast to-ascii</code> [<em>options</em>] <em>text</em></p>
<h3 id="description-65"><a class="header" href="#description-65">DESCRIPTION</a></h3>
<p>将十六进制数据转换为 ASCII 字符串。</p>
<h3 id="options-64"><a class="header" href="#options-64">OPTIONS</a></h3>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-60"><a class="header" href="#examples-60">EXAMPLES</a></h3>
<ol>
<li>将十六进制数据转换为 ASCII 字符串：
<pre><code class="language-sh">cast to-ascii "0x68656c6c6f"
</code></pre>
</li>
</ol>
<h3 id="see-also-60"><a class="header" href="#see-also-60">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-to-base"><a class="header" href="#cast-to-base">cast to-base</a></h2>
<h3 id="name-67"><a class="header" href="#name-67">NAME</a></h3>
<p>cast-to-base - 将一个基数的数字转换为另一个基数。</p>
<h3 id="synopsis-66"><a class="header" href="#synopsis-66">SYNOPSIS</a></h3>
<p><code>cast to-base</code> [<em>options</em>] <em>value</em> <em>base</em></p>
<h3 id="description-66"><a class="header" href="#description-66">DESCRIPTION</a></h3>
<p>将一个基数的数字转换为另一个基数。</p>
<h3 id="options-65"><a class="header" href="#options-65">OPTIONS</a></h3>
<h4 id="base-options"><a class="header" href="#base-options">Base Options</a></h4>
<p><code>--base-in</code> <em>base</em>
    输入数字的基数。可用选项：</p>
<p>    10, d, dec, decimal</p>
<p>    16, h, hex, hexadecimal</p>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-61"><a class="header" href="#examples-61">EXAMPLES</a></h3>
<ol>
<li>
<p>将十进制数 64 转换为十六进制</p>
<pre><code class="language-sh">cast to-base 64 hex
</code></pre>
</li>
<li>
<p>将十六进制数 100 转换为二进制</p>
<pre><code class="language-sh">cast to-base 0x100 2
</code></pre>
</li>
</ol>
<blockquote>
<p>注意：–base-in 参数不是强制的，但如果输入不明确则需要使用。</p>
</blockquote>
<h3 id="see-also-61"><a class="header" href="#see-also-61">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-to-bytes32"><a class="header" href="#cast-to-bytes32">cast to-bytes32</a></h2>
<h3 id="name-68"><a class="header" href="#name-68">NAME</a></h3>
<p>cast-to-bytes32 - 将十六进制数据右填充到32字节。</p>
<h3 id="synopsis-67"><a class="header" href="#synopsis-67">SYNOPSIS</a></h3>
<p><code>cast to-bytes32</code> [<em>options</em>] <em>bytes</em></p>
<h3 id="description-67"><a class="header" href="#description-67">DESCRIPTION</a></h3>
<p>将十六进制数据右填充到32字节。</p>
<p>请注意，此命令仅用于填充字节字符串。如果您想将<a href="https://docs.soliditylang.org/en/v0.8.16/types.html#string-literals-and-types" title="" target="_blank">Solidity字符串字面量</a>格式化为<code>bytes32</code>，请使用<a href="reference/cast/./cast-format-bytes32-string.html">format-bytes32-string</a>。</p>
<h3 id="options-66"><a class="header" href="#options-66">OPTIONS</a></h3>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="see-also-62"><a class="header" href="#see-also-62">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-to-dec"><a class="header" href="#cast-to-dec">cast to-dec</a></h2>
<h3 id="name-69"><a class="header" href="#name-69">NAME</a></h3>
<p>cast-to-dec - 将一个基数的数字转换为十进制</p>
<h3 id="synopsis-68"><a class="header" href="#synopsis-68">SYNOPSIS</a></h3>
<p><code>cast to-dec</code> [<em>options</em>] <em>value</em></p>
<h3 id="description-68"><a class="header" href="#description-68">DESCRIPTION</a></h3>
<p>将一个基数的数字转换为十进制</p>
<h3 id="options-67"><a class="header" href="#options-67">OPTIONS</a></h3>
<p><code>--base-in</code> <em>base_in</em>
    输入的基数。</p>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-62"><a class="header" href="#examples-62">EXAMPLES</a></h3>
<ol>
<li>将十六进制的 ff 转换为十进制
<pre><code class="language-sh">cast to-dec ff
</code></pre>
</li>
</ol>
<h3 id="see-also-63"><a class="header" href="#see-also-63">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-to-fixed-point"><a class="header" href="#cast-to-fixed-point">cast to-fixed-point</a></h2>
<h3 id="name-70"><a class="header" href="#name-70">NAME</a></h3>
<p>cast-to-fixed-point - 将整数转换为定点数。</p>
<h3 id="synopsis-69"><a class="header" href="#synopsis-69">SYNOPSIS</a></h3>
<p><code>cast to-fixed-point</code> [<em>options</em>] <em>decimals</em> <em>value</em></p>
<h3 id="description-69"><a class="header" href="#description-69">DESCRIPTION</a></h3>
<p>将整数转换为定点数。</p>
<h3 id="options-68"><a class="header" href="#options-68">OPTIONS</a></h3>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-63"><a class="header" href="#examples-63">EXAMPLES</a></h3>
<ol>
<li>将250转换为带有2位小数的定点数：
<pre><code class="language-sh">cast to-fixed-point 2 250
</code></pre>
</li>
</ol>
<h3 id="see-also-64"><a class="header" href="#see-also-64">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-to-hex"><a class="header" href="#cast-to-hex">cast to-hex</a></h2>
<h3 id="name-71"><a class="header" href="#name-71">NAME</a></h3>
<p>cast-to-hex - 将一个基数的数字转换为另一个基数</p>
<h3 id="synopsis-70"><a class="header" href="#synopsis-70">SYNOPSIS</a></h3>
<p><code>cast to-hex</code> [<em>options</em>] <em>value</em></p>
<h3 id="description-70"><a class="header" href="#description-70">DESCRIPTION</a></h3>
<p>将一个基数的数字转换为另一个基数</p>
<h3 id="options-69"><a class="header" href="#options-69">OPTIONS</a></h3>
<p><code>--base-in</code> <em>base_in</em>
    输入的基数。</p>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="see-also-65"><a class="header" href="#see-also-65">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-to-hexdata"><a class="header" href="#cast-to-hexdata">cast to-hexdata</a></h2>
<h3 id="name-72"><a class="header" href="#name-72">NAME</a></h3>
<p>cast-to-hexdata - 将输入规范化为小写、0x前缀的十六进制。</p>
<h3 id="synopsis-71"><a class="header" href="#synopsis-71">SYNOPSIS</a></h3>
<p><code>cast to-hexdata</code> [<em>options</em>] <em>input</em></p>
<h3 id="description-71"><a class="header" href="#description-71">DESCRIPTION</a></h3>
<p>将输入规范化为小写、0x前缀的十六进制。</p>
<p>输入数据（<em>input</em>）可以是以下几种形式：</p>
<ul>
<li>带有或不带有0x前缀的混合大小写十六进制。</li>
<li>应该通过<code>:</code>分隔并连接的0x前缀十六进制。</li>
<li>包含十六进制的文件的绝对路径。</li>
<li>一个<code>@tag</code>，其中tag在环境变量中定义。</li>
</ul>
<h3 id="options-70"><a class="header" href="#options-70">OPTIONS</a></h3>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-64"><a class="header" href="#examples-64">EXAMPLES</a></h3>
<ol>
<li>
<p>添加0x前缀：</p>
<pre><code class="language-sh">cast to-hexdata deadbeef
</code></pre>
</li>
<li>
<p>连接十六进制值：</p>
<pre><code class="language-sh">cast to-hexdata "deadbeef:0xbeef"
</code></pre>
</li>
<li>
<p>规范化<code>MY_VAR</code>中的十六进制值：</p>
<pre><code class="language-sh">cast to-hexdata "@MY_VAR"
</code></pre>
</li>
</ol>
<h3 id="see-also-66"><a class="header" href="#see-also-66">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-to-int256"><a class="header" href="#cast-to-int256">cast to-int256</a></h2>
<h3 id="name-73"><a class="header" href="#name-73">NAME</a></h3>
<p>cast-to-int256 - 将一个数字转换为十六进制编码的 int256。</p>
<h3 id="synopsis-72"><a class="header" href="#synopsis-72">SYNOPSIS</a></h3>
<p><code>cast to-int256</code> [<em>options</em>] <em>value</em></p>
<h3 id="description-72"><a class="header" href="#description-72">DESCRIPTION</a></h3>
<p>将一个数字转换为十六进制编码的 int256。</p>
<h3 id="options-71"><a class="header" href="#options-71">OPTIONS</a></h3>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="see-also-67"><a class="header" href="#see-also-67">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-to-rlp"><a class="header" href="#cast-to-rlp">cast to-rlp</a></h2>
<h3 id="name-74"><a class="header" href="#name-74">NAME</a></h3>
<p>cast-to-rlp - 将十六进制数据编码为RLP。</p>
<h3 id="synopsis-73"><a class="header" href="#synopsis-73">SYNOPSIS</a></h3>
<p><code>cast to-rlp</code> <em>array</em></p>
<h3 id="description-73"><a class="header" href="#description-73">DESCRIPTION</a></h3>
<p>将十六进制字符串或十六进制字符串的JSON数组进行RLP编码。</p>
<h3 id="options-72"><a class="header" href="#options-72">OPTIONS</a></h3>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-65"><a class="header" href="#examples-65">EXAMPLES</a></h3>
<ol>
<li>编码RLP数据：
<pre><code class="language-sh">cast to-rlp '["0xaa","0xbb","cc"]'

cast to-rlp f0a9     
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-to-uint256"><a class="header" href="#cast-to-uint256">cast to-uint256</a></h2>
<h3 id="name-75"><a class="header" href="#name-75">NAME</a></h3>
<p>cast-to-uint256 - 将一个数字转换为十六进制编码的 uint256。</p>
<h3 id="synopsis-74"><a class="header" href="#synopsis-74">SYNOPSIS</a></h3>
<p><code>cast to-uint256</code> [<em>options</em>] <em>value</em></p>
<h3 id="description-74"><a class="header" href="#description-74">DESCRIPTION</a></h3>
<p>将一个数字转换为十六进制编码的 uint256。</p>
<h3 id="options-73"><a class="header" href="#options-73">OPTIONS</a></h3>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="see-also-68"><a class="header" href="#see-also-68">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-to-unit"><a class="header" href="#cast-to-unit">cast to-unit</a></h2>
<h3 id="name-76"><a class="header" href="#name-76">NAME</a></h3>
<p>cast-to-unit - 将以太币数量转换为另一种单位。</p>
<h3 id="synopsis-75"><a class="header" href="#synopsis-75">SYNOPSIS</a></h3>
<p><code>cast to-unit</code> [<em>options</em>] <em>value</em> [<em>unit</em>]</p>
<h3 id="description-75"><a class="header" href="#description-75">DESCRIPTION</a></h3>
<p>将以太币数量转换为另一种单位。</p>
<p>要转换的值（<em>value</em>）可以是以太币的数量（以 wei 为单位），或者是带有单位的数字。</p>
<p>有效的单位包括：</p>
<ul>
<li><code>ether</code></li>
<li><code>gwei</code></li>
<li><code>wei</code></li>
</ul>
<h3 id="options-74"><a class="header" href="#options-74">OPTIONS</a></h3>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-66"><a class="header" href="#examples-66">EXAMPLES</a></h3>
<ol>
<li>
<p>将 1000 wei 转换为 gwei</p>
<pre><code class="language-sh">cast to-unit 1000 gwei
</code></pre>
</li>
<li>
<p>将 1 eth 转换为 gwei</p>
<pre><code class="language-sh">cast to-unit 1ether gwei
</code></pre>
</li>
</ol>
<h3 id="see-also-69"><a class="header" href="#see-also-69">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-to-wei"><a class="header" href="#cast-to-wei">cast to-wei</a></h2>
<h3 id="name-77"><a class="header" href="#name-77">NAME</a></h3>
<p>cast-to-wei - 将以太币数量转换为wei。</p>
<h3 id="synopsis-76"><a class="header" href="#synopsis-76">SYNOPSIS</a></h3>
<p><code>cast to-wei</code> [<em>options</em>] <em>value</em> [<em>unit</em>]</p>
<h3 id="description-76"><a class="header" href="#description-76">DESCRIPTION</a></h3>
<p>将以太币数量转换为wei。</p>
<p>建议使用 <a href="reference/cast/./cast-to-unit.html"><code>cast to-unit</code></a>。</p>
<h3 id="options-75"><a class="header" href="#options-75">OPTIONS</a></h3>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="see-also-70"><a class="header" href="#see-also-70">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a>, <a href="reference/cast/./cast-to-unit.html">cast calldata</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-shl"><a class="header" href="#cast-shl">cast shl</a></h2>
<h3 id="name-78"><a class="header" href="#name-78">NAME</a></h3>
<p>cast-shl - 执行左移操作。</p>
<h3 id="synopsis-77"><a class="header" href="#synopsis-77">SYNOPSIS</a></h3>
<p><code>cast shl</code> [<em>options</em>] <em>value</em> <em>shift</em></p>
<h3 id="description-77"><a class="header" href="#description-77">DESCRIPTION</a></h3>
<p>执行左移操作。</p>
<h3 id="options-76"><a class="header" href="#options-76">OPTIONS</a></h3>
<pre><code class="language-markdown">#### 基本选项

`--base-in` *base*
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;输入数字的基数。可用选项：

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;10, d, dec, decimal

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;16, h, hex, hexadecimal

`--base-out` *base*
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;输出数字的期望基数。可用选项：

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2, b, bin, binary

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;8, o, oct, octal

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;10, d, dec, decimal

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;16, h, hex, hexadecimal
</code></pre>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-67"><a class="header" href="#examples-67">EXAMPLES</a></h3>
<ol>
<li>对数字 61 执行 3 位左移
<pre><code class="language-sh">cast shl --base-in 10 61 3
</code></pre>
</li>
</ol>
<blockquote>
<p>注意：–base-in 参数不是强制的，但如果输入不明确则需要使用。</p>
</blockquote>
<h3 id="see-also-71"><a class="header" href="#see-also-71">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a>, <a href="reference/cast/./cast-shr.html">cast shr</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-shr"><a class="header" href="#cast-shr">cast shr</a></h2>
<h3 id="name-79"><a class="header" href="#name-79">NAME</a></h3>
<p>cast-shr - 执行右移操作。</p>
<h3 id="synopsis-78"><a class="header" href="#synopsis-78">SYNOPSIS</a></h3>
<p><code>cast shr</code> [<em>options</em>] <em>value</em> <em>shift</em></p>
<h3 id="description-78"><a class="header" href="#description-78">DESCRIPTION</a></h3>
<p>执行右移操作。</p>
<h3 id="options-77"><a class="header" href="#options-77">OPTIONS</a></h3>
<pre><code class="language-markdown">#### 基本选项

`--base-in` *base*
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;输入数字的基数。可用选项：

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;10, d, dec, decimal

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;16, h, hex, hexadecimal

`--base-out` *base*
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;输出数字的期望基数。可用选项：

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2, b, bin, binary

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;8, o, oct, octal

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;10, d, dec, decimal

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;16, h, hex, hexadecimal
</code></pre>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-68"><a class="header" href="#examples-68">EXAMPLES</a></h3>
<ol>
<li>对 0x12 执行一次右移位操作
<pre><code class="language-sh">cast shr --base-in 16 0x12 1
</code></pre>
</li>
</ol>
<blockquote>
<p>注意：–base-in 参数不是强制的，但如果输入不明确，则需要使用。</p>
</blockquote>
<h3 id="see-also-72"><a class="header" href="#see-also-72">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a>, <a href="reference/cast/./cast-shl.html">cast shl</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="实用命令-2"><a class="header" href="#实用命令-2">实用命令</a></h2>
<ul>
<li><a href="reference/cast/./cast-address-zero.html">cast address-zero</a></li>
<li><a href="reference/cast/./cast-sig.html">cast sig</a></li>
<li><a href="reference/cast/./cast-sig-event.html">cast sig-event</a></li>
<li><a href="reference/cast/./cast-keccak.html">cast keccak</a></li>
<li><a href="reference/cast/./cast-compute-address.html">cast compute-address</a></li>
<li><a href="reference/cast/./cast-create2.html">cast create2</a></li>
<li><a href="reference/cast/./cast-interface.html">cast interface</a></li>
<li><a href="reference/cast/./cast-index.html">cast index</a></li>
<li><a href="reference/cast/./cast-concat-hex.html">cast concat-hex</a></li>
<li><a href="reference/cast/./cast-max-int.html">cast max-int</a></li>
<li><a href="reference/cast/./cast-min-int.html">cast min-int</a></li>
<li><a href="reference/cast/./cast-max-uint.html">cast max-uint</a></li>
<li><a href="reference/cast/./cast-to-check-sum-address.html">cast to-check-sum-address</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-address-zero"><a class="header" href="#cast-address-zero">cast address-zero</a></h2>
<h3 id="名称-15"><a class="header" href="#名称-15">名称</a></h3>
<p>cast address-zero - 打印零地址。</p>
<h3 id="概要-16"><a class="header" href="#概要-16">概要</a></h3>
<p><code>cast address-zero</code></p>
<h3 id="描述-16"><a class="header" href="#描述-16">描述</a></h3>
<p>打印零地址。</p>
<h3 id="选项-15"><a class="header" href="#选项-15">选项</a></h3>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<p><a href="reference/cast/./cast.html">cast</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-sig"><a class="header" href="#cast-sig">cast sig</a></h2>
<h3 id="name-80"><a class="header" href="#name-80">NAME</a></h3>
<p>cast-sig - 获取函数的签名选择器。</p>
<h3 id="synopsis-79"><a class="header" href="#synopsis-79">SYNOPSIS</a></h3>
<p><code>cast sig</code> [<em>options</em>] <em>sig</em></p>
<h3 id="description-79"><a class="header" href="#description-79">DESCRIPTION</a></h3>
<p>获取函数的签名选择器。</p>
<p>签名（<em>sig</em>）是一个形式为 <code>&lt;function name&gt;(&lt;types...&gt;)</code> 的片段。</p>
<h3 id="options-78"><a class="header" href="#options-78">OPTIONS</a></h3>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-69"><a class="header" href="#examples-69">EXAMPLES</a></h3>
<ol>
<li>
<p>获取函数 <code>transfer(address,uint256)</code> 的选择器：</p>
<pre><code class="language-sh">cast sig "transfer(address,uint256)"
</code></pre>
</li>
<li>
<p>获取一个期望 <code>struct</code> 的函数的选择器：</p>
<pre><code class="language-solidity">contract Test {
    struct MyStruct {
        address addr;
        uint256 amount;
    }
    function myfunction(MyStruct memory t) public pure {}
}
</code></pre>
<p>Structs 被编码为元组（参见 <a href="reference/cast/../../misc/struct-encoding.html">struct 编码</a>）。</p>
<pre><code class="language-sh">cast sig "myfunction((address,uint256))"
</code></pre>
</li>
</ol>
<h3 id="see-also-73"><a class="header" href="#see-also-73">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a>, <a href="reference/cast/../../misc/struct-encoding.html">struct 编码</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-sig-event"><a class="header" href="#cast-sig-event">cast sig-event</a></h2>
<h3 id="name-81"><a class="header" href="#name-81">NAME</a></h3>
<p>cast-sig-event - 从事件字符串生成事件签名。</p>
<h3 id="synopsis-80"><a class="header" href="#synopsis-80">SYNOPSIS</a></h3>
<p><code>cast sig-event</code> [<em>options</em>] <em>event_string</em></p>
<h3 id="description-80"><a class="header" href="#description-80">DESCRIPTION</a></h3>
<p>从事件字符串生成事件签名。</p>
<h3 id="options-79"><a class="header" href="#options-79">OPTIONS</a></h3>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-70"><a class="header" href="#examples-70">EXAMPLES</a></h3>
<ol>
<li>获取日志 <code>Transfer(address indexed from, address indexed to, uint256 amount)</code> 的哈希：
<pre><code class="language-sh">cast sig-event "Transfer(address indexed from, address indexed to, uint256 amount)"
</code></pre>
</li>
</ol>
<h3 id="see-also-74"><a class="header" href="#see-also-74">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-keccak"><a class="header" href="#cast-keccak">cast keccak</a></h2>
<h3 id="name-82"><a class="header" href="#name-82">NAME</a></h3>
<p>cast-keccak - 使用 keccak-256 哈希任意数据。</p>
<h3 id="synopsis-81"><a class="header" href="#synopsis-81">SYNOPSIS</a></h3>
<p><code>cast keccak</code> [<em>options</em>] <em>data</em></p>
<h3 id="description-81"><a class="header" href="#description-81">DESCRIPTION</a></h3>
<p>使用 keccak-256 哈希任意数据。</p>
<h3 id="options-80"><a class="header" href="#options-80">OPTIONS</a></h3>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="see-also-75"><a class="header" href="#see-also-75">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-compute-address-1"><a class="header" href="#cast-compute-address-1">cast compute-address</a></h2>
<h3 id="name-83"><a class="header" href="#name-83">NAME</a></h3>
<p>cast-compute-address - 根据给定的nonce和部署者地址计算合约地址。</p>
<h3 id="synopsis-82"><a class="header" href="#synopsis-82">SYNOPSIS</a></h3>
<p><code>cast compute-address</code> [<em>options</em>] <em>address</em></p>
<h3 id="description-82"><a class="header" href="#description-82">DESCRIPTION</a></h3>
<p>根据给定的nonce和部署者地址计算合约地址。</p>
<h3 id="options-81"><a class="header" href="#options-81">OPTIONS</a></h3>
<h4 id="计算选项"><a class="header" href="#计算选项">计算选项</a></h4>
<p><code>--nonce</code> <em>nonce</em><br />
    账户的nonce。默认为从RPC获取的最新nonce。</p>
<h4 id="rpc选项-1"><a class="header" href="#rpc选项-1">RPC选项</a></h4>
<pre><code class="language-markdown">`--rpc-url` *url*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;RPC 端点。接受一个 URL 或 [rpc_endpoints] 表中已有的别名，例如 `mainnet`。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `ETH_RPC_URL`
</code></pre>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="see-also-76"><a class="header" href="#see-also-76">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a>, <a href="reference/cast/./cast-proof.html">cast proof</a>, <a href="reference/cast/./cast-create2.html">cast create2</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-create2"><a class="header" href="#cast-create2">cast create2</a></h2>
<h3 id="名称-16"><a class="header" href="#名称-16">名称</a></h3>
<p>cast-create2 - 使用CREATE2生成确定性合约地址</p>
<h3 id="概要-17"><a class="header" href="#概要-17">概要</a></h3>
<p><code>cast create2</code> [<em>选项</em>]</p>
<h3 id="描述-17"><a class="header" href="#描述-17">描述</a></h3>
<p>使用CREATE2生成确定性合约地址</p>
<h3 id="选项-16"><a class="header" href="#选项-16">选项</a></h3>
<p><code>--starts-with</code> <em>hex</em>
    合约地址的前缀。</p>
<p><code>--ends-with</code> <em>hex</em>
    合约地址的后缀。</p>
<p><code>--matching</code> <em>hex</em>
    地址必须匹配的序列。</p>
<p><code>--case-sensitive</code>
    区分大小写的匹配。</p>
<p><code>--deployer</code> <em>address</em>
    合约部署者的地址 [默认: <code>0x4e59b44847b379578588920ca78fbf26c0b4956c</code>]</p>
<p><code>--init-code</code> <em>hex</em>
    要部署的合约的初始化代码。</p>
<p><code>--init-code-hash</code> <em>hash</em>
    要部署的合约的初始化代码哈希。</p>
<p><code>--jobs</code> <em>jobs</em>
    使用的线程数。默认为并限制为逻辑核心数。</p>
<p><code>--caller</code> <em>address</em>
    调用者的地址。用于盐的前20个字节。</p>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="示例-15"><a class="header" href="#示例-15">示例</a></h3>
<ol>
<li>
<p>生成一个以 <code>dead</code> 开头的合约地址：</p>
<pre><code class="language-sh">cast create2 --starts-with dead
</code></pre>
</li>
<li>
<p>生成一个以 <code>beef</code> 结尾的合约地址：</p>
<pre><code class="language-sh">cast create2 --ends-with beef
</code></pre>
</li>
<li>
<p>一个更复杂的示例：</p>
<pre><code class="language-sh">cast create2 --starts-with dead --case-sensitive --deployer 0x0000000000FFe8B47B3e2130213B802212439497 --init-code-hash 0x0c591f26891d6443cf08c5be3584c1e6ae10a4c2f07c5c53218741e9755fb9cd
</code></pre>
</li>
</ol>
<h3 id="另见-2"><a class="header" href="#另见-2">另见</a></h3>
<p><a href="reference/cast/./cast.html">cast</a>, <a href="reference/cast/./cast-compute-address.html">cast compute-address</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-interface"><a class="header" href="#cast-interface">cast interface</a></h2>
<h3 id="name-84"><a class="header" href="#name-84">NAME</a></h3>
<p>cast-interface - 从给定的 ABI 生成 Solidity 接口。</p>
<h3 id="synopsis-83"><a class="header" href="#synopsis-83">SYNOPSIS</a></h3>
<p><code>cast interface</code> [<em>options</em>] <em>address_or_path</em></p>
<h3 id="description-83"><a class="header" href="#description-83">DESCRIPTION</a></h3>
<p>从给定的 ABI 生成 Solidity 接口。</p>
<p>参数 (<em>address_or_path</em>) 可以是包含 ABI 的文件路径，或者是地址。</p>
<p>如果提供地址，则从 Etherscan 获取账户的 ABI 生成接口。</p>
<blockquote>
<p>ℹ️ <strong>注意</strong></p>
<p>该命令目前不支持 ABI 编码器 v2。</p>
</blockquote>
<h3 id="options-82"><a class="header" href="#options-82">OPTIONS</a></h3>
<h4 id="interface-options"><a class="header" href="#interface-options">Interface Options</a></h4>
<p><code>-n</code> <em>name</em><br />
<code>--name</code> <em>name</em><br />
    用于生成接口的名称。默认名称为 <code>Interface</code>。</p>
<p><code>-o</code> <em>path</em><br />
    输出文件的路径。如果未指定，接口将输出到标准输出。</p>
<p><code>-p</code> <em>version</em><br />
<code>--pragma</code> <em>version</em><br />
    用于接口的 Solidity pragma 版本。默认: <code>^0.8.10</code>。</p>
<p><code>-j</code><br />
<code>--json</code><br />
    输出合约的 JSON ABI。</p>
<pre><code class="language-markdown">#### Etherscan 选项

`--chain` *chain_name*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Etherscan 链。

`--etherscan-api-key` *key*  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Etherscan API 密钥，或 [Etherscan 配置表](../config/etherscan.md#etherscan) 中的密钥。  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `ETHERSCAN_API_KEY`
</code></pre>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-71"><a class="header" href="#examples-71">EXAMPLES</a></h3>
<ol>
<li>
<p>从文件生成接口：</p>
<pre><code class="language-sh">cast interface ./path/to/abi.json
</code></pre>
</li>
<li>
<p>使用 Etherscan 生成接口：</p>
<pre><code class="language-sh">cast interface -o IWETH.sol 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2
</code></pre>
</li>
<li>
<p>从文件生成并命名接口：</p>
<pre><code class="language-sh">cast interface -n LilENS ./path/to/abi.json
</code></pre>
</li>
<li>
<p>从 Etherscan 获取合约的 JSON ABI：</p>
<pre><code class="language-sh">cast interface -o IWETH.sol -j 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2
</code></pre>
</li>
</ol>
<h3 id="see-also-77"><a class="header" href="#see-also-77">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a>, <a href="reference/cast/./cast-proof.html">cast proof</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-index"><a class="header" href="#cast-index">cast index</a></h2>
<h3 id="name-85"><a class="header" href="#name-85">NAME</a></h3>
<p>cast-index - 计算映射中条目的存储槽位置。</p>
<h3 id="synopsis-84"><a class="header" href="#synopsis-84">SYNOPSIS</a></h3>
<p><code>cast index</code> <em>key_type</em> <em>key</em> <em>slot</em></p>
<h3 id="description-84"><a class="header" href="#description-84">DESCRIPTION</a></h3>
<p>计算映射中条目的存储槽位置。</p>
<p>使用 <code>cast storage</code> 获取值。</p>
<h3 id="options-83"><a class="header" href="#options-83">OPTIONS</a></h3>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-72"><a class="header" href="#examples-72">EXAMPLES</a></h3>
<pre><code class="language-solidity">// World.sol

mapping (address =&gt; uint256) public mapping1;
mapping (string =&gt; string) public mapping2;
</code></pre>
<ol>
<li>计算类型为 <code>mapping(string =&gt; string)</code> 的映射中条目 (<code>hello</code>) 的存储槽位置，位于槽 1：
<pre><code class="language-sh">&gt;&gt; cast index string "hello" 1
0x3556fc8e3c702d4479a1ab7928dd05d87508462a12f53307b5407c969223d1f8
&gt;&gt; cast storage [address] 0x3556fc8e3c702d4479a1ab7928dd05d87508462a12f53307b5407c969223d1f8
world
</code></pre>
</li>
</ol>
<h3 id="see-also-78"><a class="header" href="#see-also-78">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-concat-hex-1"><a class="header" href="#cast-concat-hex-1">cast concat-hex</a></h2>
<h3 id="name-86"><a class="header" href="#name-86">NAME</a></h3>
<p>cast-concat-hex - 连接十六进制字符串。</p>
<h3 id="synopsis-85"><a class="header" href="#synopsis-85">SYNOPSIS</a></h3>
<p><code>cast concat-hex</code> <em>data…</em></p>
<h3 id="description-85"><a class="header" href="#description-85">DESCRIPTION</a></h3>
<p>连接十六进制字符串。</p>
<h3 id="options-84"><a class="header" href="#options-84">OPTIONS</a></h3>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-73"><a class="header" href="#examples-73">EXAMPLES</a></h3>
<ol>
<li>连接十六进制字符串：
<pre><code class="language-sh">cast concat-hex 0xa 0xb 0xc
</code></pre>
</li>
</ol>
<h3 id="see-also-79"><a class="header" href="#see-also-79">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-max-int"><a class="header" href="#cast-max-int">cast max-int</a></h2>
<h3 id="name-87"><a class="header" href="#name-87">NAME</a></h3>
<p>cast-max-int - 获取最大 i256 值。</p>
<h3 id="synopsis-86"><a class="header" href="#synopsis-86">SYNOPSIS</a></h3>
<p><code>cast max-int</code></p>
<h3 id="description-86"><a class="header" href="#description-86">DESCRIPTION</a></h3>
<p>获取最大 i256 值。</p>
<h3 id="options-85"><a class="header" href="#options-85">OPTIONS</a></h3>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="see-also-80"><a class="header" href="#see-also-80">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a>, <a href="reference/cast/./cast-min-int.html">cast min-int</a>, <a href="reference/cast/./cast-max-uint.html">cast max-uint</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-min-int-1"><a class="header" href="#cast-min-int-1">cast min-int</a></h2>
<h3 id="name-88"><a class="header" href="#name-88">NAME</a></h3>
<p>cast-min-int - 获取最小 i256 值。</p>
<h3 id="synopsis-87"><a class="header" href="#synopsis-87">SYNOPSIS</a></h3>
<p><code>cast min-int</code></p>
<h3 id="description-87"><a class="header" href="#description-87">DESCRIPTION</a></h3>
<p>获取最小 i256 值。</p>
<h3 id="options-86"><a class="header" href="#options-86">OPTIONS</a></h3>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="see-also-81"><a class="header" href="#see-also-81">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a>, <a href="reference/cast/./cast-max-int.html">cast max-int</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-max-uint"><a class="header" href="#cast-max-uint">cast max-uint</a></h2>
<h3 id="name-89"><a class="header" href="#name-89">NAME</a></h3>
<p>cast-max-uint - 获取最大 uint256 值。</p>
<h3 id="synopsis-88"><a class="header" href="#synopsis-88">SYNOPSIS</a></h3>
<p><code>cast max-uint</code></p>
<h3 id="description-88"><a class="header" href="#description-88">DESCRIPTION</a></h3>
<p>获取最大 uint256 值。</p>
<h3 id="options-87"><a class="header" href="#options-87">OPTIONS</a></h3>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="see-also-82"><a class="header" href="#see-also-82">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a>, <a href="reference/cast/./cast-max-int.html">cast max-int</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-to-check-sum-address"><a class="header" href="#cast-to-check-sum-address">cast to-check-sum-address</a></h2>
<h3 id="name-90"><a class="header" href="#name-90">NAME</a></h3>
<p>cast-to-check-sum-address - 将地址转换为校验和格式（<a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md" title="" target="_blank">EIP-55</a>）。</p>
<h3 id="synopsis-89"><a class="header" href="#synopsis-89">SYNOPSIS</a></h3>
<p><code>cast to-check-sum-address</code> <em>address</em></p>
<h3 id="description-89"><a class="header" href="#description-89">DESCRIPTION</a></h3>
<p>将地址转换为校验和格式（<a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md" title="" target="_blank">EIP-55</a>）。</p>
<h3 id="options-88"><a class="header" href="#options-88">OPTIONS</a></h3>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="see-also-83"><a class="header" href="#see-also-83">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="钱包命令"><a class="header" href="#钱包命令">钱包命令</a></h2>
<ul>
<li><a href="reference/cast/./cast-wallet.html">cast wallet</a></li>
<li><a href="reference/cast/./cast-wallet-address.html">cast wallet address</a></li>
<li><a href="reference/cast/./cast-wallet-new.html">cast wallet new</a></li>
<li><a href="reference/cast/./cast-wallet-sign.html">cast wallet sign</a></li>
<li><a href="reference/cast/./cast-wallet-vanity.html">cast wallet vanity</a></li>
<li><a href="reference/cast/./cast-wallet-verify.html">cast wallet verify</a></li>
<li><a href="reference/cast/./cast-wallet-import.html">cast wallet import</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-wallet"><a class="header" href="#cast-wallet">cast wallet</a></h2>
<h3 id="名称-17"><a class="header" href="#名称-17">名称</a></h3>
<p>cast-wallet - 钱包管理工具。</p>
<h3 id="概要-18"><a class="header" href="#概要-18">概要</a></h3>
<p><code>cast wallet</code> [<em>选项</em>] <em>命令</em> [<em>参数</em>]<br />
<code>cast wallet</code> [<em>选项</em>] <code>--version</code><br />
<code>cast wallet</code> [<em>选项</em>] <code>--help</code></p>
<h3 id="描述-18"><a class="header" href="#描述-18">描述</a></h3>
<p>这个程序是一组用于使用、创建和管理钱包的工具。</p>
<h3 id="命令-1"><a class="header" href="#命令-1">命令</a></h3>
<p><a href="reference/cast/./cast-wallet-new.html">cast wallet new</a><br />
    创建一个新的随机密钥对。</p>
<p><a href="reference/cast/./cast-wallet-address.html">cast wallet address</a><br />
    将私钥转换为地址。</p>
<p><a href="reference/cast/./cast-wallet-sign.html">cast wallet sign</a><br />
    签名消息。</p>
<p><a href="reference/cast/./cast-wallet-vanity.html">cast wallet vanity</a><br />
    生成一个自定义地址。</p>
<p><a href="reference/cast/./cast-wallet-verify.html">cast wallet verify</a><br />
    验证消息的签名。</p>
<p><a href="reference/cast/./cast-wallet-import.html">cast wallet import</a><br />
    将私钥导入加密密钥库。</p>
<p><a href="reference/cast/./cast-wallet-list.html">cast wallet list</a><br />
    列出密钥库默认目录中的所有账户。</p>
<h3 id="选项-17"><a class="header" href="#选项-17">选项</a></h3>
<h4 id="特殊选项-2"><a class="header" href="#特殊选项-2">特殊选项</a></h4>
<p><code>-V</code><br />
<code>--version</code><br />
    打印版本信息并退出。</p>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-wallet-new"><a class="header" href="#cast-wallet-new">cast wallet new</a></h2>
<h3 id="name-91"><a class="header" href="#name-91">NAME</a></h3>
<p>cast-wallet-new - 创建一个新的随机密钥对。</p>
<h3 id="synopsis-90"><a class="header" href="#synopsis-90">SYNOPSIS</a></h3>
<p><code>cast wallet new</code> [<em>options</em>] [<em>path</em>]</p>
<h3 id="description-90"><a class="header" href="#description-90">DESCRIPTION</a></h3>
<p>创建一个新的随机密钥对。</p>
<p>如果指定了 <em>path</em>，则新的密钥对将写入一个使用密码加密的 JSON 密钥库。
（<em>path</em> 应为一个现有目录。）</p>
<h3 id="options-89"><a class="header" href="#options-89">OPTIONS</a></h3>
<h4 id="keystore-options"><a class="header" href="#keystore-options">Keystore Options</a></h4>
<p><code>-p</code><br />
<code>--password</code><br />
    触发 JSON 密钥库的隐藏密码提示。<br />
    <strong>已弃用：现在默认提示隐藏密码。</strong></p>
<p><code>--unsafe-password</code> <em>password</em><br />
    JSON 密钥库的明文密码。</p>
<p>    这<strong>不安全</strong>，建议使用 <code>--password</code> 代替。<br />
    环境变量：<code>CAST_PASSWORD</code></p>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-74"><a class="header" href="#examples-74">EXAMPLES</a></h3>
<ol>
<li>
<p>创建一个新的密钥对，但不保存到密钥库：</p>
<pre><code class="language-sh">cast wallet new
</code></pre>
</li>
<li>
<p>创建一个新的密钥对并保存到 <code>keystore</code> 目录：</p>
<pre><code class="language-sh">cast wallet new keystore
</code></pre>
</li>
</ol>
<h3 id="see-also-84"><a class="header" href="#see-also-84">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a>, <a href="reference/cast/./cast-wallet.html">cast wallet</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-new-mnemonic"><a class="header" href="#cast-new-mnemonic">cast new-mnemonic</a></h2>
<h3 id="name-92"><a class="header" href="#name-92">NAME</a></h3>
<p>cast-wallet-new-mnemonic - 创建一个包含指定数量单词的新助记词。</p>
<h3 id="synopsis-91"><a class="header" href="#synopsis-91">SYNOPSIS</a></h3>
<p><code>cast wallet new-mnemonic</code> [<em>options</em>]</p>
<h3 id="description-91"><a class="header" href="#description-91">DESCRIPTION</a></h3>
<p>生成一个随机的 BIP39 助记词短语。</p>
<h3 id="options-90"><a class="header" href="#options-90">OPTIONS</a></h3>
<h4 id="新助记词选项"><a class="header" href="#新助记词选项">新助记词选项</a></h4>
<p><code>-w</code>
<code>--words</code>
    助记词的单词数量。默认为 12。</p>
<p><code>-a</code>
<code>--accounts</code>
    要显示的账户数量，这些账户由助记词派生。默认为 1。</p>
<h3 id="examples-75"><a class="header" href="#examples-75">EXAMPLES</a></h3>
<ol>
<li>创建一个包含 24 个单词的新助记词。
<pre><code class="language-sh">cast wallet new-mnemonic --words 24
</code></pre>
</li>
</ol>
<pre><code class="language-text">成功生成一个新的助记词。
短语:
decrease where seek crop segment want icon medal sleep social blast provide virus grief pledge soccer stereo trick dry dirt rotate explain into nominee

账户:
- 账户 0:
地址:     0x34644D4eC92ae1832877cE22AD9bA4b00c7397c8
私钥: 0x832a3784d0a130c8a0ce3cc6dfc336a41ca7801a117eac7a3bfaace52e4d239c
</code></pre>
<h3 id="see-also-85"><a class="header" href="#see-also-85">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-wallet-address"><a class="header" href="#cast-wallet-address">cast wallet address</a></h2>
<h3 id="name-93"><a class="header" href="#name-93">NAME</a></h3>
<p>cast-wallet-address - 将私钥转换为地址。</p>
<h3 id="synopsis-92"><a class="header" href="#synopsis-92">SYNOPSIS</a></h3>
<p><code>cast wallet address</code> [<em>options</em>]</p>
<h3 id="description-92"><a class="header" href="#description-92">DESCRIPTION</a></h3>
<p>将私钥转换为地址。</p>
<h3 id="options-91"><a class="header" href="#options-91">OPTIONS</a></h3>
<h4 id="keystore-选项"><a class="header" href="#keystore-选项">Keystore 选项</a></h4>
<pre><code class="language-markdown">#### 钱包选项 - 原始:
`-i`  
`--interactive &lt;NUM&gt;`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 打开一个交互式提示符以输入您的私钥。接受一个值，表示要输入的私钥数量。  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 默认为 `0`。  

`--mnemonic-derivation-path &lt;PATHS&gt;`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 钱包派生路径。适用于 `--mnemonic-path` 和硬件钱包。  

`--mnemonic-indexes &lt;INDEXES&gt;`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 使用给定助记词索引的私钥。与 `--mnemonic-paths` 一起使用。  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 默认为 `0`。

`--mnemonic-passphrase &lt;PASSPHRASE&gt;`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 使用 BIP39 密码短语。  

`--mnemonic &lt;PATHS&gt;`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 使用指定路径的助记词短语或助记词文件。  

`--private-key &lt;RAW_PRIVATE_KEY&gt;`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 使用提供的私钥。

`--private-keys &lt;RAW_PRIVATE_KEYS&gt;`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 使用提供的私钥。
</code></pre>
<pre><code class="language-markdown">#### 钱包选项 - Keystore

`--keystore` _路径_  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;使用指定文件夹或文件中的 keystore。  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `ETH_KEYSTORE`

`--account` _账户名称_  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;通过文件名从默认 keystores 文件夹（~/.foundry/keystores）中使用 keystore。  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `ETH_KEYSTORE_ACCOUNT`

`--interactive`

`--password` _密码_  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;keystore 密码。与 `--keystore` 一起使用。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `ETH_PASSWORD`
</code></pre>
<pre><code class="language-markdown">#### 钱包选项 - 硬件钱包

`-t`  
`--trezor`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;使用 Trezor 硬件钱包。

`-l`  
`--ledger`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;使用 Ledger 硬件钱包。
</code></pre>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-76"><a class="header" href="#examples-76">EXAMPLES</a></h3>
<ol>
<li>获取 <code>keystore.json</code> 中的密钥对的地址：
<pre><code class="language-sh">cast wallet address --keystore keystore.json
</code></pre>
</li>
</ol>
<h3 id="see-also-86"><a class="header" href="#see-also-86">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a>, <a href="reference/cast/./cast-wallet.html">cast wallet</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-wallet-sign"><a class="header" href="#cast-wallet-sign">cast wallet sign</a></h2>
<h3 id="name-94"><a class="header" href="#name-94">NAME</a></h3>
<p>cast-wallet-sign - 签名消息。</p>
<h3 id="synopsis-93"><a class="header" href="#synopsis-93">SYNOPSIS</a></h3>
<p><code>cast wallet sign</code> [<em>options</em>] <em>message</em></p>
<h3 id="description-93"><a class="header" href="#description-93">DESCRIPTION</a></h3>
<p>签名消息。</p>
<h3 id="options-92"><a class="header" href="#options-92">OPTIONS</a></h3>
<pre><code class="language-markdown">#### 钱包选项 - 原始:
`-i`  
`--interactive &lt;NUM&gt;`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 打开一个交互式提示符以输入您的私钥。接受一个值，表示要输入的私钥数量。  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 默认为 `0`。  

`--mnemonic-derivation-path &lt;PATHS&gt;`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 钱包派生路径。适用于 `--mnemonic-path` 和硬件钱包。  

`--mnemonic-indexes &lt;INDEXES&gt;`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 使用给定助记词索引的私钥。与 `--mnemonic-paths` 一起使用。  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 默认为 `0`。

`--mnemonic-passphrase &lt;PASSPHRASE&gt;`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 使用 BIP39 密码短语。  

`--mnemonic &lt;PATHS&gt;`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 使用指定路径的助记词短语或助记词文件。  

`--private-key &lt;RAW_PRIVATE_KEY&gt;`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 使用提供的私钥。

`--private-keys &lt;RAW_PRIVATE_KEYS&gt;`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 使用提供的私钥。
</code></pre>
<pre><code class="language-markdown">#### 钱包选项 - Keystore

`--keystore` _路径_  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;使用指定文件夹或文件中的 keystore。  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `ETH_KEYSTORE`

`--account` _账户名称_  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;通过文件名从默认 keystores 文件夹（~/.foundry/keystores）中使用 keystore。  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `ETH_KEYSTORE_ACCOUNT`

`--interactive`

`--password` _密码_  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;keystore 密码。与 `--keystore` 一起使用。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境变量: `ETH_PASSWORD`
</code></pre>
<pre><code class="language-markdown">#### 钱包选项 - 硬件钱包

`-t`  
`--trezor`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;使用 Trezor 硬件钱包。

`-l`  
`--ledger`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;使用 Ledger 硬件钱包。
</code></pre>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-77"><a class="header" href="#examples-77">EXAMPLES</a></h3>
<ol>
<li>
<p>使用 keystore 签名消息：</p>
<pre><code class="language-sh">cast wallet sign --keystore keystore.json --interactive "hello"
</code></pre>
</li>
<li>
<p>使用原始私钥签名消息：</p>
<pre><code class="language-sh">cast wallet sign --private-key $PRIV_KEY "hello"
</code></pre>
</li>
</ol>
<h3 id="see-also-87"><a class="header" href="#see-also-87">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a>, <a href="reference/cast/./cast-wallet.html">cast wallet</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-wallet-vanity"><a class="header" href="#cast-wallet-vanity">cast wallet vanity</a></h2>
<h3 id="名称-18"><a class="header" href="#名称-18">名称</a></h3>
<p>cast-wallet-vanity - 生成一个自定义地址。</p>
<h3 id="概要-19"><a class="header" href="#概要-19">概要</a></h3>
<p><code>cast wallet vanity</code> [<em>选项</em>]</p>
<h3 id="描述-19"><a class="header" href="#描述-19">描述</a></h3>
<p>生成一个自定义地址。</p>
<p>如果指定了 <code>--nonce</code>，则该命令将尝试生成一个自定义合约地址。<code>--save-path</code> 选项允许指定一个自定义文件路径来保存生成的钱包详细信息。</p>
<h3 id="选项-18"><a class="header" href="#选项-18">选项</a></h3>
<h4 id="密钥库选项"><a class="header" href="#密钥库选项">密钥库选项</a></h4>
<p><code>--starts-with</code> <em>hex</em><br />
    自定义地址的前缀。</p>
<p><code>--ends-with</code> <em>hex</em><br />
    自定义地址的后缀。</p>
<p><code>--nonce</code> <em>nonce</em><br />
    生成一个由生成的密钥对创建的自定义合约地址，并指定 nonce。</p>
<p><code>--save-path</code> <em>path</em><br />
    保存生成的自定义钱包的路径。如果提供，钱包详细信息将保存在此位置的 JSON 文件中。</p>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="示例-16"><a class="header" href="#示例-16">示例</a></h3>
<ol>
<li>
<p>创建一个以 <code>dead</code> 开头的新密钥对：</p>
<pre><code class="language-sh">cast wallet vanity --starts-with dead
</code></pre>
</li>
<li>
<p>创建一个以 <code>beef</code> 结尾的新密钥对：</p>
<pre><code class="language-sh">cast wallet vanity --ends-with beef
</code></pre>
</li>
<li>
<p>创建一个以 <code>dead</code> 开头的新密钥对，并将详细信息保存到特定路径：</p>
<pre><code class="language-sh">cast wallet vanity --starts-with dead --save-path /path/to/save
</code></pre>
</li>
</ol>
<h3 id="另请参阅-8"><a class="header" href="#另请参阅-8">另请参阅</a></h3>
<p><a href="reference/cast/./cast.html">cast</a>, <a href="reference/cast/./cast-wallet.html">cast wallet</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-wallet-verify"><a class="header" href="#cast-wallet-verify">cast wallet verify</a></h2>
<h3 id="name-95"><a class="header" href="#name-95">NAME</a></h3>
<p>cast-wallet-verify - 验证消息的签名。</p>
<h3 id="synopsis-94"><a class="header" href="#synopsis-94">SYNOPSIS</a></h3>
<p><code>cast wallet verify</code> [<em>options</em>] <code>--address</code> <em>address</em> <em>message</em> <em>signature</em></p>
<h3 id="description-94"><a class="header" href="#description-94">DESCRIPTION</a></h3>
<p>验证消息的签名。</p>
<h3 id="options-93"><a class="header" href="#options-93">OPTIONS</a></h3>
<h4 id="签名选项"><a class="header" href="#签名选项">签名选项</a></h4>
<p><code>-a</code> <em>address</em><br />
<code>--address</code> <em>address</em><br />
    消息签名者的地址。</p>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="see-also-88"><a class="header" href="#see-also-88">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a>, <a href="reference/cast/./cast-wallet.html">cast wallet</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-wallet-import"><a class="header" href="#cast-wallet-import">cast wallet import</a></h2>
<h3 id="name-96"><a class="header" href="#name-96">NAME</a></h3>
<p>cast-wallet-import - 将私钥导入加密密钥库</p>
<h3 id="synopsis-95"><a class="header" href="#synopsis-95">SYNOPSIS</a></h3>
<p><code>cast wallet import</code> [<em>options</em>] <em>account_name</em></p>
<h3 id="description-95"><a class="header" href="#description-95">DESCRIPTION</a></h3>
<p>将私钥导入加密密钥库。</p>
<p>如果没有指定 <em>keystore-dir</em>，它将保存在默认的 <code>~/.foundry/keystores</code> 中，因此可以通过 <code>forge script</code>、<code>cast send</code> 或其他需要私钥的方法中的 <code>--account</code> 选项访问。</p>
<h3 id="options-94"><a class="header" href="#options-94">OPTIONS</a></h3>
<h4 id="directory-options"><a class="header" href="#directory-options">Directory Options</a></h4>
<p><code>-k</code><br />
<code>--keystore-dir</code></p>
<p>    存储加密密钥库的路径。<br />
    默认为 <code>~/.foundry/keystores</code>。</p>
<pre><code class="language-markdown">#### 钱包选项 - 原始:
`-i`  
`--interactive &lt;NUM&gt;`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 打开一个交互式提示符以输入您的私钥。接受一个值，表示要输入的私钥数量。  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 默认为 `0`。  

`--mnemonic-derivation-path &lt;PATHS&gt;`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 钱包派生路径。适用于 `--mnemonic-path` 和硬件钱包。  

`--mnemonic-indexes &lt;INDEXES&gt;`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 使用给定助记词索引的私钥。与 `--mnemonic-paths` 一起使用。  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 默认为 `0`。

`--mnemonic-passphrase &lt;PASSPHRASE&gt;`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 使用 BIP39 密码短语。  

`--mnemonic &lt;PATHS&gt;`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 使用指定路径的助记词短语或助记词文件。  

`--private-key &lt;RAW_PRIVATE_KEY&gt;`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 使用提供的私钥。

`--private-keys &lt;RAW_PRIVATE_KEYS&gt;`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 使用提供的私钥。
</code></pre>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="examples-78"><a class="header" href="#examples-78">EXAMPLES</a></h3>
<ol>
<li>
<p>从私钥创建密钥库：</p>
<pre><code class="language-sh">cast wallet import BOB --interactive
</code></pre>
</li>
<li>
<p>从助记词创建密钥库：</p>
<pre><code class="language-sh">cast wallet import ALICE --mnemonic "test test test test test test test test test test test test"
</code></pre>
</li>
<li>
<p>从助记词和特定助记词索引创建密钥库：</p>
<pre><code class="language-sh">cast wallet import ALICE --mnemonic "test test test test test test test test test test test test" --mnemonic-index 1
</code></pre>
</li>
</ol>
<h3 id="see-also-89"><a class="header" href="#see-also-89">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a>, <a href="reference/cast/./cast-wallet.html">cast wallet</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cast-wallet-list"><a class="header" href="#cast-wallet-list">cast wallet list</a></h2>
<h3 id="name-97"><a class="header" href="#name-97">NAME</a></h3>
<p>cast-wallet-list - 列出密钥库默认目录中的所有账户。</p>
<h3 id="synopsis-96"><a class="header" href="#synopsis-96">SYNOPSIS</a></h3>
<p><code>cast wallet list</code></p>
<h3 id="description-96"><a class="header" href="#description-96">DESCRIPTION</a></h3>
<p>列出密钥库默认目录 <code>~/.foundry/keystores</code> 中的所有账户。</p>
<h3 id="options-95"><a class="header" href="#options-95">OPTIONS</a></h3>
<pre><code class="language-markdown">#### 常用选项

`-h`  
`--help`  
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;打印帮助信息。
</code></pre>
<h3 id="see-also-90"><a class="header" href="#see-also-90">SEE ALSO</a></h3>
<p><a href="reference/cast/./cast.html">cast</a>, <a href="reference/cast/./cast-wallet.html">cast wallet</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="anvil"><a class="header" href="#anvil">anvil</a></h2>
<h3 id="名称-19"><a class="header" href="#名称-19">名称</a></h3>
<p>anvil - 创建一个本地测试网节点，用于部署和测试智能合约。它还可以用于分叉其他 EVM 兼容网络。</p>
<h3 id="概要-20"><a class="header" href="#概要-20">概要</a></h3>
<p><code>anvil</code> [<em>选项</em>]</p>
<h3 id="描述-20"><a class="header" href="#描述-20">描述</a></h3>
<p>创建一个本地测试网节点，用于部署和测试智能合约。它还可以用于分叉其他 EVM 兼容网络。</p>
<p>本节涵盖了关于挖矿模式、支持的传输层、支持的 RPC 方法、Anvil 标志及其用法的广泛信息列表。你可以同时运行多个标志。</p>
<h4 id="挖矿模式"><a class="header" href="#挖矿模式">挖矿模式</a></h4>
<p>挖矿模式指的是使用 Anvil 挖矿的频率。默认情况下，它会在提交交易时自动生成一个新区块。</p>
<p>你可以更改此设置为间隔挖矿，这意味着将在用户选择的给定时间段内生成一个新区块。如果你想要这种类型的挖矿，可以通过添加 <code>--block-time &lt;block-time-in-seconds&gt;</code> 标志来实现，如下例所示。</p>
<pre><code class="language-sh"># 每 10 秒生成一个新区块
anvil --block-time 10
</code></pre>
<p>还有一种第三种挖矿模式称为从不。在这种情况下，它禁用自动和间隔挖矿，改为按需挖矿。你可以通过输入以下命令来实现：</p>
<pre><code class="language-sh"># 启用从不挖矿模式
anvil --no-mining
</code></pre>
<p>为了加快区块的最终确定，你可以使用 <code>--slots-in-an-epoch</code> 标志并设置值为 <code>1</code>。这将导致高度为 <code>N-2</code> 的区块被最终确定，其中 <code>N</code> 是最新区块。</p>
<h4 id="支持的传输层"><a class="header" href="#支持的传输层">支持的传输层</a></h4>
<p>支持 HTTP 和 Websocket 连接。服务器默认监听端口 8545，但可以通过运行以下命令进行更改：</p>
<pre><code class="language-sh">anvil --port &lt;端口&gt;
</code></pre>
<h4 id="默认-create2-部署者"><a class="header" href="#默认-create2-部署者">默认 CREATE2 部署者</a></h4>
<p>Anvil 在未分叉时，包含 <a href="https://github.com/Arachnid/deterministic-deployment-proxy" title="" target="_blank">默认 CREATE2 部署者代理</a> 在地址 <code>0x4e59b44847b379578588920ca78fbf26c0b4956c</code>。</p>
<p>这允许你在本地测试 CREATE2 部署而无需分叉。</p>
<h4 id="支持的-rpc-方法"><a class="header" href="#支持的-rpc-方法">支持的 RPC 方法</a></h4>
<h5 id="标准方法"><a class="header" href="#标准方法">标准方法</a></h5>
<p>标准方法基于 <a href="https://eth.wiki/json-rpc/API" title="" target="_blank">此</a> 参考。</p>
<ul>
<li>
<p><code>web3_clientVersion</code></p>
</li>
<li>
<p><code>web3_sha3</code></p>
</li>
<li>
<p><code>eth_chainId</code></p>
</li>
<li>
<p><code>eth_networkId</code></p>
</li>
<li>
<p><code>eth_gasPrice</code></p>
</li>
<li>
<p><code>eth_accounts</code></p>
</li>
<li>
<p><code>eth_blockNumber</code></p>
</li>
<li>
<p><code>eth_getBalance</code></p>
</li>
<li>
<p><code>eth_getStorageAt</code></p>
</li>
<li>
<p><code>eth_getBlockByHash</code></p>
</li>
<li>
<p><code>eth_getBlockByNumber</code></p>
</li>
<li>
<p><code>eth_getTransactionCount</code></p>
</li>
<li>
<p><code>eth_getBlockTransactionCountByHash</code></p>
</li>
<li>
<p><code>eth_getBlockTransactionCountByNumber</code></p>
</li>
<li>
<p><code>eth_getUncleCountByBlockHash</code></p>
</li>
<li>
<p><code>eth_getUncleCountByBlockNumber</code></p>
</li>
<li>
<p><code>eth_getCode</code></p>
</li>
<li>
<p><code>eth_sign</code></p>
</li>
<li>
<p><code>eth_signTypedData_v4</code></p>
</li>
<li>
<p><code>eth_sendTransaction</code></p>
</li>
<li>
<p><code>eth_sendRawTransaction</code></p>
</li>
<li>
<p><code>eth_call</code></p>
</li>
<li>
<p><code>eth_createAccessList</code></p>
</li>
<li>
<p><code>eth_estimateGas</code></p>
</li>
<li>
<p><code>eth_getTransactionByHash</code></p>
</li>
<li>
<p><code>eth_getTransactionByBlockHashAndIndex</code></p>
</li>
<li>
<p><code>eth_getTransactionByBlockNumberAndIndex</code></p>
</li>
<li>
<p><code>eth_getTransactionReceipt</code></p>
</li>
<li>
<p><code>eth_getUncleByBlockHashAndIndex</code></p>
</li>
<li>
<p><code>eth_getUncleByBlockNumberAndIndex</code></p>
</li>
<li>
<p><code>eth_getLogs</code></p>
</li>
<li>
<p><code>eth_newFilter</code></p>
</li>
<li>
<p><code>eth_getFilterChanges</code></p>
</li>
<li>
<p><code>eth_newBlockFilter</code></p>
</li>
<li>
<p><code>eth_newPendingTransactionFilter</code></p>
</li>
<li>
<p><code>eth_getFilterLogs</code></p>
</li>
<li>
<p><code>eth_uninstallFilter</code></p>
</li>
<li>
<p><code>eth_getWork</code></p>
</li>
<li>
<p><code>eth_subscribe</code></p>
</li>
<li>
<p><code>eth_unsubscribe</code></p>
</li>
<li>
<p><code>eth_syncing</code></p>
</li>
<li>
<p><code>eth_submitWork</code></p>
</li>
<li>
<p><code>eth_submitHashrate</code></p>
</li>
<li>
<p><code>eth_feeHistory</code></p>
</li>
<li>
<p><code>eth_getProof</code></p>
</li>
<li>
<p><code>debug_traceTransaction</code>
使用 <code>anvil --steps-tracing</code> 获取 <code>structLogs</code></p>
</li>
<li>
<p><code>debug_traceCall</code>
注意，非标准追踪尚未支持。这意味着你不能传递任何参数给 <code>trace</code> 参数。</p>
</li>
<li>
<p><code>trace_transaction</code></p>
</li>
<li>
<p><code>trace_block</code></p>
</li>
</ul>
<h5 id="自定义方法"><a class="header" href="#自定义方法">自定义方法</a></h5>
<p><code>anvil_*</code> 命名空间是 <code>hardhat</code> 的别名。更多信息，请参考 <a href="https://hardhat.org/hardhat-network/reference#hardhat-network-methods" title="" target="_blank">Hardhat 文档</a>。</p>
<p><code>anvil_impersonateAccount</code>
发送交易伪装成外部拥有的账户或合约。</p>
<p><code>anvil_stopImpersonatingAccount</code>
停止伪装账户或合约，如果之前通过 <code>anvil_impersonateAccount</code> 设置。</p>
<p><code>anvil_autoImpersonateAccount</code>
接受 <code>true</code> 启用自动伪装账户，<code>false</code> 禁用。启用后，任何交易的 sender 将自动伪装。与 <code>anvil_impersonateAccount</code> 相同。</p>
<p><code>anvil_getAutomine</code>
如果启用自动挖矿，返回 true，否则返回 false。</p>
<p><code>anvil_mine</code>
挖一系列区块。</p>
<p><code>anvil_dropTransaction</code>
从池中移除交易。</p>
<p><code>anvil_reset</code>
重置分叉到新的分叉状态，并可选地更新分叉配置。</p>
<p><code>anvil_setRpcUrl</code>
设置后端 RPC URL。</p>
<p><code>anvil_setBalance</code>
修改账户的余额。</p>
<p><code>anvil_setCode</code>
设置合约的代码。</p>
<p><code>anvil_setNonce</code>
设置地址的 nonce。</p>
<p><code>anvil_setStorageAt</code>
写入账户存储的单个槽。</p>
<p><code>anvil_setCoinbase</code>
设置 coinbase 地址。</p>
<p><code>anvil_setLoggingEnabled</code>
启用或禁用日志记录。</p>
<p><code>anvil_setMinGasPrice</code>
设置节点的最低 gas 价格。</p>
<p><code>anvil_setNextBlockBaseFeePerGas</code>
设置下一个区块的基础费用。</p>
<p><code>anvil_setChainId</code>
设置当前 EVM 实例的链 ID。</p>
<p><code>anvil_dumpState</code>
返回表示链完整状态的十六进制字符串。可以重新导入到 Anvil 的新实例中以重新获得相同的状态。</p>
<p><code>anvil_loadState</code>
当给定之前由 <code>anvil_dumpState</code> 返回的十六进制字符串时，将内容合并到当前链状态中。将覆盖任何冲突的账户/存储槽。</p>
<p><code>anvil_nodeInfo</code>
检索当前运行的 Anvil 节点的配置参数。</p>
<h5 id="特殊方法"><a class="header" href="#特殊方法">特殊方法</a></h5>
<p>特殊方法来自 Ganache。你可以查看文档 <a href="https://github.com/trufflesuite/ganache-cli-archive/blob/master/README.md" title="" target="_blank">这里</a>。</p>
<p><code>evm_setAutomine</code>
根据单个布尔参数启用或禁用自动挖矿，即每次向网络提交新交易时自动挖矿。</p>
<p><code>evm_setIntervalMining</code>
将挖矿行为设置为间隔，并设置给定的间隔（秒）。</p>
<p><code>evm_snapshot</code>
在当前区块快照区块链状态。</p>
<p><code>evm_revert</code>
将区块链状态恢复到之前的快照。接受单个参数，即要恢复到的快照 ID。</p>
<p><code>evm_increaseTime</code>
向前跳跃给定的时间量，以秒为单位。</p>
<p><code>evm_setNextBlockTimestamp</code>
类似于 <code>evm_increaseTime</code>，但接受下一个区块的确切时间戳。</p>
<p><code>anvil_setBlockTimestampInterval</code>
类似于 <code>evm_increaseTime</code>，但设置区块时间戳 <code>interval</code>。下一个区块的时间戳将计算为 <code>lastBlock_timestamp + interval</code>。</p>
<p><code>evm_setBlockGasLimit</code>
设置后续区块的区块 gas 限制。</p>
<p><code>anvil_removeBlockTimestampInterval</code>
移除存在的 <code>anvil_setBlockTimestampInterval</code>。</p>
<p><code>evm_mine</code>
挖一个区块。</p>
<p><code>anvil_enableTraces</code>
为返回给用户的交易开启调用追踪（而不是仅返回 txhash/receipt）。</p>
<p><code>eth_sendUnsignedTransaction</code>
无论签名状态如何，执行交易。</p>
<p>对于接下来的三个方法，请确保阅读 <a href="https://geth.ethereum.org/docs/rpc/ns-txpool" title="" target="_blank">Geth 的文档</a>。</p>
<p><code>txpool_status</code>
返回当前等待包含在下一个区块中的交易数量，以及仅计划未来执行的交易。</p>
<p><code>txpool_inspect</code>
返回当前等待包含在下一个区块中的所有交易的摘要，以及仅计划未来执行的交易。</p>
<p><code>txpool_content</code>
返回当前等待包含在下一个区块中的所有交易的详细信息，以及仅计划未来执行的交易。</p>
<h5 id="otterscan-方法"><a class="header" href="#otterscan-方法">Otterscan 方法</a></h5>
<p><code>ots_*</code> 命名空间实现了 <a href="https://github.com/otterscan/otterscan/blob/develop/docs/custom-jsonrpc.md" title="" target="_blank">Otterscan 规范</a>。</p>
<p><code>ots_getApiLevel</code>
由 Otterscan 用于检查是否连接到兼容节点，并在不兼容时显示友好消息。</p>
<p><code>ots_getInternalOperations</code>
返回交易中的内部 ETH 转账。</p>
<p><code>ots_hasCode</code>
检查某个地址是否包含已部署的代码。</p>
<p><code>ots_getTransactionError</code>
提取交易的原始错误输出。</p>
<p><code>ots_traceTransaction</code>
提取所有类型的调用、合约创建和自毁，并返回调用树。</p>
<p><code>ots_getBlockDetails</code>
为 Otterscan 的区块详情页面定制和扩展的 eth_getBlock*。</p>
<p><code>ots_getBlockTransactions</code>
获取某个区块的分页交易，并移除一些冗余字段如 logs。</p>
<p><code>ots_searchTransactionsBefore</code>
获取某个地址的分页入站/出站交易调用，并在给定目标区块之前。</p>
<p><code>ots_searchTransactionsAfter</code>
获取某个地址的分页入站/出站交易调用，并在给定目标区块之后。</p>
<p><code>ots_getTransactionBySenderAndNonce</code>
获取某个发送者地址的给定 nonce 的交易哈希。</p>
<p><code>ots_getContractCreator</code>
获取创建合约的交易哈希和地址。</p>
<h3 id="选项-19"><a class="header" href="#选项-19">选项</a></h3>
<h4 id="通用选项"><a class="header" href="#通用选项">通用选项</a></h4>
<p><code>-a, --accounts &lt;账户数&gt;</code>
     设置账户数量。[默认: 10]</p>
<p><code>--auto-impersonate</code>
     启动时启用 autoImpersonate。</p>
<p><code>-b, --block-time &lt;区块时间&gt;</code>
     间隔挖矿的区块时间（秒）。</p>
<p><code>--balance &lt;余额&gt;</code>
     设置账户的余额。[默认: 10000]</p>
<p><code>--derivation-path &lt;派生路径&gt;</code>
     设置要派生的子密钥的派生路径。[默认: m/44’/60’/0’/0/]</p>
<p><code>-h, --help</code>
     打印帮助信息。</p>
<p><code>--hardfork &lt;硬分叉&gt;</code>
     选择要使用的 EVM 硬分叉，例如 <code>shanghai</code>, <code>paris</code>, <code>london</code> 等… [默认: latest]</p>
<p><code>--init &lt;路径&gt;</code>
     使用给定的 <code>genesis.json</code> 文件初始化创世区块。</p>
<p><code>-m, --mnemonic &lt;助记词&gt;</code>
     用于生成账户的 BIP39 助记词短语。</p>
<p><code>--no-mining</code>
     禁用自动和间隔挖矿，改为按需挖矿。</p>
<p><code>--order &lt;排序&gt;</code>
     交易在 mempool 中的排序方式。[默认: fees]</p>
<p><code>-p, --port &lt;端口&gt;</code>
     监听的端口号。[默认: 8545]</p>
<p><code>--steps-tracing</code>
     启用用于 debug 调用返回 geth 风格追踪的步骤追踪。[别名: tracing]</p>
<p><code>--ipc [&lt;路径&gt;]</code>
     在给定的 <code>路径</code> 参数或默认路径启动 IPC 端点：unix: <code>tmp/anvil.ipc</code>，windows: <code>\\.\pipe\anvil.ipc</code>。</p>
<p><code>--silent</code>
     启动时不打印任何内容。</p>
<p><code>--timestamp &lt;时间戳&gt;</code>
     设置创世区块的时间戳。</p>
<p><code>-V, --version</code>
     打印版本信息。</p>
<p><code>--disable-default-create2-deployer</code>
     禁用在未分叉时运行 Anvil 的默认 CREATE2 工厂部署。</p>
<h4 id="evm-选项"><a class="header" href="#evm-选项">EVM 选项</a></h4>
<p><code>-f, --fork-url &lt;URL&gt;</code>
     从远程端点获取状态，而不是从空状态开始。</p>
<p><code>--fork-block-number &lt;区块&gt;</code>
     从远程端点获取特定区块号的状态（必须在同一命令行中传递 <code>--fork-url</code>）。</p>
<p><code>--fork-retry-backoff &lt;回退&gt;</code>
     遇到错误时的初始重试回退。</p>
<p><code>--retries &lt;重试次数&gt;</code>
     虚假网络的重试请求次数（超时请求）。[默认: 5]</p>
<p><code>--timeout &lt;超时&gt;</code>
     分叉模式下发送给远程 JSON-RPC 服务器的请求超时（毫秒）。[默认: 45000]</p>
<p><code>--compute-units-per-second &lt;CUPS&gt;</code>
     设置此提供者假设的每秒可用计算单元数。[默认: 330]
     另见，<a href="https://github.com/alchemyplatform/alchemy-docs/blob/master/documentation/compute-units.md#rate-limits-cups" title="" target="_blank">Alchemy Ratelimits</a>。</p>
<p><code>--no-rate-limit</code>
     禁用此节点的提供者速率限制。如果存在，将始终覆盖 <code>--compute-units-per-second</code>。[默认: false]
     另见，<a href="https://github.com/alchemyplatform/alchemy-docs/blob/master/documentation/compute-units.md#rate-limits-cups" title="" target="_blank">Alchemy Ratelimits</a>。</p>
<p><code>--no-storage-caching</code>
     禁用 RPC 缓存；所有存储槽都从端点读取。此标志覆盖项目的配置文件（必须在同一命令行中传递 –fork-url）。</p>
<h4 id="执行环境配置"><a class="header" href="#执行环境配置">执行环境配置</a></h4>
<p><code>--base-fee &lt;费用&gt;</code>
<code>--block-base-fee-per-gas &lt;费用&gt;</code>
     区块中的基础费用。</p>
<p><code>--chain-id &lt;链ID&gt;</code>
     链 ID。[默认: 31337]</p>
<p><code>--code-size-limit &lt;代码大小&gt;</code>
     EIP-170: 合约代码大小限制（字节）。用于增加测试的限制。[默认: 0x6000 (~25kb)]</p>
<p><code>--gas-limit &lt;gas限制&gt;</code>
     区块 gas 限制。</p>
<p><code>--gas-price &lt;gas价格&gt;</code>
     gas 价格。</p>
<h4 id="服务器选项"><a class="header" href="#服务器选项">服务器选项</a></h4>
<p><code>--allow-origin &lt;允许来源&gt;</code>
     设置 CORS <code>allow_origin</code>。[默认: *]</p>
<p><code>--no-cors</code>
     禁用 CORS。</p>
<p><code>--host &lt;主机&gt;</code>
     服务器将监听的 IP 地址。</p>
<p><code>--config-out &lt;输出文件&gt;</code>
     将 <code>anvil</code> 的输出作为 json 写入用户指定的文件。</p>
<p><code>--prune-history</code>
     不保留完整的链历史。</p>
<h3 id="示例-17"><a class="header" href="#示例-17">示例</a></h3>
<ol>
<li>设置账户数量为 15 且余额为 300 ETH</li>
</ol>
<pre><code class="language-sh">anvil --accounts 15 --balance 300
</code></pre>
<ol start="2">
<li>选择将执行测试的地址</li>
</ol>
<pre><code class="language-sh">anvil --sender 0xC8479C45EE87E0B437c09d3b8FE8ED14ccDa825E
</code></pre>
<ol start="3">
<li>将交易在 mempool 中的排序方式更改为 FIFO</li>
</ol>
<pre><code class="language-sh">anvil --order fifo
</code></pre>
<h3 id="shell-补全"><a class="header" href="#shell-补全">Shell 补全</a></h3>
<p><code>anvil completions</code> <em>shell</em></p>
<p>为给定的 shell 生成 shell 补全脚本。</p>
<p>支持的 shell 有：</p>
<ul>
<li>bash</li>
<li>elvish</li>
<li>fish</li>
<li>powershell</li>
<li>zsh</li>
</ul>
<h4 id="示例-18"><a class="header" href="#示例-18">示例</a></h4>
<ol>
<li>为 zsh 生成 shell 补全脚本：
<pre><code class="language-sh">anvil completions zsh &gt; $HOME/.oh-my-zsh/completions/_anvil
</code></pre>
</li>
</ol>
<h3 id="在-docker-中使用"><a class="header" href="#在-docker-中使用">在 Docker 中使用</a></h3>
<p>为了在 Github Actions 中以 <a href="reference/anvil/../../tutorials/foundry-docker.html">Docker 容器</a> 运行 anvil 作为服务，其中无法向 entrypoint 命令传递参数，使用 <code>ANVIL_IP_ADDR</code> 环境变量设置主机的 IP。<code>ANVIL_IP_ADDR=0.0.0.0</code> 等同于提供 <code>--host &lt;ip&gt;</code> 选项。</p>
<h4 id="使用-genesisjson"><a class="header" href="#使用-genesisjson">使用 <code>genesis.json</code></a></h4>
<p>Anvil 中的 <code>genesis.json</code> 文件与 Geth 中的作用类似，定义网络的初始状态、共识规则和预分配账户，以确保所有节点一致启动并维护网络完整性。所有值，包括余额、gas 限制等，均定义为十六进制。</p>
<ul>
<li><code>chainId</code>: 区块链的标识符，每个网络唯一。</li>
<li><code>nonce</code>: 用于确保数据完整性的哈希算法中的计数器。</li>
<li><code>timestamp</code>: 创世区块的创建时间，Unix 时间。</li>
<li><code>extraData</code>: 创世区块创建者可以包含的额外数据。</li>
<li><code>gasLimit</code>: 区块中可以使用的最大 gas 量。</li>
<li><code>difficulty</code>: 挖矿新区块的难度。</li>
<li><code>mixHash</code>: 证明区块有足够计算量的唯一标识符。</li>
<li><code>coinbase</code>: 挖出此区块的矿工的以太坊地址。</li>
<li><code>stateRoot</code>: 状态 trie 的根，反映所有交易后的最终状态。</li>
<li><code>alloc</code>: 允许预分配以太币到一组具有预定义余额的地址。</li>
<li><code>number</code>: 区块号，创世区块为 0。</li>
<li><code>gasUsed</code>: 区块中使用的总 gas。</li>
<li><code>parentHash</code>: 父区块的哈希，创世区块为全零，因为没有父区块。</li>
</ul>
<p>模拟主网的 genesis 示例可以在这里找到 <a href="https://github.com/paradigmxyz/reth/blob/8f3e4a15738d8174d41f4aede5570ecead141a77/crates/primitives/res/genesis/mainnet.json" title="" target="_blank">这里</a>。</p>
<pre><code class="language-json">{
  "chainId": "0x2323",
  "nonce": "0x42",
  "timestamp": "0x0",
  "extraData": "0x11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa",
  "gasLimit": "0x1388",
  "difficulty": "0x400000000",
  "mixHash": "0x0000000000000000000000000000000000000000000000000000000000000000",
  "coinbase": "0x0000000000000000000000000000000000000000",
  "stateRoot": "0xd7f8974fb5ac78d9ac099b9ad5018bedc2ce0a72dad1827a1709da30580f0544",
  "alloc": {
    "000d836201318ec6899a67540690382780743280": {
      "balance": "0xad78ebc5ac6200000"
    }
  },
  "number": "0x0",
  "gasUsed": "0x0",
  "parentHash": "0x0000000000000000000000000000000000000000000000000000000000000000"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="chisel"><a class="header" href="#chisel">chisel</a></h2>
<h3 id="name-98"><a class="header" href="#name-98">NAME</a></h3>
<p><code>chisel</code> - 在 REPL 环境中测试 Solidity 输入并接收详细反馈。</p>
<h3 id="synopsis-97"><a class="header" href="#synopsis-97">SYNOPSIS</a></h3>
<p><code>chisel</code> [<em>options</em>]</p>
<h4 id="子命令-bin"><a class="header" href="#子命令-bin">子命令 (bin)</a></h4>
<ol>
<li><code>chisel list</code>
<ul>
<li>显示存储在 <code>~/.foundry/cache/chisel</code> 中的所有缓存会话。</li>
</ul>
</li>
<li><code>chisel load &lt;id&gt;</code>
<ul>
<li>如果存在 <code>id = &lt;id&gt;</code> 的缓存会话，启动 REPL 并加载相应的会话。</li>
</ul>
</li>
<li><code>chisel view &lt;id&gt;</code>
<ul>
<li>如果存在 <code>id = &lt;id&gt;</code> 的缓存会话，显示会话的 REPL 合约的源代码。</li>
</ul>
</li>
<li><code>chisel clear-cache</code>
<ul>
<li>删除 <code>~/.foundry/cache/chisel</code> 目录中的所有缓存文件。这些会话无法恢复，因此请谨慎使用此命令。</li>
</ul>
</li>
</ol>
<h4 id="标志"><a class="header" href="#标志">标志</a></h4>
<p>查看 <code>man chisel</code> 或 <code>chisel --help</code> 以获取所有可用的环境配置标志。</p>
<h3 id="description-97"><a class="header" href="#description-97">DESCRIPTION</a></h3>
<p>Chisel 是一个 Solidity REPL（即“读取-求值-打印循环”），允许开发人员编写和测试 Solidity 代码片段。它提供了一个交互式环境来编写和执行 Solidity 代码，以及一组内置命令来处理和调试代码。这使得它成为一个有用的工具，可以快速测试和试验 Solidity 代码，而无需启动沙盒 foundry 测试套件。</p>
<h3 id="用法"><a class="header" href="#用法">用法</a></h3>
<p>要打开 chisel，只需执行 <code>chisel</code> 二进制文件。</p>
<p>从那里，输入有效的 Solidity 代码。除了命令之外，chisel 提示符有两种输入：</p>
<ol>
<li>表达式
<ul>
<li>表达式是返回值或可以单独求值的语句。例如，<code>1 &lt;&lt; 8</code> 是一个表达式，它将求值为一个值为 <code>256</code> 的 <code>uint256</code>。表达式将立即求值，并且在会话状态中不会持久存在。</li>
<li>示例：
<ul>
<li><code>address(0).balance</code></li>
<li><code>abi.encode(256, bytes32(0), "Chisel!")</code></li>
<li><code>myViewFunc(128)</code></li>
<li>…</li>
</ul>
</li>
</ul>
</li>
<li>语句
<ul>
<li>语句是旨在在会话状态中持久存在的代码片段。语句包括变量定义、调用返回值的非状态突变函数以及合约、函数、事件、错误、映射或结构定义。如果希望将表达式作为语句求值，可以在末尾附加一个分号（<code>;</code>）。</li>
<li>示例：
<ul>
<li>
<p><code>uint256 a = 0xa57b</code></p>
</li>
<li>
<p><code>myStateMutatingFunc(128)</code> || <code>myViewFunc(128);</code> &lt;- 注意 <code>;</code></p>
</li>
<li>
<pre><code class="language-solidity">function hash64(
  bytes32 _a,
  bytes32 _b
) internal pure returns (bytes32 _hash) { 
    assembly {
        // 将我们要哈希的 64 字节存储在暂存空间中
        mstore(0x00, _a)
        mstore(0x20, _b)

        // 哈希暂存空间中的内存
        // 并将结果赋值给 `_hash`
        _hash := keccak256(0x00, 0x40)
    }
}
</code></pre>
</li>
<li>
<p><code>event ItHappened(bytes32 indexed hash)</code></p>
</li>
<li>
<p><code>struct Complex256 { uint256 re; uint256 im; }</code></p>
</li>
<li>
<p>…</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="可用命令"><a class="header" href="#可用命令">可用命令</a></h4>
<pre><code class="language-text">No solidity versions installed! Installing solidity version 0.8.19...
Welcome to Chisel! Type `!help` to show available commands.
⚒️ Chisel help
=============
General
	!help | !h - Display all commands
	!quit | !q - Quit Chisel
	!exec &lt;command&gt; [args] | !e &lt;command&gt; [args] - Execute a shell command and print the output

Session
	!clear | !c - Clear current session source
	!source | !so - Display the source code of the current session
	!save [id] | !s [id] - Save the current session to cache
	!load &lt;id&gt; | !l &lt;id&gt; - Load a previous session ID from cache
	!list | !ls - List all cached sessions
	!clearcache | !cc - Clear the chisel cache of all stored sessions
	!export | !ex - Export the current session source to a script file
	!fetch &lt;addr&gt; &lt;name&gt; | !fe &lt;addr&gt; &lt;name&gt; - Fetch the interface of a verified contract on Etherscan
	!edit - Open the current session in an editor

Environment
	!fork &lt;url&gt; | !f &lt;url&gt; - Fork an RPC for the current session. Supply 0 arguments to return to a local network
	!traces | !t - Enable / disable traces for the current session
	!calldata [data] | !cd [data] - Set calldata (`msg.data`) for the current session (appended after function selector). Clears it if no argument provided.

Debug
	!memdump | !md - Dump the raw memory of the current state
	!stackdump | !sd - Dump the raw stack of the current state
	!rawstack &lt;var&gt; | !rs &lt;var&gt; - Display the raw value of a variable's stack allocation. For variables that are &gt; 32 bytes in length, this will display their memory pointer.
</code></pre>
<p><strong>General</strong></p>
<p><code>!help</code> | <code>!h</code></p>
<p>显示所有命令。</p>
<p><code>!quit</code> | <code>!q</code></p>
<p>退出 Chisel。</p>
<p><code>!exec &lt;command&gt; [args]</code> | <code>!e &lt;command&gt; [args]</code></p>
<p>执行 shell 命令并打印输出。</p>
<p>示例：</p>
<pre><code class="language-sh">➜ !e ls
CHANGELOG.md
LICENSE
README.md
TESTS.md
artifacts
cache
contracts
crytic-export
deploy
deploy-config
deployments
dist
echidna.yaml
forge-artifacts
foundry.toml
hardhat.config.ts
layout-lock.json
node_modules
package.json
scripts
slither.config.json
slither.db.json
src
tasks
test-case-generator
tsconfig.build.json
tsconfig.build.tsbuildinfo
tsconfig.json
</code></pre>
<p><strong>Session</strong></p>
<p><code>!clear</code> | <code>!c</code></p>
<p>清除当前会话源代码。</p>
<p>在底层，每个 Chisel 会话都有一个底层合约，随着输入语句的增加而改变。此命令清除该合约并将会话重置为默认状态。</p>
<p><code>!source</code> | <code>!so</code></p>
<p>显示当前会话的源代码。</p>
<p>如上所述，每个 Chisel 会话都有一个底层合约。此命令将显示该合约的源代码。</p>
<p><code>!save [id]</code> | <code>!s [id]</code></p>
<p>将当前会话保存到缓存。</p>
<p>Chisel 允许缓存会话，如果您在 Chisel 中测试更复杂的逻辑或在稍后时间返回会话，这非常有用。所有缓存的 Chisel 会话都存储在 <code>~/.foundry/cache/chisel</code> 中。</p>
<p>如果未提供 <code>id</code> 参数，Chisel 将自动为正在保存的会话分配一个数字 ID。</p>
<p><code>!load &lt;id&gt;</code> | <code>!l &lt;id&gt;</code></p>
<p>从缓存加载以前的会话 ID。</p>
<p>此命令将从缓存加载以前缓存的会话。除了会话源代码外，所有环境设置也将加载。<code>id</code> 参数必须对应于 <code>~/.foundry/cache/chisel</code> 目录中现有的缓存会话。</p>
<p><code>!list</code> | <code>!ls</code></p>
<p>列出所有缓存的会话。</p>
<p>此命令将显示 <code>~/.foundry/cache/chisel</code> 目录中的所有缓存 chisel 会话。</p>
<p><code>!clearcache</code> | <code>!cc</code></p>
<p>清除所有存储的会话的 chisel 缓存。</p>
<p>删除 <code>~/.foundry/cache/chisel</code> 目录中的所有缓存文件。这些会话无法恢复，因此请谨慎使用此命令。</p>
<p><code>!export</code> | <code>!ex</code></p>
<p>将当前会话源代码导出到脚本文件。</p>
<p>如果从 foundry 项目的根目录执行 <code>chisel</code>，可以将当前会话导出到项目 <code>scripts</code> 目录中的 foundry 脚本。</p>
<p><code>!fetch &lt;addr&gt; &lt;name&gt;</code> | <code>!fe &lt;addr&gt; &lt;name&gt;</code></p>
<p>从 Etherscan 获取已验证合约的接口。</p>
<p>此命令将尝试从 Etherscan API 解析位于 <code>&lt;addr&gt;</code> 的已验证合约的接口。如果成功，接口将以 <code>&lt;name&gt;</code> 插入到会话源代码中。</p>
<p>目前，只能获取以太坊主网上已验证合约的接口。未来，Chisel 将支持从多个 Etherscan 支持的链获取接口。</p>
<p><code>!edit</code></p>
<p>在编辑器中打开当前会话的 <code>run()</code> 函数。</p>
<p>chisel 将使用 <code>$EDITOR</code> 环境变量中定义的编辑器。</p>
<p><strong>Environment</strong></p>
<p><code>!fork &lt;url&gt;</code> | <code>!f &lt;url&gt;</code></p>
<p>为当前会话分叉一个 RPC。不提供参数则返回本地网络。</p>
<p>尝试分叉提供的 RPC 的状态。如果未提供 URL，则返回使用空白本地开发网络状态。</p>
<p><code>!traces</code> | <code>!t</code></p>
<p>为当前会话启用/禁用跟踪。</p>
<p>启用跟踪后，在每个语句插入后将打印 foundry 风格的调用跟踪和日志。</p>
<p><strong>Debug</strong></p>
<p><code>!memdump</code> | <code>!md</code></p>
<p>转储当前状态的原始内存。</p>
<p>尝试在 REPL 合约的 <code>run</code> 函数执行完最后一条指令后，转储机器状态的原始内存。</p>
<p><code>!stackdump</code> | <code>!sd</code></p>
<p>转储当前状态的原始堆栈。</p>
<p>尝试在 REPL 合约的 <code>run</code> 函数执行完最后一条指令后，转储机器状态的原始堆栈。</p>
<p><code>!rawstack &lt;var&gt;</code> | <code>!rs &lt;var&gt;</code></p>
<p>显示变量的堆栈分配的原始值。对于长度大于 32 字节的变量，这将显示其内存指针。</p>
<p>当您希望查看长度小于 32 字节的变量的完整原始堆栈分配时，此命令非常有用。</p>
<p>示例：</p>
<pre><code class="language-sh">➜ address addr
➜ assembly {
    addr := not(0)
}
➜ addr
Type: address
└ Data: 0xffffffffffffffffffffffffffffffffffffffff
➜ !rs addr
Type: bytes32
└ Data: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
➜ 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="配置参考"><a class="header" href="#配置参考">配置参考</a></h2>
<ul>
<li><a href="reference/config/./overview.html">概述</a></li>
<li><a href="reference/config/./project.html">项目</a></li>
<li><a href="reference/config/./solidity-compiler.html">Solidity 编译器</a></li>
<li><a href="reference/config/./testing.html">测试</a></li>
<li><a href="reference/config/./inline-test-config.html">内联测试配置</a></li>
<li><a href="reference/config/./formatter.html">格式化工具</a></li>
<li><a href="reference/config/./doc-generator.html">文档生成器</a></li>
<li><a href="reference/config/./etherscan.html">Etherscan</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="配置概述"><a class="header" href="#配置概述">配置概述</a></h2>
<p>Foundry 的配置系统允许您配置其工具。</p>
<h3 id="配置文件"><a class="header" href="#配置文件">配置文件</a></h3>
<p>配置可以任意命名空间到配置文件中。默认配置文件名为 <code>default</code>，所有其他配置文件都继承自此配置文件的值。配置文件在 <code>profile</code> 映射中定义。</p>
<p>要添加一个名为 <code>local</code> 的配置文件，您可以添加：</p>
<pre><code class="language-toml">[profile.local]
</code></pre>
<p>您可以通过设置 <code>FOUNDRY_PROFILE</code> 环境变量来选择要使用的配置文件。</p>
<h3 id="全局配置"><a class="header" href="#全局配置">全局配置</a></h3>
<p>您可以在 <code>~/.foundry</code> 文件夹中创建一个 <code>foundry.toml</code> 文件来全局配置 Foundry。</p>
<h3 id="环境变量"><a class="header" href="#环境变量">环境变量</a></h3>
<p>配置可以通过带有 <code>FOUNDRY_</code> 和 <code>DAPP_</code> 前缀的环境变量进行覆盖。</p>
<p>例外情况是：</p>
<ul>
<li><code>FOUNDRY_FFI</code>, <code>DAPP_FFI</code>, <code>DAPP_TEST_FFI</code></li>
<li><code>FOUNDRY_PROFILE</code></li>
<li><code>FOUNDRY_REMAPPINGS</code>, <code>DAPP_REMAPPINGS</code></li>
<li><code>FOUNDRY_LIBRARIES</code>, <code>DAPP_LIBRARIES</code></li>
<li><code>FOUNDRY_FS_PERMISSIONS</code>, <code>DAPP_FS_PERMISSIONS</code>, <code>DAPP_TEST_FS_PERMISSIONS</code></li>
<li><code>DAPP_TEST_CACHE</code></li>
<li><code>DAPP_TEST_FUZZ_RUNS</code></li>
<li><code>DAPP_TEST_FUZZ_DEPTH</code></li>
</ul>
<h3 id="配置格式"><a class="header" href="#配置格式">配置格式</a></h3>
<p>配置文件使用 <a href="https://toml.io" title="" target="_blank">TOML 格式</a> 编写，在各个部分中包含简单的键值对。</p>
<p>本页详细描述了每个配置键。要查看默认值，请参阅本文档中的特定键，或查看 <a href="reference/config//static/config.default.toml">默认配置</a>。</p>
<h3 id="配置键"><a class="header" href="#配置键">配置键</a></h3>
<p>本节记录所有配置键。所有配置键必须位于一个配置文件下，例如 <code>default</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="项目"><a class="header" href="#项目">项目</a></h2>
<p>与项目相关的配置。</p>
<h5 id="src"><a class="header" href="#src"><code>src</code></a></h5>
<ul>
<li>类型: 字符串</li>
<li>默认值: src</li>
<li>环境变量: <code>FOUNDRY_SRC</code> 或 <code>DAPP_SRC</code></li>
</ul>
<p>合约源代码相对于项目根目录的路径。</p>
<h5 id="test"><a class="header" href="#test"><code>test</code></a></h5>
<ul>
<li>类型: 字符串</li>
<li>默认值: test</li>
<li>环境变量: <code>FOUNDRY_TEST</code> 或 <code>DAPP_TEST</code></li>
</ul>
<p>测试合约源代码相对于项目根目录的路径。</p>
<h5 id="script"><a class="header" href="#script"><code>script</code></a></h5>
<ul>
<li>类型: 字符串</li>
<li>默认值: script</li>
<li>环境变量: <code>FOUNDRY_SCRIPT</code> 或 <code>DAPP_SCRIPT</code></li>
</ul>
<p>脚本合约源代码相对于项目根目录的路径。</p>
<h5 id="out"><a class="header" href="#out"><code>out</code></a></h5>
<ul>
<li>类型: 字符串</li>
<li>默认值: out</li>
<li>环境变量: <code>FOUNDRY_OUT</code> 或 <code>DAPP_OUT</code></li>
</ul>
<p>存放合约工件的路径，相对于项目根目录。</p>
<h5 id="libs"><a class="header" href="#libs"><code>libs</code></a></h5>
<ul>
<li>类型: 字符串数组（路径）</li>
<li>默认值: lib</li>
<li>环境变量: <code>FOUNDRY_LIBS</code> 或 <code>DAPP_LIBS</code></li>
</ul>
<p>包含库的路径数组，相对于项目根目录。</p>
<h5 id="cache"><a class="header" href="#cache"><code>cache</code></a></h5>
<ul>
<li>类型: 布尔值</li>
<li>默认值: true</li>
<li>环境变量: <code>FOUNDRY_CACHE</code> 或 <code>DAPP_CACHE</code></li>
</ul>
<p>是否启用缓存。如果启用，编译源代码、测试和依赖项的结果将缓存到 <code>cache</code> 中。</p>
<h5 id="cache_path"><a class="header" href="#cache_path"><code>cache_path</code></a></h5>
<ul>
<li>类型: 字符串</li>
<li>默认值: cache</li>
<li>环境变量: <code>FOUNDRY_CACHE_PATH</code> 或 <code>DAPP_CACHE_PATH</code></li>
</ul>
<p>缓存的路径，相对于项目根目录。</p>
<h5 id="broadcast"><a class="header" href="#broadcast"><code>broadcast</code></a></h5>
<ul>
<li>类型: 字符串</li>
<li>默认值: broadcast</li>
</ul>
<p>广播交易日志的路径，相对于项目根目录。</p>
<h5 id="force"><a class="header" href="#force"><code>force</code></a></h5>
<ul>
<li>类型: 布尔值</li>
<li>默认值: false</li>
<li>环境变量: <code>FOUNDRY_FORCE</code> 或 <code>DAPP_FORCE</code></li>
</ul>
<p>是否执行清理构建，丢弃缓存。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="solidity-编译器"><a class="header" href="#solidity-编译器">Solidity 编译器</a></h2>
<p>与 Solidity 编译器行为相关的配置。</p>
<p><strong>章节</strong></p>
<ul>
<li><a href="reference/config/solidity-compiler.html#general">通用</a></li>
<li><a href="reference/config/solidity-compiler.html#optimizer">优化器</a></li>
<li><a href="reference/config/solidity-compiler.html#model-checker">模型检查器</a></li>
</ul>
<h3 id="通用-1"><a class="header" href="#通用-1">通用</a></h3>
<p>与 Solidity 编译器行为相关的配置。</p>
<h5 id="remappings"><a class="header" href="#remappings"><code>remappings</code></a></h5>
<ul>
<li>类型: 字符串数组 (重映射)</li>
<li>默认值: 无</li>
<li>环境变量: <code>FOUNDRY_REMAPPINGS</code> 或 <code>DAPP_REMAPPINGS</code></li>
</ul>
<p>一个重映射数组，格式为 <code>&lt;名称&gt;=&lt;目标&gt;</code>。</p>
<p>重映射将 Solidity 导入重定向到不同的目录。例如，以下重映射</p>
<pre><code class="language-ignore">@openzeppelin/=node_modules/@openzeppelin/openzeppelin-contracts/
</code></pre>
<p>对于如下导入</p>
<pre><code class="language-solidity">import "@openzeppelin/contracts/utils/Context.sol";
</code></pre>
<p>将变为</p>
<pre><code class="language-solidity">import "node_modules/@openzeppelin/openzeppelin-contracts/contracts/utils/Context.sol";
</code></pre>
<h5 id="auto_detect_remappings"><a class="header" href="#auto_detect_remappings"><code>auto_detect_remappings</code></a></h5>
<ul>
<li>类型: 布尔值</li>
<li>默认值: true</li>
<li>环境变量: <code>FOUNDRY_AUTO_DETECT_REMAPPINGS</code> 或 <code>DAPP_AUTO_DETECT_REMAPPINGS</code></li>
</ul>
<p>如果启用，Foundry 将自动尝试通过扫描 <code>libs</code> 文件夹来检测重映射。</p>
<p>如果设置为 <code>false</code>，则仅使用 <code>foundry.toml</code> 和 <code>remappings.txt</code> 中的重映射。</p>
<h5 id="allow_paths"><a class="header" href="#allow_paths"><code>allow_paths</code></a></h5>
<ul>
<li>类型: 字符串数组 (路径)</li>
<li>默认值: 无</li>
<li>环境变量: <code>FOUNDRY_ALLOW_PATHS</code> 或 <code>DAPP_ALLOW_PATHS</code></li>
</ul>
<p>告诉 solc 允许从其他目录读取源文件。这主要与 <code>pnpm</code> 或类似管理的复杂工作区相关。</p>
<p>参见 <a href="https://docs.soliditylang.org/en/latest/path-resolution.html#allowed-paths" title="" target="_blank">solc allowed-paths</a></p>
<h5 id="include_paths"><a class="header" href="#include_paths"><code>include_paths</code></a></h5>
<ul>
<li>类型: 字符串数组 (路径)</li>
<li>默认值: 无</li>
<li>环境变量: <code>FOUNDRY_INCLUDE_PATHS</code> 或 <code>DAPP_INCLUDE_PATHS</code></li>
</ul>
<p>使额外的源目录可用于默认导入回调。如果你想导入位置不固定的合约，例如使用包管理器安装的第三方库，可以使用此选项。可以多次使用。仅当基本路径有非空值时才有效。</p>
<p>参见 <a href="https://docs.soliditylang.org/en/latest/path-resolution.html" title="" target="_blank">solc 路径解析</a></p>
<h5 id="libraries"><a class="header" href="#libraries"><code>libraries</code></a></h5>
<ul>
<li>类型: 字符串数组 (库)</li>
<li>默认值: 无</li>
<li>环境变量: <code>FOUNDRY_LIBRARIES</code> 或 <code>DAPP_LIBRARIES</code></li>
</ul>
<p>一个库数组，格式为 <code>&lt;文件&gt;:&lt;库&gt;:&lt;地址&gt;</code>，例如：<code>src/MyLibrary.sol:MyLibrary:0xfD88CeE74f7D78697775aBDAE53f9Da1559728E4</code>。</p>
<h5 id="solc_version"><a class="header" href="#solc_version"><code>solc_version</code></a></h5>
<ul>
<li>类型: 字符串 (语义版本)</li>
<li>默认值: 无</li>
<li>环境变量: <code>FOUNDRY_SOLC_VERSION</code> 或 <code>DAPP_SOLC_VERSION</code></li>
</ul>
<p>如果指定，将覆盖自动检测系统（详见下文），并使用单一的 Solidity 编译器版本进行项目编译。</p>
<p>仅支持严格的版本（例如 <code>0.8.11</code> 有效，但 <code>^0.8.0</code> 无效）。</p>
<h5 id="auto_detect_solc"><a class="header" href="#auto_detect_solc"><code>auto_detect_solc</code></a></h5>
<ul>
<li>类型: 布尔值</li>
<li>默认值: true</li>
<li>环境变量: <code>FOUNDRY_AUTO_DETECT_SOLC</code> 或 <code>DAPP_AUTO_DETECT_SOLC</code></li>
</ul>
<p>如果启用，Foundry 将自动尝试解析适当的 Solidity 编译器版本以编译你的项目。</p>
<p>如果设置了 <code>solc_version</code>，则忽略此键。</p>
<h5 id="offline"><a class="header" href="#offline"><code>offline</code></a></h5>
<ul>
<li>类型: 布尔值</li>
<li>默认值: false</li>
<li>环境变量: <code>FOUNDRY_OFFLINE</code> 或 <code>DAPP_OFFLINE</code></li>
</ul>
<p>如果启用，Foundry 将不会尝试下载任何缺失的 solc 版本。</p>
<p>如果 <code>offline</code> 和 <code>auto-detect-solc</code> 都设置为 <code>true</code>，将自动检测所需的 solc 版本，但不会安装任何缺失的版本。</p>
<h5 id="ignored_warnings_from"><a class="header" href="#ignored_warnings_from"><code>ignored_warnings_from</code></a></h5>
<ul>
<li>类型: 字符串数组 (文件路径)</li>
<li>默认值: 无</li>
<li>环境变量: <code>FOUNDRY_IGNORED_WARNINGS_FROM</code> 或 <code>DAPP_IGNORED_WARNINGS_FROM</code></li>
</ul>
<p>一个文件路径数组，编译过程中应忽略这些路径中的警告。当你有特定目录的文件产生已知警告，并且希望在不影响其他文件的情况下抑制这些警告时，这很有用。</p>
<p>数组中的每个条目应为目录路径或特定文件路径。例如：</p>
<p><code>ignored_warnings_from = ["path/to/warnings/file1.sol", "path/to/warnings/file2.sol"]</code></p>
<p>此配置将导致编译器忽略指定路径中的任何警告。</p>
<h5 id="ignored_error_codes"><a class="header" href="#ignored_error_codes"><code>ignored_error_codes</code></a></h5>
<ul>
<li>类型: 整数/字符串数组</li>
<li>默认值: 对于源文件、SPDX 许可证标识符和合约大小为无，对于测试为无</li>
<li>环境变量: <code>FOUNDRY_IGNORED_ERROR_CODES</code> 或 <code>DAPP_IGNORED_ERROR_CODES</code></li>
</ul>
<p>一个 Solidity 编译器错误代码数组，编译过程中应忽略这些代码，例如警告。</p>
<p>有效值包括：</p>
<ul>
<li><code>license</code>: 1878</li>
<li><code>code-size</code>: 5574</li>
<li><code>func-mutability</code>: 2018</li>
<li><code>unused-var</code>: 2072</li>
<li><code>unused-param</code>: 5667</li>
<li><code>unused-return</code>: 9302</li>
<li><code>virtual-interfaces</code>: 5815</li>
<li><code>missing-receive-ether</code>: 3628</li>
<li><code>shadowing</code>: 2519</li>
<li><code>same-varname</code>: 8760</li>
<li><code>unnamed-return</code>: 6321</li>
<li><code>unreachable</code>: 5740</li>
<li><code>pragma-solidity</code>: 3420</li>
<li><code>constructor-visibility</code>: 2462</li>
<li><code>init-code-size</code>: 3860</li>
<li><code>transient-storage</code>: 2394</li>
<li><code>too-many-warnings</code>: 4591</li>
</ul>
<h5 id="deny_warnings"><a class="header" href="#deny_warnings"><code>deny_warnings</code></a></h5>
<ul>
<li>类型: 布尔值</li>
<li>默认值: false</li>
<li>环境变量: <code>FOUNDRY_DENY_WARNINGS</code> 或 <code>DAPP_DENY_WARNINGS</code></li>
</ul>
<p>如果启用，Foundry 会将 Solidity 编译器警告视为错误，阻止将工件写入磁盘。</p>
<h5 id="evm_version"><a class="header" href="#evm_version"><code>evm_version</code></a></h5>
<ul>
<li>类型: 字符串</li>
<li>默认值: paris</li>
<li>环境变量: <code>FOUNDRY_EVM_VERSION</code> 或 <code>DAPP_EVM_VERSION</code></li>
</ul>
<p>测试期间使用的 EVM 版本。值<strong>必须</strong>是 EVM 硬分叉名称，例如 <code>london</code>、<code>byzantium</code> 等。</p>
<h5 id="revert_strings"><a class="header" href="#revert_strings"><code>revert_strings</code></a></h5>
<ul>
<li>类型: 字符串</li>
<li>默认值: default</li>
<li>环境变量: <code>FOUNDRY_REVERT_STRINGS</code> 或 <code>DAPP_REVERT_STRINGS</code></li>
</ul>
<p>可能的值包括：</p>
<ul>
<li><code>default</code> 不注入编译器生成的回退字符串，保留用户提供的字符串。</li>
<li><code>strip</code> 删除所有回退字符串（如果可能，即如果使用字面量），保留副作用。</li>
<li><code>debug</code> 为编译器生成的内部回退注入字符串，目前为 ABI 编码器 V1 和 V2 实现。</li>
<li><code>verboseDebug</code> 甚至将更多信息附加到用户提供的回退字符串（尚未实现）。</li>
</ul>
<h5 id="extra_output_files"><a class="header" href="#extra_output_files"><code>extra_output_files</code></a></h5>
<ul>
<li>类型: 字符串数组</li>
<li>默认值: 无</li>
<li>环境变量: 无</li>
</ul>
<p>应写入工件目录的 Solidity 编译器额外输出。</p>
<p>有效值包括：</p>
<ul>
<li><code>metadata</code>: 写入工件目录中的 <code>metadata.json</code> 文件</li>
<li><code>ir</code>: 写入工件目录中的 <code>.ir</code> 文件</li>
<li><code>irOptimized</code>: 写入工件目录中的 <code>.iropt</code> 文件</li>
<li><code>ewasm</code>: 写入工件目录中的 <code>.ewasm</code> 文件</li>
<li><code>evm.assembly</code>: 写入工件目录中的 <code>.asm</code> 文件</li>
</ul>
<h5 id="extra_output"><a class="header" href="#extra_output"><code>extra_output</code></a></h5>
<ul>
<li>类型: 字符串数组</li>
<li>默认值: 见下文</li>
<li>环境变量: 无</li>
</ul>
<p>在合约工件中包含的额外输出。</p>
<p>以下值总是设置，因为它们是 Forge 所需的：</p>
<pre><code class="language-toml">extra_output = [
  "abi",
  "evm.bytecode",
  "evm.deployedBytecode",
  "evm.methodIdentifiers",
]
</code></pre>
<p>有关有效值的列表，参见 [Solidity 文档][output-desc]。</p>
<h5 id="bytecode_hash"><a class="header" href="#bytecode_hash"><code>bytecode_hash</code></a></h5>
<ul>
<li>类型: 字符串</li>
<li>默认值: ipfs</li>
<li>环境变量: <code>FOUNDRY_BYTECODE_HASH</code> 或 <code>DAPP_BYTECODE_HASH</code></li>
</ul>
<p>确定用于字节码附加元数据哈希的方法。</p>
<p>有效值包括：</p>
<ul>
<li>ipfs (默认)</li>
<li>bzzr1</li>
<li>none</li>
</ul>
<h5 id="sparse_mode"><a class="header" href="#sparse_mode"><code>sparse_mode</code></a></h5>
<ul>
<li>类型: 布尔值</li>
<li>默认值: false</li>
<li>环境变量: <code>FOUNDRY_SPARSE_MODE</code> 或 <code>DAPP_SPARSE_MODE</code></li>
</ul>
<p>启用 <a href="reference/config/../forge/forge-build.html#sparse-mode-experimental">稀疏模式</a> 进行构建。</p>
<h3 id="优化器-1"><a class="header" href="#优化器-1">优化器</a></h3>
<p>与 Solidity 优化器相关的配置。</p>
<h5 id="optimizer"><a class="header" href="#optimizer"><code>optimizer</code></a></h5>
<ul>
<li>类型: 布尔值</li>
<li>默认值: true</li>
<li>环境变量: <code>FOUNDRY_OPTIMIZER</code> 或 <code>DAPP_OPTIMIZER</code></li>
</ul>
<p>是否启用 Solidity 优化器。</p>
<h5 id="optimizer_runs"><a class="header" href="#optimizer_runs"><code>optimizer_runs</code></a></h5>
<ul>
<li>类型: 整数</li>
<li>默认值: 200</li>
<li>环境变量: <code>FOUNDRY_OPTIMIZER_RUNS</code> 或 <code>DAPP_OPTIMIZER_RUNS</code></li>
</ul>
<p>执行的优化器运行次数。</p>
<h5 id="via_ir"><a class="header" href="#via_ir"><code>via_ir</code></a></h5>
<ul>
<li>类型: 布尔值</li>
<li>默认值: false</li>
<li>环境变量: <code>FOUNDRY_VIA_IR</code> 或 <code>DAPP_VIA_IR</code></li>
</ul>
<p>如果设置为 true，将编译管道更改为通过新的 IR 优化器。</p>
<h5 id="use_literal_content"><a class="header" href="#use_literal_content"><code>use_literal_content</code></a></h5>
<ul>
<li>类型: 布尔值</li>
<li>默认值: false</li>
</ul>
<p>如果设置为 true，编译将仅使用字面量内容，不使用 URL。</p>
<h5 id="optimizer_details"><a class="header" href="#optimizer_details"><code>[optimizer_details]</code></a></h5>
<p>优化器细节部分用于调整 Solidity 优化器的行为。此部分有几个可配置的值（每个都是布尔值）：</p>
<ul>
<li><code>peephole</code></li>
<li><code>inliner</code></li>
<li><code>jumpdestRemover</code></li>
<li><code>orderLiterals</code></li>
<li><code>deduplicate</code></li>
<li><code>cse</code></li>
<li><code>constantOptimizer</code></li>
<li><code>yul</code></li>
</ul>
<p>参见 Solidity <a href="https://docs.soliditylang.org/en/latest/using-the-compiler.html#compiler-input-and-output-json-description" title="" target="_blank">编译器输入描述</a> 获取默认值。</p>
<h5 id="optimizer_detailsyul_details"><a class="header" href="#optimizer_detailsyul_details"><code>[optimizer_details.yul_details]</code></a></h5>
<p>优化器细节部分的 Yul 细节子部分用于调整新的 IR 优化器的行为。有两个配置值：</p>
<ul>
<li><code>stack_allocation</code>: 尝试通过更早释放它们来改善堆栈槽的分配。</li>
<li><code>optimizer_steps</code>: 选择要应用的优化器步骤。</li>
</ul>
<p>参见 Solidity <a href="https://docs.soliditylang.org/en/latest/using-the-compiler.html#compiler-input-and-output-json-description" title="" target="_blank">编译器输入描述</a> 获取默认值。</p>
<blockquote>
<p>ℹ️ <strong>注意</strong>
如果在使用 <code>via_ir</code> 时遇到编译器错误，请显式启用旧版 <code>optimizer</code> 并将 <code>optimizer_steps</code> 留空</p>
</blockquote>
<h3 id="模型检查器"><a class="header" href="#模型检查器">模型检查器</a></h3>
<p>Solidity 模型检查器是 Solidity 编译器中内置的可选模块，适用于 OSX 和 Linux。在 <a href="https://docs.soliditylang.org/en/latest/smtchecker.html#tutorial" title="" target="_blank">Solidity 编译器文档</a> 中了解更多关于模型检查器的信息</p>
<blockquote>
<p>ℹ️ <strong>注意</strong>
模型检查器需要 <code>z3</code> 版本 4.8.8 或 4.8.14 在 Linux 上。</p>
</blockquote>
<p>模型检查器设置在配置的 <code>[model_checker]</code> 部分中配置。</p>
<p>模型检查器将在调用 <code>forge build</code> 时运行，任何发现将显示为警告。</p>
<p>以下是使用模型检查器时的推荐设置：</p>
<pre><code class="language-toml">[profile.default.model_checker]
contracts = {'/path/to/project/src/Contract.sol' = ['Contract']}
engine = 'chc'
timeout = 10000
targets = ['assert']
</code></pre>
<p>设置要验证的合约非常重要，否则所有可用的合约都将被验证，这可能需要很长时间。</p>
<p>推荐的引擎是 <code>chc</code>，但 <code>bmc</code> 和 <code>all</code>（运行两者）也是接受的。</p>
<p>设置适当的超时时间（以毫秒为单位）也很重要，因为默认时间可能不足以给底层求解器。</p>
<p>如果没有给出验证目标，则仅检查断言。</p>
<h5 id="model_checker"><a class="header" href="#model_checker"><code>[model_checker]</code></a></h5>
<p>模型检查器部分中可用的键如下。</p>
<h6 id="model_checkercontracts"><a class="header" href="#model_checkercontracts"><code>model_checker.contracts</code></a></h6>
<ul>
<li>类型: 表</li>
<li>默认值: 所有</li>
<li>环境变量: 无</li>
</ul>
<p>指定模型检查器将分析的合约。</p>
<p>表的键是源文件的路径，值是要检查的合约名称数组。</p>
<p>例如：</p>
<pre><code class="language-toml">[profile.default.model_checker]
contracts = { "src/MyContracts.sol" = ["ContractA", "ContractB"] }
</code></pre>
<h6 id="model_checkerdiv_mod_with_slacks"><a class="header" href="#model_checkerdiv_mod_with_slacks"><code>model_checker.div_mod_with_slacks</code></a></h6>
<ul>
<li>类型: 布尔值</li>
<li>默认值: false</li>
<li>环境变量: 无</li>
</ul>
<p>设置如何编码除法和取模操作。</p>
<p>参见 <a href="https://docs.soliditylang.org/en/latest/smtchecker.html#division-and-modulo-with-slack-variables" title="" target="_blank">Solidity 文档</a> 获取更多信息。</p>
<h6 id="model_checkerengine"><a class="header" href="#model_checkerengine"><code>model_checker.engine</code></a></h6>
<ul>
<li>类型: 字符串（见下文）</li>
<li>默认值: all</li>
<li>环境变量: 无</li>
</ul>
<p>指定要运行的模型检查器引擎。有效值包括：</p>
<ul>
<li><code>chc</code>: 约束 Horn 子句引擎</li>
<li><code>bmc</code>: 有界模型检查引擎</li>
<li><code>all</code>: 运行两个引擎</li>
</ul>
<p>参见 <a href="https://docs.soliditylang.org/en/latest/smtchecker.html#model-checking-engines" title="" target="_blank">Solidity 文档</a> 获取更多关于引擎的信息。</p>
<h6 id="model_checkerinvariants"><a class="header" href="#model_checkerinvariants"><code>model_checker.invariants</code></a></h6>
<ul>
<li>类型: 字符串数组</li>
<li>默认值: 无</li>
<li>环境变量: 无</li>
</ul>
<p>设置模型检查器不变量。有效值包括：</p>
<ul>
<li><code>contract</code>: 合约不变量</li>
<li><code>reentrancy</code>: 重入属性</li>
</ul>
<p>参见 <a href="https://docs.soliditylang.org/en/latest/smtchecker.html#reported-inferred-inductive-invariants" title="" target="_blank">Solidity 文档</a> 获取更多关于不变量的信息。</p>
<h6 id="model_checkershow_unproved"><a class="header" href="#model_checkershow_unproved"><code>model_checker.show_unproved</code></a></h6>
<ul>
<li>类型: 布尔值</li>
<li>默认值: false</li>
<li>环境变量: 无</li>
</ul>
<p>是否输出所有未证明的目标。</p>
<p>参见 <a href="https://docs.soliditylang.org/en/latest/smtchecker.html#unproved-targets" title="" target="_blank">Solidity 文档</a> 获取更多信息。</p>
<h6 id="model_checkersolvers"><a class="header" href="#model_checkersolvers"><code>model_checker.solvers</code></a></h6>
<ul>
<li>类型: 字符串数组</li>
<li>默认值: 无</li>
<li>环境变量: 无</li>
</ul>
<p>设置模型检查器求解器。有效值包括：</p>
<ul>
<li><code>cvc4</code></li>
<li><code>eld</code>: 在 v0.8.18 中引入</li>
<li><code>smtlib2</code></li>
<li><code>z3</code></li>
</ul>
<p>参见 <a href="https://docs.soliditylang.org/en/latest/smtchecker.html#smt-and-horn-solvers" title="" target="_blank">Solidity 文档</a> 获取更多信息。</p>
<h6 id="model_checkertimeout"><a class="header" href="#model_checkertimeout"><code>model_checker.timeout</code></a></h6>
<ul>
<li>类型: 数字 (毫秒)</li>
<li>默认值: 无</li>
<li>环境变量: 无</li>
</ul>
<p>设置底层模型检查器引擎的超时时间（以毫秒为单位）。</p>
<h6 id="model_checkertargets"><a class="header" href="#model_checkertargets"><code>model_checker.targets</code></a></h6>
<ul>
<li>类型: 字符串数组</li>
<li>默认值: assert</li>
<li>环境变量: 无</li>
</ul>
<p>设置模型检查器目标。有效值包括：</p>
<ul>
<li><code>assert</code>: 断言</li>
<li><code>underflow</code>: 算术下溢</li>
<li><code>overflow</code>: 算术上溢</li>
<li><code>divByZero</code>: 除以零</li>
<li><code>constantCondition</code>: 平凡条件和不可达代码</li>
<li><code>popEmptyArray</code>: 弹出空数组</li>
<li><code>outOfBounds</code>: 数组/固定字节索引访问越界</li>
<li><code>default</code>: 上述所有（注意：不是 Forge 的默认值）</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="测试-2"><a class="header" href="#测试-2">测试</a></h2>
<p>与 <code>forge test</code> 行为相关的配置。</p>
<p><strong>章节</strong></p>
<ul>
<li><a href="reference/config/testing.html#general">通用</a></li>
<li><a href="reference/config/testing.html#fuzz">模糊测试</a></li>
<li><a href="reference/config/testing.html#invariant">不变性测试</a></li>
</ul>
<h3 id="通用-2"><a class="header" href="#通用-2">通用</a></h3>
<h5 id="verbosity"><a class="header" href="#verbosity"><code>verbosity</code></a></h5>
<ul>
<li>类型: 整数</li>
<li>默认值: 0</li>
<li>环境变量: <code>FOUNDRY_VERBOSITY</code> 或 <code>DAPP_VERBOSITY</code></li>
</ul>
<p>测试期间使用的详细级别。</p>
<ul>
<li><strong>级别 2 (<code>-vv</code>)</strong>: 测试期间发出的日志也会显示。</li>
<li><strong>级别 3 (<code>-vvv</code>)</strong>: 失败测试的堆栈跟踪也会显示。</li>
<li><strong>级别 4 (<code>-vvvv</code>)</strong>: 所有测试的堆栈跟踪都会显示，并且失败测试的设置跟踪也会显示。</li>
<li><strong>级别 5 (<code>-vvvvv</code>)</strong>: 堆栈跟踪和设置跟踪总是显示。</li>
</ul>
<h5 id="ffi"><a class="header" href="#ffi"><code>ffi</code></a></h5>
<ul>
<li>类型: 布尔值</li>
<li>默认值: false</li>
<li>环境变量: <code>FOUNDRY_FFI</code> 或 <code>DAPP_FFI</code></li>
</ul>
<p>是否启用 <code>ffi</code> 作弊码。</p>
<p><strong>警告:</strong> 启用此作弊码会对您的项目安全产生影响，因为它允许测试在您的计算机上执行任意程序。</p>
<h5 id="sender"><a class="header" href="#sender"><code>sender</code></a></h5>
<ul>
<li>类型: 字符串 (地址)</li>
<li>默认值: 0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38</li>
<li>环境变量: <code>FOUNDRY_SENDER</code> 或 <code>DAPP_SENDER</code></li>
</ul>
<p>测试中的 <code>msg.sender</code> 值。</p>
<h5 id="tx_origin"><a class="header" href="#tx_origin"><code>tx_origin</code></a></h5>
<ul>
<li>类型: 字符串 (地址)</li>
<li>默认值: 0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38</li>
<li>环境变量: <code>FOUNDRY_TX_ORIGIN</code> 或 <code>DAPP_TX_ORIGIN</code></li>
</ul>
<p>测试中的 <code>tx.origin</code> 值。</p>
<h5 id="initial_balance"><a class="header" href="#initial_balance"><code>initial_balance</code></a></h5>
<ul>
<li>类型: 字符串 (十六进制)</li>
<li>默认值: 0xffffffffffffffffffffffff</li>
<li>环境变量: <code>FOUNDRY_INITIAL_BALANCE</code> 或 <code>DAPP_INITIAL_BALANCE</code></li>
</ul>
<p>测试合约的初始余额，以 wei 为单位，用十六进制表示。</p>
<h5 id="block_number"><a class="header" href="#block_number"><code>block_number</code></a></h5>
<ul>
<li>类型: 整数</li>
<li>默认值: 1</li>
<li>环境变量: <code>FOUNDRY_BLOCK_NUMBER</code> 或 <code>DAPP_BLOCK_NUMBER</code></li>
</ul>
<p>测试中的 <code>block.number</code> 值。</p>
<h5 id="chain_id"><a class="header" href="#chain_id"><code>chain_id</code></a></h5>
<ul>
<li>类型: 整数</li>
<li>默认值: 31337</li>
<li>环境变量: <code>FOUNDRY_CHAIN_ID</code> 或 <code>DAPP_CHAIN_ID</code></li>
</ul>
<p>测试中的 <code>chainid</code> 操作码值。</p>
<h5 id="gas_limit"><a class="header" href="#gas_limit"><code>gas_limit</code></a></h5>
<ul>
<li>类型: 整数或字符串</li>
<li>默认值: 9223372036854775807</li>
<li>环境变量: <code>FOUNDRY_GAS_LIMIT</code> 或 <code>DAPP_GAS_LIMIT</code></li>
</ul>
<p>每个测试用例的 gas 限制。</p>
<blockquote>
<p>ℹ️ <strong>注意</strong></p>
<p>由于 Forge 依赖的一个限制，您<strong>无法将 gas 限制</strong>提高到默认值以上而不将值更改为字符串。</p>
<p>为了使用更高的 gas 限制，请使用字符串：</p>
</blockquote>
<pre><code class="language-toml">gas_limit = "18446744073709551615" # u64::MAX
</code></pre>
<h5 id="gas_price"><a class="header" href="#gas_price"><code>gas_price</code></a></h5>
<ul>
<li>类型: 整数</li>
<li>默认值: 0</li>
<li>环境变量: <code>FOUNDRY_GAS_PRICE</code> 或 <code>DAPP_GAS_PRICE</code></li>
</ul>
<p>测试中的 gas 价格（以 wei 为单位）。</p>
<h5 id="block_base_fee_per_gas"><a class="header" href="#block_base_fee_per_gas"><code>block_base_fee_per_gas</code></a></h5>
<ul>
<li>类型: 整数</li>
<li>默认值: 0</li>
<li>环境变量: <code>FOUNDRY_BLOCK_BASE_FEE_PER_GAS</code> 或 <code>DAPP_BLOCK_BASE_FEE_PER_GAS</code></li>
</ul>
<p>测试中的每 gas 基础费用（以 wei 为单位）。</p>
<h5 id="block_coinbase"><a class="header" href="#block_coinbase"><code>block_coinbase</code></a></h5>
<ul>
<li>类型: 字符串 (地址)</li>
<li>默认值: 0x0000000000000000000000000000000000000000</li>
<li>环境变量: <code>FOUNDRY_BLOCK_COINBASE</code> 或 <code>DAPP_BLOCK_COINBASE</code></li>
</ul>
<p>测试中的 <code>block.coinbase</code> 值。</p>
<h5 id="block_timestamp"><a class="header" href="#block_timestamp"><code>block_timestamp</code></a></h5>
<ul>
<li>类型: 整数</li>
<li>默认值: 1</li>
<li>环境变量: <code>FOUNDRY_BLOCK_TIMESTAMP</code> 或 <code>DAPP_BLOCK_TIMESTAMP</code></li>
</ul>
<p>测试中的 <code>block.timestamp</code> 值。</p>
<h5 id="block_difficulty"><a class="header" href="#block_difficulty"><code>block_difficulty</code></a></h5>
<ul>
<li>类型: 整数</li>
<li>默认值: 0</li>
<li>环境变量: <code>FOUNDRY_BLOCK_DIFFICULTY</code> 或 <code>DAPP_BLOCK_DIFFICULTY</code></li>
</ul>
<p>测试中的 <code>block.difficulty</code> 值。</p>
<h5 id="gas_reports"><a class="header" href="#gas_reports"><code>gas_reports</code></a></h5>
<ul>
<li>类型: 字符串数组 (合约名称)</li>
<li>默认值: [“*”]</li>
<li>环境变量: <code>FOUNDRY_GAS_REPORTS</code> 或 <code>DAPP_GAS_REPORTS</code></li>
</ul>
<p>要打印 gas 报告的合约。</p>
<h5 id="no_storage_caching"><a class="header" href="#no_storage_caching"><code>no_storage_caching</code></a></h5>
<ul>
<li>类型: 布尔值</li>
<li>默认值: false</li>
<li>环境变量: <code>FOUNDRY_NO_STORAGE_CACHING</code> 或 <code>DAPP_NO_STORAGE_CACHING</code></li>
</ul>
<p>如果设置为 <code>true</code>，则测试中来自 RPC 端点的区块数据将不会被缓存。否则，数据会被缓存到 <code>$HOME/.foundry/cache/&lt;chain id&gt;/&lt;block number&gt;</code>。</p>
<h5 id="rpc_storage_caching"><a class="header" href="#rpc_storage_caching"><code>[rpc_storage_caching]</code></a></h5>
<p><code>[rpc_storage_caching]</code> 块决定哪些 RPC 端点被缓存。</p>
<h6 id="rpc_storage_cachingchains"><a class="header" href="#rpc_storage_cachingchains"><code>rpc_storage_caching.chains</code></a></h6>
<ul>
<li>类型: 字符串或字符串数组 (链名称)</li>
<li>默认值: all</li>
<li>环境变量: 无</li>
</ul>
<p>决定哪些链被缓存。默认情况下，所有链都被缓存。</p>
<p>有效值为：</p>
<ul>
<li>“all”</li>
<li>链名称列表，例如 <code>["optimism", "mainnet"]</code></li>
</ul>
<h6 id="rpc_storage_cachingendpoints"><a class="header" href="#rpc_storage_cachingendpoints"><code>rpc_storage_caching.endpoints</code></a></h6>
<ul>
<li>类型: 字符串或正则表达式模式数组 (匹配 URL)</li>
<li>默认值: remote</li>
<li>环境变量: 无</li>
</ul>
<p>决定哪些 RPC 端点被缓存。默认情况下，只有远程端点被缓存。</p>
<p>有效值为：</p>
<ul>
<li>all</li>
<li>remote (默认)</li>
<li>正则表达式模式列表，例如 <code>["localhost"]</code></li>
</ul>
<h5 id="eth_rpc_url"><a class="header" href="#eth_rpc_url"><code>eth_rpc_url</code></a></h5>
<ul>
<li>类型: 字符串</li>
<li>默认值: 无</li>
<li>环境变量: <code>FOUNDRY_ETH_RPC_URL</code> 或 <code>DAPP_ETH_RPC_URL</code></li>
</ul>
<p>应使用的 RPC 服务器的 URL。</p>
<h5 id="etherscan_api_key"><a class="header" href="#etherscan_api_key"><code>etherscan_api_key</code></a></h5>
<ul>
<li>类型: 字符串</li>
<li>默认值: 无</li>
<li>环境变量: <code>FOUNDRY_ETHERSCAN_API_KEY</code> 或 <code>DAPP_ETHERSCAN_API_KEY</code></li>
</ul>
<p>用于 RPC 调用的 Etherscan API 密钥。</p>
<h5 id="match-test"><a class="header" href="#match-test"><code>match-test</code></a></h5>
<ul>
<li>类型: 正则表达式</li>
<li>默认值: 无</li>
<li>环境变量: <code>FOUNDRY_MATCH_TEST</code> 或 <code>DAPP_MATCH_TEST</code></li>
</ul>
<p>仅运行匹配正则表达式的测试方法。
等同于 <code>forge test --match-test &lt;TEST_PATTERN&gt;</code></p>
<h5 id="no-match-test"><a class="header" href="#no-match-test"><code>no-match-test</code></a></h5>
<ul>
<li>类型: 正则表达式</li>
<li>默认值: 无</li>
<li>环境变量: <code>FOUNDRY_NO_MATCH_TEST</code> 或 <code>DAPP_NO_MATCH_TEST</code></li>
</ul>
<p>仅运行不匹配正则表达式的测试方法。
等同于 <code>forge test --no-match-test &lt;TEST_PATTERN_INVERSE&gt;</code></p>
<h5 id="match-contract"><a class="header" href="#match-contract"><code>match-contract</code></a></h5>
<ul>
<li>类型: 正则表达式</li>
<li>默认值: 无</li>
<li>环境变量: <code>FOUNDRY_MATCH_CONTRACT</code> 或 <code>DAPP_MATCH_CONTRACT</code></li>
</ul>
<p>仅运行匹配正则表达式的合约中的测试方法。
等同于 <code>forge test --match-contract &lt;CONTRACT_PATTERN&gt;</code></p>
<h5 id="no-match-contract"><a class="header" href="#no-match-contract"><code>no-match-contract</code></a></h5>
<ul>
<li>类型: 正则表达式</li>
<li>默认值: 无</li>
<li>环境变量: <code>FOUNDRY_NO_MATCH_CONTRACT</code> 或 <code>DAPP_NO_MATCH_CONTRACT</code></li>
</ul>
<p>仅运行不匹配正则表达式的合约中的测试方法。
等同于 <code>forge test --no-match-contract &lt;CONTRACT_PATTERN_INVERSE&gt;</code></p>
<h5 id="match-path"><a class="header" href="#match-path"><code>match-path</code></a></h5>
<ul>
<li>类型: 正则表达式</li>
<li>默认值: 无</li>
<li>环境变量: <code>FOUNDRY_MATCH_PATH</code> 或 <code>DAPP_MATCH_PATH</code></li>
</ul>
<p>仅运行匹配路径的文件中的测试方法。
等同于 <code>forge test --match-path &lt;PATH_PATTERN&gt;</code></p>
<h5 id="no-match-path"><a class="header" href="#no-match-path"><code>no-match-path</code></a></h5>
<ul>
<li>类型: 正则表达式</li>
<li>默认值: 无</li>
<li>环境变量: <code>FOUNDRY_NO_MATCH_PATH</code> 或 <code>DAPP_NO_MATCH_PATH</code></li>
</ul>
<p>仅运行不匹配路径的文件中的测试方法。
等同于 <code>forge test --no-match-path &lt;PATH_PATTERN_INVERSE&gt;</code></p>
<h5 id="block_gas_limit"><a class="header" href="#block_gas_limit"><code>block_gas_limit</code></a></h5>
<ul>
<li>类型: 整数</li>
<li>默认值: 无</li>
<li>环境变量: <code>FOUNDRY_BLOCK_GAS_LIMIT</code> 或 <code>DAPP_BLOCK_GAS_LIMIT</code></li>
</ul>
<p>EVM 执行期间的 <code>block.gaslimit</code> 值。</p>
<h5 id="memory_limit"><a class="header" href="#memory_limit"><code>memory_limit</code></a></h5>
<ul>
<li>类型: 整数</li>
<li>默认值: 33554432</li>
<li>环境变量: <code>FOUNDRY_MEMORY_LIMIT</code> 或 <code>DAPP_MEMORY_LIMIT</code></li>
</ul>
<p>EVM 的内存限制（以字节为单位）。</p>
<h5 id="names"><a class="header" href="#names"><code>names</code></a></h5>
<ul>
<li>类型: 布尔值</li>
<li>默认值: false</li>
<li>环境变量: <code>FOUNDRY_NAMES</code> 或 <code>DAPP_NAMES</code></li>
</ul>
<p>打印编译的合约名称。</p>
<h5 id="sizes"><a class="header" href="#sizes"><code>sizes</code></a></h5>
<ul>
<li>类型: 布尔值</li>
<li>默认值: false</li>
<li>环境变量: <code>FOUNDRY_SIZES</code> 或 <code>DAPP_SIZES</code></li>
</ul>
<p>打印编译的合约大小。</p>
<h5 id="rpc_endpoints"><a class="header" href="#rpc_endpoints"><code>rpc_endpoints</code></a></h5>
<ul>
<li>类型: RPC 端点表</li>
<li>默认值: 无</li>
<li>环境变量: 无</li>
</ul>
<p>此部分存在于配置文件之外，定义了一个 RPC 端点表，其中键指定了 RPC 端点的名称，值是 RPC 端点本身。</p>
<p>值可以是有效的 RPC 端点或对环境变量的引用（用 <code>${}</code> 包裹）。</p>
<p>这些 RPC 端点可以在测试和 Solidity 脚本中使用（参见 <a href="reference/config/../../cheatcodes/rpc.html"><code>vm.rpc</code></a>）。</p>
<p>以下示例定义了一个名为 <code>optimism</code> 的端点和一个名为 <code>mainnet</code> 的端点，该端点引用了一个环境变量 <code>RPC_MAINNET</code>：</p>
<pre><code class="language-toml">[rpc_endpoints]
optimism = "https://optimism.alchemyapi.io/v2/..."
mainnet = "${RPC_MAINNET}"
</code></pre>
<h5 id="prompt_timeout"><a class="header" href="#prompt_timeout"><code>prompt_timeout</code></a></h5>
<ul>
<li>类型: 整数</li>
<li>默认值: 120</li>
<li>环境变量: <code>FOUNDRY_PROMPT_TIMEOUT</code></li>
</ul>
<p><code>vm.prompt</code> 在超时前等待的秒数。</p>
<h3 id="模糊测试-1"><a class="header" href="#模糊测试-1">模糊测试</a></h3>
<p><code>[fuzz]</code> 部分的配置值。</p>
<h5 id="runs"><a class="header" href="#runs"><code>runs</code></a></h5>
<ul>
<li>类型: 整数</li>
<li>默认值: 256</li>
<li>环境变量: <code>FOUNDRY_FUZZ_RUNS</code> 或 <code>DAPP_FUZZ_RUNS</code></li>
</ul>
<p>每个模糊测试用例执行的模糊运行次数。更高的值在测试速度的代价下提供更多结果的置信度。</p>
<h5 id="max_test_rejects"><a class="header" href="#max_test_rejects"><code>max_test_rejects</code></a></h5>
<ul>
<li>类型: 整数</li>
<li>默认值: 65536</li>
<li>环境变量: <code>FOUNDRY_FUZZ_MAX_TEST_REJECTS</code></li>
</ul>
<p>在测试整体中止之前可能被拒绝的组合输入的最大数量。
“全局”过滤器适用于整个测试用例。如果测试用例被拒绝，整个测试用例将重新生成。</p>
<h5 id="seed"><a class="header" href="#seed"><code>seed</code></a></h5>
<ul>
<li>类型: 字符串 (十六进制)</li>
<li>默认值: 无</li>
<li>环境变量: <code>FOUNDRY_FUZZ_SEED</code></li>
</ul>
<p>模糊测试 RNG 算法的可选种子。</p>
<h5 id="dictionary_weight"><a class="header" href="#dictionary_weight"><code>dictionary_weight</code></a></h5>
<ul>
<li>类型: 整数 (0 到 100 之间)</li>
<li>默认值: 40</li>
<li>环境变量: <code>FOUNDRY_FUZZ_DICTIONARY_WEIGHT</code></li>
</ul>
<p>字典的权重。更高的字典权重将使模糊输入偏向“有趣的”值，例如边界值如 <code>type(uint256).max</code> 或来自您环境的合约地址。</p>
<h5 id="include_storage"><a class="header" href="#include_storage"><code>include_storage</code></a></h5>
<ul>
<li>类型: 布尔值</li>
<li>默认值: true</li>
<li>环境变量: <code>FOUNDRY_FUZZ_INCLUDE_STORAGE</code></li>
</ul>
<p>指示是否包含存储值的标志。</p>
<h5 id="include_push_bytes"><a class="header" href="#include_push_bytes"><code>include_push_bytes</code></a></h5>
<ul>
<li>类型: 布尔值</li>
<li>默认值: true</li>
<li>环境变量: <code>FOUNDRY_FUZZ_INCLUDE_PUSH_BYTES</code></li>
</ul>
<p>指示是否包含 push bytes 值的标志。</p>
<h3 id="不变性测试-1"><a class="header" href="#不变性测试-1">不变性测试</a></h3>
<p><code>[invariant]</code> 部分的配置值。</p>
<blockquote>
<p>ℹ️ <strong>注意</strong></p>
<p><code>[invariant]</code> 部分的配置具有回退逻辑
对于常见的配置条目（<code>runs</code>, <code>seed</code>, <code>dictionary_weight</code> 等）。</p>
<ul>
<li>如果条目在任一部分中未设置，则将使用默认值。</li>
<li>如果条目在 <code>[fuzz]</code> 部分中设置，但在 <code>[invariant]</code> 部分中未设置，这些值将自动设置为 <code>[fuzz]</code> 部分中指定的值。</li>
<li>对于 <code>default</code> 以外的任何配置文件：
<ul>
<li>如果在 <code>[invariant]</code>（与 <code>[profile.default.invariant]</code> 相同）部分中至少设置了一个条目，则将使用 <code>[invariant]</code> 部分的值，包括默认值。</li>
<li>如果在 <code>[invariant]</code> 部分中未设置任何条目，但在 <code>[fuzz]</code>（与 <code>[profile.default.fuzz]</code> 相同）部分中设置了条目，则将使用 <code>[fuzz]</code> 部分的值。</li>
<li>如果上述情况均不适用，则将使用默认值。</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="runs-1"><a class="header" href="#runs-1"><code>runs</code></a></h5>
<ul>
<li>类型: 整数</li>
<li>默认值: 256</li>
<li>环境变量: <code>FOUNDRY_INVARIANT_RUNS</code></li>
</ul>
<p>每个不变性测试组必须执行的运行次数。另见 <a href="reference/config/testing.html#runs">fuzz.runs</a></p>
<h5 id="depth"><a class="header" href="#depth"><code>depth</code></a></h5>
<ul>
<li>类型: 整数</li>
<li>默认值: 500</li>
<li>环境变量: <code>FOUNDRY_INVARIANT_DEPTH</code></li>
</ul>
<p>在一次运行中尝试破坏不变性的调用次数。</p>
<h5 id="fail_on_revert"><a class="header" href="#fail_on_revert"><code>fail_on_revert</code></a></h5>
<ul>
<li>类型: 布尔值</li>
<li>默认值: false</li>
<li>环境变量: <code>FOUNDRY_INVARIANT_FAIL_ON_REVERT</code></li>
</ul>
<p>如果发生回滚，则失败不变性模糊测试。</p>
<h5 id="call_override"><a class="header" href="#call_override"><code>call_override</code></a></h5>
<ul>
<li>类型: 布尔值</li>
<li>默认值: false</li>
<li>环境变量: <code>FOUNDRY_INVARIANT_CALL_OVERRIDE</code></li>
</ul>
<p>在运行不变性测试时覆盖不安全的</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="内联测试配置"><a class="header" href="#内联测试配置">内联测试配置</a></h2>
<p>Foundry 用户可以使用环境变量和 <code>foundry.toml</code> 中的配置语句来指定总体测试配置。详细描述请查看 [<code>测试参考</code>][Testing Reference]。</p>
<p>尽管这在一般情况下可能有效，但某些测试可能需要更精细的配置控制。为此，Forge 提供了一种方法，可以在不变测试和模糊测试场景中指定每项测试的配置。</p>
<p>用户可以直接在 Solidity 注释中内联测试配置语句。这将影响 <code>forge test</code> 命令在特定测试实例中的行为，如下例所示。</p>
<pre><code class="language-solidity">contract MyTest is Test {
  /// forge-config: default.fuzz.runs = 100
  /// forge-config: ci.fuzz.runs = 500
  function test_SimpleFuzzTest(uint256 x) public {
    // --- snip ---
  }
}
</code></pre>
<p>这里我们要求模糊测试器分别在 <code>default</code> 和 <code>ci</code> 配置文件中运行 <code>100</code> 次和 <code>500</code> 次。有趣的是，这将覆盖任何全局级别的模糊测试 <code>runs</code> 设置。所有其他配置将从全局上下文中继承，使其成为所有可能配置的回退。</p>
<h3 id="块注释"><a class="header" href="#块注释">块注释</a></h3>
<p>内联测试配置也可以在块注释中表示，如下例所示。</p>
<pre><code class="language-solidity">contract MyTest is Test {
  /**
   * forge-config: default.fuzz.runs = 1024
   * forge-config: default.fuzz.max-test-rejects = 500
   */
  function test_SimpleFuzzTest(uint256 x) public {
    // --- snip ---
  }
}
</code></pre>
<h3 id="内联模糊测试配置"><a class="header" href="#内联模糊测试配置">内联模糊测试配置</a></h3>
<p>用户可以指定表格中描述的配置。每个语句必须具有 <code>forge-config: ${PROFILE}.fuzz.</code> 形式的前缀。</p>
<div class="table-wrapper"><table><thead><tr><th>参数</th><th>类型</th><th>描述</th></tr></thead><tbody>
<tr><td><code>runs</code></td><td>整数</td><td>为此特定测试用例执行的模糊测试次数。[<code>参考</code>][testing]。</td></tr>
<tr><td><code>max-test-rejects</code></td><td>整数</td><td>在测试整体中止之前可能被拒绝的组合输入的最大数量。[<code>参考</code>][Max test rejects]。</td></tr>
</tbody></table>
</div>
<p>模糊测试配置示例</p>
<pre><code class="language-solidity">contract MyFuzzTest is Test {
  /// forge-config: default.fuzz.runs = 100
  /// forge-config: default.fuzz.max-test-rejects = 2
  function test_InlineConfig(uint256 x) public {
    // --- snip ---
  }
}
</code></pre>
<h3 id="内联不变测试配置"><a class="header" href="#内联不变测试配置">内联不变测试配置</a></h3>
<p>用户可以指定表格中描述的配置。每个语句必须具有 <code>forge-config: ${PROFILE}.invariant.</code> 形式的前缀。</p>
<div class="table-wrapper"><table><thead><tr><th>参数</th><th>类型</th><th>描述</th></tr></thead><tbody>
<tr><td><code>runs</code></td><td>整数</td><td>为此特定测试用例执行的不变测试次数。[<code>参考</code>][Invariant runs]。</td></tr>
<tr><td><code>depth</code></td><td>整数</td><td>在一次运行中尝试破坏不变性的调用次数。[<code>参考</code>][Invariant depth]。</td></tr>
<tr><td><code>fail-on-revert</code></td><td>布尔值</td><td>如果在不变模糊测试中发生回滚，则失败。[<code>参考</code>][Fail on revert]。</td></tr>
<tr><td><code>call-override</code></td><td>布尔值</td><td>在运行不变测试时覆盖不安全的对外调用。[<code>参考</code>][Invariant call override]。</td></tr>
</tbody></table>
</div>
<p>不变测试配置示例</p>
<pre><code class="language-solidity">contract MyInvariantTest is Test {
  /// forge-config: default.invariant.runs = 100
  /// forge-config: default.invariant.depth = 2
  /// forge-config: default.invariant.fail-on-revert = false
  /// forge-config: default.invariant.call-override = true
  function invariant_InlineConfig() public {
    // --- snip ---
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="格式化工具"><a class="header" href="#格式化工具">格式化工具</a></h2>
<p>与 Forge 格式化工具行为相关的配置。这些键位于 <code>[fmt]</code> 部分下。</p>
<h3 id="single_line_statement_blocks"><a class="header" href="#single_line_statement_blocks"><code>single_line_statement_blocks</code></a></h3>
<blockquote>
<p>这允许独立于行长度配置语句块的样式。</p>
</blockquote>
<p>Foundry 中的 <code>single_line_statement_blocks</code> 配置选项控制语句块（用 <code>{ }</code> 包围的代码块）是否会被格式化为单行或多行。</p>
<p>它有三个可能的值：</p>
<ul>
<li><code>"single"</code> - 如果可能，语句块将被格式化为单行。</li>
<li><code>"multi"</code> - 语句块将始终被格式化为多行。</li>
<li><code>"preserve"</code> - 保持语句块现有的单行/多行格式。</li>
</ul>
<p>例如，使用 <code>"single"</code>：</p>
<pre><code class="language-solidity">if (true) { return true; }
</code></pre>
<p>使用 <code>"multi"</code>：</p>
<pre><code class="language-solidity">if (true) {
  return true;
}
</code></pre>
<p>使用 <code>"preserve"</code>，将保持代码的原始格式。</p>
<h3 id="multiline_func_header"><a class="header" href="#multiline_func_header"><code>multiline_func_header</code></a></h3>
<blockquote>
<p>这允许配置长函数头的格式。</p>
</blockquote>
<ul>
<li>类型: 字符串</li>
<li>默认值: <code>attributes_first</code></li>
<li>环境变量: <code>FOUNDRY_FMT_MULTILINE_FUNC_HEADER</code> 或 <code>DAPP_FMT_MULTILINE_FUNC_HEADER</code></li>
</ul>
<p>Foundry 中的 <code>multiline_func_header</code> 配置选项控制当函数头（包含函数名、参数、返回值等的行）超过最大行长度时的格式。</p>
<p>多行函数头的样式，如果它不适合一行。有效值：</p>
<ul>
<li><code>"attributes_first"</code> - （默认）首先将函数属性多行写入</li>
<li><code>"params_first"</code> - 将函数头分成多行，每个参数单独一行。函数名保持在第一行。</li>
<li><code>"all"</code> - 如果函数参数或属性是多行的，则将所有内容多行</li>
</ul>
<p>例如，使用 <code>"params_first"</code>：</p>
<pre><code class="language-solidity">function myFunction(
    uint256 param1, 
    uint256 param2,
    uint256 param3
) public returns (uint256) {
  // ...
}
</code></pre>
<p>使用 <code>"all"</code>：</p>
<pre><code class="language-solidity">function myFunction(
    uint256 param1,
    uint256 param2, 
    uint256 param3
) 
    public 
    returns (uint256) 
{
  // ...  
}
</code></pre>
<h3 id="sort_imports"><a class="header" href="#sort_imports"><code>sort_imports</code></a></h3>
<blockquote>
<p>帮助组织导入并使其更容易快速找到特定的导入。</p>
</blockquote>
<p>Foundry 中的 <code>sort_imports</code> 配置选项控制是否按字母顺序对导入语句进行排序。</p>
<p>从提供的代码片段中：</p>
<ul>
<li>在 <code>fmt.rs</code> 中，<code>sort_imports</code> 是一个可以设置为 <code>true</code> 或 <code>false</code> 的配置选项。</li>
<li>在 <code>formatter.rs</code> 中，调用 <code>sort_imports()</code> 方法以在启用 <code>sort_imports</code> 时按字母顺序对导入语句进行排序。</li>
<li>它找到源代码中由空行分隔的导入组。</li>
<li>然后按字母顺序对每个组内的导入语句进行排序。</li>
</ul>
<p>因此，启用 <code>sort_imports</code> 将按字母顺序重新排列 solidity 导入语句，同时保留组之间的相对顺序。</p>
<h3 id="contract_new_lines"><a class="header" href="#contract_new_lines"><code>contract_new_lines</code></a></h3>
<blockquote>
<p>控制合约定义前后空白行的添加。</p>
</blockquote>
<p>Foundry 中的 <code>contract_new_lines</code> 配置选项控制是否在合约定义前后添加空行。</p>
<p>启用时（<code>contract_new_lines = true</code>）：</p>
<ul>
<li>在合约定义开始前添加一个空行。</li>
<li>在合约定义结束后也添加一个空行。</li>
</ul>
<p>例如，启用 <code>contract_new_lines</code>：</p>
<pre><code class="language-solidity">// 合约前的空行
contract MyContract {
  // ...
}
// 合约后的空行
</code></pre>
<p>这有助于视觉上分隔合约定义并提高可读性。</p>
<p>禁用时（<code>contract_new_lines = false</code>），合约前后不会添加空行。</p>
<p>因此，<code>contract_new_lines</code> 选项控制合约定义前后空白行的添加。</p>
<h3 id="override_spacing"><a class="header" href="#override_spacing"><code>override_spacing</code></a></h3>
<p>Foundry 中的 <code>override_spacing</code> 配置选项控制是否在 <code>override</code> 关键字和父合约之间打印空格。</p>
<p>启用时：</p>
<ul>
<li>在 <code>override</code> 关键字后添加一个空格。</li>
</ul>
<p>例如：</p>
<pre><code class="language-solidity">contract Child is Parent {
  function foo() override (Parent) public { }
}
</code></pre>
<p>禁用时，<code>override</code> 和父合约之间没有空格：</p>
<pre><code class="language-solidity">contract Child is Parent {
  function foo() override(Parent) public { } 
}
</code></pre>
<p>启用配置 <code>override</code> 声明的样式。</p>
<ul>
<li><code>override_spacing = true</code> - 在 <code>override</code> 后打印一个空格</li>
<li><code>override_spacing = false</code> - 不在 <code>override</code> 后打印空格</li>
</ul>
<h3 id="line_length"><a class="header" href="#line_length"><code>line_length</code></a></h3>
<ul>
<li>类型: 数字</li>
<li>默认值: 120</li>
<li>环境变量: <code>FOUNDRY_FMT_LINE_LENGTH</code> 或 <code>DAPP_FMT_LINE_LENGTH</code></li>
</ul>
<p>格式化工具尝试换行的最大行长度。</p>
<h3 id="tab_width"><a class="header" href="#tab_width"><code>tab_width</code></a></h3>
<ul>
<li>类型: 数字</li>
<li>默认值: 4</li>
<li>环境变量: <code>FOUNDRY_FMT_TAB_WIDTH</code> 或 <code>DAPP_FMT_TAB_WIDTH</code></li>
</ul>
<p>每个缩进级别的空格数。</p>
<h3 id="bracket_spacing"><a class="header" href="#bracket_spacing"><code>bracket_spacing</code></a></h3>
<ul>
<li>类型: 布尔值</li>
<li>默认值: false</li>
<li>环境变量: <code>FOUNDRY_FMT_BRACKET_SPACING</code> 或 <code>DAPP_FMT_BRACKET_SPACING</code></li>
</ul>
<p>是否在括号之间打印空格。</p>
<h3 id="int_types"><a class="header" href="#int_types"><code>int_types</code></a></h3>
<ul>
<li>类型: 字符串</li>
<li>默认值: <code>long</code></li>
<li>环境变量: <code>FOUNDRY_FMT_INT_TYPES</code> 或 <code>DAPP_FMT_INT_TYPES</code></li>
</ul>
<p>uint/int256 类型的样式。有效值：</p>
<ul>
<li><code>long</code>（默认）: 使用显式的 <code>uint256</code> 或 <code>int256</code></li>
<li><code>short</code>: 使用隐式的 <code>uint</code> 或 <code>int</code></li>
<li><code>preserve</code>: 使用源代码中定义的类型</li>
</ul>
<h3 id="quote_style"><a class="header" href="#quote_style"><code>quote_style</code></a></h3>
<ul>
<li>类型: 字符串</li>
<li>默认值: <code>double</code></li>
<li>环境变量: <code>FOUNDRY_FMT_QUOTE_STYLE</code> 或 <code>DAPP_FMT_QUOTE_STYLE</code></li>
</ul>
<p>定义引号样式。有效值：</p>
<ul>
<li><code>double</code>（默认）: 尽可能使用双引号 (<code>"</code>)</li>
<li><code>single</code>: 尽可能使用单引号 (<code>'</code>)</li>
<li><code>preserve</code>: 使用源代码中定义的引号</li>
</ul>
<h3 id="number_underscore"><a class="header" href="#number_underscore"><code>number_underscore</code></a></h3>
<ul>
<li>类型: 字符串</li>
<li>默认值: <code>preserve</code></li>
<li>环境变量: <code>FOUNDRY_FMT_NUMBER_UNDERSCORE</code> 或 <code>DAPP_FMT_NUMBER_UNDERSCORE</code></li>
</ul>
<p>数字字面量中下划线的样式。有效值：</p>
<ul>
<li><code>preserve</code>（默认）: 使用源代码中定义的下划线</li>
<li><code>thousands</code>: 如果大于 9999，每千位添加一个下划线。例如 <code>1000</code> 格式化为 <code>1000</code>，<code>10000</code> 格式化为 <code>10_000</code></li>
<li><code>remove</code>: 移除所有下划线</li>
</ul>
<h3 id="wrap_comments"><a class="header" href="#wrap_comments"><code>wrap_comments</code></a></h3>
<ul>
<li>
<p>类型: 布尔值</p>
</li>
<li>
<p>默认值: false</p>
</li>
<li>
<p>环境变量: <code>FOUNDRY_FMT_WRAP_COMMENTS</code> 或 <code>DAPP_FMT_WRAP_COMMENTS</code></p>
</li>
</ul>
<p>是否在达到 <code>line_length</code> 时换行注释。</p>
<h3 id="ignore"><a class="header" href="#ignore"><code>ignore</code></a></h3>
<ul>
<li>类型: 字符串数组（模式）</li>
<li>默认值: <code>[]</code></li>
<li>环境变量: <code>FOUNDRY_FMT_IGNORE</code> 或 <code>DAPP_FMT_IGNORE</code></li>
</ul>
<p>格式化时要忽略的文件列表。这是一个逗号分隔的 glob 模式列表。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="文档生成器"><a class="header" href="#文档生成器">文档生成器</a></h2>
<p>与 Forge 文档生成器行为相关的配置。这些键设置在 <code>[doc]</code> 部分。</p>
<h5 id="out-1"><a class="header" href="#out-1"><code>out</code></a></h5>
<ul>
<li>类型: 字符串</li>
<li>默认值: <code>docs</code></li>
<li>环境变量: <code>FOUNDRY_DOC_OUT</code></li>
</ul>
<p>生成文档的输出路径。</p>
<h5 id="title"><a class="header" href="#title"><code>title</code></a></h5>
<ul>
<li>类型: 字符串</li>
<li>环境变量: <code>FOUNDRY_DOC_TITLE</code></li>
</ul>
<p>生成文档的标题。</p>
<h5 id="book"><a class="header" href="#book"><code>book</code></a></h5>
<ul>
<li>类型: 字符串</li>
<li>默认值: <code>./book.toml</code></li>
<li>环境变量: <code>FOUNDRY_DOC_BOOK</code></li>
</ul>
<p>用户提供的 <code>book.toml</code> 路径。在生成文档时，它将与默认设置合并。</p>
<h5 id="repository"><a class="header" href="#repository"><code>repository</code></a></h5>
<ul>
<li>类型: 字符串</li>
<li>环境变量: <code>FOUNDRY_DOC_REPOSITORY</code></li>
</ul>
<p>Git 仓库的 URL。用于提供指向 Git 源文件的链接。
如果缺失，<code>forge</code> 将尝试查找当前的 origin URL 并使用其值。</p>
<h5 id="ignore-1"><a class="header" href="#ignore-1"><code>ignore</code></a></h5>
<ul>
<li>类型: 字符串数组（模式）</li>
<li>默认值: <code>[]</code></li>
<li>环境变量: <code>FOUNDRY_DOC_IGNORE</code></li>
</ul>
<p>生成文档时要忽略的文件列表。这是一个逗号分隔的 glob 模式列表。</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-json">{
  "translation": "## Etherscan\n\n与Etherscan相关的配置，例如API密钥。Forge在多个地方使用此配置。\n\n`[etherscan]`部分是将键映射到Etherscan配置表的映射。Etherscan配置表包含以下键：\n\n- `key` (字符串) (**必需**): 给定网络的Etherscan API密钥。此属性的值也可以指向环境变量。\n- `chain`: 此Etherscan配置所针对的链的名称或ID。\n- `url`: Etherscan API URL。\n\n如果配置的键是链名称，则不需要`chain`，否则需要。`url`可以用于显式设置名称不原生支持的链的Etherscan API URL。\n\n使用TOML内联表语法，所有这些都是有效的：\n\n```toml\n[etherscan]\nmainnet = { key = \"${ETHERSCAN_MAINNET_KEY}\" }\nmainnet2 = { key = \"ABCDEFG\", chain = \"mainnet\" }\noptimism = { key = \"1234567\" }\nunknown_chain = { key = \"ABCDEFG\", url = \"&lt;etherscan api url for this chain&gt;\" }\n```"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="作弊码参考"><a class="header" href="#作弊码参考">作弊码参考</a></h2>
<p>作弊码提供了强大的断言功能，能够改变 EVM 的状态，模拟数据等。</p>
<p>作弊码通过作弊码地址（<code>0x7109709ECfa91a80626fF3989D68f67F5b1DD12D</code>）提供。</p>
<blockquote>
<p>ℹ️ <strong>注意</strong></p>
<p>如果在使用模糊测试地址时遇到此地址的错误，你可能希望通过以下行将其从模糊测试中排除：</p>
<pre><code class="language-solidity">vm.assume(address_ != 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);
</code></pre>
</blockquote>
<p>你也可以通过 Forge 标准库的 <a href="cheatcodes/../reference/forge-std/#forge-stds-test"><code>Test</code></a> 合约中可用的 <code>vm</code> 轻松访问作弊码。</p>
<h3 id="forge-标准库作弊码"><a class="header" href="#forge-标准库作弊码">Forge 标准库作弊码</a></h3>
<p>Forge Std 实现了作弊码的包装器，这些包装器结合了多个标准作弊码以改善开发体验。这些并不是技术上的作弊码，而是 Forge 作弊码的组合。</p>
<p>你可以在<a href="cheatcodes/../reference/forge-std/std-cheats.html">参考部分</a>查看 Forge 标准库的作弊码包装器列表。你可以参考 <a href="https://github.com/foundry-rs/forge-std/blob/master/src/Test.sol" title="" target="_blank">Forge Std 源代码</a> 了解更多关于包装器如何在底层工作的信息。</p>
<h3 id="作弊码类型"><a class="header" href="#作弊码类型">作弊码类型</a></h3>
<p>以下是不同 Forge 作弊码的子部分。</p>
<ul>
<li><a href="cheatcodes/./environment.html">环境</a>：改变 EVM 状态的作弊码。</li>
<li><a href="cheatcodes/./assertions.html">断言</a>：强大的断言作弊码。</li>
<li><a href="cheatcodes/./fuzzer.html">模糊测试</a>：配置模糊测试的作弊码。</li>
<li><a href="cheatcodes/./external.html">外部</a>：与外部状态（文件、命令等）交互的作弊码。</li>
<li><a href="cheatcodes/./utilities.html">实用工具</a>：较小的实用工具作弊码。</li>
<li><a href="cheatcodes/./forking.html">分叉</a>：分叉模式作弊码。</li>
<li><a href="cheatcodes/./snapshots.html">快照</a>：快照作弊码。</li>
<li><a href="cheatcodes/./rpc.html">RPC</a>：与 RPC 相关的作弊码。</li>
<li><a href="cheatcodes/./fs.html">文件</a>：处理文件的作弊码。</li>
</ul>
<h3 id="添加新的作弊码"><a class="header" href="#添加新的作弊码">添加新的作弊码</a></h3>
<p>如果你需要新功能，请考虑<a href="cheatcodes/../contributing.html">为 Foundry 的代码库贡献</a>以添加作弊码。</p>
<h3 id="作弊码接口"><a class="header" href="#作弊码接口">作弊码接口</a></h3>
<p>这是 Forge 中所有作弊码的 Solidity 接口。</p>
<pre><code class="language-solidity">interface CheatCodes {
    // 这允许我们 getRecordedLogs()
    struct Log {
        bytes32[] topics;
        bytes data;
    }

    // readCallers() 的可能调用者模式
    enum CallerMode {
        None,
        Broadcast,
        RecurrentBroadcast,
        Prank,
        RecurrentPrank
    }

    enum AccountAccessKind {
        Call,
        DelegateCall,
        CallCode,
        StaticCall,
        Create,
        SelfDestruct,
        Resume
    }

    struct Wallet {
        address addr;
        uint256 publicKeyX;
        uint256 publicKeyY;
        uint256 privateKey;
    }

    struct ChainInfo {
        uint256 forkId;
        uint256 chainId;
    }

    struct AccountAccess {
        ChainInfo chainInfo;
        AccountAccessKind kind;
        address account;
        address accessor;
        bool initialized;
        uint256 oldBalance;
        uint256 newBalance;
        bytes deployedCode;
        uint256 value;
        bytes data;
        bool reverted;
        StorageAccess[] storageAccesses;
    }

    struct StorageAccess {
        address account;
        bytes32 slot;
        bool isWrite;
        bytes32 previousValue;
        bytes32 newValue;
        bool reverted;
    }

    // 从名称派生私钥，用该名称标记账户，并返回钱包
    function createWallet(string calldata) external returns (Wallet memory);

    // 从私钥生成钱包并返回钱包
    function createWallet(uint256) external returns (Wallet memory);

    // 从私钥生成钱包，用该名称标记账户，并返回钱包
    function createWallet(uint256, string calldata) external returns (Wallet memory);

    // 签名数据，(Wallet, digest) =&gt; (v, r, s)
    function sign(Wallet calldata, bytes32) external returns (uint8, bytes32, bytes32);

    // 获取钱包的 nonce
    function getNonce(Wallet calldata) external returns (uint64);

    // 设置 block.timestamp
    function warp(uint256) external;

    // 设置 block.number
    function roll(uint256) external;

    // 设置 block.basefee
    function fee(uint256) external;

    // 设置 block.difficulty
    // 从巴黎硬分叉开始不再起作用，并将回滚。
    function difficulty(uint256) external;
    
    // 设置 block.prevrandao
    // 在巴黎硬分叉之前不起作用，并将回滚。
    function prevrandao(bytes32) external;

    // 设置 block.chainid
    function chainId(uint256) external;

    // 从地址加载存储槽
    function load(address account, bytes32 slot) external returns (bytes32);

    // 将值存储到地址的存储槽
    function store(address account, bytes32 slot, bytes32 value) external;

    // 签名数据
    function sign(uint256 privateKey, bytes32 digest)
        external
        returns (uint8 v, bytes32 r, bytes32 s);

    // 从给定的私钥计算地址
    function addr(uint256 privateKey) external returns (address);

    // 从提供的助记词字符串或助记词文件路径派生私钥，
    // 在派生路径 m/44'/60'/0'/0/{index}。
    function deriveKey(string calldata, uint32) external returns (uint256);
    // 从提供的助记词字符串或助记词文件路径派生私钥，
    // 在派生路径 {path}{index}
    function deriveKey(string calldata, string calldata, uint32) external returns (uint256);

    // 获取账户的 nonce
    function getNonce(address account) external returns (uint64);

    // 设置账户的 nonce
    // 新的 nonce 必须高于账户的当前 nonce
    function setNonce(address account, uint64 nonce) external;

    // 通过终端执行外部函数调用
    function ffi(string[] calldata) external returns (bytes memory);

    // 设置环境变量，(name, value)
    function setEnv(string calldata, string calldata) external;

    // 读取环境变量，(name) =&gt; (value)
    function envBool(string calldata) external returns (bool);
    function envUint(string calldata) external returns (uint256);
    function envInt(string calldata) external returns (int256);
    function envAddress(string calldata) external returns (address);
    function envBytes32(string calldata) external returns (bytes32);
    function envString(string calldata) external returns (string memory);
    function envBytes(string calldata) external returns (bytes memory);

    // 读取环境变量作为数组，(name, delim) =&gt; (value[])
    function envBool(string calldata, string calldata)
        external
        returns (bool[] memory);
    function envUint(string calldata, string calldata)
        external
        returns (uint256[] memory);
    function envInt(string calldata, string calldata)
        external
        returns (int256[] memory);
    function envAddress(string calldata, string calldata)
        external
        returns (address[] memory);
    function envBytes32(string calldata, string calldata)
        external
        returns (bytes32[] memory);
    function envString(string calldata, string calldata)
        external
        returns (string[] memory);
    function envBytes(string calldata, string calldata)
        external
        returns (bytes[] memory);

    // 读取环境变量并提供默认值，(name, value) =&gt; (value)
    function envOr(string calldata, bool) external returns (bool);
    function envOr(string calldata, uint256) external returns (uint256);
    function envOr(string calldata, int256) external returns (int256);
    function envOr(string calldata, address) external returns (address);
    function envOr(string calldata, bytes32) external returns (bytes32);
    function envOr(string calldata, string calldata) external returns (string memory);
    function envOr(string calldata, bytes calldata) external returns (bytes memory);
    
    // 读取环境变量作为数组并提供默认值，(name, value[]) =&gt; (value[])
    function envOr(string calldata, string calldata, bool[] calldata) external returns (bool[] memory);
    function envOr(string calldata, string calldata, uint256[] calldata) external returns (uint256[] memory);
    function envOr(string calldata, string calldata, int256[] calldata) external returns (int256[] memory);
    function envOr(string calldata, string calldata, address[] calldata) external returns (address[] memory);
    function envOr(string calldata, string calldata, bytes32[] calldata) external returns (bytes32[] memory);
    function envOr(string calldata, string calldata, string[] calldata) external returns (string[] memory);
    function envOr(string calldata, string calldata, bytes[] calldata) external returns (bytes[] memory);

    // 将 Solidity 类型转换为字符串
    function toString(address) external returns(string memory);
    function toString(bytes calldata) external returns(string memory);
    function toString(bytes32) external returns(string memory);
    function toString(bool) external returns(string memory);
    function toString(uint256) external returns(string memory);
    function toString(int256) external returns(string memory);

    // 设置下一个调用的 msg.sender 为输入地址
    function prank(address) external;

    // 设置所有后续调用的 msg.sender 为输入地址
    // 直到调用 `stopPrank`
    function startPrank(address) external;

    // 设置下一个调用的 msg.sender 为输入地址，
    // 并将 tx.origin 设置为第二个输入
    function prank(address, address) external;

    // 设置所有后续调用的 msg.sender 为输入地址，直到
    // 调用 `stopPrank`，并将 tx.origin 设置为第二个输入
    function startPrank(address, address) external;

    // 重置后续调用的 msg.sender 为 `address(this)`
    function stopPrank() external;

    // 从状态中读取当前的 `msg.sender` 和 `tx.origin`，并报告是否有任何活动的调用者修改
    function readCallers() external returns (CallerMode callerMode, address msgSender, address txOrigin);

    // 设置地址的余额
    function deal(address who, uint256 newBalance) external;
    
    // 设置地址的代码
    function etch(address who, bytes calldata code) external;

    // 标记测试为跳过。必须在测试顶部调用。
    function skip(bool skip) external;

    // 预期下一个调用出现错误
    function expectRevert() external;
    function expectRevert(bytes calldata) external;
    function expectRevert(bytes4) external;

    // 记录所有存储读取和写入
    function record() external;

    // 获取给定地址在记录会话期间访问的所有读取和写入槽，
    function accesses(address)
        external
        returns (bytes32[] memory reads, bytes32[] memory writes);
    
    // 记录作为 CREATE、CALL 或 SELFDESTRUCT 操作码的一部分的所有账户访问，
    // 以及调用的上下文。
    function startStateDiffRecording() external;

    // 返回 `startStateDiffRecording` 会话中的所有账户访问的有序数组。
    function stopAndReturnStateDiff() external returns (AccountAccess[] memory accesses);

    // 记录所有交易日志
    function recordLogs() external;

    // 获取所有记录的日志
    function getRecordedLogs() external returns (Log[] memory);

    // 准备一个预期日志，签名如下：
    //   (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).
    //
    // 调用此函数，然后发出一个事件，然后调用一个函数。
    // 内部在调用之后，我们检查是否按预期顺序发出了日志
    // 带有预期的主题和数据（由布尔值指定）
    //
    // 第二种形式还检查提供的地址与发出事件的合约。
    function expectEmit(bool, bool, bool, bool) external;
    function expectEmit(bool, bool, bool, bool, address) external;

    // 模拟对地址的调用，返回指定数据。
    //
    // 调用数据可以是严格匹配或部分匹配，例如，如果你只
    // 传递一个 Solidity 选择器到预期的调用数据，那么整个 Solidity
    // 函数将被模拟。
    function mockCall(address, bytes calldata, bytes calldata) external;

    // 模拟对地址的调用，返回指定的错误
    //
    // 调用数据可以是严格匹配或部分匹配，例如，如果你只
    // 传递一个 Solidity 选择器到预期的调用数据，那么整个 Solidity
    // 函数将被模拟。
    function mockCallRevert(address where, bytes calldata data, bytes calldata retdata) external;

    // 清除所有模拟和回滚的模拟调用
    function clearMockedCalls() external;

    // 预期对地址的调用，带有指定的调用数据。
    // 调用数据可以是严格匹配或部分匹配
    function expectCall(address callee, bytes calldata data) external;
    // 预期对地址的调用，带有指定的
    // 调用数据和消息值。
    // 调用数据可以是严格匹配或部分匹配
    function expectCall(address callee, uint256, bytes calldata data) external;

    // 从 artifact 文件获取 _creation_ 字节码。传入 json 文件的相对路径
    function getCode(string calldata) external returns (bytes memory);
    // 从 artifact 文件获取 _deployed_ 字节码。传入 json 文件的相对路径
    function getDeployedCode(string calldata) external returns (bytes memory);

    // 在测试跟踪中标记地址
    function label(address addr, string calldata label) external;
    
    // 检索地址的标签
    function getLabel(address addr) external returns (string memory);

    // 在模糊测试时，如果条件不满足，生成新的输入
    function assume(bool) external;

    // 设置 block.coinbase (who)
    function coinbase(address) external;

    // 使用调用测试合约的地址或提供的地址
    // 作为发送者，使下一个调用（仅在此调用深度）创建一个
    // 可以稍后签名并发送上链的交易
    function broadcast() external;
    function broadcast(address) external;

    // 使用调用测试合约的地址或提供的地址
    // 作为发送者，使所有后续调用（仅在此调用深度）创建
    // 可以稍后签名并发送上链的交易
    function startBroadcast() external;
    function startBroadcast(address) external;
    function startBroadcast(uint256 privateKey) external;

    // 停止收集上链交易
    function stopBroadcast() external;

    // 将文件的全部内容读取为字符串，(path) =&gt; (data)
    function readFile(string calldata) external returns (string memory);
    // 获取当前项目根路径
    function projectRoot() external returns (string memory);
    // 将文件的下一行读取为字符串，(path) =&gt; (line)
    function readLine(string calldata) external returns (string memory);
    // 将数据写入文件，如果不存在则创建文件，如果存在则完全替换其内容。
    // (path, data) =&gt; ()
    function writeFile(string calldata, string calldata) external;
    // 将行写入文件，如果不存在则创建文件。
    // (path, data) =&gt; ()
    function writeLine(string calldata, string calldata) external;
    // 关闭文件以读取，重置偏移量并允许从头开始读取。
    // (path) =&gt; ()
    function closeFile(string calldata) external;
    // 删除文件。此作弊码将在以下情况下回滚，但不限于这些情况：
    // - 路径指向目录。
    // - 文件不存在。
    // - 用户缺乏删除文件的权限。
    // (path) =&gt; ()
    function removeFile(string calldata) external;
    // 如果给定路径指向现有实体，则返回 true，否则返回 false
    // (path) =&gt; (bool)
    function exists(string calldata) external returns (bool);
    // 如果路径存在于磁盘上并且指向常规文件，则返回 true，否则返回 false
    // (path) =&gt; (bool)
    function isFile(string calldata) external returns (bool);
    // 如果路径存在于磁盘上并且指向目录，则返回 true，否则返回 false
    // (path) =&gt; (bool)
    function isDir(string calldata) external returns (bool);
    
    // 返回与 'key' 对应的值
    function parseJson(string memory json, string memory key) external returns (bytes memory);
    // 返回整个 json 文件
    function parseJson(string memory json) external returns (bytes memory);
    // 检查 json 字符串中是否存在键
    function keyExists(string memory json, string memory key) external returns (bytes memory);
    // 获取 json 字符串中的键列表
    function parseJsonKeys(string memory json, string memory key) external returns (string[] memory);

    // 快照当前的 evm 状态。
    // 返回创建的快照的 id。
    // 要恢复快照，请使用 `revertTo`
    function snapshot() external returns (uint256);
    // 将 evm 状态恢复到之前的快照
    // 传入要恢复的快照 id。
    // 这将删除快照以及在此快照 id 之后拍摄的所有快照。
    function revertTo(uint256) external returns (bool);

    // 使用给定的端点和块创建新的分叉，
    // 并返回分叉的标识符
    function createFork(string calldata, uint256) external returns (uint256);
    // 使用给定的端点和 _latest_ 块创建新的分叉，
    // 并返回分叉的标识符
    function createFork(string calldata) external returns (uint256);

    // 创建并选择一个新的分叉，使用给定的端点和块，
    // 并返回分叉的标识符
    function createSelectFork(string calldata, uint256)
        external
        returns (uint256);
    // 创建并选择一个新的分叉，使用给定的端点和
    // 最新块，并返回分叉的标识符
    function createSelectFork(string calldata) external returns (uint256);

    // 使用 `createFork` 创建的分叉标识符
    // 并将相应的分叉状态设置为活动状态。
    function selectFork(uint256) external;

    // 返回当前活动的分叉
    // 如果没有活动的分叉，则回滚
    function activeFork() external returns (uint256);

    // 将当前活动的分叉更新到给定的块号
    // 这类似于 `roll`，但对于当前活动的分叉
    function rollFork(uint256) external;
    // 将给定的分叉更新到给定的块号
    function rollFork(uint256 forkId, uint256 blockNumber) external;

    // 从活动的分叉获取给定的交易并在当前状态下执行
    function transact(bytes32) external;
    // 从给定的分叉获取给定的交易并在当前状态下执行
    function transact(uint256, bytes32) external;

    // 标记账户应在使用多分叉设置时跨分叉使用持久存储，
    // 这意味着对该状态的更改将在切换分叉时保留
    function makePersistent(address) external;
    function makePersistent(address, address) external;
    function makePersistent(address, address, address) external;
    function makePersistent(address[] calldata) external;
    // 撤销之前通过 `makePersistent` 添加的地址的持久状态
    function revokePersistent(address) external;
    function revokePersistent(address[] calldata) external;
    // 如果账户被标记为持久状态，则返回 true
    function isPersistent(address) external returns (bool);

    /// 返回给定别名的 RPC url
    function rpcUrl(string calldata) external returns (string memory);
    /// 返回所有 rpc urls 及其别名 `[alias, url][]`
    function rpcUrls() external returns (string[2][] memory);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="环境"><a class="header" href="#环境">环境</a></h2>
<ul>
<li><a href="cheatcodes/./warp.html"><code>warp</code></a></li>
<li><a href="cheatcodes/./roll.html"><code>roll</code></a></li>
<li><a href="cheatcodes/./fee.html"><code>fee</code></a></li>
<li><a href="cheatcodes/./difficulty.html"><code>difficulty</code></a></li>
<li><a href="cheatcodes/./prevrandao.html"><code>prevrandao</code></a></li>
<li><a href="cheatcodes/./chain-id.html"><code>chainId</code></a></li>
<li><a href="cheatcodes/./store.html"><code>store</code></a></li>
<li><a href="cheatcodes/./load.html"><code>load</code></a></li>
<li><a href="cheatcodes/./etch.html"><code>etch</code></a></li>
<li><a href="cheatcodes/./deal.html"><code>deal</code></a></li>
<li><a href="cheatcodes/./prank.html"><code>prank</code></a></li>
<li><a href="cheatcodes/./start-prank.html"><code>startPrank</code></a></li>
<li><a href="cheatcodes/./stop-prank.html"><code>stopPrank</code></a></li>
<li><a href="cheatcodes/./read-callers.html"><code>readCallers</code></a></li>
<li><a href="cheatcodes/./record.html"><code>record</code></a></li>
<li><a href="cheatcodes/./accesses.html"><code>accesses</code></a></li>
<li><a href="cheatcodes/./record-logs.html"><code>recordLogs</code></a></li>
<li><a href="cheatcodes/./get-recorded-logs.html"><code>getRecordedLogs</code></a></li>
<li><a href="cheatcodes/./set-nonce.html"><code>setNonce</code></a></li>
<li><a href="cheatcodes/./get-nonce.html"><code>getNonce</code></a></li>
<li><a href="cheatcodes/./mock-call.html"><code>mockCall</code></a></li>
<li><a href="cheatcodes/./mock-call-revert.html"><code>mockCallRevert</code></a></li>
<li><a href="cheatcodes/./clear-mocked-calls.html"><code>clearMockedCalls</code></a></li>
<li><a href="cheatcodes/./coinbase.html"><code>coinbase</code></a></li>
<li><a href="cheatcodes/./broadcast.html"><code>broadcast</code></a></li>
<li><a href="cheatcodes/./start-broadcast.html"><code>startBroadcast</code></a></li>
<li><a href="cheatcodes/./stop-broadcast.html"><code>stopBroadcast</code></a></li>
<li><a href="cheatcodes/./pause-gas-metering.html"><code>pauseGasMetering</code></a></li>
<li><a href="cheatcodes/./resume-gas-metering.html"><code>resumeGasMetering</code></a></li>
<li><a href="cheatcodes/./tx-gas-price.html"><code>txGasPrice</code></a></li>
<li><a href="cheatcodes/./start-state-diff-recording.html"><code>startStateDiffRecording</code></a></li>
<li><a href="cheatcodes/./stop-and-return-state-diff.html"><code>stopAndReturnStateDiff</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="warp"><a class="header" href="#warp"><code>warp</code></a></h2>
<h3 id="签名"><a class="header" href="#签名">签名</a></h3>
<pre><code class="language-solidity">function warp(uint256) external;
</code></pre>
<h3 id="描述-21"><a class="header" href="#描述-21">描述</a></h3>
<p>设置 <code>block.timestamp</code>。</p>
<h3 id="示例-19"><a class="header" href="#示例-19">示例</a></h3>
<pre><code class="language-solidity">vm.warp(1641070800);
emit log_uint(block.timestamp); // 1641070800
</code></pre>
<h3 id="另请参阅-9"><a class="header" href="#另请参阅-9">另请参阅</a></h3>
<p>Forge 标准库</p>
<p><a href="cheatcodes/../reference/forge-std/skip.html"><code>skip</code></a>, <a href="cheatcodes/../reference/forge-std/rewind.html"><code>rewind</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="roll"><a class="header" href="#roll"><code>roll</code></a></h2>
<h3 id="签名-1"><a class="header" href="#签名-1">签名</a></h3>
<pre><code class="language-solidity">function roll(uint256) external;
</code></pre>
<h3 id="描述-22"><a class="header" href="#描述-22">描述</a></h3>
<p>设置 <code>block.number</code>。</p>
<h3 id="示例-20"><a class="header" href="#示例-20">示例</a></h3>
<pre><code class="language-solidity">vm.roll(100);
emit log_uint(block.number); // 100
</code></pre>
<h3 id="另请参阅-10"><a class="header" href="#另请参阅-10">另请参阅</a></h3>
<ul>
<li><a href="cheatcodes/./roll-fork.html">rollFork</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="fee"><a class="header" href="#fee"><code>fee</code></a></h2>
<h3 id="签名-2"><a class="header" href="#签名-2">签名</a></h3>
<pre><code class="language-solidity">function fee(uint256) external;
</code></pre>
<h3 id="描述-23"><a class="header" href="#描述-23">描述</a></h3>
<p>设置 <code>block.basefee</code>。</p>
<h3 id="示例-21"><a class="header" href="#示例-21">示例</a></h3>
<pre><code class="language-solidity">vm.fee(25 gwei);
emit log_uint(block.basefee); // 25000000000
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="getblocktimestamp"><a class="header" href="#getblocktimestamp"><code>getBlockTimestamp</code></a></h2>
<h3 id="签名-3"><a class="header" href="#签名-3">签名</a></h3>
<pre><code class="language-solidity">function getBlockTimestamp() external view returns (uint256 timestamp);
</code></pre>
<h3 id="描述-24"><a class="header" href="#描述-24">描述</a></h3>
<p>获取当前的 <code>block.timestamp</code>。这在使用 <code>vm.warp</code> 和 <code>--via-ir</code> 编译的情况下非常有用，因为 <code>block.timestamp</code> 在交易过程中被假定为常量。这意味着在每次 forge 测试中，对 <code>block.timestamp</code> 的多次调用会被优化为仅返回一个常量值，而不是实际访问当前的 <code>block.timestamp</code>。<code>vm.getBlockTimestamp()</code> 避免了这种优化，并返回当前的 <code>block.timestamp</code>。</p>
<h3 id="示例-22"><a class="header" href="#示例-22">示例</a></h3>
<pre><code class="language-solidity">assertEq(vm.getBlockTimestamp(), 1, "timestamp 应该是 1");
vm.warp(10);
assertEq(vm.getBlockTimestamp(), 10, "warp 失败");
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="getblocknumber"><a class="header" href="#getblocknumber"><code>getBlockNumber</code></a></h2>
<h3 id="签名-4"><a class="header" href="#签名-4">签名</a></h3>
<pre><code class="language-solidity">function getBlockNumber() external view returns (uint256 timestamp);
</code></pre>
<h3 id="描述-25"><a class="header" href="#描述-25">描述</a></h3>
<p>获取当前的 <code>block.number</code>。这在使用 <code>vm.roll</code> 和 <code>--via-ir</code> 编译的情况下非常有用，因为 <code>block.number</code> 在交易过程中被假定为常量。这意味着在每次 forge 测试中，多次调用 <code>block.number</code> 会被优化为仅返回一个常量值，而不是实际访问当前的 <code>block.number</code>。<code>vm.getBlockNumber()</code> 避免了这种优化，并返回当前的 <code>block.number</code>。</p>
<h3 id="示例-23"><a class="header" href="#示例-23">示例</a></h3>
<pre><code class="language-solidity">uint256 height = vm.getBlockNumber();
assertEq(height, uint256(block.number));
vm.roll(10);
assertEq(vm.getBlockNumber(), 10);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="difficulty"><a class="header" href="#difficulty"><code>difficulty</code></a></h2>
<h3 id="签名-5"><a class="header" href="#签名-5">签名</a></h3>
<pre><code class="language-solidity">function difficulty(uint256) external;
</code></pre>
<h3 id="描述-26"><a class="header" href="#描述-26">描述</a></h3>
<p>设置 <code>block.difficulty</code>。</p>
<p>如果在合并后的 EVM 版本（巴黎及以后）中使用，将会回滚。在这种情况下，请使用 <a href="cheatcodes/./prevrandao.html"><code>vm.prevrandao</code></a> 代替。</p>
<h3 id="示例-24"><a class="header" href="#示例-24">示例</a></h3>
<pre><code class="language-solidity">vm.difficulty(25);
emit log_uint(block.difficulty); // 25
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="prevrandao"><a class="header" href="#prevrandao"><code>prevrandao</code></a></h2>
<h3 id="签名-6"><a class="header" href="#签名-6">签名</a></h3>
<pre><code class="language-solidity">function prevrandao(bytes32) external;
</code></pre>
<h3 id="描述-27"><a class="header" href="#描述-27">描述</a></h3>
<p>设置 <code>block.prevrandao</code>。</p>
<p>如果在巴黎硬分叉之前的 EVM 版本中使用，将会回滚。在这种情况下，请使用 <a href="cheatcodes/./difficulty.html"><code>vm.difficulty</code></a> 代替。</p>
<h3 id="示例-25"><a class="header" href="#示例-25">示例</a></h3>
<pre><code class="language-solidity">vm.prevrandao(bytes32(uint256(42)));
emit log_uint(block.prevrandao); // 42
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="chainid"><a class="header" href="#chainid"><code>chainId</code></a></h2>
<h3 id="签名-7"><a class="header" href="#签名-7">签名</a></h3>
<pre><code class="language-solidity">function chainId(uint256) external;
</code></pre>
<h3 id="描述-28"><a class="header" href="#描述-28">描述</a></h3>
<p>设置 <code>block.chainid</code>。</p>
<h3 id="示例-26"><a class="header" href="#示例-26">示例</a></h3>
<pre><code class="language-solidity">vm.chainId(31337);
emit log_uint(block.chainid); // 31337
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="store"><a class="header" href="#store"><code>store</code></a></h2>
<h3 id="签名-8"><a class="header" href="#签名-8">签名</a></h3>
<pre><code class="language-solidity">function store(address account, bytes32 slot, bytes32 value) external;
</code></pre>
<h3 id="描述-29"><a class="header" href="#描述-29">描述</a></h3>
<p>将值 <code>value</code> 存储在账户 <code>account</code> 的存储槽 <code>slot</code> 中。</p>
<h3 id="示例-27"><a class="header" href="#示例-27">示例</a></h3>
<pre><code class="language-solidity">/// contract LeetContract {
///     uint256 private leet = 1337; // slot 0
/// }

vm.store(address(leetContract), bytes32(uint256(0)), bytes32(uint256(31337)));
bytes32 leet = vm.load(address(leetContract), bytes32(uint256(0)));
emit log_uint(uint256(leet)); // 31337
</code></pre>
<h3 id="参见-3"><a class="header" href="#参见-3">参见</a></h3>
<p>Forge 标准库</p>
<p><a href="cheatcodes/../reference/forge-std/std-storage.html">Std Storage</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="load"><a class="header" href="#load"><code>load</code></a></h2>
<h3 id="签名-9"><a class="header" href="#签名-9">签名</a></h3>
<pre><code class="language-solidity">function load(address account, bytes32 slot) external returns (bytes32);
</code></pre>
<h3 id="描述-30"><a class="header" href="#描述-30">描述</a></h3>
<p>从账户 <code>account</code> 的存储槽 <code>slot</code> 中加载值。</p>
<h3 id="示例-28"><a class="header" href="#示例-28">示例</a></h3>
<pre><code class="language-solidity">/// contract LeetContract {
///     uint256 private leet = 1337; // slot 0
/// }

bytes32 leet = vm.load(address(leetContract), bytes32(uint256(0)));
emit log_uint(uint256(leet)); // 1337
</code></pre>
<h3 id="参见-4"><a class="header" href="#参见-4">参见</a></h3>
<p>Forge 标准库</p>
<p><a href="cheatcodes/../reference/forge-std/std-storage.html">Std Storage</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="etch"><a class="header" href="#etch"><code>etch</code></a></h2>
<h3 id="签名-10"><a class="header" href="#签名-10">签名</a></h3>
<pre><code class="language-solidity">function etch(address who, bytes calldata code) external;
</code></pre>
<h3 id="描述-31"><a class="header" href="#描述-31">描述</a></h3>
<p>将地址 <code>who</code> 的字节码设置为 <code>code</code>。</p>
<h3 id="示例-29"><a class="header" href="#示例-29">示例</a></h3>
<pre><code class="language-solidity">bytes memory code = address(awesomeContract).code;
address targetAddr = makeAddr("target");
vm.etch(targetAddr, code);
log_bytes(address(targetAddr).code); // 0x6080604052348015610010...
</code></pre>
<h4 id="使用-vmetch-启用自定义预编译"><a class="header" href="#使用-vmetch-启用自定义预编译">使用 <code>vm.etch</code> 启用自定义预编译</a></h4>
<p>某些链，如 Blast 或 Arbitrum，运行时带有自定义预编译。Foundry 在 vanilla EVM 上操作，并不知道这些预编译。如果你遇到由于预编译不可用而导致的回滚，可以使用 <code>vm.etch</code> 作弊码将缺失预编译的模拟注入到预期出现的地址。</p>
<pre><code class="language-solidity">pragma solidity 0.8.10;

import "forge-std/Test.sol";

// Firstly, we implement a mock emulating the actual precompile behavior
contract YieldMock {
    address private constant blastContract = 0x4300000000000000000000000000000000000002;

    mapping(address =&gt; uint8) public getConfiguration;

    function configure(address contractAddress, uint8 flags) external returns (uint256) {
        require(msg.sender == blastContract);

        getConfiguration[contractAddress] = flags;
        return 0;
    }

    function claim(address, address, uint256) external pure returns (uint256) {
        return 0;
    }

    function getClaimableAmount(address) external pure returns (uint256) {
        return 0;
    }
}

contract SomeBlastTest is Test {
    function setUp() public {
        vm.createSelectFork("blastRpcUrl");
        // Deploy mock of the precompile
        YieldMock yieldMock = new YieldMock();
        // Set mock bytecode to the expected precompile address
        vm.etch(0x0000000000000000000000000000000000000100, address(yieldMock).code);
    }

    function testSomething() public {
        // Now we can interact with Blast contracts without reverts
    }
}
</code></pre>
<div class="warning">
<p>注入预编译的模拟可能很棘手，因为这样的模拟不会完全模拟链上实际预编译的行为。</p>
<p>在上面的例子中，模拟不会导致实际收益的累积，如果配置了任何收益模式。</p>
</div>
<h3 id="另请参阅-11"><a class="header" href="#另请参阅-11">另请参阅</a></h3>
<p>Forge 标准库</p>
<ul>
<li><a href="cheatcodes/../reference/forge-std/deployCode.html"><code>deployCode</code></a></li>
<li><a href="cheatcodes/../reference/forge-std/deployCodeTo.html"><code>deployCodeTo</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="deal"><a class="header" href="#deal"><code>deal</code></a></h2>
<h3 id="签名-11"><a class="header" href="#签名-11">签名</a></h3>
<pre><code class="language-solidity">function deal(address who, uint256 newBalance) external;
</code></pre>
<h3 id="描述-32"><a class="header" href="#描述-32">描述</a></h3>
<p>将地址 <code>who</code> 的余额设置为 <code>newBalance</code>。</p>
<p>如果使用 <code>deal</code> 的替代签名（定义在 <code>StdCheats.sol</code> 中），则可以额外指定 ERC20 代币地址，以及一个更新 <code>totalSupply</code> 的选项。</p>
<h3 id="示例-30"><a class="header" href="#示例-30">示例</a></h3>
<pre><code class="language-solidity">address alice = makeAddr("alice");
emit log_address(alice);
vm.deal(alice, 1 ether);
log_uint256(alice.balance); // 1000000000000000000
</code></pre>
<pre><code class="language-solidity">address alice = makeAddr("alice");
emit log_address(alice);
deal(address(DAI), alice, 1 ether); // 首先导入 StdUtils.sol
log_uint256(address(DAI).balanceOf(alice)); // 1000000000000000000
</code></pre>
<h3 id="参见-5"><a class="header" href="#参见-5">参见</a></h3>
<p>Forge 标准库</p>
<p><a href="cheatcodes/../reference/forge-std/deal.html"><code>deal</code></a>, <a href="cheatcodes/../reference/forge-std/hoax.html"><code>hoax</code></a>, <a href="cheatcodes/../reference/forge-std/startHoax.html"><code>startHoax</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="prank"><a class="header" href="#prank"><code>prank</code></a></h2>
<h3 id="签名-12"><a class="header" href="#签名-12">签名</a></h3>
<pre><code class="language-solidity">function prank(address) external;
</code></pre>
<pre><code class="language-solidity">function prank(address sender, address origin) external;
</code></pre>
<h3 id="描述-33"><a class="header" href="#描述-33">描述</a></h3>
<p>将 <code>msg.sender</code> 设置为指定的地址 <strong>仅对下一次调用</strong> 有效。“下一次调用” 包括静态调用，但不包括对作弊码地址的调用。</p>
<p>如果使用 <code>prank</code> 的替代签名，则 <code>tx.origin</code> 也会在下一次调用中被设置。</p>
<h3 id="示例-31"><a class="header" href="#示例-31">示例</a></h3>
<pre><code class="language-solidity">/// function withdraw() public {
///     require(msg.sender == owner);

vm.prank(owner);
myContract.withdraw(); // [PASS]
</code></pre>
<h3 id="另请参阅-12"><a class="header" href="#另请参阅-12">另请参阅</a></h3>
<p>Forge 标准库</p>
<p><a href="cheatcodes/../reference/forge-std/hoax.html"><code>hoax</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="startprank"><a class="header" href="#startprank"><code>startPrank</code></a></h2>
<h3 id="签名-13"><a class="header" href="#签名-13">签名</a></h3>
<pre><code class="language-solidity">function startPrank(address) external;
</code></pre>
<pre><code class="language-solidity">function startPrank(address sender, address origin) external;
</code></pre>
<h3 id="描述-34"><a class="header" href="#描述-34">描述</a></h3>
<p>设置 <code>msg.sender</code> <strong>对于所有后续调用</strong>，直到调用 <a href="cheatcodes/./stop-prank.html"><code>stopPrank</code></a> 为止。</p>
<p>如果使用 <code>startPrank</code> 的替代签名，则 <code>tx.origin</code> 也会被设置为所有后续调用。</p>
<h3 id="另请参阅-13"><a class="header" href="#另请参阅-13">另请参阅</a></h3>
<p>Forge 标准库</p>
<p><a href="cheatcodes/../reference/forge-std/startHoax.html"><code>startHoax</code></a>, <a href="cheatcodes/../reference/forge-std/change-prank.html"><code>changePrank</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="stopprank"><a class="header" href="#stopprank"><code>stopPrank</code></a></h2>
<h3 id="签名-14"><a class="header" href="#签名-14">签名</a></h3>
<pre><code class="language-solidity">function stopPrank() external;
</code></pre>
<h3 id="描述-35"><a class="header" href="#描述-35">描述</a></h3>
<p>停止由 <a href="cheatcodes/./start-prank.html"><code>startPrank</code></a> 启动的活跃恶作剧，将 <code>msg.sender</code> 和 <code>tx.origin</code> 重置为调用 <code>startPrank</code> 之前的值。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="readcallers"><a class="header" href="#readcallers"><code>readCallers</code></a></h2>
<h3 id="签名-15"><a class="header" href="#签名-15">签名</a></h3>
<pre><code class="language-solidity">enum CallerMode {
    None,
    Broadcast,
    RecurrentBroadcast,
    Prank,
    RecurrentPrank
}

function readCallers() 
external 
returns (CallerMode callerMode, address msgSender, address txOrigin);
</code></pre>
<h3 id="描述-36"><a class="header" href="#描述-36">描述</a></h3>
<p>读取当前的 <code>CallerMode</code>、<code>msg.sender</code> 和 <code>tx.origin</code>。</p>
<p><code>CallerMode</code> 枚举指示是否有活动的调用者修改及其类型。</p>
<ul>
<li>
<p>如果有活动的 prank：</p>
<ul>
<li><code>callerMode</code> 将等于：
<ul>
<li><code>CallerMode.Prank</code> 如果 prank 已通过 <a href="cheatcodes/./prank.html"><code>prank</code></a> 设置。</li>
<li><code>CallerMode.RecurrentPrank</code> 如果 prank 已通过 <a href="cheatcodes/./start-prank.html"><code>startPrank</code></a> 设置。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>如果有活动的 broadcast：</p>
<ul>
<li><code>callerMode</code> 将等于：
<ul>
<li><code>CallerMode.Broadcast</code> 如果 broadcast 已通过 <a href="cheatcodes/./broadcast.html"><code>broadcast</code></a> 设置。</li>
<li><code>CallerMode.RecurrentBroadcast</code> 如果 broadcast 已通过 <a href="cheatcodes/./start-broadcast.html"><code>startBroadcast</code></a> 设置。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>如果没有活动的调用者修改：</p>
<ul>
<li><code>callerMode</code> 将等于 <code>CallerMode.None</code>。</li>
</ul>
</li>
</ul>
<h3 id="示例-32"><a class="header" href="#示例-32">示例</a></h3>
<pre><code class="language-solidity">CallerMode callerMode;
address msgSender;
address txOrigin;

// 示例 1
(callerMode, msgSender, txOrigin) = vm.readCallers();
assertEq(callerMode, CallerMode.None);
assertEq(msgSender, defaultSenderAddress);
assertEq(txOrigin, defaultOriginAddress);

// 示例 2
vm.prank(senderPrankAddress);
(callerMode, msgSender, txOrigin) = vm.readCallers();
assertEq(callerMode, CallerMode.Prank);
assertEq(msgSender, senderPrankAddress);
assertEq(txOrigin, defaultOriginAddress);

// 示例 3
vm.prank(senderPrankAddress, originPrankAddress);
(callerMode, msgSender, txOrigin) = vm.readCallers();
assertEq(callerMode, CallerMode.Prank);
assertEq(msgSender, senderPrankAddress);
assertEq(txOrigin, originPrankAddress);

// 示例 4
vm.broadcast(broadcastAddress);
(callerMode, msgSender, txOrigin) = vm.readCallers();
assertEq(callerMode, CallerMode.Broadcast);
assertEq(msgSender, broadcastAddress);
assertEq(txOrigin, broadcastAddress);
</code></pre>
<h3 id="参见-6"><a class="header" href="#参见-6">参见</a></h3>
<ul>
<li><a href="cheatcodes/./prank.html">prank</a></li>
<li><a href="cheatcodes/./start-prank.html">startPrank</a></li>
<li><a href="cheatcodes/./broadcast.html">broadcast</a></li>
<li><a href="cheatcodes/./start-broadcast.html">startBroadcast</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="record"><a class="header" href="#record"><code>record</code></a></h2>
<h3 id="签名-16"><a class="header" href="#签名-16">签名</a></h3>
<pre><code class="language-solidity">function record() external;
</code></pre>
<h3 id="描述-37"><a class="header" href="#描述-37">描述</a></h3>
<p>告诉虚拟机开始记录所有的存储读取和写入。要访问这些读取和写入，请使用 <a href="cheatcodes/./accesses.html"><code>accesses</code></a>。</p>
<blockquote>
<p>ℹ️ <strong>注意</strong></p>
<p>每次写入也会计为一次额外的读取。</p>
</blockquote>
<h3 id="示例-33"><a class="header" href="#示例-33">示例</a></h3>
<pre><code class="language-solidity">/// contract NumsContract {
///     uint256 public num1 = 100; // slot 0
///     uint256 public num2 = 200; // slot 1
/// }

vm.record();
numsContract.num2();
(bytes32[] memory reads, bytes32[] memory writes) = vm.accesses(
  address(numsContract)
);
emit log_uint(uint256(reads[0])); // 1
</code></pre>
<h3 id="参见-7"><a class="header" href="#参见-7">参见</a></h3>
<p>Forge 标准库</p>
<p><a href="cheatcodes/../reference/forge-std/std-storage.html">Std Storage</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="accesses"><a class="header" href="#accesses"><code>accesses</code></a></h2>
<h3 id="签名-17"><a class="header" href="#签名-17">签名</a></h3>
<pre><code class="language-solidity">function accesses(
  address
)
external
returns (
  bytes32[] memory reads,
  bytes32[] memory writes
);
</code></pre>
<h3 id="描述-38"><a class="header" href="#描述-38">描述</a></h3>
<p>获取在某个地址上已读取（<code>reads</code>）或写入（<code>writes</code>）的所有存储槽。</p>
<p>请注意，必须先调用 <a href="cheatcodes/./record.html"><code>record</code></a>。</p>
<blockquote>
<p>ℹ️ <strong>注意</strong></p>
<p>每次写入也会计为一次额外的读取。</p>
</blockquote>
<h3 id="示例-34"><a class="header" href="#示例-34">示例</a></h3>
<pre><code class="language-solidity">/// contract NumsContract {
///     uint256 public num1 = 100; // slot 0
///     uint256 public num2 = 200; // slot 1
/// }

vm.record();
numsContract.num2();
(bytes32[] memory reads, bytes32[] memory writes) = vm.accesses(
  address(numsContract)
);
emit log_uint(uint256(reads[0])); // 1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="recordlogs"><a class="header" href="#recordlogs"><code>recordLogs</code></a></h2>
<h3 id="签名-18"><a class="header" href="#签名-18">签名</a></h3>
<pre><code class="language-solidity">function recordLogs() external;
</code></pre>
<h3 id="描述-39"><a class="header" href="#描述-39">描述</a></h3>
<p>告诉虚拟机开始记录所有发出的日志。要访问这些日志，请使用 <a href="cheatcodes/./get-recorded-logs.html"><code>getRecordedLogs</code></a>。</p>
<h3 id="示例-35"><a class="header" href="#示例-35">示例</a></h3>
<pre><code class="language-solidity">/// event LogCompleted(
///   uint256 indexed topic1,
///   bytes data
/// );

vm.recordLogs();

emit LogCompleted(10, "operation completed");

Vm.Log[] memory entries = vm.getRecordedLogs();

assertEq(entries.length, 1);
assertEq(entries[0].topics[0], keccak256("LogCompleted(uint256,bytes)"));
assertEq(entries[0].topics[1], bytes32(uint256(10)));
assertEq(abi.decode(entries[0].data, (string)), "operation completed");
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="getrecordedlogs"><a class="header" href="#getrecordedlogs"><code>getRecordedLogs</code></a></h2>
<h3 id="签名-19"><a class="header" href="#签名-19">签名</a></h3>
<pre><code class="language-solidity">struct Log {
  bytes32[] topics;
  bytes data;
  address emitter;
}

function getRecordedLogs()
external
returns (
  Log[] memory
);
</code></pre>
<h3 id="描述-40"><a class="header" href="#描述-40">描述</a></h3>
<p>获取由 <a href="cheatcodes/./record-logs.html"><code>recordLogs</code></a> 记录的已发出事件。</p>
<p>调用此函数时会消耗记录的日志。</p>
<h3 id="示例-36"><a class="header" href="#示例-36">示例</a></h3>
<pre><code class="language-solidity">/// event LogTopic1(
///   uint256 indexed topic1,
///   bytes data
/// );

/// event LogTopic12(
///   uint256 indexed topic1,
///   uint256 indexed topic2,
///   bytes data
/// );

/// bytes memory testData0 = "Some data";
/// bytes memory testData1 = "Other data";


// 启动记录器
vm.recordLogs();

emit LogTopic1(10, testData0);
emit LogTopic12(20, 30, testData1);

// 注意你的条目是 &lt;Interface&gt;.Log[]
// 而不是 &lt;instance&gt;.Log[]
Vm.Log[] memory entries = vm.getRecordedLogs();

assertEq(entries.length, 2);

// 记住 topics[0] 是事件签名
assertEq(entries[0].topics.length, 2);
assertEq(entries[0].topics[0], keccak256("LogTopic1(uint256,bytes)"));
assertEq(entries[0].topics[1], bytes32(uint256(10)));
// assertEq 不会比较 bytes 变量。尝试使用字符串代替。
assertEq(abi.decode(entries[0].data, (string)), string(testData0));

assertEq(entries[1].topics.length, 3);
assertEq(entries[1].topics[0], keccak256("LogTopic12(uint256,uint256,bytes)"));
assertEq(entries[1].topics[1], bytes32(uint256(20)));
assertEq(entries[1].topics[2], bytes32(uint256(30)));
assertEq(abi.decode(entries[1].data, (string)), string(testData1));

// 发出另一个事件
emit LogTopic1(40, testData0);

// 你上次的读取消耗了记录的日志，
// 你只会得到在那次调用之后最新发出的事件
entries = vm.getRecordedLogs();

assertEq(entries.length, 1);

assertEq(entries[0].topics.length, 2);
assertEq(entries[0].topics[0], keccak256("LogTopic1(uint256,bytes)"));
assertEq(entries[0].topics[1], bytes32(uint256(40)));
assertEq(abi.decode(entries[0].data, (string)), string(testData0));

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="setnonce"><a class="header" href="#setnonce"><code>setNonce</code></a></h2>
<h3 id="签名-20"><a class="header" href="#签名-20">签名</a></h3>
<pre><code class="language-solidity">function setNonce(address account, uint64 nonce) external;
</code></pre>
<h3 id="描述-41"><a class="header" href="#描述-41">描述</a></h3>
<p>设置给定账户的 nonce。</p>
<p>新的 nonce 必须高于账户当前的 nonce。</p>
<h3 id="示例-37"><a class="header" href="#示例-37">示例</a></h3>
<pre><code class="language-solidity">vm.setNonce(address(100), 1234);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="getnonce"><a class="header" href="#getnonce"><code>getNonce</code></a></h2>
<h3 id="签名-21"><a class="header" href="#签名-21">签名</a></h3>
<pre><code class="language-solidity">function getNonce(address account) external returns (uint64);
</code></pre>
<pre><code class="language-solidity">function getNonce(Wallet memory wallet) external returns (uint64);
</code></pre>
<h3 id="描述-42"><a class="header" href="#描述-42">描述</a></h3>
<p>获取给定账户或 <a href="cheatcodes/./create-wallet.html">Wallet</a> 的 nonce。</p>
<h3 id="示例-38"><a class="header" href="#示例-38">示例</a></h3>
<h4 id="address"><a class="header" href="#address"><code>address</code></a></h4>
<pre><code class="language-solidity">uint256 nonce = vm.getNonce(address(100));
emit log_uint(nonce); // 0
</code></pre>
<h4 id="wallet"><a class="header" href="#wallet"><code>Wallet</code></a></h4>
<pre><code class="language-solidity">Wallet memory alice = vm.createWallet("alice");
uint256 nonce = vm.getNonce(alice);
emit log_uint(nonce); // 0
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="mockcall"><a class="header" href="#mockcall"><code>mockCall</code></a></h2>
<h3 id="签名-22"><a class="header" href="#签名-22">签名</a></h3>
<pre><code class="language-solidity">function mockCall(address where, bytes calldata data, bytes calldata retdata) external;
</code></pre>
<pre><code class="language-solidity">function mockCall(
    address where,
    uint256 value,
    bytes calldata data,
    bytes calldata retdata
) external;
</code></pre>
<h3 id="描述-43"><a class="header" href="#描述-43">描述</a></h3>
<p>如果调用数据与 <code>data</code> 完全或部分匹配，则模拟对地址 <code>where</code> 的所有调用并返回 <code>retdata</code>。</p>
<p>当对 <code>where</code> 进行调用时，首先检查调用数据是否与 <code>data</code> 完全匹配。如果没有，则检查调用数据是否在起始字节处有部分匹配。</p>
<p>如果找到匹配项，则从调用中返回 <code>retdata</code>。</p>
<p><strong>使用第二个签名</strong>，我们可以模拟带有特定 <code>msg.value</code> 的调用。在存在歧义的情况下，<code>Calldata</code> 匹配优先于 <code>msg.value</code>。</p>
<p>模拟调用有效，直到调用 <a href="cheatcodes/./clear-mocked-calls.html"><code>clearMockedCalls</code></a>。</p>
<blockquote>
<p>ℹ️ <strong>注意</strong></p>
<p>如果地址上没有代码，对模拟地址的调用可能会回滚。这是因为 Solidity 在某些合约调用之前插入了一个 <code>extcodesize</code> 检查。</p>
<p>要绕过这一点，如果模拟地址没有代码，请使用 <a href="cheatcodes/./etch.html"><code>etch</code></a> 作弊码。</p>
</blockquote>
<blockquote>
<p>ℹ️ <strong>内部调用</strong></p>
<p>此作弊码目前不适用于内部调用。请参见问题 <a href="https://github.com/foundry-rs/foundry/issues/432" title="" target="_blank">#432</a>。</p>
</blockquote>
<h3 id="示例-39"><a class="header" href="#示例-39">示例</a></h3>
<p>模拟精确调用：</p>
<pre><code class="language-solidity">function testMockCall() public {
    vm.mockCall(
        address(0),
        abi.encodeWithSelector(MyToken.balanceOf.selector, address(1)),
        abi.encode(10)
    );
    assertEq(IERC20(address(0)).balanceOf(address(1)), 10);
}
</code></pre>
<p>模拟整个函数：</p>
<pre><code class="language-solidity">function testMockCall() public {
    vm.mockCall(
        address(0),
        abi.encodeWithSelector(MyToken.balanceOf.selector),
        abi.encode(10)
    );
    assertEq(IERC20(address(0)).balanceOf(address(1)), 10);
    assertEq(IERC20(address(0)).balanceOf(address(2)), 10);
}
</code></pre>
<p>模拟带有特定 <code>msg.value</code> 的调用：</p>
<pre><code class="language-solidity">function testMockCall() public {
    assertEq(example.pay{value: 10}(1), 1);
    assertEq(example.pay{value: 1}(2), 2);
    vm.mockCall(
        address(example),
        10,
        abi.encodeWithSelector(example.pay.selector),
        abi.encode(99)
    );
    assertEq(example.pay{value: 10}(1), 99);
    assertEq(example.pay{value: 1}(2), 2);
}
</code></pre>
<p>模拟公共变量：</p>
<pre><code class="language-solidity">contract Example {
    uint256 public number = 10;
}

contract ExampleTest is Test {
    Example public example;

    function setUp() public {
        example = new Example();
    }

    function testMockPublicVariable() public {
        assertEq(example.number(), 10);
        vm.mockCall(
            address(example),
            abi.encodeWithSelector(bytes4(keccak256("number()"))),
            abi.encode(5)
        );
        assertEq(example.number(), 5);
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="mockcallrevert"><a class="header" href="#mockcallrevert"><code>mockCallRevert</code></a></h2>
<h3 id="签名-23"><a class="header" href="#签名-23">签名</a></h3>
<pre><code class="language-solidity">function mockCallRevert(address where, bytes calldata data, bytes calldata retdata) external;
</code></pre>
<pre><code class="language-solidity">function mockCallRevert(
    address where,
    uint256 value,
    bytes calldata data,
    bytes calldata retdata
) external;
</code></pre>
<h3 id="描述-44"><a class="header" href="#描述-44">描述</a></h3>
<p>如果调用数据严格或宽松匹配 <code>data</code>，则对地址 <code>where</code> 的所有调用都会被还原，并返回 <code>retdata</code>。</p>
<p><code>retdata</code> 可以是原始返回消息或自定义错误。</p>
<p>当对 <code>where</code> 进行调用时，首先检查调用数据是否与 <code>data</code> 完全匹配。
如果不匹配，则检查调用数据是否存在部分匹配，匹配从调用数据的第一个字节开始。</p>
<p>如果找到匹配，则调用被还原，并返回 <code>retdata</code>。</p>
<p><strong>使用第二个签名</strong>，我们可以使用特定的 <code>msg.value</code> 模拟调用。如果存在歧义，调用数据匹配优先于 <code>msg.value</code>。</p>
<p>被还原的模拟调用一直有效，直到调用 <a href="cheatcodes/./clear-mocked-calls.html"><code>clearMockedCalls</code></a>。</p>
<blockquote>
<p>ℹ️ <strong>内部调用</strong></p>
<p>此作弊代码目前不适用于内部调用。请参见问题 <a href="https://github.com/foundry-rs/foundry/issues/432" title="" target="_blank">#432</a>。</p>
</blockquote>
<h3 id="示例-40"><a class="header" href="#示例-40">示例</a></h3>
<p>使用原始错误消息还原精确调用：</p>
<pre><code class="language-solidity">function testMockCallRevert() public {
    vm.mockCallRevert(
        address(0),
        abi.encodeWithSelector(MyToken.balanceOf.selector, address(1)),
        "REVERT_MESSAGE"
    );
    vm.expectRevert("REVERT_MESSAGE");
    IERC20(address(0)).balanceOf(address(1));
}
</code></pre>
<p>使用自定义错误还原调用：</p>
<pre><code class="language-solidity">function testMockCallRevertWithCustomError() public {
    bytes memory customError = abi.encodeWithSelector(TestError.selector, "ERROR_MESSAGE");
    vm.mockCallRevert(
        address(0),
        abi.encodeWithSelector(MyToken.balanceOf.selector, address(1)),
        customError
    );
    vm.expectRevert(customError);
    IERC20(address(0)).balanceOf(address(1));
}
</code></pre>
<p>使用给定的 <code>msg.value</code> 模拟调用：</p>
<pre><code class="language-solidity">function testMockCallRevertWithValue() public {
    assertEq(example.pay{value: 10}(1), 1);
    assertEq(example.pay{value: 1}(2), 2);
    vm.mockCallRevert(
        address(example),
        10,
        abi.encodeWithSelector(example.pay.selector),
        "ERROR_MESSAGE"
    );
    assertEq(example.pay{value: 1}(2), 2);
    vm.expectRevert("ERROR_MESSAGE");
    assertEq(example.pay{value: 10}(1), 99);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="clearmockedcalls"><a class="header" href="#clearmockedcalls"><code>clearMockedCalls</code></a></h2>
<h3 id="签名-24"><a class="header" href="#签名-24">签名</a></h3>
<pre><code class="language-solidity">function clearMockedCalls() external;
</code></pre>
<h3 id="描述-45"><a class="header" href="#描述-45">描述</a></h3>
<p>清除所有<a href="cheatcodes/./mock-call.html">模拟调用</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="coinbase"><a class="header" href="#coinbase"><code>coinbase</code></a></h2>
<h3 id="签名-25"><a class="header" href="#签名-25">签名</a></h3>
<pre><code class="language-solidity">function coinbase(address) external;
</code></pre>
<h3 id="描述-46"><a class="header" href="#描述-46">描述</a></h3>
<p>设置 <code>block.coinbase</code>。</p>
<h3 id="示例-41"><a class="header" href="#示例-41">示例</a></h3>
<pre><code class="language-solidity">emit log_address(block.coinbase); // 0x0000000000000000000000000000000000000000
vm.coinbase(0xEA674fdDe714fd979de3EdF0F56AA9716B898ec8);
emit log_address(block.coinbase); // 0xea674fdde714fd979de3edf0f56aa9716b898ec8
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="broadcast-1"><a class="header" href="#broadcast-1"><code>broadcast</code></a></h2>
<h3 id="签名-26"><a class="header" href="#签名-26">签名</a></h3>
<pre><code class="language-solidity">function broadcast() external;
</code></pre>
<pre><code class="language-solidity">function broadcast(address who) external;
</code></pre>
<pre><code class="language-solidity">function broadcast(uint256 privateKey) external;
</code></pre>
<h3 id="描述-47"><a class="header" href="#描述-47">描述</a></h3>
<p>使用调用测试合约的地址或提供的地址/私钥作为发送者，使得下一个调用（仅在此调用深度且不包括作弊码调用）创建一个可以稍后签名并发送到链上的交易。</p>
<h3 id="示例-42"><a class="header" href="#示例-42">示例</a></h3>
<pre><code class="language-solidity">function deploy() public {
    vm.broadcast(ACCOUNT_A);
    Test test = new Test();

    // 这不会生成需要签名的交易
    uint256 b = test.t(4);

    // 这会生成需要签名的交易
    vm.broadcast(ACCOUNT_B);
    test.t(2);

    // 这也会生成需要签名的交易，使用环境变量中的私钥
    vm.broadcast(vm.envUint("PRIVATE_KEY"));
    test.t(3);
} 
</code></pre>
<h3 id="参见-8"><a class="header" href="#参见-8">参见</a></h3>
<ul>
<li><a href="cheatcodes/./start-broadcast.html">startBroadcast</a></li>
<li><a href="cheatcodes/./stop-broadcast.html">stopBroadcast</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="startbroadcast"><a class="header" href="#startbroadcast"><code>startBroadcast</code></a></h2>
<h3 id="签名-27"><a class="header" href="#签名-27">签名</a></h3>
<pre><code class="language-solidity">function startBroadcast() external;
</code></pre>
<pre><code class="language-solidity">function startBroadcast(address who) external;
</code></pre>
<pre><code class="language-solidity">function startBroadcast(uint256 privateKey) external;
</code></pre>
<h3 id="描述-48"><a class="header" href="#描述-48">描述</a></h3>
<p>使用调用测试合约的地址或提供的地址/私钥作为发送者，所有后续调用（仅在此调用深度且不包括作弊码调用）将创建可以稍后签名并发送上链的交易。</p>
<h3 id="示例-43"><a class="header" href="#示例-43">示例</a></h3>
<pre><code class="language-solidity">function t(uint256 a) public returns (uint256) {
    uint256 b = 0;
    emit log_string("here");
    return b;
}

function deployOther() public {
    vm.startBroadcast(ACCOUNT_A);
    Test test = new Test();
    
    // 将触发一笔交易
    test.t(1);
    
    vm.stopBroadcast();

    // 再次广播，这次使用环境变量中的私钥
    vm.startBroadcast(vm.envUint("PRIVATE_KEY"));
    test.t(3);
    vm.stopBroadcast();
}
</code></pre>
<h3 id="另请参阅-14"><a class="header" href="#另请参阅-14">另请参阅</a></h3>
<ul>
<li><a href="cheatcodes/./broadcast.html">broadcast</a></li>
<li><a href="cheatcodes/./stop-broadcast.html">stopBroadcast</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="stopbroadcast"><a class="header" href="#stopbroadcast"><code>stopBroadcast</code></a></h2>
<h3 id="签名-28"><a class="header" href="#签名-28">签名</a></h3>
<pre><code class="language-solidity">function stopBroadcast() external;
</code></pre>
<h3 id="描述-49"><a class="header" href="#描述-49">描述</a></h3>
<p>停止收集交易以便稍后在链上广播。</p>
<h3 id="示例-44"><a class="header" href="#示例-44">示例</a></h3>
<pre><code class="language-solidity">function deployNoArgs() public {
    // 广播下一个调用
    cheats.broadcast();
    Test test1 = new Test();

    // 广播此行和 `stopBroadcast` 之间的所有调用
    cheats.startBroadcast();
    Test test2 = new Test();
    cheats.stopBroadcast();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pausegasmetering"><a class="header" href="#pausegasmetering"><code>pauseGasMetering</code></a></h2>
<h3 id="签名-29"><a class="header" href="#签名-29">签名</a></h3>
<pre><code class="language-solidity">function pauseGasMetering() external;
</code></pre>
<h3 id="描述-50"><a class="header" href="#描述-50">描述</a></h3>
<p>暂停 gas 计量（即 <code>gasleft()</code> 不会随着操作的执行而减少）。</p>
<p>这对于通过关闭不必要的代码的 gas 计量来更好地了解 gas 成本非常有用，还可以用于避免长时间运行的脚本因 gas 耗尽而终止。</p>
<blockquote>
<p>ℹ️ <strong>注意</strong></p>
<p><code>pauseGasMetering</code> <em>关闭了来自 gas 计量的 DoS 保护</em>。</p>
<p>如果服务假设特定实例的 EVM 会因 gas 使用而完成，则不再成立，在这种情况下应启用超时。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="resumegasmetering"><a class="header" href="#resumegasmetering"><code>resumeGasMetering</code></a></h2>
<h3 id="签名-30"><a class="header" href="#签名-30">签名</a></h3>
<pre><code class="language-solidity">function resumeGasMetering() external;
</code></pre>
<h3 id="描述-51"><a class="header" href="#描述-51">描述</a></h3>
<p>恢复 gas 计量（即 <code>gasleft()</code> 会随着操作的执行而减少）。Gas 使用量将在暂停时的相同数量上恢复。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="txgasprice"><a class="header" href="#txgasprice"><code>txGasPrice</code></a></h2>
<h3 id="签名-31"><a class="header" href="#签名-31">签名</a></h3>
<pre><code class="language-solidity">function txGasPrice(uint256) external;
</code></pre>
<pre><code class="language-solidity">function txGasPrice(uint256 newGasPrice) external;
</code></pre>
<h3 id="描述-52"><a class="header" href="#描述-52">描述</a></h3>
<p>设置 <code>tx.gasprice</code> <strong>用于当前交易的剩余部分</strong>。</p>
<h3 id="示例-45"><a class="header" href="#示例-45">示例</a></h3>
<p>我们可以使用这个功能来获取交易的准确 gas 使用量。</p>
<pre><code class="language-solidity">function testCalculateGas() public {
    vm.txGasPrice(2);
    uint256 gasStart = gasleft();
    myContract.doStuff();
    uint256 gasEnd = gasleft();
    uint256 gasUsed = (gasStart - gasEnd) * tx.gasprice; // tx.gasprice 现在是 2
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="startstatediffrecording"><a class="header" href="#startstatediffrecording"><code>startStateDiffRecording</code></a></h2>
<h3 id="签名-32"><a class="header" href="#签名-32">签名</a></h3>
<pre><code class="language-solidity">function startStateDiffRecording()
</code></pre>
<h3 id="描述-53"><a class="header" href="#描述-53">描述</a></h3>
<p>记录所有作为 CREATE、CALL 或 SELFDESTRUCT 操作码一部分的状态变化，并按顺序记录调用上下文。
有关如何访问和解释记录的状态变化的更多详细信息，请参阅 <a href="cheatcodes/./stop-and-return-state-diff.html"><code>stopAndReturnStateDiff</code></a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="stopandreturnstatediff"><a class="header" href="#stopandreturnstatediff"><code>stopAndReturnStateDiff</code></a></h2>
<h3 id="签名-33"><a class="header" href="#签名-33">签名</a></h3>
<pre><code class="language-solidity">enum AccountAccessKind {
    Call,
    DelegateCall,
    CallCode,
    StaticCall,
    Create,
    SelfDestruct,
    Resume,
    Balance,
    Extcodesize,
    Extcodehash,
    Extcodecopy
}

struct ChainInfo {
    uint256 forkId;
    uint256 chainId;
}

struct AccountAccess {
    ChainInfo chainInfo;
    AccountAccessKind kind;
    address account;
    address accessor;
    bool initialized;
    uint256 oldBalance;
    uint256 newBalance;
    bytes deployedCode;
    uint256 value;
    bytes data;
    bool reverted;
    StorageAccess[] storageAccesses;
    uint64 depth;
}

struct StorageAccess {
    address account;
    bytes32 slot;
    bool isWrite;
    bytes32 previousValue;
    bytes32 newValue;
    bool reverted;
}

function stopAndReturnStateDiff() external returns (AccountAccess[] memory accesses);
</code></pre>
<h3 id="描述-54"><a class="header" href="#描述-54">描述</a></h3>
<p>检索在调用 <a href="cheatcodes/./start-state-diff-recording.html"><code>startStateDiffRecording</code></a> 之后记录的状态变化。此函数将在调用时消耗记录的状态差异并禁用状态差异记录。可以调用 <code>startStateDiffRecording</code> 以恢复记录。</p>
<p>有两种类型的状态变化记录；账户访问和存储访问，分别表示为 <code>AccountAccess</code> 和 <code>StorageAccess</code>。</p>
<p>账户状态变化（<code>AccountAccess</code>）在新的 EVM 上下文开始时记录；即由各种 CREATE、CALL 和 SELFDESTRUCT 操作引起。
一个 <code>AccountAccess</code> 记录包含存储访问，表示为 <code>StorageAccess</code>，这些访问在通过子调用或创建操作被抢占之前发生。</p>
<p><code>AccountAccess</code> 记录的顺序反映了其相关操作的 EVM 执行顺序。每当创建或恢复 EVM 上下文时，都会创建一个 <code>AccountAccess</code>。
如果创建了子上下文，则记录一个 <code>Resume</code> <code>AccountAccess</code>，以指示之前被抢占的 <code>AccountAccess</code> 已恢复。</p>
<h3 id="accountaccesskind"><a class="header" href="#accountaccesskind"><code>AccountAccessKind</code></a></h3>
<p>访问账户的类型，决定了被访问的 <code>account</code>。这通常由启动账户执行上下文的 EVM 操作指定。
如果类型是 <code>Call</code>、<code>DelegateCall</code>、<code>StaticCall</code> 或 <code>CallCode</code>，则 <code>account</code> 是被调用者。
如果类型是 Create，则账户是新创建的账户。
如果类型是 SelfDestruct，则账户是自毁接收者。
如果类型是 Resume，则账户表示已恢复的执行上下文。</p>
<ul>
<li><code>Call</code> - 账户被调用</li>
<li><code>DelegateCall</code> - 账户通过委托调用被调用</li>
<li><code>CallCode</code> - 账户通过 callcode 被调用</li>
<li><code>StaticCall</code> - 账户通过 staticcall 被调用</li>
<li><code>Create</code> - 账户被创建</li>
<li><code>SelfDestruct</code> - 账户被自毁</li>
<li><code>Resume</code> - 指示之前被抢占的账户访问已恢复</li>
<li><code>Balance</code> - 账户的代码大小被读取</li>
<li><code>Extcodesize</code> - 账户的代码大小被读取</li>
<li><code>Extcodehash</code> - 账户的代码哈希被读取</li>
<li><code>Extcodecopy</code> - 账户的代码被复制</li>
</ul>
<h3 id="accountaccess"><a class="header" href="#accountaccess"><code>AccountAccess</code></a></h3>
<ul>
<li><code>chainInfo</code> - 访问发生的链和分叉</li>
<li><code>kind</code> - 账户访问的类型。这决定了如何解释 <code>AccountAccess</code></li>
<li><code>account</code> - 被访问的账户。对于 <code>AccountAccessKind.Create</code>，它是创建的账户。
在 <code>AccountAccessKind.SelfDestruct</code> 的情况下，它是自毁接收者。
对于所有其他类型的 <code>AccountAccessKind</code>，它是当前 EVM 上下文的账户。</li>
<li><code>accessor</code> - 访问 <code>account</code> 的对象。即账户创建者、调用者或被自毁的账户。</li>
<li><code>initialized</code> - 访问前账户是否已初始化或为空。
如果账户有代码、非零 nonce 或非零余额，则认为已初始化。</li>
<li><code>oldBalance</code> - 被访问 <code>account</code> 之前的余额。</li>
<li><code>newBalance</code> - 被访问账户的潜在新余额。
即，即使发生回滚，所有余额变化也会记录在此。</li>
<li><code>deployedCode</code> - 在 <code>AccountAccessKind.Create</code> 情况下部署的 <code>account</code> 的代码。对于所有其他账户访问类型，此字段为空。</li>
<li><code>value</code> - 随账户访问传递的值。</li>
<li><code>data</code> - 提供的输入数据（即 <code>msg.data</code>），在 <code>CREATE</code> 或 <code>CALL</code> 类型的访问中。</li>
<li><code>reverted</code> - 如果此访问在当前或父上下文中回滚。</li>
<li><code>storageAccesses</code> - 在账户访问未被抢占时进行的存储访问的有序列表。</li>
<li><code>depth</code> - 记录状态差异时遍历的调用深度。</li>
</ul>
<h3 id="storageaccess"><a class="header" href="#storageaccess"><code>StorageAccess</code></a></h3>
<p>在 <code>AccountAccess</code> 期间进行的存储访问。<code>StorageAccess</code> 不能在没有关联的 <code>AccountAccess</code> 的情况下存在。这意味着当在给定上下文开始记录状态差异时，在该上下文期间进行的存储访问不会被记录，因为该上下文（但不是其子上下文）未被记录。</p>
<p><code>StorageAccess</code> 包含以下字段：</p>
<ul>
<li><code>account</code> - 其存储被访问的账户</li>
<li><code>slot</code> - 被访问的槽</li>
<li><code>isWrite</code> - 访问是否为写操作</li>
<li><code>previousValue</code> - 此存储访问前的槽值</li>
<li><code>newValue</code> - 此存储访问后的槽值</li>
<li><code>reverted</code> - 如果此访问被回滚</li>
</ul>
<h3 id="恢复的-accountaccess"><a class="header" href="#恢复的-accountaccess">恢复的 <code>AccountAccess</code></a></h3>
<p>当子上下文返回到其父上下文时，会生成这种类型的 AccountAccess。它保留与原始上下文相同的值，包括 <code>accessor</code>、<code>account</code>、<code>initialized</code>、<code>storageAccesses</code> 和 <code>reverted</code>。
以下控制流表说明了如何记录恢复的 AccountAccess。</p>
<div class="table-wrapper"><table><thead><tr><th>合约 A 的 <code>alpha()</code> 步骤</th><th>合约 B 的 <code>beta()</code> 步骤</th><th>AccountAccess 记录状态</th></tr></thead><tbody>
<tr><td>调用 A.alpha()</td><td></td><td>[A.call]</td></tr>
<tr><td>访问状态</td><td></td><td>[A.call[A.access]]</td></tr>
<tr><td>调用 B.beta()</td><td>B.beta() 开始</td><td>[A.call[A.access], B.call]</td></tr>
<tr><td>(执行暂停)</td><td>访问状态</td><td>[A.call[A.access], B.call[B.access]]</td></tr>
<tr><td></td><td>返回</td><td></td></tr>
<tr><td>恢复执行</td><td>(返回到 A.alpha())</td><td>[A.call[A.access], B.call[B.access]]</td></tr>
<tr><td>访问状态</td><td></td><td>[<br> A.call[A.access], <br> B.call[B.access], <br> A.resume[A.access’]<br>]</td></tr>
</tbody></table>
</div>
<blockquote>
<p>ℹ️ <strong>注意</strong></p>
<p>仅当上下文恢复后发生存储访问时，才会创建恢复的 AccountAccess。</p>
</blockquote>
<h3 id="示例在-create-操作期间记录存储状态变化"><a class="header" href="#示例在-create-操作期间记录存储状态变化">示例：在 CREATE 操作期间记录存储状态变化</a></h3>
<pre><code class="language-solidity">contract Contract {
    uint256 internal _reserved;
    uint256 public data;
    constructor(uint _data) payable { data = _data; }
}

vm.startStateDiffRecording();
Contract contract = new Contract{value: 1 ether}(100);
Vm.AccountAccess[] memory records = vm.stopAndReturnStateDiff();

assertEq(records.length, 1);
assertEq(records[0].kind, Vm.AccountAccessKind.Create);
assertEq(records[0].account, address(contract));
assertEq(records[0].accessor, address(this));
assertEq(records[0].initialized, true);
assertEq(records[0].oldBalance, 0);
assertEq(records[0].newBalance, 1 ether);
assertEq(records[0].deployedCode, address(contract).code);
assertEq(records[0].value, 1 ether);
assertEq(records[0].data, abi.encodePacked(type(Contract).creationCode, (uint(100))));
assertEq(records[0].reverted, false);

assertEq(records[0].storageAccesses.length, 1);
assertEq(records[0].storageAccesses[0].account, address(contract));
assertEq(records[0].storageAccesses[0].slot, bytes32(uint256(1)));
assertEq(records[0].storageAccesses[0].isWrite, true);
assertEq(records[0].storageAccesses[0].previousValue, bytes32(uint(0)));
assertEq(records[0].storageAccesses[0].newValue, bytes32(uint(100)));
assertEq(records[0].storageAccesses[0].reverted, false);
</code></pre>
<p>注意，此示例中没有 <code>Resume</code> 账户访问。</p>
<h3 id="示例恢复的账户访问"><a class="header" href="#示例恢复的账户访问">示例：恢复的账户访问</a></h3>
<pre><code class="language-solidity">contract Foo {
    Bar b;
    uint256 public val;
    constructor(Bar _b) { b = _b; }
    function run() external {
        val = val + 1;
        b.run();
        val = val + 1;
    }
}
contract Bar {
    function run() external {}
}

Bar bar = new Bar();
Foo foo = new Foo(bar);

vm.startStateDiffRecording();
foo.run();
Vm.AccountAccess[] memory records = vm.stopAndReturnStateDiff();

assertEq(records.length, 3);
Vm.AccountAccess memory fooCall = records[0];
assertEq(fooCall.kind, Vm.AccountAccessKind.Call);
assertEq(fooCall.account, address(foo));
assertEq(fooCall.accessor, address(this));
// foo.val 增加
assertEq(fooCall.storageAccesses.length, 2);
assertEq(fooCall.storageAccesses[0].isWrite, false);
assertEq(fooCall.storageAccesses[1].isWrite, true);
assertEq(fooCall.storageAccesses[1].oldValue, bytes32(uint(0)));
assertEq(fooCall.storageAccesses[1].newValue, bytes32(uint(1)));

// bar.run CALL
Vm.AccountAccess memory barCall = records[1];
assertEq(barCall.kind, Vm.AccountAccessKind.Call);
assertEq(barCall.account, address(bar));
assertEq(barCall.accessor, address(foo));

// foo.run RESUME
Vm.AccountAccess memory fooResume = records[2];
assertEq(fooResume.kind, Vm.AccountAccessKind.Resume);
// foo.val 增加
assertEq(fooResume.storageAccesses.length, 2);
assertEq(fooResume.storageAccesses[0].isWrite, false);
assertEq(fooResume.storageAccesses[1].isWrite, true);
assertEq(fooResume.storageAccesses[1].oldValue, bytes32(uint(1)));
assertEq(fooResume.storageAccesses[1].newValue, bytes32(uint(2)));
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="断言"><a class="header" href="#断言">断言</a></h2>
<ul>
<li><a href="cheatcodes/./expect-revert.html"><code>expectRevert</code></a></li>
<li><a href="cheatcodes/./expect-emit.html"><code>expectEmit</code></a></li>
<li><a href="cheatcodes/./expect-call.html"><code>expectCall</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="expectrevert"><a class="header" href="#expectrevert"><code>expectRevert</code></a></h2>
<h3 id="签名-34"><a class="header" href="#签名-34">签名</a></h3>
<pre><code class="language-solidity">function expectRevert() external;
</code></pre>
<pre><code class="language-solidity">function expectRevert(bytes4 message) external;
</code></pre>
<pre><code class="language-solidity">function expectRevert(bytes calldata message) external;
</code></pre>
<h3 id="描述-55"><a class="header" href="#描述-55">描述</a></h3>
<p>如果<strong>下一次调用</strong>没有以预期的数据 <code>message</code> 回滚，那么 <code>expectRevert</code> 将会回滚。</p>
<p>在调用 <code>expectRevert</code> 之后，在回滚调用之前的其他作弊码调用将被忽略。</p>
<p>这意味着，例如，我们可以在回滚调用之前立即调用 <a href="cheatcodes/./prank.html"><code>prank</code></a>。</p>
<p>有三种签名：</p>
<ul>
<li><strong>无参数</strong>：断言下一次调用会回滚，无论消息是什么。</li>
<li><strong>带 <code>bytes4</code></strong>：断言下一次调用会以指定的 4 字节回滚。</li>
<li><strong>带 <code>bytes</code></strong>：断言下一次调用会以指定的字节回滚。</li>
</ul>
<blockquote>
<p>⚠️ <strong>注意：与低级调用一起使用</strong></p>
<p>通常，成功的调用会返回 <code>true</code> 的状态（以及任何返回数据），而回滚的调用会返回 <code>false</code>。</p>
<p>Solidity 编译器会插入检查以确保调用成功，并在失败时回滚。</p>
<p>在低级调用中，<code>expectRevert</code> 作弊码通过使低级调用返回的 <code>status</code> 布尔值对应于 <code>expectRevert</code> 是否成功，而不是低级调用是否成功。因此，<code>status</code> 为 false 对应于作弊码失败。</p>
<p>除此之外，<code>expectRevert</code> 还会在低级调用中篡改返回数据，并且不可用。</p>
<p>请参见以下示例。为了清晰起见，<code>status</code> 已重命名为 <code>revertsAsExpected</code>：</p>
<pre><code class="language-solidity">function testLowLevelCallRevert() public {
    vm.expectRevert(bytes("error message"));
    (bool revertsAsExpected, ) = address(myContract).call(myCalldata);
    assertTrue(revertsAsExpected, "expectRevert: call did not revert");
}
</code></pre>
</blockquote>
<h3 id="示例-46"><a class="header" href="#示例-46">示例</a></h3>
<p>要使用 <code>expectRevert</code> 与 <code>string</code>，将其作为字符串字面量传递。</p>
<pre><code class="language-solidity">vm.expectRevert("error message");
</code></pre>
<p>要使用 <code>expectRevert</code> 与不带参数的自定义 <a href="https://docs.soliditylang.org/en/v0.8.11/contracts.html#errors" title="" target="_blank">错误类型</a>，使用其选择器。</p>
<pre><code class="language-solidity">vm.expectRevert(CustomError.selector);
</code></pre>
<p>要使用 <code>expectRevert</code> 与带参数的自定义 <a href="https://docs.soliditylang.org/en/v0.8.11/contracts.html#errors" title="" target="_blank">错误类型</a>，使用 ABI 编码错误类型。</p>
<pre><code class="language-solidity">vm.expectRevert(
    abi.encodeWithSelector(CustomError.selector, 1, 2)
);
</code></pre>
<p>如果你需要断言一个函数回滚<strong>没有</strong>消息，可以使用 <code>expectRevert(bytes(""))</code>。</p>
<pre><code class="language-solidity">function testExpectRevertNoReason() public {
    Reverter reverter = new Reverter();
    vm.expectRevert(bytes(""));
    reverter.revertWithoutReason();
}
</code></pre>
<p>无消息的回滚发生在出现 EVM 错误时，例如当交易消耗的 gas 超过区块的 gas 限制时。</p>
<p>如果你需要断言一个函数回滚一个四字符的消息，例如 <code>AAAA</code>，可以使用：</p>
<pre><code class="language-solidity">function testFourLetterMessage() public {
    vm.expectRevert(bytes("AAAA"));
}
</code></pre>
<p>如果使用 <code>expectRevert("AAAA")</code>，编译器会抛出错误，因为它不知道使用哪个重载。</p>
<p>最后，你也可以在一个测试中有多个 <code>expectRevert()</code> 检查。</p>
<pre><code class="language-solidity">function testMultipleExpectReverts() public {
    vm.expectRevert("INVALID_AMOUNT");
    vault.send(user, 0);

    vm.expectRevert("INVALID_ADDRESS");
    vault.send(address(0), 200);
}
</code></pre>
<h3 id="另请参阅-15"><a class="header" href="#另请参阅-15">另请参阅</a></h3>
<p>Forge 标准库</p>
<p><a href="cheatcodes/../reference/forge-std/std-errors.html">Std Errors</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="expectemit"><a class="header" href="#expectemit"><code>expectEmit</code></a></h2>
<h3 id="签名-35"><a class="header" href="#签名-35">签名</a></h3>
<pre><code class="language-solidity">function expectEmit() external;
</code></pre>
<pre><code class="language-solidity">function expectEmit(
    bool checkTopic1,
    bool checkTopic2,
    bool checkTopic3,
    bool checkData
) external;
</code></pre>
<pre><code class="language-solidity">function expectEmit(address emitter) external;
</code></pre>
<pre><code class="language-solidity">function expectEmit(
    bool checkTopic1,
    bool checkTopic2,
    bool checkTopic3,
    bool checkData,
    address emitter
) external;
</code></pre>
<h3 id="描述-56"><a class="header" href="#描述-56">描述</a></h3>
<p>断言在下次调用期间会发出特定的日志。</p>
<ol>
<li>调用作弊代码，指定我们是否应该检查第一个、第二个或第三个主题，以及日志数据（<code>expectEmit()</code> 检查所有这些）。主题 0 总是被检查。</li>
<li>在下次调用期间发出我们预期会看到的事件。</li>
<li>执行调用。</li>
</ol>
<p>你可以在下次调用中多次执行步骤 1 和 2 以匹配一系列事件。</p>
<p>如果事件在当前作用域中不可用（例如，如果我们使用接口或外部智能合约），我们可以用相同的事件签名自己定义事件。</p>
<p><code>expectEmit</code> 有两种变体：</p>
<ul>
<li><strong>不检查发射地址</strong>：断言主题匹配<strong>不</strong>检查发射地址。</li>
<li><strong>带 <code>address</code></strong>：断言主题匹配并且发射地址匹配。</li>
</ul>
<blockquote>
<p>ℹ️ <strong>匹配序列</strong></p>
<p>在发出大量事件的函数中，可以“跳过”事件并仅匹配特定序列，但此序列必须始终按顺序排列。例如，假设一个函数发出事件：<code>A, B, C, D, E, F, F, G</code>。</p>
<p><code>expectEmit</code> 将能够匹配范围，并且可以在中间跳过事件：</p>
<ul>
<li><code>[A, B, C]</code> 是有效的。</li>
<li><code>[B, D, F]</code> 是有效的。</li>
<li><code>[G]</code> 或其他单一事件组合是有效的。</li>
<li><code>[B, A]</code> 或类似的乱序组合是<strong>无效的</strong>（事件必须按顺序排列）。</li>
<li><code>[C, F, F]</code> 是有效的。</li>
<li><code>[F, F, C]</code> 是<strong>无效的</strong>（乱序）。</li>
</ul>
</blockquote>
<h3 id="示例-47"><a class="header" href="#示例-47">示例</a></h3>
<p>这不检查发射地址。</p>
<pre><code class="language-solidity">event Transfer(address indexed from, address indexed to, uint256 amount);

function testERC20EmitsTransfer() public {
    vm.expectEmit();

    // 我们发出预期会看到的事件。
    emit MyToken.Transfer(address(this), address(1), 10);

    // 我们执行调用。
    myToken.transfer(address(1), 10);
}
</code></pre>
<p>这检查发射地址。</p>
<pre><code class="language-solidity">event Transfer(address indexed from, address indexed to, uint256 amount);

function testERC20EmitsTransfer() public {
    // 我们通过传递地址来检查代币是否是事件发射者。
    vm.expectEmit(address(myToken));
    emit MyToken.Transfer(address(this), address(1), 10);

    // 我们执行调用。
    myToken.transfer(address(1), 10);
}
</code></pre>
<p>我们还可以断言在一次调用中发出多个事件。</p>
<pre><code class="language-solidity">function testERC20EmitsBatchTransfer() public {
    // 我们声明多个预期的转账事件
    for (uint256 i = 0; i &lt; users.length; i++) {
        // 这里我们使用较长的签名进行演示。此调用检查
        // topic0（总是检查），topic1（true），topic2（true），不检查 topic3（false），以及数据（true）。
        vm.expectEmit(true, true, false, true);
        emit Transfer(address(this), users[i], 10);
    }

    // 我们还预期一个自定义的 `BatchTransfer(uint256 numberOfTransfers)` 事件。
    vm.expectEmit(false, false, false, true);
    emit BatchTransfer(users.length);

    // 我们执行调用。
    myToken.batchTransfer(users, 10);
}
</code></pre>
<p>此示例失败，因为预期的事件在下次调用中未发出。</p>
<pre><code class="language-solidity">event Transfer(address indexed from, address indexed to, uint256 amount);

function testERC20EmitsTransfer() public {
    // 我们通过传递地址作为第五个参数来检查代币是否是事件发射者。
    vm.expectEmit(true, true, false, true, address(myToken));
    emit MyToken.Transfer(address(this), address(1), 10);

    // 我们执行一个不相关的调用，该调用不会发出预期的事件，
    // 使作弊代码失败。
    myToken.approve(address(this), 1e18);
    // 我们执行调用，但它不会有任何效果，因为作弊代码已经失败。
    myToken.transfer(address(1), 10);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="expectcall"><a class="header" href="#expectcall"><code>expectCall</code></a></h2>
<pre><code class="language-solidity">function expectCall(address callee, bytes calldata data) external;
</code></pre>
<pre><code class="language-solidity">function expectCall(address callee, bytes calldata data, uint64 count) external;
</code></pre>
<pre><code class="language-solidity">function expectCall(
    address callee,
    uint256 value,
    bytes calldata data
) external;
</code></pre>
<pre><code class="language-solidity">function expectCall(
    address callee,
    uint256 value,
    bytes calldata data,
    uint64 count
) external;
</code></pre>
<h3 id="描述-57"><a class="header" href="#描述-57">描述</a></h3>
<p>期望对指定地址 <code>callee</code> 进行调用，其中调用数据要么严格匹配 <code>data</code>，要么宽松匹配 <code>data</code>。该作弊码有两种调用方式：</p>
<ul>
<li>如果没有指定 <code>count</code> 参数，则期望调用至少被调用的次数与作弊码被调用的次数相同。对于相同的调用数据，不能在没有 <code>count</code> 的情况下调用作弊码，然后传入 <code>count</code> 参数。</li>
<li>如果指定了 <code>count</code>，则期望调用严格被调用 <code>count</code> 次。对于相同的调用数据，<code>count</code> 值不能通过另一个作弊码调用被覆盖，也不能通过不带 <code>count</code> 参数的作弊码调用增加。</li>
</ul>
<p><code>count</code> 也可以设置为 0，以断言不会进行调用。</p>
<p>当对 <code>callee</code> 进行调用时，首先检查调用数据是否与 <code>data</code> 完全匹配。如果没有，则检查调用数据是否存在部分匹配，匹配从调用数据的第一个字节开始。</p>
<p><strong>使用第二个签名</strong>，我们还可以检查调用是否使用预期的 <code>msg.value</code> 进行。</p>
<p>如果测试在没有进行调用的情况下终止，则测试失败。</p>
<blockquote>
<p>ℹ️ <strong>内部调用</strong></p>
<p>该作弊码目前不适用于内部调用。请参见问题 <a href="https://github.com/foundry-rs/foundry/issues/432" title="" target="_blank">#432</a>。</p>
</blockquote>
<h3 id="示例-48"><a class="header" href="#示例-48">示例</a></h3>
<p>期望在代币 <code>MyToken</code> 上调用 <code>transfer</code> 一次：</p>
<pre><code class="language-solidity">address alice = makeAddr("alice");
emit log_address(alice);
vm.expectCall(
  address(token), abi.encodeCall(token.transfer, (alice, 10))
);
token.transfer(alice, 10);
// [PASS]
</code></pre>
<p>期望在代币 <code>MyToken</code> 上调用 <code>transfer</code> <em>至少</em> 两次：</p>
<pre><code class="language-solidity">address alice = makeAddr("alice");
emit log_address(alice);
vm.expectCall(
  address(token), abi.encodeCall(token.transfer, (alice, 10))
);
vm.expectCall(
  address(token), abi.encodeCall(token.transfer, (alice, 10))
);
token.transfer(alice, 10);
token.transfer(alice, 10);
token.transfer(alice, 10);
// [PASS]
</code></pre>
<p>期望在代币 <code>MyToken</code> 上不调用 <code>transfer</code>：</p>
<pre><code class="language-solidity">address alice = makeAddr("alice");
emit log_address(alice);
vm.expectCall(
  address(token), abi.encodeCall(token.transfer, (alice, 10)), 0
);
token.transferFrom(alice, address(0), 10);
// [PASS]
</code></pre>
<p>期望在代币 <code>MyToken</code> 上调用 <code>transfer</code> 且任何调用数据被调用 2 次：</p>
<pre><code class="language-solidity">address alice = makeAddr("alice");
emit log_address(alice);
vm.expectCall(
  address(token), abi.encodeWithSelector(token.transfer.selector), 2
);
token.transfer(alice, 10);
token.transfer(alice, 10);
// [PASS]
</code></pre>
<p>期望在 <code>Contract</code> 上调用 <code>pay</code> 且具有特定的 <code>msg.value</code> 和 <code>calldata</code>：</p>
<pre><code class="language-solidity">Contract target = new Contract();
vm.expectCall(
            address(target),
            1,
            abi.encodeWithSelector(target.pay.selector, 2)
        );
target.pay{value: 1}(2);
// [PASS]
</code></pre>
<p>期望在 <code>Contract</code> 上调用 <code>pay</code> 且具有特定的 <code>msg.value</code> 和 <code>calldata</code> 3 次：</p>
<pre><code class="language-solidity">Contract target = new Contract();
vm.expectCall(
            address(target),
            1,
            abi.encodeWithSelector(target.pay.selector, 2),
            3
        );
target.pay{value: 1}(2);
target.pay{value: 1}(2);
target.pay{value: 1}(2);
// [PASS]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="模糊测试器"><a class="header" href="#模糊测试器">模糊测试器</a></h2>
<ul>
<li><a href="cheatcodes/./assume.html"><code>assume</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="assume"><a class="header" href="#assume"><code>assume</code></a></h2>
<h3 id="签名-36"><a class="header" href="#签名-36">签名</a></h3>
<pre><code class="language-solidity">function assume(bool) external;
</code></pre>
<h3 id="描述-58"><a class="header" href="#描述-58">描述</a></h3>
<p>如果布尔表达式评估为 false，模糊测试器将丢弃当前的模糊输入并开始新的模糊测试运行。</p>
<p><code>assume</code> 作弊码主要应用于非常窄的检查。
广泛的检查会减慢测试速度，因为需要一段时间才能找到有效的值，并且如果达到最大拒绝次数，测试可能会失败。</p>
<p>您可以通过在 <code>foundry.toml</code> 文件中设置 <a href="cheatcodes/../reference/config/testing.html#max_test_rejects"><code>fuzz.max_test_rejects</code></a> 来配置拒绝阈值。</p>
<p>对于广泛的检查，例如确保 <code>uint256</code> 落在某个范围内，您可以使用取模运算符或 Forge Standard 的 <a href="cheatcodes/../reference/forge-std/bound.html"><code>bound</code></a> 方法来限制输入。</p>
<p>有关通过 <code>assume</code> 进行过滤的更多信息，请参见<a href="https://altsysrq.github.io/proptest-book/proptest/tutorial/filtering.html#filtering" title="" target="_blank">这里</a>。</p>
<h3 id="示例-49"><a class="header" href="#示例-49">示例</a></h3>
<pre><code class="language-solidity">// 使用 assume 的好例子
function testSomething(uint256 a) public {
    vm.assume(a != 1);
    require(a != 1);
    // [PASS]
}
</code></pre>
<pre><code class="language-solidity">// 在这种情况下，assume 不是很好的选择，因此您应该手动限制输入
function testSomethingElse(uint256 a) public {
    a = bound(a, 100, 1e36);
    require(a &gt;= 100 &amp;&amp; a &lt;= 1e36);
    // [PASS]
}
</code></pre>
<h3 id="另请参阅-16"><a class="header" href="#另请参阅-16">另请参阅</a></h3>
<p>Forge Standard Library</p>
<p><a href="cheatcodes/../reference/forge-std/bound.html"><code>bound</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="分叉-2"><a class="header" href="#分叉-2">分叉</a></h2>
<ul>
<li><a href="cheatcodes/./create-fork.html"><code>createFork</code></a></li>
<li><a href="cheatcodes/./select-fork.html"><code>selectFork</code></a></li>
<li><a href="cheatcodes/./create-select-fork.html"><code>createSelectFork</code></a></li>
<li><a href="cheatcodes/./active-fork.html"><code>activeFork</code></a></li>
<li><a href="cheatcodes/./roll-fork.html"><code>rollFork</code></a></li>
<li><a href="cheatcodes/./make-persistent.html"><code>makePersistent</code></a></li>
<li><a href="cheatcodes/./revoke-persistent.html"><code>revokePersistent</code></a></li>
<li><a href="cheatcodes/./is-persistent.html"><code>isPersistent</code></a></li>
<li><a href="cheatcodes/./allow-cheatcodes.html"><code>allowCheatcodes</code></a></li>
<li><a href="cheatcodes/./transact.html"><code>transact</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="createfork"><a class="header" href="#createfork"><code>createFork</code></a></h2>
<h3 id="签名-37"><a class="header" href="#签名-37">签名</a></h3>
<pre><code class="language-solidity">// 创建一个新的分叉，使用给定的端点和最新的区块，并返回分叉的标识符
function createFork(string calldata urlOrAlias) external returns (uint256)
</code></pre>
<pre><code class="language-solidity">// 创建一个新的分叉，使用给定的端点和区块，并返回分叉的标识符
function createFork(string calldata urlOrAlias, uint256 block) external returns (uint256);
</code></pre>
<pre><code class="language-solidity">// 创建一个新的分叉，使用给定的端点和给定交易所在的区块，并重放该区块中在该交易之前的所有交易
function createFork(string calldata urlOrAlias, bytes32 transaction) external returns (uint256);
</code></pre>
<h3 id="描述-59"><a class="header" href="#描述-59">描述</a></h3>
<p>从给定的端点创建一个新的分叉，并返回分叉的标识符。如果传递了区块号作为参数，分叉将从该区块开始，否则将从最新的区块开始。</p>
<p>如果提供了交易哈希，它将把分叉回滚到交易所在的区块，并重放该区块中在该交易之前执行的所有交易。</p>
<h3 id="示例-50"><a class="header" href="#示例-50">示例</a></h3>
<p>创建一个新的主网分叉，使用最新的区块号：</p>
<pre><code class="language-solidity">uint256 forkId = vm.createFork(MAINNET_RPC_URL);
vm.selectFork(forkId);

assertEq(block.number, 15_171_037); // 截至撰写时，2022-07-19 04:55:27 UTC
</code></pre>
<p>创建一个新的主网分叉，使用给定的区块号：</p>
<pre><code class="language-solidity">uint256 forkId = vm.createFork(MAINNET_RPC_URL, 1_337_000);
vm.selectFork(forkId);

assertEq(block.number, 1_337_000);
</code></pre>
<h3 id="另请参阅-17"><a class="header" href="#另请参阅-17">另请参阅</a></h3>
<ul>
<li><a href="cheatcodes/./active-fork.html">activeFork</a></li>
<li><a href="cheatcodes/./select-fork.html">selectFork</a></li>
<li><a href="cheatcodes/./create-select-fork.html">createSelectFork</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="selectfork"><a class="header" href="#selectfork"><code>selectFork</code></a></h2>
<h3 id="签名-38"><a class="header" href="#签名-38">签名</a></h3>
<pre><code class="language-solidity">function selectFork(uint256 forkId) external;
</code></pre>
<h3 id="描述-60"><a class="header" href="#描述-60">描述</a></h3>
<p>接受一个由 <code>createFork</code> 创建的分叉标识符，并将相应的分叉状态设置为活动状态。</p>
<h3 id="示例-51"><a class="header" href="#示例-51">示例</a></h3>
<p>选择一个之前创建的分叉：</p>
<pre><code class="language-solidity">uint256 forkId = vm.createFork(MAINNET_RPC_URL);

vm.selectFork(forkId);

assertEq(vm.activeFork(), forkId);
</code></pre>
<h3 id="参见-9"><a class="header" href="#参见-9">参见</a></h3>
<ul>
<li><a href="cheatcodes/./create-fork.html">createFork</a></li>
<li><a href="cheatcodes/./active-fork.html">activeFork</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="createselectfork"><a class="header" href="#createselectfork"><code>createSelectFork</code></a></h2>
<h3 id="签名-39"><a class="header" href="#签名-39">签名</a></h3>
<pre><code class="language-solidity">function createSelectFork(string calldata urlOrAlias) external returns (uint256);
</code></pre>
<pre><code class="language-solidity">function createSelectFork(string calldata urlOrAlias, uint256 block) external returns (uint256);
</code></pre>
<pre><code class="language-solidity">function createSelectFork(string calldata urlOrAlias, bytes32 transaction) external returns (uint256);
</code></pre>
<h3 id="描述-61"><a class="header" href="#描述-61">描述</a></h3>
<p>从给定的端点创建并选择一个新的分叉，并返回分叉的标识符。如果传递了一个区块号作为参数，分叉将从该区块开始，否则它将从最新的区块开始。</p>
<p>如果提供了交易哈希，它将把分叉回滚到交易被挖出的区块，并重放所有之前执行的交易。</p>
<h3 id="示例-52"><a class="header" href="#示例-52">示例</a></h3>
<p>创建并选择一个新的主网分叉，使用最新的区块号：</p>
<pre><code class="language-solidity">uint256 forkId = vm.createSelectFork(MAINNET_RPC_URL);

assertEq(block.number, 15_171_037); // 截至撰写时，2022-07-19 04:55:27 UTC
</code></pre>
<p>创建并选择一个新的主网分叉，使用给定的区块号：</p>
<pre><code class="language-solidity">uint256 forkId = vm.createSelectFork(MAINNET_RPC_URL, 1_337_000);

assertEq(block.number, 1_337_000);
</code></pre>
<h3 id="另请参阅-18"><a class="header" href="#另请参阅-18">另请参阅</a></h3>
<ul>
<li><a href="cheatcodes/./create-fork.html">createFork</a></li>
<li><a href="cheatcodes/./select-fork.html">selectFork</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="activefork"><a class="header" href="#activefork"><code>activeFork</code></a></h2>
<h3 id="签名-40"><a class="header" href="#签名-40">签名</a></h3>
<pre><code class="language-solidity">function activeFork() external returns (uint256);
</code></pre>
<h3 id="描述-62"><a class="header" href="#描述-62">描述</a></h3>
<p>返回当前活动分叉的标识符。如果没有当前活动的分叉，则回退。</p>
<h3 id="示例-53"><a class="header" href="#示例-53">示例</a></h3>
<p>获取当前活动的分叉 ID：</p>
<pre><code class="language-solidity">uint256 mainnetForkId = vm.createFork(MAINNET_RPC_URL);
uint256 optimismForkId = vm.createFork(OPTIMISM_RPC_URL);

assert(mainnetForkId != optimismForkId);

vm.selectFork(mainnetForkId);
assertEq(vm.activeFork(), mainnetForkId);

vm.selectFork(optimismForkId);
assertEq(vm.activeFork(), optimismForkId);
</code></pre>
<h3 id="参见-10"><a class="header" href="#参见-10">参见</a></h3>
<ul>
<li><a href="cheatcodes/./create-fork.html">createFork</a></li>
<li><a href="cheatcodes/./select-fork.html">selectFork</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="rollfork"><a class="header" href="#rollfork"><code>rollFork</code></a></h2>
<h3 id="签名-41"><a class="header" href="#签名-41">签名</a></h3>
<pre><code class="language-solidity">// 将_active_分叉滚动到给定的区块
function rollFork(uint256 blockNumber) external;
</code></pre>
<pre><code class="language-solidity">// 将_active_分叉滚动到交易被挖出的区块，并重放所有之前执行的交易
function rollFork(bytes32 transaction) external;
</code></pre>
<pre><code class="language-solidity">// 与`rollFork(uint256 blockNumber)`相同，但使用对应于`forkId`的分叉
function rollFork(uint256 forkId, uint256 blockNumber) external;
</code></pre>
<pre><code class="language-solidity">// 与`rollFork(bytes32 transaction)`相同，但使用对应于`forkId`的分叉
function rollFork(uint256 forkId, bytes32 transaction) external;
</code></pre>
<h3 id="描述-63"><a class="header" href="#描述-63">描述</a></h3>
<p>设置 <code>block.number</code>。如果传递了分叉标识符作为参数，它将更新该分叉，否则将更新当前活动的分叉。</p>
<p>如果提供了交易哈希，它将把分叉滚动到交易被挖出的区块，并重放所有之前执行的交易。</p>
<h3 id="示例-54"><a class="header" href="#示例-54">示例</a></h3>
<p>为当前活动的分叉设置 <code>block.number</code>：</p>
<pre><code class="language-solidity">uint256 forkId = vm.createFork(MAINNET_RPC_URL);
vm.selectFork(forkId);

assertEq(block.number, 15_171_037); // 截至撰写时，2022-07-19 04:55:27 UTC

vm.rollFork(15_171_057);

assertEq(block.number, 15_171_057);
</code></pre>
<p>为传递的 <code>forkId</code> 参数标识的分叉设置 <code>block.number</code>：</p>
<pre><code class="language-solidity">uint256 optimismForkId = vm.createFork(OPTIMISM_RPC_URL);

vm.rollFork(optimismForkId, 1_337_000);

vm.selectFork(optimismForkId);

assertEq(block.number, 1_337_000);
</code></pre>
<h3 id="参见-11"><a class="header" href="#参见-11">参见</a></h3>
<ul>
<li><a href="cheatcodes/./roll.html">roll</a></li>
<li><a href="cheatcodes/./create-fork.html">createFork</a></li>
<li><a href="cheatcodes/./select-fork.html">selectFork</a></li>
<li><a href="cheatcodes/./active-fork.html">activeFork</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="makepersistent"><a class="header" href="#makepersistent"><code>makePersistent</code></a></h2>
<h3 id="签名-42"><a class="header" href="#签名-42">签名</a></h3>
<pre><code class="language-solidity">function makePersistent(address account) external;
function makePersistent(address account0, address account1) external;
function makePersistent(address account0, address account1, address account2) external;
function makePersistent(address[] calldata accounts) external;
</code></pre>
<h3 id="描述-64"><a class="header" href="#描述-64">描述</a></h3>
<p>每个分叉（<a href="cheatcodes/./create-fork.html"><code>createFork</code></a>）都有其独立的存储空间，当选择另一个分叉时（<a href="cheatcodes/./select-fork.html"><code>selectFork</code></a>），存储空间也会被替换。
默认情况下，只有测试合约账户和调用者是跨分叉持久的，这意味着当选择不同的分叉时，测试合约的状态（变量）变化会被保留。这样可以通过将数据存储在合约的变量中来共享数据。</p>
<p>然而，通过这个作弊码，可以将指定的账户标记为持久，这意味着无论当前激活的是哪个分叉，它们的状态都是可用的。</p>
<h3 id="示例-55"><a class="header" href="#示例-55">示例</a></h3>
<p>将新合约标记为持久</p>
<pre><code class="language-solidity">contract SimpleStorageContract {
    string public value;

    function set(uint256 _value) public {
        value = _value;
    }
}

function testMarkPersistent() public {
    // 默认情况下，`sender` 和合约本身是持久的
    assert(cheats.isPersistent(msg.sender));
    assert(cheats.isPersistent(address(this)));

    // 选择一个特定的分叉
    cheats.selectFork(mainnetFork);
    
    // 创建一个存储在 `mainnetFork` 存储空间中的新合约
    SimpleStorageContract simple = new SimpleStorageContract();
    
    // `simple` 未被标记为持久
    assert(!cheats.isPersistent(address(simple)));
    
    // 合约可以使用
    uint256 expectedValue = 99;
    simple.set(expectedValue);
    assertEq(simple.value(), expectedValue);
    
    // 标记为持久
    cheats.makePersistent(address(simple));
    
    // 选择一个不同的分叉
    cheats.selectFork(optimismFork);
    
    // 确保合约仍然是持久的   
    assert(cheats.isPersistent(address(simple)));
    
    // 值设置如预期
    assertEq(simple.value(), expectedValue);
}
</code></pre>
<h3 id="参见-12"><a class="header" href="#参见-12">参见</a></h3>
<ul>
<li><a href="cheatcodes/./is-persistent.html">isPersistent</a></li>
<li><a href="cheatcodes/./revoke-persistent.html">revokePersistent</a></li>
<li><a href="cheatcodes/./create-fork.html">createFork</a></li>
<li><a href="cheatcodes/./select-fork.html">selectFork</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="revokepersistent"><a class="header" href="#revokepersistent"><code>revokePersistent</code></a></h2>
<h3 id="签名-43"><a class="header" href="#签名-43">签名</a></h3>
<pre><code class="language-solidity">function revokePersistent(address) external;
function revokePersistent(address[] calldata) external;
</code></pre>
<h3 id="描述-65"><a class="header" href="#描述-65">描述</a></h3>
<p>这是 <a href="cheatcodes/./make-persistent.html"><code>makePersistent</code></a> 的对应函数，使给定的合约在分叉交换中不再持久。</p>
<h3 id="示例-56"><a class="header" href="#示例-56">示例</a></h3>
<p>撤销合约的持久状态</p>
<pre><code class="language-solidity">contract SimpleStorageContract {
    string public value;

    function set(uint256 _value) public {
        value = _value;
    }
}

function testRevokePersistent() public {
    // 选择一个特定的分叉
    cheats.selectFork(mainnetFork);
    
    // 在 `mainnetFork` 存储中创建一个新的合约
    SimpleStorageContract simple = new SimpleStorageContract();
    
    // `simple` 未被标记为持久
    assert(!cheats.isPersistent(address(simple)));
       
    // 使其持久
    cheats.makePersistent(address(simple));
    
    // 确保它是持久的
    assert(cheats.isPersistent(address(simple)));
    
    // 撤销持久状态
    cheats.revokePersistent(address(simple));
    
    // 合约不再持久
    assert(!cheats.isPersistent(address(simple)));
}
</code></pre>
<h3 id="参见-13"><a class="header" href="#参见-13">参见</a></h3>
<ul>
<li><a href="cheatcodes/./is-persistent.html">isPersistent</a></li>
<li><a href="cheatcodes/./revoke-persistent.html">revokePersistent</a></li>
<li><a href="cheatcodes/./create-fork.html">createFork</a></li>
<li><a href="cheatcodes/./select-fork.html">selectFork</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ispersistent"><a class="header" href="#ispersistent"><code>isPersistent</code></a></h2>
<h3 id="签名-44"><a class="header" href="#签名-44">签名</a></h3>
<pre><code class="language-solidity">function isPersistent(address) external returns (bool);
</code></pre>
<h3 id="描述-66"><a class="header" href="#描述-66">描述</a></h3>
<p>返回一个账户是否被标记为持久化（<a href="cheatcodes/./make-persistent.html"><code>makePersistent</code></a>）。</p>
<h3 id="示例-57"><a class="header" href="#示例-57">示例</a></h3>
<p>检查 <code>msg.sender</code> 和当前测试账户的默认状态</p>
<pre><code class="language-solidity">// 默认情况下，`sender` 和测试合约本身是持久化的
assert(cheats.isPersistent(msg.sender));
assert(cheats.isPersistent(address(this)));
</code></pre>
<h3 id="另请参阅-19"><a class="header" href="#另请参阅-19">另请参阅</a></h3>
<ul>
<li><a href="cheatcodes/./make-persistent.html">makePersistent</a></li>
<li><a href="cheatcodes/./revoke-persistent.html">revokePersistent</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="allowcheatcodes"><a class="header" href="#allowcheatcodes"><code>allowCheatcodes</code></a></h2>
<h3 id="签名-45"><a class="header" href="#签名-45">签名</a></h3>
<pre><code class="language-solidity">function allowCheatcodes(address) external;
</code></pre>
<h3 id="描述-67"><a class="header" href="#描述-67">描述</a></h3>
<p>在分叉模式下，显式授予给定地址作弊码访问权限。</p>
<p>默认情况下，测试合约及其部署者被允许访问作弊码。此外，如果合约是由已经拥有作弊码访问权限的地址部署的，则也会授予作弊码访问权限。这将防止已经部署在分叉网络上的账户访问作弊码。</p>
<blockquote>
<p>ℹ️ <strong>注意</strong></p>
<p>这仅对分叉模式下更复杂的测试设置有用。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="transact"><a class="header" href="#transact"><code>transact</code></a></h2>
<h3 id="签名-46"><a class="header" href="#签名-46">签名</a></h3>
<pre><code class="language-solidity">// 从当前激活的分叉中获取给定的交易并执行它
function transact(bytes32 txHash) external;
// 从指定的分叉中获取给定的交易并执行它
function transact(uint256 forkId, bytes32 txHash) external;
</code></pre>
<h3 id="描述-68"><a class="header" href="#描述-68">描述</a></h3>
<p>在分叉模式下，从提供者获取交易并在当前状态下执行它。</p>
<h3 id="示例-58"><a class="header" href="#示例-58">示例</a></h3>
<p>进入分叉模式并执行一笔交易：</p>
<pre><code class="language-solidity">// 在区块 https://etherscan.io/block/15596646 进入分叉模式
uint256 fork = vm.createFork(MAINNET_RPC_URL, 15596646);
vm.selectFork(fork);

// 区块中的随机转账交易：https://etherscan.io/tx/0xaba74f25a17cf0d95d1c6d0085d6c83fb8c5e773ffd2573b99a953256f989c89
bytes32 tx = 0xaba74f25a17cf0d95d1c6d0085d6c83fb8c5e773ffd2573b99a953256f989c89;

address sender = address(0xa98218cdc4f63aCe91ddDdd24F7A580FD383865b);
address recipient = address(0x0C124046Fa7202f98E4e251B50488e34416Fc306);

assertEq(sender.balance, 5764124000000000);
assertEq(recipient.balance, 3936000000000000);

// 转账金额：0.003936 Ether
uint256 transferAmount = 3936000000000000;

// 执行交易后的预期余额变化
uint256 expectedRecipientBalance = recipient.balance + transferAmount;
uint256 expectedSenderBalance = sender.balance - transferAmount;

// 执行交易
vm.transact(tx);

// 接收者收到转账
assertEq(recipient.balance, expectedRecipientBalance);

// 发送者的余额因转账和 gas 费用减少
assert(sender.balance &lt; expectedSenderBalance);
</code></pre>
<h3 id="参见-14"><a class="header" href="#参见-14">参见</a></h3>
<ul>
<li><a href="cheatcodes/./roll.html">roll</a></li>
<li><a href="cheatcodes/./create-fork.html">createFork</a></li>
<li><a href="cheatcodes/./select-fork.html">selectFork</a></li>
<li><a href="cheatcodes/./active-fork.html">activeFork</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="外部"><a class="header" href="#外部">外部</a></h2>
<ul>
<li><a href="cheatcodes/./ffi.html"><code>ffi</code></a></li>
<li><a href="cheatcodes/./prompt.html"><code>prompt</code></a></li>
<li><a href="cheatcodes/./project-root.html"><code>projectRoot</code></a></li>
<li><a href="cheatcodes/./get-code.html"><code>getCode</code></a></li>
<li><a href="cheatcodes/./get-deployed-code.html"><code>getDeployedCode</code></a></li>
<li><a href="cheatcodes/./sleep.html"><code>sleep</code></a></li>
<li><a href="cheatcodes/./unix-time.html"><code>unixTime</code></a></li>
<li><a href="cheatcodes/./set-env.html"><code>setEnv</code></a></li>
<li><a href="cheatcodes/./env-or.html"><code>envOr</code></a></li>
<li><a href="cheatcodes/./env-bool.html"><code>envBool</code></a></li>
<li><a href="cheatcodes/./env-uint.html"><code>envUint</code></a></li>
<li><a href="cheatcodes/./env-int.html"><code>envInt</code></a></li>
<li><a href="cheatcodes/./env-address.html"><code>envAddress</code></a></li>
<li><a href="cheatcodes/./env-bytes32.html"><code>envBytes32</code></a></li>
<li><a href="cheatcodes/./env-string.html"><code>envString</code></a></li>
<li><a href="cheatcodes/./env-bytes.html"><code>envBytes</code></a></li>
<li><a href="cheatcodes/./parse-json.html"><code>parseJson</code></a></li>
<li><a href="cheatcodes/./fs.html"><code>fs</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ffi-1"><a class="header" href="#ffi-1"><code>ffi</code></a></h2>
<h3 id="签名-47"><a class="header" href="#签名-47">签名</a></h3>
<pre><code class="language-solidity">function ffi(string[] calldata) external returns (bytes memory);
</code></pre>
<h3 id="描述-69"><a class="header" href="#描述-69">描述</a></h3>
<p>如果启用了 <a href="cheatcodes/../reference/config/testing.html#ffi"><code>ffi</code></a>，则调用任意命令。</p>
<p>通常建议将此作弊代码作为最后手段使用，并且不要默认启用它，因为任何可以更改项目测试的人都可以在运行测试的设备上执行任意命令。</p>
<h3 id="提示"><a class="header" href="#提示">提示</a></h3>
<ul>
<li>默认情况下，<code>ffi</code> 作弊代码假设命令的输出是十六进制编码的值（例如 ABI 编码值的十六进制字符串）。如果十六进制解码失败，它将返回输出为 UTF8 字节，您可以将其转换为字符串。</li>
<li>确保输出不包含 <code>\n</code> 换行符。（例如在 Rust 中使用 <code>print!</code> 而不是 <code>println!</code>）</li>
<li>请记住，脚本将从项目的顶层目录执行，而不是在 <code>test</code> 内部。</li>
<li>确保输入数组没有空元素。它们将被脚本处理为输入，而不是空格。</li>
<li>使用作弊代码 <code>toString</code> 可以轻松将任意数据转换为字符串，以便您可以将它们作为命令行参数传递。</li>
</ul>
<h3 id="示例-59"><a class="header" href="#示例-59">示例</a></h3>
<p>ABI 编码输出</p>
<pre><code class="language-solidity">string[] memory inputs = new string[](3);
inputs[0] = "echo";
inputs[1] = "-n";
// ABI 编码的 "gm"，作为十六进制字符串
inputs[2] = "0x00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000002676d000000000000000000000000000000000000000000000000000000000000";

bytes memory res = vm.ffi(inputs);
string memory output = abi.decode(res, (string));
assertEq(output, "gm");
</code></pre>
<p>UTF8 字符串输出</p>
<pre><code class="language-solidity">string[] memory inputs = new string[](3);
inputs[0] = "echo";
inputs[1] = "-n";
inputs[2] = "gm";

bytes memory res = vm.ffi(inputs);
assertEq(string(res), "gm");
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="prompt"><a class="header" href="#prompt"><code>prompt</code></a></h2>
<h3 id="签名-48"><a class="header" href="#签名-48">签名</a></h3>
<pre><code class="language-solidity">function prompt(string calldata promptText) external returns (string memory input);
function promptSecret(string calldata promptText) external returns (string memory input);
function promptSecretUint(string calldata promptText) external returns (uint256);
</code></pre>
<h3 id="描述-70"><a class="header" href="#描述-70">描述</a></h3>
<p>向用户显示一个交互式提示，用于插入任意数据。</p>
<p><code>vm.prompt</code> 显示一个交互式输入，而 <code>vm.promptSecret</code> 和 <code>vm.promptSecretUint</code> 显示一个隐藏输入，用于密码和其他不应泄露到终端的秘密信息。</p>
<blockquote>
<p>ℹ️ <strong>注意</strong></p>
<p>这个作弊码旨在用于脚本——不是测试。建议遵循以下最佳实践来测试使用 <code>vm.prompt</code> 的脚本并处理超时，因为脚本可能会挂起或回滚。在非交互式 shell 中运行时，此作弊码会回滚。</p>
</blockquote>
<h3 id="配置"><a class="header" href="#配置">配置</a></h3>
<p>为了防止不必要的挂起，<code>vm.prompt</code> 有一个超时配置。</p>
<p>在你的 <code>foundry.toml</code> 文件中：</p>
<pre><code class="language-toml">prompt_timeout = 120
</code></pre>
<p>默认值是 <code>120</code>，单位是秒。</p>
<h3 id="最佳实践-1"><a class="header" href="#最佳实践-1">最佳实践</a></h3>
<h4 id="测试使用-vmprompt-的脚本"><a class="header" href="#测试使用-vmprompt-的脚本">测试使用 <code>vm.prompt</code> 的脚本</a></h4>
<p>当测试包含 <code>vm.prompt</code> 的脚本时，建议使用以下模式：</p>
<pre><code class="language-solidity">contract Script {
    function run() public {
        uint256 myUint = vm.parseUint(vm.prompt("输入一个整数"));
        run(myUint);
    }

    function run(uint256 myUint) public {
        // 实际逻辑
    }
}
</code></pre>
<p>这样，我们保持了用户体验的增益（运行脚本时不需要提供 <code>--sig</code> 参数），但测试可以设置任何值给 <code>myUint</code>，而不仅仅是一个硬编码的默认值。</p>
<h4 id="处理超时"><a class="header" href="#处理超时">处理超时</a></h4>
<p>当用户在超时到期之前未能提供输入时，<code>vm.prompt</code> 作弊码会回滚。如果你愿意，可以使用 <code>try/catch</code> 处理超时：</p>
<pre><code class="language-solidity">string memory input;

try vm.prompt("用户名") returns (string memory res) {
    input = res;
}
catch (bytes memory) {
    input = "匿名";
}
</code></pre>
<h3 id="示例-60"><a class="header" href="#示例-60">示例</a></h3>
<h4 id="选择-rpc-端点"><a class="header" href="#选择-rpc-端点">选择 RPC 端点</a></h4>
<p>提供一个选项来选择要运行的 RPC/链。</p>
<p>在你的 <code>foundry.toml</code> 文件中：</p>
<pre><code class="language-toml">[rpc_endpoints]
mainnet = "https://eth.llamarpc.com"
polygon = "https://polygon.llamarpc.com"
</code></pre>
<p>在你的脚本中：</p>
<pre><code class="language-solidity">string memory rpcEndpoint = vm.prompt("RPC 端点");
vm.createSelectFork(rpcEndpoint);
</code></pre>
<h4 id="将用户输入解析为本机类型"><a class="header" href="#将用户输入解析为本机类型">将用户输入解析为本机类型</a></h4>
<p>我们可以使用字符串解析作弊码来解析用户的响应：</p>
<pre><code class="language-solidity">uint privateKey = vm.promptSecretUint("私钥");
address to = vm.parseAddress(vm.prompt("发送至"));
uint amount = vm.parseUint(vm.prompt("金额 (wei)"));
vm.broadcast(privateKey);
payable(to).transfer(amount);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="projectroot"><a class="header" href="#projectroot"><code>projectRoot</code></a></h2>
<h3 id="签名-49"><a class="header" href="#签名-49">签名</a></h3>
<pre><code class="language-solidity">function projectRoot() external returns (string memory);
</code></pre>
<h3 id="描述-71"><a class="header" href="#描述-71">描述</a></h3>
<p>返回当前 Foundry 项目的根目录。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="getcode"><a class="header" href="#getcode"><code>getCode</code></a></h2>
<h3 id="签名-50"><a class="header" href="#签名-50">签名</a></h3>
<pre><code class="language-solidity">function getCode(string calldata) external returns (bytes memory);
</code></pre>
<h3 id="描述-72"><a class="header" href="#描述-72">描述</a></h3>
<p>返回项目中给定合约路径的<strong>创建</strong>字节码。</p>
<p>calldata 参数可以是 <code>ContractFile.sol</code>（如果文件名和合约名相同）、<code>ContractFile.sol:ContractName</code> 或相对于项目根目录的工件路径。</p>
<blockquote>
<p>ℹ️ <strong>注意</strong></p>
<p><code>getCode</code> 需要读取输出目录的权限，请参阅 <a href="cheatcodes/./fs.html">文件作弊码</a>。</p>
<p>要授予读取权限，请在 <code>foundry.toml</code> 中设置 <code>fs_permissions = [{ access = "read", path = "./out"}]</code>。</p>
</blockquote>
<h3 id="示例-61"><a class="header" href="#示例-61">示例</a></h3>
<pre><code class="language-solidity">MyContract myContract = new MyContract(arg1, arg2);

// 让我们用 `getCode` 做同样的事情
bytes memory args = abi.encode(arg1, arg2);
bytes memory bytecode = abi.encodePacked(vm.getCode("MyContract.sol:MyContract"), args);
address anotherAddress;
assembly {
    anotherAddress := create(0, add(bytecode, 0x20), mload(bytecode))
}

assertEq0(address(myContract).code, anotherAddress.code); // [PASS]
</code></pre>
<p>通过结合 <code>getCode</code> 和 <a href="cheatcodes/./etch.html"><code>etch</code></a> 将合约部署到任意地址</p>
<pre><code class="language-solidity">// 部署
bytes memory args = abi.encode(arg1, arg2);
bytes memory bytecode = abi.encodePacked(vm.getCode("MyContract.sol:MyContract"), args);
address deployed;
assembly {
    deployed := create(0, add(bytecode, 0x20), mload(bytecode))
}

// 设置任意地址的字节码
vm.etch(targetAddr, deployed.code);
</code></pre>
<h3 id="支持的格式"><a class="header" href="#支持的格式">支持的格式</a></h3>
<p>您可以通过合约路径或合约名称获取工件。还支持获取特定版本的工件。如果未提供，作弊码将默认为正在执行的测试版本或工件编译的唯一版本。</p>
<pre><code class="language-solidity">vm.getCode("MyContract.sol:MyContract");
vm.getCode("MyContract");
vm.getCode("MyContract.sol:0.8.18");
vm.getCode("MyContract:0.8.18");
</code></pre>
<h3 id="另请参阅-20"><a class="header" href="#另请参阅-20">另请参阅</a></h3>
<p><a href="cheatcodes/./get-deployed-code.html"><code>getDeployedCode</code></a>
<a href="cheatcodes/./etch.html"><code>eth</code></a></p>
<p>Forge 标准库</p>
<p><a href="cheatcodes/../reference/forge-std/deployCode.html"><code>deployCode</code></a>
<a href="cheatcodes/../reference/forge-std/deployCodeTo.html"><code>deployCodeTo</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="getdeployedcode"><a class="header" href="#getdeployedcode"><code>getDeployedCode</code></a></h2>
<h3 id="签名-51"><a class="header" href="#签名-51">签名</a></h3>
<pre><code class="language-solidity">function getDeployedCode(string calldata) external returns (bytes memory);
</code></pre>
<h3 id="描述-73"><a class="header" href="#描述-73">描述</a></h3>
<p>这个作弊码与 <a href="cheatcodes/./get-code.html"><code>getCode</code></a> 类似，但只返回项目中合约的<strong>已部署</strong>字节码（即运行时字节码），给定合约的路径。</p>
<p>这个作弊码的主要用例是作为将无状态合约部署到任意地址的快捷方式。</p>
<p>调用参数可以是 <code>ContractFile.sol</code>（如果文件名和合约名相同）、<code>ContractFile.sol:ContractName</code> 或项目根目录相对路径的构件路径。</p>
<blockquote>
<p>ℹ️ <strong>注意</strong></p>
<p><code>getDeployedCode</code> 需要读取输出目录的权限，请参阅 <a href="cheatcodes/./fs.html">文件作弊码</a>。</p>
<p>要授予读取权限，请在 <code>foundry.toml</code> 中设置 <code>fs_permissions = [{ access = "read", path = "./out"}]</code>。</p>
</blockquote>
<h3 id="示例-62"><a class="header" href="#示例-62">示例</a></h3>
<p>使用 <code>getDeployedCode</code> 和 <a href="cheatcodes/./etch.html"><code>etch</code></a> 在任意地址部署一个无状态合约。</p>
<pre><code class="language-solidity">// 我们希望在特定地址部署的无状态合约
contract Override {
    event Payload(address sender, address target, bytes data);

    function emitPayload(
        address target, bytes calldata message
    ) external payable returns (uint256) {
        emit Payload(msg.sender, target, message);
        return 0;
    }
}

// 获取**已部署字节码**
bytes memory code = vm.getDeployedCode("Override.sol:Override");

// 设置任意地址的代码
address overrideAddress = address(64);
vm.etch(overrideAddress, code);
assertEq(overrideAddress.code, code);
</code></pre>
<h3 id="支持的格式-1"><a class="header" href="#支持的格式-1">支持的格式</a></h3>
<p>你可以通过合约路径或合约名称获取构件。也支持获取特定版本的构件。如果未提供，作弊码将默认使用正在执行测试的版本或构件编译的唯一版本。</p>
<pre><code class="language-solidity">vm.getDeployedCode("MyContract.sol:MyContract");
vm.getDeployedCode("MyContract");
vm.getDeployedCode("MyContract.sol:0.8.18");
vm.getDeployedCode("MyContract:0.8.18");
</code></pre>
<h3 id="另请参阅-21"><a class="header" href="#另请参阅-21">另请参阅</a></h3>
<p>Forge 标准库</p>
<p><a href="cheatcodes/./get-code.html"><code>getCode</code></a>
<a href="cheatcodes/./etch.html"><code>etch</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="sleep"><a class="header" href="#sleep"><code>sleep</code></a></h2>
<h3 id="签名-52"><a class="header" href="#签名-52">签名</a></h3>
<pre><code class="language-solidity">function sleep(uint256 milliseconds) external;
</code></pre>
<h3 id="描述-74"><a class="header" href="#描述-74">描述</a></h3>
<p>休眠指定毫秒数。</p>
<h3 id="示例-63"><a class="header" href="#示例-63">示例</a></h3>
<pre><code class="language-solidity">vm.sleep(10_000); // 暂停执行 10 秒
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="unixtime"><a class="header" href="#unixtime"><code>unixTime</code></a></h2>
<h3 id="签名-53"><a class="header" href="#签名-53">签名</a></h3>
<pre><code class="language-solidity">function unixTime() external returns (uint milliseconds);
</code></pre>
<h3 id="描述-75"><a class="header" href="#描述-75">描述</a></h3>
<p>返回自 Unix 纪元以来的时间（以毫秒为单位）。</p>
<h3 id="示例-64"><a class="header" href="#示例-64">示例</a></h3>
<pre><code class="language-solidity">uint start = vm.unixTime();
vm.sleep(10_000); // 暂停执行 10 秒
uint end = vm.unixTime();
assertEq(end - start, 10_000);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="setenv"><a class="header" href="#setenv"><code>setEnv</code></a></h2>
<h3 id="签名-54"><a class="header" href="#签名-54">签名</a></h3>
<pre><code class="language-solidity">function setEnv(string calldata key, string calldata value) external;
</code></pre>
<h3 id="描述-76"><a class="header" href="#描述-76">描述</a></h3>
<p>设置一个环境变量 <code>key=value</code>。</p>
<blockquote>
<p>ℹ️ <strong>注意</strong></p>
<p>由进程设置的环境变量只能由其自身及其子进程访问。因此，调用 <code>setEnv</code> 只会修改当前运行的 <code>forge</code> 进程的环境变量，而不会影响 shell（<code>forge</code> 的父进程），即它们不会在 <code>forge</code> 进程退出后持久存在。</p>
</blockquote>
<h3 id="提示-1"><a class="header" href="#提示-1">提示</a></h3>
<ul>
<li>环境变量键不能为空。</li>
<li>环境变量键不能包含等号 <code>=</code> 或 NUL 字符 <code>\0</code>。</li>
<li>环境变量值不能包含 NUL 字符 <code>\0</code>。</li>
</ul>
<h3 id="示例-65"><a class="header" href="#示例-65">示例</a></h3>
<pre><code class="language-solidity">string memory key = "hello";
string memory val = "world";
cheats.setEnv(key, val);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="envor"><a class="header" href="#envor"><code>envOr</code></a></h2>
<h3 id="签名-55"><a class="header" href="#签名-55">签名</a></h3>
<pre><code class="language-solidity">function envOr(string calldata key, bool defaultValue) external returns (bool value);
function envOr(string calldata key, uint256 defaultValue) external returns (uint256 value);
function envOr(string calldata key, int256 defaultValue) external returns (int256 value);
function envOr(string calldata key, address defaultValue) external returns (address value);
function envOr(string calldata key, bytes32 defaultValue) external returns (bytes32 value);
function envOr(string calldata key, string calldata defaultValue) external returns (string memory value);
function envOr(string calldata key, bytes calldata defaultValue) external returns (bytes memory value);
</code></pre>
<pre><code class="language-solidity">function envOr(string calldata key, string calldata delimiter, bool[] calldata defaultValue) external returns (bool[] memory value);
function envOr(string calldata key, string calldata delimiter, uint256[] calldata defaultValue) external returns (uint256[] memory value);
function envOr(string calldata key, string calldata delimiter, int256[] calldata defaultValue) external returns (int256[] memory value);
function envOr(string calldata key, string calldata delimiter, address[] calldata defaultValue) external returns (address[] memory value);
function envOr(string calldata key, string calldata delimiter, bytes32[] calldata defaultValue) external returns (bytes32[] memory value);
function envOr(string calldata key, string calldata delimiter, string[] calldata defaultValue) external returns (string[] memory value);
function envOr(string calldata key, string calldata delimiter, bytes[] calldata defaultValue) external returns (bytes[] memory value);
</code></pre>
<h3 id="描述-77"><a class="header" href="#描述-77">描述</a></h3>
<p>一种非失败的方式来读取任何类型的环境变量：如果请求的环境键不存在，<code>envOr()</code> 将返回默认值而不是回滚（也适用于数组）。</p>
<p>返回类型由传入的 <code>defaultValue</code> 参数的类型决定。</p>
<h3 id="提示-2"><a class="header" href="#提示-2">提示</a></h3>
<ul>
<li>使用 <code>envOr(key, defaultValue)</code> 来读取单个值</li>
<li>使用 <code>envOr(key, delimiter, defaultValue[])</code> 来读取带有分隔符的数组</li>
<li>环境变量的解析将根据 <code>defaultValue</code> 的类型进行（例如，如果默认值类型是 <code>uint</code>，环境变量也将被解析为 <code>uint</code>）</li>
<li>对字面量使用显式转换来指定默认变量的类型：<code>uint(69)</code> 将返回一个 <code>uint</code>，但 <code>int(69)</code> 将返回一个 <code>int</code></li>
<li>同样适用于：<code>string("")</code> 和 <code>bytes("")</code> - 这些将分别返回 <code>string</code> 和 <code>bytes</code></li>
<li>提供默认值时使用动态数组（<code>bool[]</code>）而不是固定大小的数组（<code>bool[4]</code>）（仅支持动态数组）</li>
</ul>
<h3 id="示例-66"><a class="header" href="#示例-66">示例</a></h3>
<h4 id="单个值"><a class="header" href="#单个值">单个值</a></h4>
<p>如果环境变量 <code>FORK</code> 未设置，可以指定其默认值为 <code>false</code>：</p>
<pre><code class="language-solidity">bool fork = vm.envOr("FORK", false);
</code></pre>
<p>或</p>
<pre><code class="language-solidity">address owner;

function setUp() {
  owner = vm.envOr("OWNER", address(this));
}
</code></pre>
<h4 id="数组"><a class="header" href="#数组">数组</a></h4>
<p>如果环境变量 <code>BAD_TOKENS</code> 未设置，可以指定默认值为空数组：</p>
<pre><code class="language-solidity">address[] badTokens;

function envBadTokens() public {
  badTokens = vm.envOr("BAD_TOKENS", ",", badTokens);
}
</code></pre>
<p>或</p>
<pre><code class="language-solidity">function envBadTokens() public {
  address[] memory defaultBadTokens = new address[](0);
  address[] memory badTokens = vm.envOr("BAD_TOKENS", ",", defaultBadTokens);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="envbool"><a class="header" href="#envbool"><code>envBool</code></a></h2>
<h3 id="签名-56"><a class="header" href="#签名-56">签名</a></h3>
<pre><code class="language-solidity">function envBool(string calldata key) external returns (bool value);
</code></pre>
<pre><code class="language-solidity">function envBool(string calldata key, string calldata delimiter) external returns (bool[] memory values);
</code></pre>
<h3 id="描述-78"><a class="header" href="#描述-78">描述</a></h3>
<p>读取环境变量作为 <code>bool</code> 或 <code>bool[]</code>。</p>
<h3 id="提示-3"><a class="header" href="#提示-3">提示</a></h3>
<ul>
<li>对于 <code>true</code>，使用 “true” 或 “True” 作为环境变量值。</li>
<li>对于 <code>false</code>，使用 “false” 或 “False” 作为环境变量值。</li>
<li>对于数组，可以使用 <code>delimiter</code> 参数指定用于分隔值的分隔符。</li>
</ul>
<h3 id="示例-67"><a class="header" href="#示例-67">示例</a></h3>
<h4 id="单个值-1"><a class="header" href="#单个值-1">单个值</a></h4>
<p>使用环境变量 <code>BOOL_VALUE=true</code>，</p>
<pre><code class="language-solidity">string memory key = "BOOL_VALUE";
bool expected = true;
bool output = cheats.envBool(key);
assert(output == expected);
</code></pre>
<h4 id="数组-1"><a class="header" href="#数组-1">数组</a></h4>
<p>使用环境变量 <code>BOOL_VALUES=true,false,True,False</code>，</p>
<pre><code class="language-solidity">string memory key = "BOOL_VALUES";
string memory delimiter = ",";
bool[4] memory expected = [true, false, true, false];
bool[] memory output = cheats.envBool(key, delimiter);
assert(keccak256(abi.encodePacked((output))) == keccak256(abi.encodePacked((expected))));
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="envuint"><a class="header" href="#envuint"><code>envUint</code></a></h2>
<h3 id="签名-57"><a class="header" href="#签名-57">签名</a></h3>
<pre><code class="language-solidity">function envUint(string calldata key) external returns (uint256 value);
</code></pre>
<pre><code class="language-solidity">function envUint(string calldata key, string calldata delimiter) external returns (uint256[] memory values);
</code></pre>
<h3 id="描述-79"><a class="header" href="#描述-79">描述</a></h3>
<p>读取环境变量作为 <code>uint256</code> 或 <code>uint256[]</code>。</p>
<h3 id="提示-4"><a class="header" href="#提示-4">提示</a></h3>
<ul>
<li>如果值以 <code>0x</code> 开头，它将被解释为十六进制值，否则，它将被视为十进制数。</li>
<li>对于数组，可以使用 <code>delimiter</code> 参数指定用于分隔值的分隔符。</li>
</ul>
<h3 id="示例-68"><a class="header" href="#示例-68">示例</a></h3>
<h4 id="单个值-2"><a class="header" href="#单个值-2">单个值</a></h4>
<p>使用环境变量 <code>UINT_VALUE=115792089237316195423570985008687907853269984665640564039457584007913129639935</code>，</p>
<pre><code class="language-solidity">string memory key = "UINT_VALUE";
uint256 expected = type(uint256).max;
uint256 output = cheats.envUint(key);
assert(output == expected);
</code></pre>
<h4 id="数组-2"><a class="header" href="#数组-2">数组</a></h4>
<p>使用环境变量 <code>UINT_VALUES=0,0x0000000000000000000000000000000000000000000000000000000000000000</code>，</p>
<pre><code class="language-solidity">string memory key = "UINT_VALUES";
string memory delimiter = ",";
uint256[2] memory expected = [type(uint256).min, type(uint256).min];
uint256[] memory output = cheats.envUint(key, delimiter);
assert(keccak256(abi.encodePacked((output))) == keccak256(abi.encodePacked((expected))));
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="envint"><a class="header" href="#envint"><code>envInt</code></a></h2>
<h3 id="签名-58"><a class="header" href="#签名-58">签名</a></h3>
<pre><code class="language-solidity">function envInt(string calldata key) external returns (int256 value);
</code></pre>
<pre><code class="language-solidity">function envInt(string calldata key, string calldata delimiter) external returns (int256[] memory values);
</code></pre>
<h3 id="描述-80"><a class="header" href="#描述-80">描述</a></h3>
<p>读取环境变量作为 <code>int256</code> 或 <code>int256[]</code>。</p>
<h3 id="提示-5"><a class="header" href="#提示-5">提示</a></h3>
<ul>
<li>如果值以 <code>0x</code>、<code>-0x</code> 或 <code>+0x</code> 开头，它将被解释为十六进制值，否则，它将被视为十进制数。</li>
<li>对于数组，可以使用 <code>delimiter</code> 参数指定用于分隔值的分隔符。</li>
</ul>
<h3 id="示例-69"><a class="header" href="#示例-69">示例</a></h3>
<h4 id="单个值-3"><a class="header" href="#单个值-3">单个值</a></h4>
<p>使用环境变量 <code>INT_VALUE=-57896044618658097711785492504343953926634992332820282019728792003956564819968</code>，</p>
<pre><code class="language-solidity">string memory key = "INT_VALUE";
int256 expected = type(int256).min;
int256 output = cheats.envInt(key);
assert(output == expected);
</code></pre>
<h4 id="数组-3"><a class="header" href="#数组-3">数组</a></h4>
<p>使用环境变量 <code>INT_VALUES=-0x8000000000000000000000000000000000000000000000000000000000000000,+0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</code>，</p>
<pre><code class="language-solidity">string memory key = "INT_VALUES";
string memory delimiter = ",";
int256[2] memory expected = [type(int256).min, type(int256).max];
int256[] memory output = cheats.envInt(key, delimiter);
assert(keccak256(abi.encodePacked((output))) == keccak256(abi.encodePacked((expected))));
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="envaddress"><a class="header" href="#envaddress"><code>envAddress</code></a></h2>
<h3 id="签名-59"><a class="header" href="#签名-59">签名</a></h3>
<pre><code class="language-solidity">function envAddress(string calldata key) external returns (address value);
</code></pre>
<pre><code class="language-solidity">function envAddress(string calldata key, string calldata delimiter) external returns (address[] memory values);
</code></pre>
<h3 id="描述-81"><a class="header" href="#描述-81">描述</a></h3>
<p>读取环境变量作为 <code>address</code> 或 <code>address[]</code>。</p>
<h3 id="提示-6"><a class="header" href="#提示-6">提示</a></h3>
<ul>
<li>对于数组，可以使用 <code>delimiter</code> 参数指定用于分隔值的分隔符。</li>
</ul>
<h3 id="示例-70"><a class="header" href="#示例-70">示例</a></h3>
<h4 id="单个值-4"><a class="header" href="#单个值-4">单个值</a></h4>
<p>使用环境变量 <code>ADDRESS_VALUE=0x7109709ECfa91a80626fF3989D68f67F5b1DD12D</code>，</p>
<pre><code class="language-solidity">string memory key = "ADDRESS_VALUE";
address expected = 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D;
address output = vm.envAddress(key);
assert(output == expected);
</code></pre>
<h4 id="数组-4"><a class="header" href="#数组-4">数组</a></h4>
<p>使用环境变量 <code>ADDRESS_VALUES=0x7109709ECfa91a80626fF3989D68f67F5b1DD12D,0x0000000000000000000000000000000000000000</code>，</p>
<pre><code class="language-solidity">string memory key = "ADDRESS_VALUES";
string memory delimiter = ",";
address[2] memory expected = [
    0x7109709ECfa91a80626fF3989D68f67F5b1DD12D,
    0x0000000000000000000000000000000000000000
];
address[] memory output = vm.envAddress(key, delimiter);
assert(keccak256(abi.encodePacked((output))) == keccak256(abi.encodePacked((expected))));
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="envbytes32"><a class="header" href="#envbytes32"><code>envBytes32</code></a></h2>
<h3 id="签名-60"><a class="header" href="#签名-60">签名</a></h3>
<pre><code class="language-solidity">function envBytes32(string calldata key) external returns (bytes32 value);
</code></pre>
<pre><code class="language-solidity">function envBytes32(string calldata key, string calldata delimiter) external returns (bytes32[] memory values);
</code></pre>
<h3 id="描述-82"><a class="header" href="#描述-82">描述</a></h3>
<p>读取环境变量作为 <code>bytes32</code> 或 <code>bytes32[]</code>。</p>
<h3 id="提示-7"><a class="header" href="#提示-7">提示</a></h3>
<ul>
<li>对于数组，可以使用 <code>delimiter</code> 参数指定用于分隔值的分隔符。</li>
</ul>
<h3 id="示例-71"><a class="header" href="#示例-71">示例</a></h3>
<h4 id="单个值-5"><a class="header" href="#单个值-5">单个值</a></h4>
<p>使用环境变量 <code>BYTES32_VALUE=0x00</code>，</p>
<pre><code class="language-solidity">string memory key = "BYTES32_VALUE";
bytes32 expected = bytes32(0x0000000000000000000000000000000000000000000000000000000000000000);
bytes32 output = cheats.envBytes32(key);
assert(output == expected);
</code></pre>
<h4 id="数组-5"><a class="header" href="#数组-5">数组</a></h4>
<p>使用环境变量 <code>BYTES32_VALUES=0x7109709ECfa91a80626fF3989D68f67F5b1DD12D,0x00</code>，</p>
<pre><code class="language-solidity">string memory key = "BYTES32_VALUES";
string memory delimiter = ",";
bytes32[2] memory expected = [
    bytes32(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D000000000000000000000000),
    bytes32(0x0000000000000000000000000000000000000000000000000000000000000000)
];
bytes32[] memory output = cheats.envBytes32(key, delimiter);
assert(keccak256(abi.encodePacked((output))) == keccak256(abi.encodePacked((expected))));
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="envstring"><a class="header" href="#envstring"><code>envString</code></a></h2>
<h3 id="签名-61"><a class="header" href="#签名-61">签名</a></h3>
<pre><code class="language-solidity">function envString(string calldata key) external returns (string value);
</code></pre>
<pre><code class="language-solidity">function envString(string calldata key, string calldata delimiter) external returns (string[] memory values);
</code></pre>
<h3 id="描述-83"><a class="header" href="#描述-83">描述</a></h3>
<p>读取环境变量作为 <code>string</code> 或 <code>string[]</code>。如果环境变量未定义，Forge 将失败并显示以下错误消息：</p>
<blockquote>
<p>[FAIL. 原因：无法将环境变量 <code>FOO</code> 获取为 <code>string</code> 类型：环境变量未找到]</p>
</blockquote>
<h3 id="提示-8"><a class="header" href="#提示-8">提示</a></h3>
<ul>
<li>您可以将环境变量放在 <code>.env</code> 文件中。运行 <code>forge test</code> 时，Forge 会自动加载它们。</li>
<li>对于数组，您可以使用 <code>delimiter</code> 参数指定用于分隔值的分隔符。</li>
<li>选择一个不会出现在字符串值中的分隔符，以便正确分隔它们。</li>
</ul>
<h3 id="示例-72"><a class="header" href="#示例-72">示例</a></h3>
<h4 id="单个值-6"><a class="header" href="#单个值-6">单个值</a></h4>
<p>使用环境变量 <code>STRING_VALUE=hello, world!</code>，</p>
<pre><code class="language-solidity">string memory key = "STRING_VALUE";
string memory expected = "hello, world!";
string memory output = vm.envString(key);
assertEq(output, expected);
</code></pre>
<h4 id="数组-6"><a class="header" href="#数组-6">数组</a></h4>
<p>使用环境变量 <code>STRING_VALUES=hello, world!|0x7109709ECfa91a80626fF3989D68f67F5b1DD12D</code>；</p>
<pre><code class="language-solidity">string memory key = "STRING_VALUES";
string memory delimiter = "|";
string[2] memory expected = [
    "hello, world!",
    "0x7109709ECfa91a80626fF3989D68f67F5b1DD12D"
];
string[] memory output = vm.envString(key, delimiter);
for (uint i = 0; i &lt; expected.length; ++i) {
    assert(keccak256(abi.encodePacked((output[i]))) == keccak256(abi.encodePacked((expected[i]))));
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="envbytes"><a class="header" href="#envbytes"><code>envBytes</code></a></h2>
<h3 id="签名-62"><a class="header" href="#签名-62">签名</a></h3>
<pre><code class="language-solidity">function envBytes(bytes calldata key) external returns (bytes value);
</code></pre>
<pre><code class="language-solidity">function envBytes(bytes calldata key, bytes calldata delimiter) external returns (bytes[] memory values);
</code></pre>
<h3 id="描述-84"><a class="header" href="#描述-84">描述</a></h3>
<p>读取环境变量作为 <code>bytes</code> 或 <code>bytes[]</code>。</p>
<h3 id="提示-9"><a class="header" href="#提示-9">提示</a></h3>
<ul>
<li>对于数组，可以使用 <code>delimiter</code> 参数指定用于分隔值的分隔符。</li>
</ul>
<h3 id="示例-73"><a class="header" href="#示例-73">示例</a></h3>
<h4 id="单个值-7"><a class="header" href="#单个值-7">单个值</a></h4>
<p>使用环境变量 <code>BYTES_VALUE=0x7109709ECfa91a80626fF3989D68f67F5b1DD12D</code>；</p>
<pre><code class="language-solidity">bytes memory key = "BYTES_VALUE";
bytes expected = hex"7109709ECfa91a80626fF3989D68f67F5b1DD12D";
bytes output = cheats.envBytes(key);
assertEq(output, expected);
</code></pre>
<h4 id="数组-7"><a class="header" href="#数组-7">数组</a></h4>
<p>使用环境变量 <code>BYTES_VALUE=0x7109709ECfa91a80626fF3989D68f67F5b1DD12D,0x00</code>；</p>
<pre><code class="language-solidity">bytes memory key = "BYTES_VALUES";
bytes memory delimiter = ",";
bytes[] memory expected = new bytes[](2);
expected[0] = hex"7109709ECfa91a80626fF3989D68f67F5b1DD12D";
expected[1] = hex"00";
bytes[] memory output = cheats.envBytes(key, delimiter);
for (uint i = 0; i &lt; expected.length; ++i) {
    assert(keccak256(abi.encodePacked((output[i]))) == keccak256(abi.encodePacked((expected[i]))));
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="keyexists"><a class="header" href="#keyexists"><code>keyExists</code></a></h2>
<h3 id="状态"><a class="header" href="#状态">状态</a></h3>
<p><code>keyExists</code> 正在被 <code>keyExistsJson</code> 取代，未来版本中将被移除。</p>
<h3 id="签名-63"><a class="header" href="#签名-63">签名</a></h3>
<pre><code class="language-solidity">// 检查 JSON 字符串中是否存在某个键。
vm.keyExists(string memory json, string memory key) returns (bool)
</code></pre>
<h3 id="描述-85"><a class="header" href="#描述-85">描述</a></h3>
<p>检查 JSON 字符串中是否存在某个键。</p>
<h3 id="示例-74"><a class="header" href="#示例-74">示例</a></h3>
<pre><code class="language-solidity">string memory path = "./path/to/jsonfile.json";
string memory json = vm.readFile(path);
bool exists = vm.keyExists(json, ".key");
assertTrue(exists);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="keyexistsjson"><a class="header" href="#keyexistsjson"><code>keyExistsJson</code></a></h2>
<h3 id="签名-64"><a class="header" href="#签名-64">签名</a></h3>
<pre><code class="language-solidity">// 检查 JSON 字符串中是否存在某个键。
vm.keyExistsJson(string memory json, string memory key) returns (bool)
</code></pre>
<h3 id="描述-86"><a class="header" href="#描述-86">描述</a></h3>
<p>检查 JSON 字符串中是否存在某个键。</p>
<h3 id="示例-75"><a class="header" href="#示例-75">示例</a></h3>
<pre><code class="language-solidity">string memory path = "./path/to/jsonfile.json";
string memory json = vm.readFile(path);
bool exists = vm.keyExistsJson(json, ".key");
assertTrue(exists);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="keyexiststoml"><a class="header" href="#keyexiststoml"><code>keyExistsToml</code></a></h2>
<h3 id="签名-65"><a class="header" href="#签名-65">签名</a></h3>
<pre><code class="language-solidity">// 检查一个键是否存在于 TOML 表中。
vm.keyExistsToml(string memory toml, string memory key) returns (bool)
</code></pre>
<h3 id="描述-87"><a class="header" href="#描述-87">描述</a></h3>
<p>检查一个键是否存在于 TOML 表中。</p>
<h3 id="示例-76"><a class="header" href="#示例-76">示例</a></h3>
<pre><code class="language-solidity">string memory path = "./path/to/tomlfile.toml";
string memory toml = vm.readFile(path);
bool exists = vm.keyExistsToml(toml, ".key");
assertTrue(exists);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="parsejson"><a class="header" href="#parsejson"><code>parseJson</code></a></h2>
<h3 id="签名-66"><a class="header" href="#签名-66">签名</a></h3>
<pre><code class="language-solidity">// 返回与'key'对应的值
vm.parseJson(string memory json, string memory key)
// 返回整个JSON文件
vm.parseJson(string memory json);
</code></pre>
<h3 id="描述-88"><a class="header" href="#描述-88">描述</a></h3>
<p>这些作弊码用于解析字符串形式的JSON文件。通常，它会与返回整个文件字符串的<code>vm.readFile()</code>结合使用。</p>
<p>你可以使用<code>forge-std</code>中的<code>stdJson</code>作为帮助库，以获得更好的用户体验。</p>
<p>作弊码接受一个<code>key</code>来搜索JSON中的特定值，或者不带key以返回整个JSON。它将值作为abi编码的<code>bytes</code>数组返回。这意味着你需要将其<code>abi.decode()</code>为适当的类型才能正常工作，否则它会<code>revert</code>。</p>
<h3 id="jsonpath-key"><a class="header" href="#jsonpath-key">JSONpath Key</a></h3>
<p><code>parseJson</code>使用一种称为JSONpath的语法来形成任意JSON文件的任意key。相同的语法（或更确切地说是一种方言）被工具<a href="https://stedolan.github.io/jq/" title="" target="_blank">
<code>jq</code></a>使用。</p>
<p>要了解更多关于语法的信息，你可以访问我们用于实现该功能的rust库的<a href="https://crates.io/crates/jsonpath-rust" title="" target="_blank">README</a>。这样你可以确保使用的是正确的jsonPath方言。</p>
<h3 id="json编码规则"><a class="header" href="#json编码规则">JSON编码规则</a></h3>
<p>我们使用术语<code>number</code>、<code>string</code>、<code>object</code>、<code>array</code>、<code>boolean</code>、<code>null</code>，因为它们在<a href="https://www.w3schools.com/js/js_json_datatypes.asp" title="" target="_blank">JSON规范</a>中定义。</p>
<p><strong>编码规则</strong></p>
<ul>
<li><code>null</code>编码为<code>bytes32(0)</code></li>
<li>大于等于0的数字编码为<code>uint256</code></li>
<li>负数编码为<code>int256</code></li>
<li>不允许使用带小数位的浮点数。</li>
<li>使用科学计数法的浮点数可以是<code>uint256</code>或<code>int256</code>，取决于值。</li>
<li>可以解码为<code>H160</code>类型且以<code>0x</code>开头的字符串编码为<code>address</code>。换句话说，如果它可以解码为地址，那么它可能是一个地址</li>
<li>以<code>0x</code>开头的字符串，如果长度为<code>66</code>则编码为<code>bytes32</code>，否则编码为<code>bytes</code></li>
<li>既不是<code>address</code>、<code>bytes32</code>也不是<code>bytes</code>的字符串，编码为<code>string</code></li>
<li>数组编码为其第一个元素类型的动态数组</li>
<li>对象（<code>{}</code>）编码为<code>tuple</code></li>
</ul>
<h3 id="类型强制"><a class="header" href="#类型强制">类型强制</a></h3>
<p>如上所述，<code>parseJson</code>需要推断JSON值的类型，这有一些固有的限制。为此，有一组<code>parseJson*</code>作弊码强制返回值的类型。</p>
<p>例如<code>vm.parseJsonUint(json, key)</code>会将值强制转换为<code>uint256</code>。这意味着它可以解析以下所有值并将其作为<code>uint256</code>返回。这包括类型为<code>number</code>的数字、作为<code>string</code>的字符串化数字及其十六进制表示。</p>
<pre><code class="language-json">{
  "hexUint": "0x12C980",
  "stringUint": "115792089237316195423570985008687907853269984665640564039457584007913129639935",
  "numberUint": 115792089237316195423570985008687907853269984665640564039457584007913129639935
}
</code></pre>
<p>同样，有适用于所有类型（包括<code>bytes</code>和<code>bytes32</code>）及其数组（<code>vm.parseJsonUintArray</code>）的作弊码。</p>
<h3 id="将json对象解码为solidity结构体"><a class="header" href="#将json对象解码为solidity结构体">将JSON对象解码为Solidity结构体</a></h3>
<p>JSON对象编码为元组，可以通过元组或结构体解码。这意味着你可以在Solidity中定义一个<code>struct</code>，它将整个JSON对象解码为该<code>struct</code>。</p>
<p>例如：</p>
<p>以下JSON：</p>
<pre><code class="language-json">{
  "a": 43,
  "b": "sigma"
}
</code></pre>
<p>将被解码为：</p>
<pre><code class="language-solidity">struct Json {
    uint256 a;
    string b;
}
</code></pre>
<p>由于值作为abi编码的元组返回，结构体属性的确切名称不需要与JSON中的键名称匹配。上述json文件也可以解码为：</p>
<pre><code class="language-solidity">struct Json {
    uint256 apple;
    string pineapple;
}
</code></pre>
<p>重要的是字母顺序。由于JSON对象是无序的数据结构，而元组是有序的，我们必须以某种方式为JSON赋予顺序。最简单的方法是按字母顺序排序键。这意味着为了正确解码JSON对象，你需要定义结构体的属性<strong>类型</strong>，这些类型对应于JSON键的字母顺序的值。</p>
<ul>
<li>结构体是按顺序解释的。这意味着元组的第一个项目将根据结构体定义的第一个项目解码（不按字母顺序）。</li>
<li>JSON将按字母顺序解析，而不是按顺序。</li>
<li>请注意，此解析使用Rust的BTreeMap crate，这意味着大写和小写字符的处理方式不同。大写字符<em>优先</em>于小写字符，即“Zebra“会优先于“apple“。</li>
</ul>
<p>因此，JSON的第一个（按字母顺序）值将被abi编码，然后根据<code>struct</code>的第一个属性的类型尝试abi解码。</p>
<p>上述JSON无法用以下结构体解码：</p>
<pre><code class="language-solidity">struct Json {
    uint256 b;
    uint256 a;
}
</code></pre>
<p>原因是它会尝试将字符串<code>"sigma"</code>解码为uint。确切地说，它会解码，但会得到一个错误的数字，因为它会错误地解释字节。</p>
<p>另一个例子，给定以下JSON：</p>
<pre><code class="language-json">{
    "apples": [
        {
            "sweetness": 7,
            "sourness": 3,
            "color": "Red"
        },
        {
            "sweetness": 5,
            "sourness": 5,
            "color": "Green"
        },
        {
            "sweetness": 9,
            "sourness": 1,
            "color": "Yellow"
        }
    ],
    "name": "Fresh Fruit"
}
</code></pre>
<p>并定义如下Solidity结构体：</p>
<pre><code class="language-solidity">struct Apple {
    string color;
    uint8 sourness;
    uint8 sweetness;
}

struct FruitStall {
    Apple[] apples;
    string name;
}
</code></pre>
<p>可以如下解码JSON：</p>
<pre><code class="language-solidity">string memory root = vm.projectRoot();
string memory path = string.concat(root, "/src/test/fixtures/fruitstall.json");
string memory json = vm.readFile(path);
bytes memory data = vm.parseJson(json);
FruitStall memory fruitstall = abi.decode(data, (FruitStall));

// 日志: Welcome to Fresh Fruit
console2.log("Welcome to", fruitstall.name);

for (uint256 i = 0; i &lt; fruitstall.apples.length; i++) {
    Apple memory apple = fruitstall.apples[i];

    // 日志:
    // Color: Red, Sourness: 3, Sweetness: 7
    // Color: Green, Sourness: 5, Sweetness: 5
    // Color: Yellow, Sourness: 1, Sweetness: 9
    console2.log(
        "Color: %s, Sourness: %d, Sweetness: %d",
        apple.color,
        apple.sourness,
        apple.sweetness
    );
}
</code></pre>
<h3 id="解码json对象的提示"><a class="header" href="#解码json对象的提示">解码JSON对象的提示</a></h3>
<p>如果你的JSON对象有<code>hex numbers</code>，它们将被编码为字节。为了更好的用户体验，将其解码为<code>uint</code>的方法是定义两个<code>struct</code>，一个中间结构体将这些值定义为<code>bytes</code>，然后是一个最终的<code>struct</code>，供用户使用。</p>
<ol>
<li>将JSON解码为中间<code>struct</code></li>
<li>通过将<code>bytes</code>转换为<code>uint</code>，将中间结构体转换为最终结构体。我们在<code>forge-std</code>中有一个帮助函数来完成这个任务</li>
<li>将最终的<code>struct</code>提供给用户使用</li>
</ol>
<h3 id="如何使用stdjson"><a class="header" href="#如何使用stdjson">如何使用StdJson</a></h3>
<ol>
<li>导入库<code>import "../StdJson.sol";</code></li>
<li>使用<code>string</code>定义其用法：<code>using stdJson for string;</code></li>
<li>如果你想解析简单值（数字、地址等），使用帮助函数</li>
<li>如果你想解析整个JSON对象：
<ol>
<li>在Solidity中定义<code>struct</code>。确保遵循字母顺序——调试起来很困难</li>
<li>使用<code>parseRaw()</code>帮助函数返回abi编码的<code>bytes</code>，然后将其解码为你的结构体</li>
</ol>
</li>
</ol>
<pre><code class="language-solidity">string memory root = vm.projectRoot();
string memory path = string.concat(root, "/src/test/fixtures/broadcast.log.json");
string memory json = vm.readFile(path);
bytes memory transactionDetails = json.parseRaw(".transactions[0].tx");
RawTx1559Detail memory rawTxDetail = abi.decode(transactionDetails, (RawTx1559Detail));
</code></pre>
<h3 id="forge脚本工件"><a class="header" href="#forge脚本工件">Forge脚本工件</a></h3>
<p>我们已经创建了一些帮助结构体和函数来读取广播forge脚本的工件。</p>
<p>目前，我们仅支持由EIP1559兼容链生成的工件，并且<strong>尚未</strong>支持解析整个<code>broadcast.json</code>工件。你需要解析单个值，例如<code>transactions</code>、<code>receipts</code>等。</p>
<p>要读取交易，只需执行以下操作：</p>
<pre><code class="language-solidity">function testReadEIP1559Transactions() public {
    string memory root = vm.projectRoot();
    string memory path = string.concat(root, "/src/test/fixtures/broadcast.log.json");
    Tx1559[] memory transactions = readTx1559s(path);
}
</code></pre>
<p>然后你可以访问这些结构体中的各个字段：</p>
<pre><code class="language-solidity">struct Tx1559 {
    string[] arguments;
    address contractAddress;
    string contractName;
    string functionSig;
    bytes32 hash;
    Tx1559Detail txDetail;
    string opcode;
}

struct Tx1559Detail {
    AccessList[] accessList;
    bytes data;
    address from;
    uint256 gas;
    uint256 nonce;
    address to;
    uint256 txType;
    uint256 value;
}
</code></pre>
<h3 id="故障排除-2"><a class="header" href="#故障排除-2">故障排除</a></h3>
<h4 id="无法读取文件"><a class="header" href="#无法读取文件">无法读取文件</a></h4>
<blockquote>
<p>FAIL. Reason: The path <code>&lt;file-path&gt;</code> is not allowed to be accessed for read operations</p>
</blockquote>
<p>如果你收到此错误，请确保在<code>foundry.toml</code>中使用<a href="cheatcodes/./fs.html"><code>fs_permissions</code>键</a>启用读取权限</p>
<h3 id="参考"><a class="header" href="#参考">参考</a></h3>
<ul>
<li>帮助库: <a href="https://github.com/foundry-rs/forge-std/blob/master/src/StdJson.sol" title="" target="_blank">stdJson.sol</a></li>
<li>使用示例: <a href="https://github.com/foundry-rs/forge-std/blob/ca8d6e00ea9cb035f6856ff732203c9a3c48b966/src/test/StdCheats.t.sol#L206" title="" target="_blank">stdCheats.t.sol</a></li>
<li><a href="cheatcodes/./fs.html">文件作弊码</a>: 用于处理文件的作弊码</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="parsetoml"><a class="header" href="#parsetoml"><code>parseToml</code></a></h2>
<h3 id="签名-67"><a class="header" href="#签名-67">签名</a></h3>
<pre><code class="language-solidity">// 返回与'key'对应的值
vm.parseToml(string memory toml, string memory key)
// 返回整个TOML文件
vm.parseToml(string memory toml);
</code></pre>
<h3 id="描述-89"><a class="header" href="#描述-89">描述</a></h3>
<p>这些作弊码用于解析字符串形式的TOML文件，并将其转换为JSON格式。通常，它与返回整个文件字符串的<code>vm.readFile()</code>结合使用。</p>
<p>你可以使用<code>forge-std</code>中的<code>stdToml</code>作为辅助库，以获得更好的用户体验。</p>
<p>作弊码接受一个<code>key</code>来搜索TOML中的特定值，或者不带key以返回整个TOML。它将值作为abi编码的<code>bytes</code>数组返回。这意味着你需要将其<code>abi.decode()</code>为适当的类型才能正常工作，否则它会<code>revert</code>。</p>
<h3 id="jsonpath-key-1"><a class="header" href="#jsonpath-key-1">JSONpath Key</a></h3>
<p><code>parseToml</code>使用一种称为JSONpath的语法来形成任意JSON文件的任意键。相同的语法（或更确切地说是一种方言）被工具<a href="https://stedolan.github.io/jq/" title="" target="_blank">
<code>jq</code></a>使用。</p>
<p>要了解更多关于语法的信息，你可以访问我们用于实现该功能的rust库的<a href="https://crates.io/crates/jsonpath-rust" title="" target="_blank">README</a>。这样你可以确保使用正确的jsonPath方言。</p>
<h3 id="编码规则"><a class="header" href="#编码规则">编码规则</a></h3>
<p>我们使用术语<code>string</code>、<code>integer</code>、<code>float</code>、<code>boolean</code>、<code>array</code>、<code>datetime</code>、<code>inline-table</code>，因为它们在<a href="https://www.w3schools.io/file/toml-datatypes/" title="" target="_blank">TOML规范</a>中定义。</p>
<p>我们使用术语<code>number</code>、<code>string</code>、<code>object</code>、<code>array</code>、<code>boolean</code>、<code>null</code>，因为它们在<a href="https://www.w3schools.com/js/js_json_datatypes.asp" title="" target="_blank">JSON规范</a>中定义。</p>
<p><strong>TOML编码规则</strong></p>
<ul>
<li><code>float</code>限制为32位（即<code>+1.5</code>）。建议使用字符串以防止精度损失</li>
<li><code>integer</code>限制为64位（即<code>9223372036854775807</code>）。建议使用字符串编码大值</li>
<li>数组值不能有混合类型（即<code>[256, "b"]</code>，只能是<code>[256, 512]</code>或<code>["a", "b"]</code>）</li>
<li><code>datetime</code>在转换时编码为<code>string</code></li>
<li><code>float</code>在转换时编码为<code>number</code></li>
<li><code>integer</code>在转换时编码为<code>number</code></li>
<li><code>inline-table</code>（或<code>table</code>）在转换时编码为<code>object</code></li>
<li><code>null</code>编码为<code>"null"</code>字符串</li>
</ul>
<p><strong>JSON编码规则</strong></p>
<ul>
<li><code>null</code>编码为<code>bytes32(0)</code>或<code>""</code></li>
<li>大于等于0的数字编码为<code>uint256</code></li>
<li>负数编码为<code>int256</code></li>
<li>不允许使用带小数位的浮点数</li>
<li>使用科学计数法的浮点数可以是<code>uint256</code>或<code>int256</code>，取决于值</li>
<li>可以解码为<code>H160</code>类型且以<code>0x</code>开头的字符串编码为<code>address</code>。换句话说，如果它可以解码为地址，它可能就是一个地址</li>
<li>以<code>0x</code>开头的字符串，如果长度为<code>66</code>则编码为<code>bytes32</code>，否则编码为<code>bytes</code></li>
<li>既不是<code>address</code>、<code>bytes32</code>也不是<code>bytes</code>的字符串，编码为<code>string</code></li>
<li>数组编码为其第一个元素类型的动态数组</li>
<li>对象（<code>{}</code>）编码为<code>tuple</code></li>
</ul>
<h3 id="类型强制-1"><a class="header" href="#类型强制-1">类型强制</a></h3>
<p>如上所述，<code>parseToml</code>需要推断TOML值的类型，这有一些固有的限制。因此，有一组<code>parseToml*</code>作弊码强制返回值的类型。</p>
<p>例如<code>vm.parseTomlUint(toml, key)</code>会将值强制转换为<code>uint256</code>。这意味着它可以解析以下所有值并将其返回为<code>uint256</code>。这包括类型为<code>number</code>的数字、类型为<code>string</code>的字符串化数字及其十六进制表示。</p>
<pre><code class="language-toml">hexUint = "0x12C980"
stringUint = "115792089237316195423570985008687907853269984665640564039457584007913129639935"
numberUint = 9223372036854775807 # TOML限制为64位整数
</code></pre>
<p>同样，所有类型（包括<code>bytes</code>和<code>bytes32</code>）及其数组（<code>vm.parseTomlUintArray</code>）都有作弊码。</p>
<h3 id="将toml表解码为solidity结构体"><a class="header" href="#将toml表解码为solidity结构体">将TOML表解码为Solidity结构体</a></h3>
<p>TOML表转换为JSON对象。JSON对象编码为元组，可以通过元组或结构体解码。这意味着你可以在Solidity中定义一个<code>struct</code>，它将整个JSON对象解码为该<code>struct</code>。</p>
<p>例如：</p>
<p>以下TOML：</p>
<pre><code class="language-toml">a = 43
b = "sigma"
</code></pre>
<p>将转换为以下JSON：</p>
<pre><code class="language-json">{
  "a": 43,
  "b": "sigma"
}
</code></pre>
<p>将解码为：</p>
<pre><code class="language-solidity">struct Json {
    uint256 a;
    string b;
}
</code></pre>
<p>由于值作为abi编码的元组返回，结构体的属性名称不需要与JSON中的键名称匹配。上述json文件也可以解码为：</p>
<pre><code class="language-solidity">struct Json {
    uint256 apple;
    string pineapple;
}
</code></pre>
<p>重要的是字母顺序。由于JSON对象是无序数据结构，而元组是有序的，我们必须以某种方式为JSON赋予顺序。最简单的方法是按字母顺序排序键。这意味着为了正确解码JSON对象，你需要定义结构体的属性<strong>类型</strong>，这些类型对应于JSON键的字母顺序的值。</p>
<ul>
<li>结构体按顺序解释。这意味着元组的第一个项目将根据结构体定义的第一个项目解码（不按字母顺序）。</li>
<li>JSON将按字母顺序解析，不按顺序。</li>
<li>注意，这种解析使用Rust的BTreeMap crate，这意味着大写和小写字符串的处理方式不同。大写字符<em>优先</em>于小写字符，即“Zebra“会优先于“apple“。</li>
</ul>
<p>因此，JSON的第一个（按字母顺序）值将进行abi编码，然后尝试根据<code>struct</code>的第一个属性的类型进行abi解码。</p>
<p>上述TOML不能用以下结构体解码：</p>
<pre><code class="language-solidity">struct Json {
    uint256 b;
    uint256 a;
}
</code></pre>
<p>原因是它将尝试将字符串<code>"sigma"</code>解码为uint。确切地说，它会被解码，但会得到一个错误的数字，因为它会错误地解释字节。</p>
<p>另一个例子，给定以下TOML：</p>
<pre><code class="language-toml">name = "Fresh Fruit"

[[apples]]
sweetness = 7
sourness = 3
color = "Red"

[[apples]]
sweetness = 5
sourness = 5
color = "Green"

[[apples]]
sweetness = 9
sourness = 1
color = "Yellow"
</code></pre>
<p>将转换为以下JSON：</p>
<pre><code class="language-json">{
    "apples": [
        {
            "sweetness": 7,
            "sourness": 3,
            "color": "Red"
        },
        {
            "sweetness": 5,
            "sourness": 5,
            "color": "Green"
        },
        {
            "sweetness": 9,
            "sourness": 1,
            "color": "Yellow"
        }
    ],
    "name": "Fresh Fruit"
}
</code></pre>
<p>并定义如下Solidity结构体：</p>
<pre><code class="language-solidity">struct Apple {
    string color;
    uint8 sourness;
    uint8 sweetness;
}

struct FruitStall {
    Apple[] apples;
    string name;
}
</code></pre>
<p>可以如下解码TOML：</p>
<pre><code class="language-solidity">string memory root = vm.projectRoot();
string memory path = string.concat(root, "/src/test/fixtures/fruitstall.toml");
string memory toml = vm.readFile(path);
bytes memory data = vm.parseToml(toml);
FruitStall memory fruitstall = abi.decode(data, (FruitStall));

// 日志: Welcome to Fresh Fruit
console2.log("Welcome to", fruitstall.name);

for (uint256 i = 0; i &lt; fruitstall.apples.length; i++) {
    Apple memory apple = fruitstall.apples[i];

    // 日志:
    // Color: Red, Sourness: 3, Sweetness: 7
    // Color: Green, Sourness: 5, Sweetness: 5
    // Color: Yellow, Sourness: 1, Sweetness: 9
    console2.log(
        "Color: %s, Sourness: %d, Sweetness: %d",
        apple.color,
        apple.sourness,
        apple.sweetness
    );
}
</code></pre>
<h3 id="如何使用stdtoml"><a class="header" href="#如何使用stdtoml">如何使用StdToml</a></h3>
<ol>
<li>导入库<code>import "../StdToml.sol";</code></li>
<li>使用<code>string</code>定义其用法：<code>using stdToml for string;</code></li>
<li>如果你想解析简单值（数字、地址等），使用辅助函数</li>
<li>如果你想解析整个TOML表：
<ol>
<li>在Solidity中定义<code>struct</code>。确保遵循字母顺序——调试起来很困难</li>
<li>使用<code>parseRaw()</code>辅助函数返回abi编码的<code>bytes</code>，然后将其解码为你的结构体</li>
</ol>
</li>
</ol>
<pre><code class="language-solidity">string memory root = vm.projectRoot();
string memory path = string.concat(root, "/src/test/fixtures/config.toml");
string memory toml = vm.readFile(path);
bytes memory data = toml.parseRaw(".");
Config memory config = abi.decode(data, (Config))
</code></pre>
<h3 id="故障排除-3"><a class="header" href="#故障排除-3">故障排除</a></h3>
<h4 id="无法读取文件-1"><a class="header" href="#无法读取文件-1">无法读取文件</a></h4>
<blockquote>
<p>FAIL. 原因: 路径<code>&lt;file-path&gt;</code>不允许进行读取操作</p>
</blockquote>
<p>如果你收到此错误，请确保在<code>foundry.toml</code>中使用<a href="cheatcodes/./fs.html"><code>fs_permissions</code>键</a>启用读取权限</p>
<h3 id="参考-1"><a class="header" href="#参考-1">参考</a></h3>
<ul>
<li>辅助库: <a href="https://github.com/foundry-rs/forge-std/blob/master/src/StdToml.sol" title="" target="_blank">stdToml.sol</a></li>
<li><a href="cheatcodes/./fs.html">文件作弊码</a>: 用于处理文件的作弊码</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="parsejsonkeys"><a class="header" href="#parsejsonkeys"><code>parseJsonKeys</code></a></h2>
<h3 id="签名-68"><a class="header" href="#签名-68">签名</a></h3>
<pre><code class="language-solidity">// 获取 JSON 字符串中存在的键列表
function parseJsonKeys(string calldata json, string calldata key) external pure returns (string[] memory keys);
</code></pre>
<h3 id="描述-90"><a class="header" href="#描述-90">描述</a></h3>
<p>获取 JSON 字符串中存在的键列表。</p>
<h3 id="示例-77"><a class="header" href="#示例-77">示例</a></h3>
<pre><code class="language-solidity">string memory json = '{"key": {"a": 1, "b": 2}}';
string[] memory keys = vm.parseJsonKeys(json, ".key"); // ["a", "b"]
</code></pre>
<pre><code class="language-solidity">string memory json = '{"key": "something"}';
string[] memory keys = vm.parseJsonKeys(json, "$"); // ["key"]
</code></pre>
<pre><code class="language-solidity">string memory json = '{"root_key": [{"a": 1, "b": 2}]}';
string[] memory keys = vm.parseJsonKeys(json, ".root_key.0"); // ["a", "b"]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="parsetomlkeys"><a class="header" href="#parsetomlkeys"><code>parseTomlKeys</code></a></h2>
<h3 id="签名-69"><a class="header" href="#签名-69">签名</a></h3>
<pre><code class="language-solidity">// 获取TOML字符串中存在的键列表
function parseTomlKeys(string calldata toml, string calldata key) external pure returns (string[] memory keys);
</code></pre>
<h3 id="描述-91"><a class="header" href="#描述-91">描述</a></h3>
<p>获取TOML字符串中存在的键列表。</p>
<h3 id="示例-78"><a class="header" href="#示例-78">示例</a></h3>
<pre><code class="language-solidity">// [key]
// a = 1
// b = 2

string memory toml = '[key]\n a = 1\n b = 2';
string[] memory keys = vm.parseTomlKeys(toml, ".key"); // ["a", "b"]
</code></pre>
<pre><code class="language-solidity">// key = "something"

string memory toml = 'key = \"something\"';
string[] memory keys = vm.parseTomlKeys(toml, "$"); // ["key"]
</code></pre>
<pre><code class="language-solidity">// [[root_key]]
// a = 1
// b = 2

string memory toml = '[[root_key]]\n a = 1\n b = 2';
string[] memory keys = vm.parseTomlKeys(toml, ".root_key.0"); // ["a", "b"]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="serializejson"><a class="header" href="#serializejson"><code>serializeJson</code></a></h2>
<h3 id="签名-70"><a class="header" href="#签名-70">签名</a></h3>
<pre><code class="language-solidity">function serializeJson(string calldata objectKey, string calldata value)
    external
    returns (string memory json);

function serializeBool(string calldata objectKey, string calldata valueKey, bool value)
    external
    returns (string memory json);

function serializeUint(string calldata objectKey, string calldata valueKey, uint256 value)
    external
    returns (string memory json);

function serializeInt(string calldata objectKey, string calldata valueKey, int256 value)
    external
    returns (string memory json);

function serializeAddress(string calldata objectKey, string calldata valueKey, address value)
    external
    returns (string memory json);

function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32 value)
    external
    returns (string memory json);

function serializeString(string calldata objectKey, string calldata valueKey, string calldata value)
    external
    returns (string memory json);

function serializeBytes(string calldata objectKey, string calldata valueKey, bytes calldata value)
    external
    returns (string memory json);

function serializeBool(string calldata objectKey, string calldata valueKey, bool[] calldata values)
    external
    returns (string memory json);

function serializeUint(string calldata objectKey, string calldata valueKey, uint256[] calldata values)
    external
    returns (string memory json);

function serializeInt(string calldata objectKey, string calldata valueKey, int256[] calldata values)
    external
    returns (string memory json);

function serializeAddress(string calldata objectKey, string calldata valueKey, address[] calldata values)
    external
    returns (string memory json);

function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32[] calldata values)
    external
    returns (string memory json);

function serializeString(string calldata objectKey, string calldata valueKey, string[] calldata values)
    external
    returns (string memory json);

function serializeBytes(string calldata objectKey, string calldata valueKey, bytes[] calldata values)
    external
    returns (string memory json);
</code></pre>
<h3 id="描述-92"><a class="header" href="#描述-92">描述</a></h3>
<p>将值序列化为字符串化的 JSON 对象。</p>
<h3 id="工作原理"><a class="header" href="#工作原理">工作原理</a></h3>
<p>用户序列化 JSON 文件的值，最后将该对象写入文件。用户需要传递：</p>
<ul>
<li>一个用于 <em>对象</em> 的键，该值应序列化到该对象。这使用户能够并行序列化多个对象</li>
<li>一个用于 <em>值</em> 的键，该键将在 JSON 文件中作为其键</li>
<li>要序列化的值</li>
</ul>
<p><code>serializeJson</code> 函数是一个例外，它只接收一个 <code>objectKey</code> 和一个 JSON 字符串 <code>value</code>。这允许用户序列化现有的 JSON 对象，并直接将其分配给提供的 <code>objectKey</code>。如果 <code>objectKey</code> 已在使用中，则整个序列化的 JSON 将被覆盖。</p>
<p>键不需要是某种特定的形式。它们是 <code>string</code> 类型，以便于直观的人类解释。从语义上讲，它们除了用作键之外并不重要。</p>
<p>作弊码返回正在序列化的 JSON 对象 <strong>到该点为止</strong>。这样用户可以序列化内部 JSON 对象，然后将它们序列化到更大的 JSON 对象中，使用户能够创建任意的 JSON 对象。</p>
<p>最后，用户通过使用 <a href="cheatcodes/./write-json.html">writeJson</a> 将 JSON 对象写入 JSON 文件。
或者，用户可以通过使用 <a href="cheatcodes/./write-toml.html">writeToml</a> 将 JSON 对象写入 TOML 文件。</p>
<p><strong>记住：</strong> 文件路径需要在允许的路径中。更多信息请阅读 <a href="cheatcodes/./fs.html">文件作弊码</a>。</p>
<h3 id="示例-79"><a class="header" href="#示例-79">示例</a></h3>
<p>假设我们要将以下 JSON 写入文件：</p>
<p>{ “boolean”: true, “number”: 342, “object”: { “title”: “finally json serialization” } }</p>
<pre><code class="language-solidity">string memory obj1 = "some key";
vm.serializeBool(obj1, "boolean", true);
vm.serializeUint(obj1, "number", uint256(342));

string memory obj2 = "some other key";
string memory output = vm.serializeString(obj2, "title", "finally json serialization");

// 重要：这之所以有效，是因为 `serializeString` 首先尝试将 `output` 解释为
//   字符串化的 JSON 对象。如果解析失败，则将其视为普通字符串。
//   例如，等于 '{ "ok": "asd" }' 的 `output` 将生成一个对象，但
//   等于 '"ok": "asd" }' 的 `output` 将只生成一个普通字符串。
string memory finalJson = vm.serializeString(obj1, "object", output);

vm.writeJson(finalJson, "./output/example.json");
</code></pre>
<h3 id="另请参阅-22"><a class="header" href="#另请参阅-22">另请参阅</a></h3>
<ul>
<li><a href="cheatcodes/./write-json.html">writeJson</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="writejson"><a class="header" href="#writejson"><code>writeJson</code></a></h2>
<h3 id="签名-71"><a class="header" href="#签名-71">签名</a></h3>
<pre><code class="language-solidity">function writeJson(string calldata json, string calldata path) external;

function writeJson(string calldata json, string calldata path, string calldata valueKey) external;
</code></pre>
<h3 id="描述-93"><a class="header" href="#描述-93">描述</a></h3>
<p>将序列化的 JSON 对象写入文件。</p>
<p>参数 <code>json</code> 必须是一个字符串化的 JSON 对象。例如：</p>
<pre><code class="language-text">{ "boolean": true, "number": 342, "object": { "title": "finally json serialization" } }
</code></pre>
<p>这通常通过 <a href="cheatcodes/./serialize-json.html">serializeJson</a> 构建。</p>
<p>参数 <code>path</code> 是要写入的 JSON 文件的路径。</p>
<p>如果没有提供 <code>valueKey</code>，则 JSON 对象将写入一个新文件。如果文件已存在，它将被覆盖。</p>
<p>如果提供了 <code>valueKey</code>，则文件必须已经存在并且是一个有效的 JSON 文件。该文件中的对象将通过将 <em>JSON 路径</em> <code>valueKey</code> 处的值替换为 JSON 对象 <code>json</code> 来更新。</p>
<p>这对于在不首先解析然后重新序列化文件的情况下替换 JSON 文件中的某些值非常有用。请注意，JSON 路径必须指示现有键，因此这种方式无法添加新键。</p>
<p><strong>记住：</strong> 文件路径 <code>path</code> 需要在允许的路径中。更多信息请阅读 <a href="cheatcodes/./fs.html">File cheatcodes</a>。</p>
<h4 id="json-路径"><a class="header" href="#json-路径">JSON 路径</a></h4>
<p>让我们考虑以下 JSON 对象：</p>
<pre><code class="language-json">{
  "boolean": true,
  "number": 342,
  "obj1": {
    "aNumber": 123,
    "obj2": {
      "aNumber": 123,
      "obj3": {
        "veryDeep": 13371337
      }
    }
  }
}
</code></pre>
<p>根对象总是被假定，因此我们可以通过以点 (<code>.</code>) 开始路径来引用其子对象。例如，<code>.boolean</code>、<code>.number</code> 和 <code>.obj1</code>。
我们可以深入到任意深度：<code>.obj1.aNumber</code> 或 <code>.obj1.obj2.aNumber</code>。
我们甚至可以在子树中搜索键：<code>.obj1..veryDeep</code> 或只是 <code>..veryDeep</code>，因为没有歧义。</p>
<p>请参见示例以查看实际操作。</p>
<h3 id="示例-80"><a class="header" href="#示例-80">示例</a></h3>
<h4 id="一个简单的示例"><a class="header" href="#一个简单的示例">一个简单的示例</a></h4>
<pre><code class="language-solidity">string memory jsonObj = '{ "boolean": true, "number": 342, "myObject": { "title": "finally json serialization" } }';
vm.writeJson(jsonObj, "./output/example.json");

// 将 `myObject` 的值替换为一个新的对象
string memory newJsonObj = '{ "aNumber": 123, "aString": "asd" }';
vm.writeJson(newJsonObj, "./output/example.json", ".myObject");

// 将新对象中的 `aString` 的值替换
vm.writeJson("my new string", "./output/example.json", ".myObject.aString");

// 这里是 example.json 的内容：
// 
// {
//   "boolean": true,
//   "number": 342,
//   "myObject": {
//     "aNumber": 123,
//     "aString": "my new string"
//   }
// }
</code></pre>
<h4 id="一个更复杂的示例"><a class="header" href="#一个更复杂的示例">一个更复杂的示例</a></h4>
<pre><code class="language-solidity">string memory jsonObj = '{ "boolean": true, "number": 342, "obj1": { "foo": "bar" } }';
vm.writeJson(jsonObj, "./output/example2.json");

string memory jsonObj2 = '{ "aNumber": 123, "obj2": {} }';
vm.writeJson(jsonObj2, "./output/example2.json", ".obj1");

string memory jsonObj3 = '{ "aNumber": 123, "obj3": { "veryDeep": 3 } }';
vm.writeJson(jsonObj3, "./output/example2.json", ".obj1.obj2");

// 这里是 example2.json 的内容：
//
// {
//   "boolean": true,
//   "number": 342,
//   "obj1": {
//     "aNumber": 123,
//     "obj2": {
//       "aNumber": 123,
//       "obj3": {
//         "veryDeep": 3
//       }
//     }
//   }
// }

// 注意，在这种情况下，JSON 对象只是值 13371337。
vm.writeJson("13371337", "./output/example2.json", "..veryDeep");

// 这里是最终的 example2.json 内容：
//
// {
//   "boolean": true,
//   "number": 342,
//   "obj1": {
//     "aNumber": 123,
//     "obj2": {
//       "aNumber": 123,
//       "obj3": {
//         "veryDeep": 13371337
//       }
//     }
//   }
// }
</code></pre>
<h3 id="另请参阅-23"><a class="header" href="#另请参阅-23">另请参阅</a></h3>
<ul>
<li><a href="cheatcodes/./serialize-json.html">serializeJson</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="writetoml"><a class="header" href="#writetoml"><code>writeToml</code></a></h2>
<h3 id="签名-72"><a class="header" href="#签名-72">签名</a></h3>
<pre><code class="language-solidity">function writeToml(string calldata json, string calldata path) external;

function writeToml(string calldata json, string calldata path, string calldata valueKey) external;
</code></pre>
<h3 id="描述-94"><a class="header" href="#描述-94">描述</a></h3>
<p>将序列化的 JSON 对象转换后写入 TOML 文件。</p>
<p>参数 <code>json</code> 必须是一个字符串化的 JSON 对象。例如：</p>
<pre><code class="language-text">{ "boolean": true, "number": 342, "object": { "title": "finally json serialization" } }
</code></pre>
<p>这通常通过 <a href="cheatcodes/./serialize-json.html">serializeJson</a> 构建。</p>
<p>参数 <code>path</code> 是要写入的 TOML 文件的路径。</p>
<p>如果没有提供 <code>valueKey</code>，则会将 TOML 对象写入一个新文件。如果文件已存在，它将被覆盖。</p>
<p>如果提供了 <code>valueKey</code>，则文件必须已经存在并且是一个有效的 TOML 文件。该文件中的对象将通过将 <em>JSON 路径</em> <code>valueKey</code> 处的值替换为 JSON 对象 <code>json</code> 转换后的值来更新。</p>
<p>这对于在不先解析然后重新序列化文件的情况下替换 TOML 文件中的某些值非常有用。请注意，TOML 路径必须指示一个现有键，因此无法通过这种方式添加新键。</p>
<p><strong>记住：</strong> 文件路径 <code>path</code> 需要在允许的路径中。更多信息请阅读 <a href="cheatcodes/./fs.html">File cheatcodes</a>。</p>
<h4 id="json-路径-1"><a class="header" href="#json-路径-1">JSON 路径</a></h4>
<p>让我们考虑以下 JSON 对象：</p>
<pre><code class="language-json">{
  "boolean": true,
  "number": 342,
  "obj1": {
    "aNumber": 123,
    "obj2": {
      "aNumber": 123,
      "obj3": {
        "veryDeep": 13371337
      }
    }
  }
}
</code></pre>
<p>根对象总是被假定，因此我们可以通过以点 (<code>.</code>) 开始路径来引用其子对象。例如，<code>.boolean</code>、<code>.number</code> 和 <code>.obj1</code>。
我们可以深入到任意深度：<code>.obj1.aNumber</code> 或 <code>.obj1.obj2.aNumber</code>。
我们甚至可以在子树中搜索键：<code>.obj1..veryDeep</code> 或只是 <code>..veryDeep</code>，因为没有歧义。</p>
<p>请参见示例以查看实际操作。</p>
<h3 id="示例-81"><a class="header" href="#示例-81">示例</a></h3>
<h4 id="一个简单的示例-1"><a class="header" href="#一个简单的示例-1">一个简单的示例</a></h4>
<pre><code class="language-solidity">string memory jsonObj = '{ "boolean": true, "number": 342, "myObject": { "title": "finally json serialization" } }';
vm.writeToml(jsonObj, "./output/example.toml");

// 将 `myObject` 的值替换为一个新的对象
string memory newJsonObj = '{ "aNumber": 123, "aString": "asd" }';
vm.writeToml(newJsonObj, "./output/example.toml", ".myObject");

// 将新对象中的 `aString` 的值替换
vm.writeToml("my new string", "./output/example.toml", ".myObject.aString");

// 这里是 example.toml 的内容：
// 
// boolean = true
// number = 342

// [myObject]
// aNumber = 123
// aString = "my new string"
</code></pre>
<h4 id="一个更复杂的示例-1"><a class="header" href="#一个更复杂的示例-1">一个更复杂的示例</a></h4>
<pre><code class="language-solidity">string memory jsonObj = '{ "boolean": true, "number": 342, "obj1": { "foo": "bar" } }';
vm.writeToml(jsonObj, "./output/example2.toml");

string memory jsonObj2 = '{ "aNumber": 123, "obj2": {} }';
vm.writeToml(jsonObj2, "./output/example2.toml", ".obj1");

string memory jsonObj3 = '{ "aNumber": 123, "obj3": { "veryDeep": 3 } }';
vm.writeToml(jsonObj3, "./output/example2.toml", ".obj1.obj2");

// 这里是 example2.toml 的内容：
//
// boolean = true
// number = 342
//
// [obj1]
// aNumber = 123
//
// [obj1.obj2]
// aNumber = 123
//
// [obj1.obj2.obj3]
// veryDeep = 3

// 注意在这种情况下，JSON 对象只是值 13371337。
vm.writeToml("13371337", "./output/example2.toml", "..veryDeep");

// 这里是最终的 example2.toml 内容：
//
// boolean = true
// number = 342
//
// [obj1]
// aNumber = 123
//
// [obj1.obj2]
// aNumber = 123
//
// [obj1.obj2.obj3]
// veryDeep = 13371337
</code></pre>
<h3 id="参见-15"><a class="header" href="#参见-15">参见</a></h3>
<ul>
<li><a href="cheatcodes/./serialize-json.html">serializeJson</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="工具"><a class="header" href="#工具">工具</a></h2>
<ul>
<li><a href="cheatcodes/./addr.html"><code>addr</code></a></li>
<li><a href="cheatcodes/./sign.html"><code>sign</code></a></li>
<li><a href="cheatcodes/./label.html"><code>label</code></a></li>
<li><a href="cheatcodes/./get-label.html"><code>getLabel</code></a></li>
<li><a href="cheatcodes/./derive-key.html"><code>deriveKey</code></a></li>
<li><a href="cheatcodes/./remember-key.html"><code>rememberKey</code></a></li>
<li><a href="cheatcodes/./to-string.html"><code>toString</code></a></li>
<li><a href="cheatcodes/./breakpoint.html"><code>breakpoint</code></a></li>
<li><a href="cheatcodes/./create-wallet.html"><code>createWallet</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="addr"><a class="header" href="#addr"><code>addr</code></a></h2>
<h3 id="签名-73"><a class="header" href="#签名-73">签名</a></h3>
<pre><code class="language-solidity">function addr(uint256 privateKey) external returns (address);
</code></pre>
<h3 id="描述-95"><a class="header" href="#描述-95">描述</a></h3>
<p>计算给定私钥的地址。</p>
<h3 id="示例-82"><a class="header" href="#示例-82">示例</a></h3>
<pre><code class="language-solidity">address alice = vm.addr(1);
emit log_address(alice); // 0x7e5f4552091a69125d5dfcb7b8c2659029395bdf
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="sign"><a class="header" href="#sign"><code>sign</code></a></h2>
<h3 id="签名-74"><a class="header" href="#签名-74">签名</a></h3>
<pre><code class="language-solidity">function sign(uint256 privateKey, bytes32 digest) external returns (uint8 v, bytes32 r, bytes32 s);
</code></pre>
<pre><code class="language-solidity">function sign(Wallet memory wallet, bytes32 digest) external returns (uint8 v, bytes32 r, bytes32 s);
</code></pre>
<h3 id="描述-96"><a class="header" href="#描述-96">描述</a></h3>
<p>使用私钥 <code>privateKey</code> 或 <a href="cheatcodes/./create-wallet.html">Wallet</a> <code>wallet</code> 对摘要 <code>digest</code> 进行签名，返回 <code>(v, r, s)</code>。</p>
<p>这对于测试需要签名数据并执行 <code>ecrecover</code> 以验证签名者的函数非常有用。</p>
<h3 id="示例-83"><a class="header" href="#示例-83">示例</a></h3>
<pre><code class="language-solidity">(address alice, uint256 alicePk) = makeAddrAndKey("alice");
emit log_address(alice);
bytes32 hash = keccak256("Signed by Alice");
(uint8 v, bytes32 r, bytes32 s) = vm.sign(alicePk, hash);
address signer = ecrecover(hash, v, r, s);
assertEq(alice, signer); // [PASS]
</code></pre>
<p>这对于测试需要签名的函数非常有用：</p>
<pre><code class="language-solidity">// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.17;

import { ECDSA } from "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";

contract SigningExample is Ownable {
    using ECDSA for bytes32;

    address public systemAddress;

    function setSystemAddress(address _address) external onlyOwner {
        systemAddress = _address;
    }

    function purchase(uint256 _amount, string calldata _nonce, bytes calldata _signature) external payable {
        require(isValidSignature(
            systemAddress,
            keccak256(abi.encodePacked(msg.sender, _amount, _nonce)),
            _signature
            ), "Invalid Signature"
        );

        // mint tokens
    }

    function isValidSignature(address _systemAddress, bytes32 hash, bytes memory signature) internal view returns (bool) {
        require(_systemAddress != address(0), "Missing System Address");

        bytes32 signedHash = hash.toEthSignedMessageHash();
        return signedHash.recover(signature) == _systemAddress;
    }

}

contract SigningExampleTest is Test {
    using ECDSA for bytes32;

    SigningExample public signingExample;

    uint256 internal userPrivateKey;
    uint256 internal signerPrivateKey;

    function setUp() public {
        signingExample = new SigningExample();

        userPrivateKey = 0xa11ce;
        signerPrivateKey = 0xabc123;

        address signer = vm.addr(signerPrivateKey);
        signingExample.setSystemAddress(signer);
    }

    function testPurchase() public {
        address user = vm.addr(userPrivateKey);
        address signer = vm.addr(signerPrivateKey);

        uint256 amount = 2;
        string memory nonce = 'QSfd8gQE4WYzO29';

        vm.startPrank(signer);
        bytes32 digest = keccak256(abi.encodePacked(user, amount, nonce)).toEthSignedMessageHash();
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(signerPrivateKey, digest);
        bytes memory signature = abi.encodePacked(r, s, v); // note the order here is different from line above.
        vm.stopPrank();

        vm.startPrank(user);
        // Give the user some ETH, just for good measure
        vm.deal(user, 1 ether);

        signingExample.purchase(
            amount,
            nonce,
            signature
        );
        vm.stopPrank();
    }
}
</code></pre>
<h4 id="wallet-1"><a class="header" href="#wallet-1"><code>Wallet</code></a></h4>
<p>Wallet 重载是一个简单的包装器，使用钱包的私钥对摘要进行签名</p>
<pre><code class="language-solidity">Wallet memory alice = vm.createWallet("alice");
bytes32 hash = keccak256("Signed by Alice");
(uint8 v, bytes32 r, bytes32 s) = vm.sign(alice, hash);
address signer = ecrecover(hash, v, r, s);
assertEq(alice.addr, signer); // [PASS]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="skip"><a class="header" href="#skip"><code>skip</code></a></h2>
<h2 id="签名-75"><a class="header" href="#签名-75">签名</a></h2>
<pre><code class="language-solidity">function skip(bool skip) external;
</code></pre>
<h2 id="描述-97"><a class="header" href="#描述-97">描述</a></h2>
<p>将测试标记为跳过，条件性地。必须在测试的顶部调用它，以确保在没有任何执行的情况下跳过测试。</p>
<p>如果 <code>skip</code> 被调用时传入一个 false 布尔值，它将不会跳过测试。</p>
<p>标记为跳过的测试将在测试运行器和摘要中显示 <code>[SKIPPED]</code> 标签，以便轻松识别跳过的测试。</p>
<h3 id="示例-84"><a class="header" href="#示例-84">示例</a></h3>
<pre><code class="language-solidity">
function testSkip() public {
    vm.skip(true);
    /// 这个 revert 不会被触发，因为这个测试将被跳过。
    revert("Should not reach this revert");
}

function testNotSkip() public {
    vm.skip(false);
    /// 这个 revert 将被触发，因为这个测试不会被跳过，并且测试将失败。
    revert("Should reach this revert");
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="label"><a class="header" href="#label"><code>label</code></a></h2>
<h3 id="签名-76"><a class="header" href="#签名-76">签名</a></h3>
<pre><code class="language-solidity">function label(address addr, string calldata label) external;
</code></pre>
<h3 id="描述-98"><a class="header" href="#描述-98">描述</a></h3>
<p>为 <code>addr</code> 设置一个标签 <code>label</code>，该标签将显示在测试跟踪中。</p>
<p>如果一个地址被标记了，标签将显示在测试跟踪中，而不是地址本身。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="getlabel"><a class="header" href="#getlabel"><code>getLabel</code></a></h2>
<h3 id="签名-77"><a class="header" href="#签名-77">签名</a></h3>
<pre><code class="language-solidity">function getLabel(address) external returns (string memory);
</code></pre>
<h3 id="描述-99"><a class="header" href="#描述-99">描述</a></h3>
<p>如果之前已经标记了地址，则检索该地址的标签。如果没有标记，则返回前缀为 <code>unlabeled:</code> 的地址。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="derivekey"><a class="header" href="#derivekey"><code>deriveKey</code></a></h2>
<h3 id="签名-78"><a class="header" href="#签名-78">签名</a></h3>
<pre><code class="language-solidity">function deriveKey(
  string calldata mnemonic,
  uint32 index
) external returns (uint256);
</code></pre>
<pre><code class="language-solidity">function deriveKey(
  string calldata mnemonic,
  string calldata path,
  uint32 index
) external returns (uint256);
</code></pre>
<h3 id="描述-100"><a class="header" href="#描述-100">描述</a></h3>
<p>从给定的助记词或助记词文件路径派生私钥。</p>
<p>第一个签名在派生路径 <code>m/44'/60'/0'/0/{index}</code> 下派生。
第二个签名允许你将派生路径指定为第二个参数。</p>
<h3 id="示例-85"><a class="header" href="#示例-85">示例</a></h3>
<p>从测试助记词在路径 <code>m/44'/60'/0'/0/0</code> 下派生私钥：</p>
<pre><code class="language-solidity">string memory mnemonic = "test test test test test test test test test test test junk";
uint256 privateKey = vm.deriveKey(mnemonic, 0);
</code></pre>
<p>从测试助记词在路径 <code>m/44'/60'/0'/1/0</code> 下派生私钥：</p>
<pre><code class="language-solidity">string memory mnemonic = "test test test test test test test test test test test junk";
uint256 privateKey = vm.deriveKey(mnemonic, "m/44'/60'/0'/1/", 0);
</code></pre>
<h3 id="另请参阅-24"><a class="header" href="#另请参阅-24">另请参阅</a></h3>
<ul>
<li><a href="cheatcodes/./remember-key.html">rememberKey</a></li>
</ul>
<p>Forge 标准库：</p>
<ul>
<li><a href="cheatcodes/../reference/forge-std/derive-remember-key.html">deriveRememberKey</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="parsebytes"><a class="header" href="#parsebytes"><code>parseBytes</code></a></h2>
<h3 id="签名-79"><a class="header" href="#签名-79">签名</a></h3>
<pre><code class="language-solidity">function parseBytes(string calldata stringifiedValue) external pure returns (bytes memory parsedValue);
</code></pre>
<h3 id="描述-101"><a class="header" href="#描述-101">描述</a></h3>
<p>将 <code>string</code> 类型的值解析为 <code>bytes</code> 类型。</p>
<h3 id="示例-86"><a class="header" href="#示例-86">示例</a></h3>
<pre><code class="language-solidity">string memory bytesAsString = "0x00000000000000000000000000000000";
bytes memory stringToBytes = vm.parseBytes(bytesAsString); // 0x00000000000000000000000000000000
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="parseaddress"><a class="header" href="#parseaddress"><code>parseAddress</code></a></h2>
<h3 id="签名-80"><a class="header" href="#签名-80">签名</a></h3>
<pre><code class="language-solidity">function parseAddress(string calldata stringifiedValue) external pure returns (address parsedValue);
</code></pre>
<h3 id="描述-102"><a class="header" href="#描述-102">描述</a></h3>
<p>将 <code>string</code> 类型的值解析为 <code>address</code> 类型。</p>
<h3 id="示例-87"><a class="header" href="#示例-87">示例</a></h3>
<pre><code class="language-solidity">string memory addressAsString = "0x0000000000000000000000000000000000000000";
address stringToAddress = vm.parseAddress(addressAsString); // 0x0000000000000000000000000000000000000000
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="parseuint"><a class="header" href="#parseuint"><code>parseUint</code></a></h2>
<h3 id="签名-81"><a class="header" href="#签名-81">签名</a></h3>
<pre><code class="language-solidity">function parseUint(string calldata stringifiedValue) external pure returns (uint256 parsedValue);
</code></pre>
<h3 id="描述-103"><a class="header" href="#描述-103">描述</a></h3>
<p>将 <code>string</code> 类型的值解析为 <code>uint256</code> 类型。</p>
<h3 id="示例-88"><a class="header" href="#示例-88">示例</a></h3>
<pre><code class="language-solidity">string memory uintAsString = "12345";
uint256 stringToUint = vm.parseUint(uintAsString); // 12345
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="parseint"><a class="header" href="#parseint"><code>parseInt</code></a></h2>
<h3 id="签名-82"><a class="header" href="#签名-82">签名</a></h3>
<pre><code class="language-solidity">function parseInt(string calldata stringifiedValue) external pure returns (int256 parsedValue);
</code></pre>
<h3 id="描述-104"><a class="header" href="#描述-104">描述</a></h3>
<p>将 <code>string</code> 类型的值解析为 <code>int256</code> 类型。</p>
<h3 id="示例-89"><a class="header" href="#示例-89">示例</a></h3>
<pre><code class="language-solidity">string memory intAsString = "-12345";
int256 stringToInt = vm.parseInt(intAsString); // -12345
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="parsebytes32"><a class="header" href="#parsebytes32"><code>parseBytes32</code></a></h2>
<h3 id="签名-83"><a class="header" href="#签名-83">签名</a></h3>
<pre><code class="language-solidity">function parseBytes32(string calldata stringifiedValue) external pure returns (bytes32 parsedValue);
</code></pre>
<h3 id="描述-105"><a class="header" href="#描述-105">描述</a></h3>
<p>将 <code>string</code> 类型的值解析为 <code>bytes32</code> 类型。</p>
<h3 id="示例-90"><a class="header" href="#示例-90">示例</a></h3>
<pre><code class="language-solidity">string memory bytes32AsString = "0x0000000000000000000000000000000000000000000000000000000000000000";
bytes32 stringToBytes32 = vm.parseBytes32(bytes32AsString); // 0x0000000000000000000000000000000000000000000000000000000000000000
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="parsebool"><a class="header" href="#parsebool"><code>parseBool</code></a></h2>
<h3 id="签名-84"><a class="header" href="#签名-84">签名</a></h3>
<pre><code class="language-solidity">function parseBool(string calldata stringifiedValue) external pure returns (bool parsedValue);
</code></pre>
<h3 id="描述-106"><a class="header" href="#描述-106">描述</a></h3>
<p>将 <code>string</code> 类型的值解析为 <code>bool</code> 类型。</p>
<h3 id="示例-91"><a class="header" href="#示例-91">示例</a></h3>
<pre><code class="language-solidity">string memory boolAsString = "false";
bool stringToBool = vm.parseBool(boolAsString); // false
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="rememberkey"><a class="header" href="#rememberkey"><code>rememberKey</code></a></h2>
<h3 id="签名-85"><a class="header" href="#签名-85">签名</a></h3>
<pre><code class="language-solidity">function rememberKey(uint256 privateKey) external returns (address);
</code></pre>
<h3 id="描述-107"><a class="header" href="#描述-107">描述</a></h3>
<p>将私钥存储在 forge 的本地钱包中，并返回相应的地址，该地址稍后可用于<a href="cheatcodes/./broadcast.html">广播</a>。</p>
<h3 id="示例-92"><a class="header" href="#示例-92">示例</a></h3>
<p>从测试助记词路径 <code>m/44'/60'/0'/0/0</code> 派生私钥，将其存储在 forge 的钱包中，并使用它开始广播交易：</p>
<pre><code class="language-solidity">string memory mnemonic = "test test test test test test test test test test test junk";
uint256 privateKey = vm.deriveKey(mnemonic, 0);
address deployer = vm.rememberKey(privateKey);

vm.startBroadcast(deployer);
...
vm.stopBroadcast();
</code></pre>
<p>从 <code>PRIVATE_KEY</code> 环境变量加载私钥，并使用它开始广播交易：</p>
<pre><code class="language-solidity">address deployer = vm.rememberKey(vm.envUint("PRIVATE_KEY"));

vm.startBroadcast(deployer);
...
vm.stopBroadcast();
</code></pre>
<h3 id="参见-16"><a class="header" href="#参见-16">参见</a></h3>
<ul>
<li><a href="cheatcodes/./derive-key.html">deriveKey</a></li>
</ul>
<p>Forge 标准库：</p>
<ul>
<li><a href="cheatcodes/../reference/forge-std/derive-remember-key.html">deriveRememberKey</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="tostring"><a class="header" href="#tostring"><code>toString</code></a></h2>
<h3 id="签名-86"><a class="header" href="#签名-86">签名</a></h3>
<pre><code class="language-solidity">function toString(address) external returns (string memory);
function toString(bool) external returns (string memory);
function toString(uint256) external returns (string memory);
function toString(int256) external returns (string memory);
function toString(bytes32) external returns (string memory);
function toString(bytes) external returns (string memory);
</code></pre>
<h3 id="描述-108"><a class="header" href="#描述-108">描述</a></h3>
<p>将任何类型转换为其字符串版本。对于需要字符串的操作非常有用，例如 cheatcode <code>ffi</code>。</p>
<p>字节被转换为以 <code>0x</code> 开头的十六进制表示字符串，表示它们以十六进制编码。</p>
<h3 id="示例-93"><a class="header" href="#示例-93">示例</a></h3>
<pre><code class="language-solidity">uint256 number = 420;
string memory stringNumber = vm.toString(number);
vm.assertEq(stringNumber, "420");
</code></pre>
<pre><code class="language-solidity">bytes memory testBytes = hex"7109709ECfa91a80626fF3989D68f67F5b1DD12D";
string memory stringBytes = cheats.toString(testBytes);
assertEq("0x7109709ecfa91a80626ff3989d68f67f5b1dd12d", stringBytes);
</code></pre>
<pre><code class="language-solidity">address testAddress =  0x7109709ECfa91a80626fF3989D68f67F5b1DD12D;
string memory stringAddress = cheats.toString(testAddress);
assertEq("0x7109709ECfa91a80626fF3989D68f67F5b1DD12D", stringAddress);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="breakpoint"><a class="header" href="#breakpoint"><code>breakpoint</code></a></h2>
<h3 id="签名-87"><a class="header" href="#签名-87">签名</a></h3>
<pre><code class="language-solidity">function breakpoint(string) external;
function breakpoint(string, bool) external;
</code></pre>
<h3 id="描述-109"><a class="header" href="#描述-109">描述</a></h3>
<p>在调试器视图中放置一个断点以跳转。</p>
<p>调用 <code>vm.breakpoint('&lt;char&gt;, true)</code> 等同于 <code>vm.breakpoint('&lt;char&gt;)</code>，但调用 <code>vm.breakpoint('&lt;char&gt;, false)</code> 将删除 <code>'&lt;char&gt;</code> 处的断点。</p>
<p>如果字符被覆盖，只有最后访问的那个断点会被考虑。</p>
<h3 id="示例-94"><a class="header" href="#示例-94">示例</a></h3>
<pre><code class="language-solidity">function testBreakpoint() public {
    vm.breakpoint("a");
}
</code></pre>
<p>在测试环境中打开调试器并按下 <code>'a</code> 后，调试器步骤将放置在调用断点作弊码的地方。</p>
<p><img src="cheatcodes/../images/breakpoint.png" alt="breakpoint a" /></p>
<h3 id="另请参阅-25"><a class="header" href="#另请参阅-25">另请参阅</a></h3>
<p><a href="cheatcodes/../forge/debugger.html">debugger</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="createwallet"><a class="header" href="#createwallet"><code>createWallet</code></a></h2>
<h3 id="签名-88"><a class="header" href="#签名-88">签名</a></h3>
<pre><code class="language-solidity">  struct Wallet {
      address addr;
      uint256 publicKeyX;
      uint256 publicKeyY;
      uint256 privateKey;
  }
</code></pre>
<pre><code class="language-solidity">  function createWallet(string calldata) external returns (Wallet memory);
</code></pre>
<pre><code class="language-solidity">  function createWallet(uint256) external returns (Wallet memory);
</code></pre>
<pre><code class="language-solidity">  function createWallet(uint256, string calldata) external returns (Wallet memory);
</code></pre>
<h3 id="描述-110"><a class="header" href="#描述-110">描述</a></h3>
<p>在给定一个参数来派生私钥时，创建一个新的 Wallet 结构体。</p>
<h3 id="提示-10"><a class="header" href="#提示-10">提示</a></h3>
<p><a href="cheatcodes/./sign.html"><code>sign()</code></a> 和 <a href="cheatcodes/./get-nonce.html"><code>getNonce()</code></a> 也都支持 Wallet 结构体的函数重载。</p>
<h3 id="示例-95"><a class="header" href="#示例-95">示例</a></h3>
<h4 id="uint256"><a class="header" href="#uint256"><code>uint256</code></a></h4>
<pre><code class="language-solidity">Wallet memory wallet = vm.createWallet(uint256(keccak256(bytes("1"))));

emit log_uint(wallet.privateKey); // uint256(keccak256(bytes("1")))

emit log_address(wallet.addr); // vm.addr(wallet.privateKey)

emit log_address(
    address(
        uint160(
            uint256(
                keccak256(abi.encode(wallet.publicKeyX, wallet.publicKeyY))
            )
        )
    )
); // wallet.addr

emit log_string(vm.getLabel(wallet.addr)); // ""
</code></pre>
<h4 id="string"><a class="header" href="#string"><code>string</code></a></h4>
<pre><code class="language-solidity">Wallet memory wallet = vm.createWallet("bob's wallet");

emit log_uint(wallet.privateKey); // uint256(keccak256(bytes("bob's wallet")))

emit log_address(wallet.addr); // vm.addr(wallet.privateKey)

emit log_address(
    address(
        uint160(
            uint256(
                keccak256(abi.encode(wallet.publicKeyX, wallet.publicKeyY))
            )
        )
    )
); // wallet.addr

emit log_string(vm.getLabel(wallet.addr)); // "bob's wallet"
</code></pre>
<h4 id="uint256-和-string"><a class="header" href="#uint256-和-string"><code>uint256</code> 和 <code>string</code></a></h4>
<pre><code class="language-solidity">Wallet memory wallet = vm.createWallet(uint256(keccak256(bytes("1"))), "bob's wallet");

emit log_uint(wallet.privateKey); // uint256(keccak256(bytes("1")))

emit log_address(wallet.addr); // vm.addr(wallet.privateKey)

emit log_address(
    address(
        uint160(
            uint256(
                keccak256(abi.encode(wallet.publicKeyX, wallet.publicKeyY))
            )
        )
    )
); // wallet.addr

emit log_string(vm.getLabel(wallet.addr)); // "bob's wallet"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="快照作弊码"><a class="header" href="#快照作弊码">快照作弊码</a></h2>
<h3 id="签名-89"><a class="header" href="#签名-89">签名</a></h3>
<pre><code class="language-solidity">// 快照当前的 EVM 状态。
// 返回创建的快照的 ID。
// 要恢复快照，请使用 `revertTo`
function snapshot() external returns(uint256);
// 将 EVM 状态恢复到之前的快照
// 接受要恢复的快照 ID。
// 这将删除该快照以及在该快照之后创建的所有快照。
function revertTo(uint256) external returns(bool);
</code></pre>
<h3 id="描述-111"><a class="header" href="#描述-111">描述</a></h3>
<p><code>snapshot</code> 对区块链的状态进行快照，并返回创建的快照的标识符。</p>
<p><code>revertTo</code> 将区块链的状态恢复到给定的快照。这将删除给定的快照，以及在该快照之后创建的所有快照（例如：恢复到 ID 为 2 的快照将删除 ID 为 2、3、4 等的快照）。</p>
<h3 id="示例-96"><a class="header" href="#示例-96">示例</a></h3>
<pre><code class="language-solidity">struct Storage {
    uint slot0;
    uint slot1;
}

contract SnapshotTest is Test {
    Storage store;
    uint256 timestamp;

    function setUp() public {
        store.slot0 = 10;
        store.slot1 = 20;
        vm.deal(address(this), 5 ether);        // 余额 = 5 ether
        timestamp = block.timestamp;
    }

    function testSnapshot() public {
        uint256 snapshot = vm.snapshot();       // 保存状态

        // 让我们改变状态
        store.slot0 = 300;
        store.slot1 = 400;
        vm.deal(address(this), 500 ether);
        vm.warp(12345);                         // block.timestamp = 12345

        assertEq(store.slot0, 300);
        assertEq(store.slot1, 400);
        assertEq(address(this).balance, 500 ether);
        assertEq(block.timestamp, 12345);

        vm.revertTo(snapshot);                  // 恢复状态

        assertEq(store.slot0, 10, "slot 0 的快照恢复不成功");
        assertEq(store.slot1, 20, "slot 1 的快照恢复不成功");
        assertEq(address(this).balance, 5 ether, "余额的快照恢复不成功");
        assertEq(block.timestamp, timestamp, "时间戳的快照恢复不成功");
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="rpc-相关的作弊码"><a class="header" href="#rpc-相关的作弊码">RPC 相关的作弊码</a></h2>
<h3 id="签名-90"><a class="header" href="#签名-90">签名</a></h3>
<pre><code class="language-solidity">// 返回配置别名的 URL
function rpcUrl(string calldata alias) external returns (string memory);
// 返回所有配置的 (别名, URL) 对
function rpcUrls() external returns(string[2][] memory);
/// 使用配置的分叉 URL 执行 Ethereum JSON-RPC 请求。
function rpc(string calldata method, string calldata params) external returns (bytes memory data);
</code></pre>
<h3 id="描述-112"><a class="header" href="#描述-112">描述</a></h3>
<p>提供作弊码以访问 <code>foundry.toml</code> 文件中 <code>rpc_endpoints</code> 对象配置的所有 RPC 端点，并能够使用配置的分叉 URL 进行 <code>rpc</code> 调用。</p>
<h3 id="示例-97"><a class="header" href="#示例-97">示例</a></h3>
<p>以下 <code>rpc_endpoints</code> 在 <code>foundry.toml</code> 中注册了两个 RPC 别名：</p>
<ul>
<li><code>optimism</code> 直接引用 URL</li>
<li><code>mainnet</code> 引用包含实际 URL 的 <code>RPC_MAINNET</code> 环境值</li>
</ul>
<p><em>环境变量需要用 <code>${}</code> 包裹</em></p>
<pre><code class="language-toml"># --snip--
[rpc_endpoints]
optimism = "https://optimism.alchemyapi.io/v2/..."
mainnet = "${RPC_MAINNET}" 
</code></pre>
<pre><code class="language-solidity">string memory url = vm.rpcUrl("optimism");
assertEq(url, "https://optimism.alchemyapi.io/v2/...");
</code></pre>
<p>如果环境变量缺失，<code>rpcUrl()</code> 将回滚：</p>
<pre><code class="language-solidity">vm.expectRevert("Failed to resolve env var `${RPC_MAINNET}` in `RPC_MAINNET`: environment variable not found");
string memory url = vm.rpcUrl("mainnet");
</code></pre>
<p>检索所有可用的别名 -&gt; URL 对</p>
<pre><code class="language-solidity">string[2][] memory allUrls = vm.rpcUrls();
assertEq(allUrls.length, 2);

string[2] memory val = allUrls[0];
assertEq(val[0], "optimism");

string[2] memory env = allUrls[1];
assertEq(env[0], "mainnet");
</code></pre>
<p>进行 <code>eth_getBalance</code> 的 RPC 调用</p>
<pre><code class="language-solidity">// 区块 &lt;https://etherscan.io/block/18332681&gt; 的余额
bytes memory result = vm.rpc("eth_getBalance", "[\"0x8D97689C9818892B700e27F316cc3E41e17fBeb9\", \"0x117BC09\"]")
assertEq(hex"10b7c11bcb51e6", result);
</code></pre>
<h3 id="另请参阅-26"><a class="header" href="#另请参阅-26">另请参阅</a></h3>
<p>Forge 配置</p>
<p><a href="cheatcodes/../reference/config/testing.html#rpc_endpoints">配置参考</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="文件作弊码"><a class="header" href="#文件作弊码">文件作弊码</a></h2>
<h3 id="签名-91"><a class="header" href="#签名-91">签名</a></h3>
<pre><code class="language-solidity">// 读取文件的全部内容到字符串，(路径) =&gt; (数据)
function readFile(string calldata) external returns (string memory);
/// 以二进制形式读取文件的全部内容。`路径`相对于项目根目录。
function readFileBinary(string calldata path) external view returns (bytes memory data);
/// 递归读取给定路径的目录，最多到`最大深度`。
/// `最大深度`默认为1，表示只返回给定目录的直接子目录。
/// 如果`跟随链接`为真，则跟随符号链接。
function readDir(string calldata path) external view returns (DirEntry[] memory entries);
// 读取文件的下一行到字符串，(路径) =&gt; (行)
function readLine(string calldata) external returns (string memory);
/// 读取符号链接，返回链接指向的路径。
/// 此作弊码在以下情况下会回滚，但不限于这些情况：
/// - `路径`不是符号链接。
/// - `路径`不存在。
function readLink(string calldata linkPath) external view returns (string memory targetPath);
// 写入数据到文件，如果不存在则创建文件，如果存在则完全替换其内容。
// (路径, 数据) =&gt; ()
function writeFile(string calldata, string calldata) external;
// 写入行到文件，如果不存在则创建文件。
// (路径, 数据) =&gt; ()
function writeLine(string calldata, string calldata) external;
// 关闭文件以进行读取，重置偏移量，允许从开头用readLine读取。
// (路径) =&gt; ()
function closeFile(string calldata) external;
// 删除文件。此作弊码在以下情况下会回滚，但不限于这些情况：
// - 路径指向目录。
// - 文件不存在。
// - 用户缺乏删除文件的权限。
// (路径) =&gt; ()
function removeFile(string calldata) external;
// 如果给定路径指向现有实体，则返回真，否则返回假
// (路径) =&gt; (布尔值)
function exists(string calldata) external returns (bool);
// 如果路径存在于磁盘上并且指向常规文件，则返回真，否则返回假
// (路径) =&gt; (布尔值)
function isFile(string calldata) external returns (bool);
// 如果路径存在于磁盘上并且指向目录，则返回真，否则返回假
// (路径) =&gt; (布尔值)
function isDir(string calldata) external returns (bool);
</code></pre>
<h3 id="描述-113"><a class="header" href="#描述-113">描述</a></h3>
<p>这些由 <a href="https://github.com/foundry-rs/forge-std" title="" target="_blank">forge-std</a> 提供的作弊码可用于文件系统操作。</p>
<p>默认情况下，文件系统访问是被禁止的，需要在 <code>foundry.toml</code> 中设置 <code>fs_permission</code>：</p>
<pre><code class="language-toml"># 配置作弊码的权限，这些作弊码涉及文件系统操作，如 `vm.writeFile`
# `access` 限制通过作弊码访问 `路径` 的方式
#    `read-write` | `true`   =&gt; 允许 `读` + `写` 访问 (`vm.readFile` + `vm.writeFile`)
#    `none`| `false` =&gt; 无访问权限
#    `read` =&gt; 仅读访问 (`vm.readFile`)
#    `write` =&gt; 仅写访问 (`vm.writeFile`)
# `allowed_paths` 进一步列出被考虑的路径，例如 `./` 表示项目根目录
# 默认情况下 _无_ 文件系统访问权限，且 _无_ 路径被允许
# 以下示例仅启用对项目目录的读访问权限：
#       `fs_permissions = [{ access = "read", path = "./"}]`
fs_permissions = [] # 默认：所有文件作弊码都被禁用
</code></pre>
<h3 id="示例-98"><a class="header" href="#示例-98">示例</a></h3>
<p>追加一行到文件，如果文件不存在则创建文件</p>
<p>这需要对文件 / 项目根目录的读访问权限</p>
<pre><code class="language-toml">fs_permissions = [{ access = "read", path = "./"}]
</code></pre>
<pre><code class="language-solidity">string memory path = "output.txt";

string memory line1 = "first line";
vm.writeLine(path, line1);

string memory line2 = "second line";
vm.writeLine(path, line2);
</code></pre>
<p>写入和读取文件</p>
<p>这需要对文件 / 项目根目录的读写访问权限：</p>
<pre><code class="language-toml">fs_permissions = [{ access = "read-write", path = "./"}]
</code></pre>
<pre><code class="language-solidity">string memory path = "file.txt";
string memory data = "hello world";
vm.writeFile(path, data);

assertEq(vm.readFile(path), data);
</code></pre>
<p>删除文件</p>
<p>这需要对文件 / 项目根目录的写访问权限：</p>
<pre><code class="language-toml">fs_permissions = [{ access = "write", path = "./"}]
</code></pre>
<pre><code class="language-solidity">string memory path = "file.txt";
vm.removeFile(path);

assertFalse(vm.exists(validPath));
</code></pre>
<p>验证文件系统路径是否有效</p>
<pre><code class="language-solidity">// 验证路径 'foo/files/bar.txt' 是否存在
string memory validPath = "foo/files/bar.txt";
assertTrue(vm.exists(validPath));
</code></pre>
<p>验证文件系统路径是否指向文件或目录</p>
<pre><code class="language-solidity">// 验证路径 'foo/file/bar.txt' 是否指向文件
string memory validFilePath = "foo/files/bar.txt";
assertTrue(vm.isFile(validFilePath));

// 验证 'foo/file' 是否指向目录
string memory validDirPath = "foo/files";
assertTrue(vm.isDir(validDirPath));
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="forge-标准库参考"><a class="header" href="#forge-标准库参考">Forge 标准库参考</a></h2>
<p>Forge 标准库（简称 Forge Std）是一组有用的合约，使编写测试更容易、更快、更用户友好。</p>
<p>使用 Forge Std 是使用 Foundry 编写测试的首选方式。</p>
<p>包含的内容：</p>
<ul>
<li>
<p><code>Vm.sol</code>：最新的 <a href="reference/forge-std/../../cheatcodes/#cheatcodes-interface">作弊码接口</a></p>
<pre><code class="language-solidity">import "forge-std/Vm.sol";
</code></pre>
</li>
<li>
<p><a href="reference/forge-std/./console-log.html"><code>console.sol</code></a> 和 <code>console2.sol</code>：Hardhat 风格的日志功能</p>
<pre><code class="language-solidity">import "forge-std/console.sol";
</code></pre>
<p><strong>注意：</strong> <code>console2.sol</code> 包含对 <code>console.sol</code> 的补丁，允许 Forge 解码对控制台的调用，但它与 Hardhat 不兼容。</p>
<pre><code class="language-solidity">import "forge-std/console2.sol";
</code></pre>
</li>
<li>
<p><code>Script.sol</code>：<a href="reference/forge-std/../../tutorials/solidity-scripting.html">Solidity 脚本</a> 的基本实用工具</p>
<pre><code class="language-solidity">import "forge-std/Script.sol";
</code></pre>
</li>
<li>
<p><code>Test.sol</code>：完整的 Forge Std 体验（更多详情<a href="reference/forge-std%5Cindex.html#forge-stds-test">如下</a>）</p>
<pre><code class="language-solidity">import "forge-std/Test.sol";
</code></pre>
</li>
</ul>
<h3 id="forge-std-的-test"><a class="header" href="#forge-std-的-test">Forge Std 的 <code>Test</code></a></h3>
<p><code>Test.sol</code> 中的 <code>Test</code> 合约提供了开始编写测试所需的所有基本功能。</p>
<p>只需导入 <code>Test.sol</code> 并在你的测试合约中继承 <code>Test</code>：</p>
<pre><code class="language-solidity">import "forge-std/Test.sol";

contract ContractTest is Test { ...
</code></pre>
<p>包含的内容：</p>
<ul>
<li>
<p>标准库</p>
<ul>
<li><a href="reference/forge-std/./std-logs.html">Std Logs</a>：扩展 DSTest 库的日志事件。</li>
<li><a href="reference/forge-std/./std-assertions.html">Std Assertions</a>：扩展 DSTest 库的断言函数。</li>
<li><a href="reference/forge-std/./std-cheats.html">Std Cheats</a>：围绕 Forge 作弊码的包装器，以提高安全性和开发体验。</li>
<li><a href="reference/forge-std/./std-errors.html">Std Errors</a>：围绕常见内部 Solidity 错误和回滚的包装器。</li>
<li><a href="reference/forge-std/./std-storage.html">Std Storage</a>：存储操作的实用工具。</li>
<li><a href="reference/forge-std/./std-math.html">Std Math</a>：有用的数学函数。</li>
<li><a href="reference/forge-std/./script-utils.html">Script Utils</a>：可以在测试和脚本中访问的实用函数。</li>
<li><a href="reference/forge-std/./console-log.html">Console Logging</a>：控制台日志函数。</li>
</ul>
</li>
<li>
<p>作弊码实例 <code>vm</code>，从中你可以调用 Forge 作弊码（见 <a href="reference/forge-std/../../cheatcodes/">作弊码参考</a>）</p>
<pre><code class="language-solidity">vm.startPrank(alice);
</code></pre>
</li>
<li>
<p>所有 Hardhat <code>console</code> 函数用于日志记录（见 <a href="reference/forge-std/./console-log.html">Console Logging</a>）</p>
<pre><code class="language-solidity">console.log(alice.balance); // 或 `console2`
</code></pre>
</li>
<li>
<p>所有 Dappsys Test 函数用于断言和日志记录（见 <a href="reference/forge-std/../ds-test.html">Dappsys Test 参考</a>）</p>
<pre><code class="language-solidity">assertEq(dai.balanceOf(alice), 10000e18);
</code></pre>
</li>
<li>
<p><code>Script.sol</code> 中也包含的实用函数（见 <a href="reference/forge-std/./script-utils.html">Script Utils</a>）</p>
<pre><code class="language-solidity">// 计算给定部署者地址和 nonce 的合约地址
address futureContract = computeCreateAddress(alice, 1);
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="标准日志"><a class="header" href="#标准日志">标准日志</a></h2>
<p>标准日志扩展了来自<a href="reference/forge-std/../ds-test.html#logging"><code>DSTest</code></a>库的日志事件。</p>
<h3 id="事件"><a class="header" href="#事件">事件</a></h3>
<pre><code class="language-solidity">event log_array(uint256[] val);
event log_array(int256[] val);
event log_named_array(string key, uint256[] val);
event log_named_array(string key, int256[] val);
</code></pre>
<h3 id="用法-1"><a class="header" href="#用法-1">用法</a></h3>
<p>本节提供使用示例。</p>
<h4 id="log_array"><a class="header" href="#log_array">log_array</a></h4>
<pre><code class="language-solidity">event log_array(&lt;type&gt;[] val);
</code></pre>
<p>其中 <code>&lt;type&gt;</code> 可以是 <code>int256</code>、<code>uint256</code>、<code>address</code>。</p>
<h5 id="示例-99"><a class="header" href="#示例-99">示例</a></h5>
<pre><code class="language-solidity">// 假设存储
// uint256[] data = [10, 20, 30, 40, 50]; 

emit log_array(data);
</code></pre>
<h4 id="log_named_array"><a class="header" href="#log_named_array">log_named_array</a></h4>
<pre><code class="language-solidity">event log_named_array(string key, &lt;type&gt;[] val);
</code></pre>
<p>其中 <code>&lt;type&gt;</code> 可以是 <code>int256</code>、<code>uint256</code>、<code>address</code>。</p>
<h5 id="示例-100"><a class="header" href="#示例-100">示例</a></h5>
<pre><code class="language-solidity">// 假设存储
// uint256[] data = [10, 20, 30, 40, 50]; 

emit log_named_array("Data", data);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="标准断言"><a class="header" href="#标准断言">标准断言</a></h2>
<ul>
<li><a href="reference/forge-std/./fail.html"><code>fail</code></a></li>
<li><a href="reference/forge-std/./assertTrue.html"><code>assertTrue</code></a></li>
<li><a href="reference/forge-std/./assertFalse.html"><code>assertFalse</code></a></li>
<li><a href="reference/forge-std/./assertEq.html"><code>assertEq</code></a></li>
<li><a href="reference/forge-std/./assertEqDecimal.html"><code>assertEqDecimal</code></a></li>
<li><a href="reference/forge-std/./assertNotEq.html"><code>assertNotEq</code></a></li>
<li><a href="reference/forge-std/./assertNotEqDecimal.html"><code>assertNotEqDecimal</code></a></li>
<li><a href="reference/forge-std/./assertLt.html"><code>assertLt</code></a></li>
<li><a href="reference/forge-std/./assertLtDecimal.html"><code>assertLtDecimal</code></a></li>
<li><a href="reference/forge-std/./assertGt.html"><code>assertGt</code></a></li>
<li><a href="reference/forge-std/./assertGtDecimal.html"><code>assertGtDecimal</code></a></li>
<li><a href="reference/forge-std/./assertLe.html"><code>assertLe</code></a></li>
<li><a href="reference/forge-std/./assertLeDecimal.html"><code>assertLeDecimal</code></a></li>
<li><a href="reference/forge-std/./assertGe.html"><code>assertGe</code></a></li>
<li><a href="reference/forge-std/./assertGeDecimal.html"><code>assertGeDecimal</code></a></li>
<li><a href="reference/forge-std/./assertApproxEqAbs.html"><code>assertApproxEqAbs</code></a></li>
<li><a href="reference/forge-std/./assertApproxEqAbsDecimal.html"><code>assertApproxEqAbsDecimal</code></a></li>
<li><a href="reference/forge-std/./assertApproxEqRel.html"><code>assertApproxEqRel</code></a></li>
<li><a href="reference/forge-std/./assertApproxEqRelDecimal.html"><code>assertApproxEqRelDecimal</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="fail"><a class="header" href="#fail"><code>fail</code></a></h2>
<h3 id="签名-92"><a class="header" href="#签名-92">签名</a></h3>
<pre><code class="language-solidity">function fail(string memory err) internal virtual;
</code></pre>
<h3 id="描述-114"><a class="header" href="#描述-114">描述</a></h3>
<p>如果命中某个分支或执行点，则使用消息使测试失败。</p>
<h3 id="示例-101"><a class="header" href="#示例-101">示例</a></h3>
<pre><code class="language-solidity">function test() external {
    for(uint256 place; place &lt; 10; ++i){
        if(game.leaderboard(place) == address(this)) return;
    }
    fail("不在前10名。");
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="asserttrue"><a class="header" href="#asserttrue"><code>assertTrue</code></a></h2>
<h3 id="签名-93"><a class="header" href="#签名-93">签名</a></h3>
<pre><code class="language-solidity">function assertTrue(bool data) internal;
</code></pre>
<pre><code class="language-solidity">function assertTrue(bool data, string memory err) internal;
</code></pre>
<h3 id="描述-115"><a class="header" href="#描述-115">描述</a></h3>
<p>断言 <code>data</code> 为真。</p>
<p>可选地包含一个错误消息在回退字符串中。</p>
<h3 id="示例-102"><a class="header" href="#示例-102">示例</a></h3>
<pre><code class="language-solidity">bool success = contract.fun();
assertTrue(success);
</code></pre>
<h3 id="另请参阅-27"><a class="header" href="#另请参阅-27">另请参阅</a></h3>
<ul>
<li><a href="reference/forge-std/./assertFalse.html"><code>assertFalse</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="assertfalse"><a class="header" href="#assertfalse"><code>assertFalse</code></a></h2>
<h3 id="签名-94"><a class="header" href="#签名-94">签名</a></h3>
<pre><code class="language-solidity">function assertFalse(bool data) internal;
</code></pre>
<pre><code class="language-solidity">function assertFalse(bool data, string memory err) internal;
</code></pre>
<h3 id="描述-116"><a class="header" href="#描述-116">描述</a></h3>
<p>断言 <code>data</code> 为假。</p>
<p>可选地包含一个错误消息在回退字符串中。</p>
<h3 id="示例-103"><a class="header" href="#示例-103">示例</a></h3>
<pre><code class="language-solidity">bool failure = contract.fun();
assertFalse(failure);
</code></pre>
<h3 id="另请参阅-28"><a class="header" href="#另请参阅-28">另请参阅</a></h3>
<ul>
<li><a href="reference/forge-std/./assertTrue.html"><code>assertTrue</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="asserteq"><a class="header" href="#asserteq"><code>assertEq</code></a></h2>
<h3 id="签名-95"><a class="header" href="#签名-95">签名</a></h3>
<h4 id="bool"><a class="header" href="#bool"><code>bool</code></a></h4>
<pre><code class="language-solidity">function assertEq(bool left, bool right) internal;
</code></pre>
<pre><code class="language-solidity">function assertEq(bool left, bool right, string memory err) internal;
</code></pre>
<h4 id="uint256-1"><a class="header" href="#uint256-1"><code>uint256</code></a></h4>
<pre><code class="language-solidity">function assertEq(uint256 left, uint256 right) internal;
</code></pre>
<pre><code class="language-solidity">function assertEq(uint256 left, uint256 right, string memory err) internal;
</code></pre>
<h4 id="int256"><a class="header" href="#int256"><code>int256</code></a></h4>
<pre><code class="language-solidity">function assertEq(int256 left, int256 right) internal;
</code></pre>
<pre><code class="language-solidity">function assertEq(int256 left, int256 right, string memory err) internal;
</code></pre>
<h4 id="address-1"><a class="header" href="#address-1"><code>address</code></a></h4>
<pre><code class="language-solidity">function assertEq(address left, address right) internal;
</code></pre>
<pre><code class="language-solidity">function assertEq(address left, address right, string memory err) internal;
</code></pre>
<h4 id="bytes32"><a class="header" href="#bytes32"><code>bytes32</code></a></h4>
<pre><code class="language-solidity">function assertEq(bytes32 left, bytes32 right) internal;
</code></pre>
<pre><code class="language-solidity">function assertEq(bytes32 left, bytes32 right, string memory err) internal;
</code></pre>
<h4 id="string-1"><a class="header" href="#string-1"><code>string</code></a></h4>
<pre><code class="language-solidity">function assertEq(string memory left, string memory right) internal;
</code></pre>
<pre><code class="language-solidity">function assertEq(string memory left, string memory right, string memory err) internal;
</code></pre>
<h4 id="bytes"><a class="header" href="#bytes"><code>bytes</code></a></h4>
<pre><code class="language-solidity">function assertEq(bytes memory left, bytes memory right) internal;
</code></pre>
<pre><code class="language-solidity">function assertEq(bytes memory left, bytes memory right, string memory err) internal;
</code></pre>
<h4 id="bool-1"><a class="header" href="#bool-1"><code>bool[]</code></a></h4>
<pre><code class="language-solidity">function assertEq(bool[] memory left, bool[] memory right) internal;
</code></pre>
<pre><code class="language-solidity">function assertEq(bool[] memory left, bool[] memory right, string memory err) internal;
</code></pre>
<h4 id="uint256-2"><a class="header" href="#uint256-2"><code>uint256[]</code></a></h4>
<pre><code class="language-solidity">function assertEq(uint256[] memory left, uint256[] memory right) internal;
</code></pre>
<pre><code class="language-solidity">function assertEq(uint256[] memory left, uint256[] memory right, string memory err) internal;
</code></pre>
<h4 id="int256-1"><a class="header" href="#int256-1"><code>int256[]</code></a></h4>
<pre><code class="language-solidity">function assertEq(int256[] memory left, int256[] memory right) internal;
</code></pre>
<pre><code class="language-solidity">function assertEq(int256[] memory left, int256[] memory right, string memory err) internal;
</code></pre>
<h4 id="address-2"><a class="header" href="#address-2"><code>address[]</code></a></h4>
<pre><code class="language-solidity">function assertEq(address[] memory left, address[] memory right) internal;
</code></pre>
<pre><code class="language-solidity">function assertEq(address[] memory left, address[] memory right, string memory err) internal;
</code></pre>
<h4 id="bytes32-1"><a class="header" href="#bytes32-1"><code>bytes32[]</code></a></h4>
<pre><code class="language-solidity">function assertEq(bytes32[] memory left, bytes32[] memory right) internal;
</code></pre>
<pre><code class="language-solidity">function assertEq(bytes32[] memory left, bytes32[] memory right, string memory err) internal;
</code></pre>
<h4 id="string-2"><a class="header" href="#string-2"><code>string[]</code></a></h4>
<pre><code class="language-solidity">function assertEq(string[] memory left, string[] memory right) internal;
</code></pre>
<pre><code class="language-solidity">function assertEq(string[] memory left, string[] memory right, string memory err) internal;
</code></pre>
<h4 id="bytes-1"><a class="header" href="#bytes-1"><code>bytes[]</code></a></h4>
<pre><code class="language-solidity">function assertEq(bytes[] memory left, bytes[] memory right) internal;
</code></pre>
<pre><code class="language-solidity">function assertEq(bytes[] memory left, bytes[] memory right, string memory err) internal;
</code></pre>
<h4 id="遗留"><a class="header" href="#遗留">遗留</a></h4>
<pre><code class="language-solidity">// 用于断言两个小于 256 位的 uint 的遗留辅助函数：`assertEqUint(uint8(1), uint128(1));`
function assertEqUint(uint256 a, uint256 b) internal;
</code></pre>
<pre><code class="language-solidity">function assertEq32(bytes32 left, bytes32 right) internal;
</code></pre>
<pre><code class="language-solidity">function assertEq32(bytes32 left, bytes32 right, string memory err) internal;
</code></pre>
<h3 id="描述-117"><a class="header" href="#描述-117">描述</a></h3>
<p>断言 <code>left</code> 等于 <code>right</code>。</p>
<p>可选地包含一个错误消息在 revert 字符串中。</p>
<h3 id="另请参阅-29"><a class="header" href="#另请参阅-29">另请参阅</a></h3>
<ul>
<li><a href="reference/forge-std/./assertEqDecimal.html"><code>assertEqDecimal</code></a></li>
<li><a href="reference/forge-std/./assertNotEq.html"><code>assertNotEq</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="asserteqdecimal"><a class="header" href="#asserteqdecimal"><code>assertEqDecimal</code></a></h2>
<h3 id="签名-96"><a class="header" href="#签名-96">签名</a></h3>
<pre><code class="language-solidity">function assertEqDecimal(uint256 left, uint256 right, uint256 decimals) internal
</code></pre>
<pre><code class="language-solidity">function assertEqDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal;
</code></pre>
<pre><code class="language-solidity">function assertEqDecimal(int256 left, int256 right, uint256 decimals) internal;
</code></pre>
<pre><code class="language-solidity">function assertEqDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal;
</code></pre>
<h3 id="描述-118"><a class="header" href="#描述-118">描述</a></h3>
<p>断言 <code>left</code> 等于 <code>right</code>。</p>
<p><code>left</code> 和 <code>right</code> 在回退字符串中以小数格式显示。</p>
<p>可选地在回退字符串中包含错误消息。</p>
<h3 id="另请参阅-30"><a class="header" href="#另请参阅-30">另请参阅</a></h3>
<ul>
<li><a href="reference/forge-std/./assertEq.html"><code>assertEq</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="assertnoteq"><a class="header" href="#assertnoteq"><code>assertNotEq</code></a></h2>
<h3 id="签名-97"><a class="header" href="#签名-97">签名</a></h3>
<h4 id="bool-2"><a class="header" href="#bool-2"><code>bool</code></a></h4>
<pre><code class="language-solidity">function assertNotEq(bool left, bool right) internal;
</code></pre>
<pre><code class="language-solidity">function assertNotEq(bool left, bool right, string memory err) internal;
</code></pre>
<h4 id="uint256-3"><a class="header" href="#uint256-3"><code>uint256</code></a></h4>
<pre><code class="language-solidity">function assertNotEq(uint256 left, uint256 right) internal;
</code></pre>
<pre><code class="language-solidity">function assertNotEq(uint256 left, uint256 right, string memory err) internal;
</code></pre>
<h4 id="int256-2"><a class="header" href="#int256-2"><code>int256</code></a></h4>
<pre><code class="language-solidity">function assertNotEq(int256 left, int256 right) internal;
</code></pre>
<pre><code class="language-solidity">function assertNotEq(int256 left, int256 right, string memory err) internal;
</code></pre>
<h4 id="address-3"><a class="header" href="#address-3"><code>address</code></a></h4>
<pre><code class="language-solidity">function assertNotEq(address left, address right) internal;
</code></pre>
<pre><code class="language-solidity">function assertNotEq(address left, address right, string memory err) internal;
</code></pre>
<h4 id="bytes32-2"><a class="header" href="#bytes32-2"><code>bytes32</code></a></h4>
<pre><code class="language-solidity">function assertNotEq(bytes32 left, bytes32 right) internal;
</code></pre>
<pre><code class="language-solidity">function assertNotEq(bytes32 left, bytes32 right, string memory err) internal;
</code></pre>
<h4 id="string-3"><a class="header" href="#string-3"><code>string</code></a></h4>
<pre><code class="language-solidity">function assertNotEq(string memory left, string memory right) internal;
</code></pre>
<pre><code class="language-solidity">function assertNotEq(string memory left, string memory right, string memory err) internal;
</code></pre>
<h4 id="bytes-2"><a class="header" href="#bytes-2"><code>bytes</code></a></h4>
<pre><code class="language-solidity">function assertNotEq(bytes memory left, bytes memory right) internal;
</code></pre>
<pre><code class="language-solidity">function assertNotEq(bytes memory left, bytes memory right, string memory err) internal;
</code></pre>
<h4 id="bool-3"><a class="header" href="#bool-3"><code>bool[]</code></a></h4>
<pre><code class="language-solidity">function assertNotEq(bool[] memory left, bool[] memory right) internal;
</code></pre>
<pre><code class="language-solidity">function assertNotEq(bool[] memory left, bool[] memory right, string memory err) internal;
</code></pre>
<h4 id="uint256-4"><a class="header" href="#uint256-4"><code>uint256[]</code></a></h4>
<pre><code class="language-solidity">function assertNotEq(uint256[] memory left, uint256[] memory right) internal;
</code></pre>
<pre><code class="language-solidity">function assertNotEq(uint256[] memory left, uint256[] memory right, string memory err) internal;
</code></pre>
<h4 id="int256-3"><a class="header" href="#int256-3"><code>int256[]</code></a></h4>
<pre><code class="language-solidity">function assertNotEq(int256[] memory left, int256[] memory right) internal;
</code></pre>
<pre><code class="language-solidity">function assertNotEq(int256[] memory left, int256[] memory right, string memory err) internal;
</code></pre>
<h4 id="address-4"><a class="header" href="#address-4"><code>address[]</code></a></h4>
<pre><code class="language-solidity">function assertNotEq(address[] memory left, address[] memory right) internal;
</code></pre>
<pre><code class="language-solidity">function assertNotEq(address[] memory left, address[] memory right, string memory err) internal;
</code></pre>
<h4 id="bytes32-3"><a class="header" href="#bytes32-3"><code>bytes32[]</code></a></h4>
<pre><code class="language-solidity">function assertNotEq(bytes32[] memory left, bytes32[] memory right) internal;
</code></pre>
<pre><code class="language-solidity">function assertNotEq(bytes32[] memory left, bytes32[] memory right, string memory err) internal;
</code></pre>
<h4 id="string-4"><a class="header" href="#string-4"><code>string[]</code></a></h4>
<pre><code class="language-solidity">function assertNotEq(string[] memory left, string[] memory right) internal;
</code></pre>
<pre><code class="language-solidity">function assertNotEq(string[] memory left, string[] memory right, string memory err) internal;
</code></pre>
<h4 id="bytes-3"><a class="header" href="#bytes-3"><code>bytes[]</code></a></h4>
<pre><code class="language-solidity">function assertNotEq(bytes[] memory left, bytes[] memory right) internal;
</code></pre>
<pre><code class="language-solidity">function assertNotEq(bytes[] memory left, bytes[] memory right, string memory err) internal;
</code></pre>
<h4 id="遗留-1"><a class="header" href="#遗留-1">遗留</a></h4>
<pre><code class="language-solidity">function assertNotEq32(bytes32 left, bytes32 right) internal;
</code></pre>
<pre><code class="language-solidity">function assertNotEq32(bytes32 left, bytes32 right, string memory err) internal;
</code></pre>
<h3 id="描述-119"><a class="header" href="#描述-119">描述</a></h3>
<p>断言 <code>left</code> 不等于 <code>right</code>。</p>
<p>可选地包含一个错误信息在回滚字符串中。</p>
<h3 id="另请参阅-31"><a class="header" href="#另请参阅-31">另请参阅</a></h3>
<ul>
<li><a href="reference/forge-std/./assertNotEqDecimal.html"><code>assertNotEqDecimal</code></a></li>
<li><a href="reference/forge-std/./assertEq.html"><code>assertEq</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="assertnoteqdecimal"><a class="header" href="#assertnoteqdecimal"><code>assertNotEqDecimal</code></a></h2>
<h3 id="签名-98"><a class="header" href="#签名-98">签名</a></h3>
<pre><code class="language-solidity">function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals) internal
</code></pre>
<pre><code class="language-solidity">function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal;
</code></pre>
<pre><code class="language-solidity">function assertNotEqDecimal(int256 left, int256 right, uint256 decimals) internal;
</code></pre>
<pre><code class="language-solidity">function assertNotEqDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal;
</code></pre>
<h3 id="描述-120"><a class="header" href="#描述-120">描述</a></h3>
<p>断言 <code>left</code> 不等于 <code>right</code>。</p>
<p><code>left</code> 和 <code>right</code> 在回退字符串中以小数格式显示。</p>
<p>可选地在回退字符串中包含错误消息。</p>
<h3 id="另请参阅-32"><a class="header" href="#另请参阅-32">另请参阅</a></h3>
<ul>
<li><a href="reference/forge-std/./assertNotEq.html"><code>assertNotEq</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="assertlt"><a class="header" href="#assertlt"><code>assertLt</code></a></h2>
<h3 id="签名-99"><a class="header" href="#签名-99">签名</a></h3>
<pre><code class="language-solidity">function assertLt(uint256 left, uint256 right) internal;
</code></pre>
<pre><code class="language-solidity">function assertLt(uint256 left, uint256 right, string memory err) internal;
</code></pre>
<pre><code class="language-solidity">function assertLt(int256 left, int256 right) internal;
</code></pre>
<pre><code class="language-solidity">function assertLt(int256 left, int256 right, string memory err) internal;
</code></pre>
<h3 id="描述-121"><a class="header" href="#描述-121">描述</a></h3>
<p>断言 <code>left</code> 严格小于 <code>right</code>。</p>
<p>可选地包含一个错误消息在回退字符串中。</p>
<h3 id="另请参阅-33"><a class="header" href="#另请参阅-33">另请参阅</a></h3>
<ul>
<li><a href="reference/forge-std/./assertLtDecimal.html"><code>assertLtDecimal</code></a></li>
<li><a href="reference/forge-std/./assertLe.html"><code>assertLe</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="assertltdecimal"><a class="header" href="#assertltdecimal"><code>assertLtDecimal</code></a></h2>
<h3 id="签名-100"><a class="header" href="#签名-100">签名</a></h3>
<pre><code class="language-solidity">function assertLtDecimal(uint256 left, uint256 right, uint256 decimals) internal
</code></pre>
<pre><code class="language-solidity">function assertLtDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal;
</code></pre>
<pre><code class="language-solidity">function assertLtDecimal(int256 left, int256 right, uint256 decimals) internal;
</code></pre>
<pre><code class="language-solidity">function assertLtDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal;
</code></pre>
<h3 id="描述-122"><a class="header" href="#描述-122">描述</a></h3>
<p>断言 <code>left</code> 严格小于 <code>right</code>。</p>
<p><code>left</code> 和 <code>right</code> 在回退字符串中以小数格式显示。</p>
<p>可选地在回退字符串中包含错误消息。</p>
<h3 id="另请参阅-34"><a class="header" href="#另请参阅-34">另请参阅</a></h3>
<ul>
<li><a href="reference/forge-std/./assertLt.html"><code>assertLt</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="assertgt"><a class="header" href="#assertgt"><code>assertGt</code></a></h2>
<h3 id="签名-101"><a class="header" href="#签名-101">签名</a></h3>
<pre><code class="language-solidity">function assertGt(uint256 left, uint256 right) internal;
</code></pre>
<pre><code class="language-solidity">function assertGt(uint256 left, uint256 right, string memory err) internal;
</code></pre>
<pre><code class="language-solidity">function assertGt(int256 left, int256 right) internal;
</code></pre>
<pre><code class="language-solidity">function assertGt(int256 left, int256 right, string memory err) internal;
</code></pre>
<h3 id="描述-123"><a class="header" href="#描述-123">描述</a></h3>
<p>断言 <code>left</code> 严格大于 <code>right</code>。</p>
<p>可选地包含一个错误消息在回退字符串中。</p>
<h3 id="另请参阅-35"><a class="header" href="#另请参阅-35">另请参阅</a></h3>
<ul>
<li><a href="reference/forge-std/./assertGtDecimal.html"><code>assertGtDecimal</code></a></li>
<li><a href="reference/forge-std/./assertGe.html"><code>assertGe</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="assertgtdecimal"><a class="header" href="#assertgtdecimal"><code>assertGtDecimal</code></a></h2>
<h3 id="签名-102"><a class="header" href="#签名-102">签名</a></h3>
<pre><code class="language-solidity">function assertGtDecimal(uint256 left, uint256 right, uint256 decimals) internal
</code></pre>
<pre><code class="language-solidity">function assertGtDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal;
</code></pre>
<pre><code class="language-solidity">function assertGtDecimal(int256 left, int256 right, uint256 decimals) internal;
</code></pre>
<pre><code class="language-solidity">function assertGtDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal;
</code></pre>
<h3 id="描述-124"><a class="header" href="#描述-124">描述</a></h3>
<p>断言 <code>left</code> 严格大于 <code>right</code>。</p>
<p><code>left</code> 和 <code>right</code> 在回退字符串中以小数格式显示。</p>
<p>可选地在回退字符串中包含错误消息。</p>
<h3 id="另请参阅-36"><a class="header" href="#另请参阅-36">另请参阅</a></h3>
<ul>
<li><a href="reference/forge-std/./assertGt.html"><code>assertGt</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="assertle"><a class="header" href="#assertle"><code>assertLe</code></a></h2>
<h3 id="签名-103"><a class="header" href="#签名-103">签名</a></h3>
<pre><code class="language-solidity">function assertLe(uint256 left, uint256 right) internal;
</code></pre>
<pre><code class="language-solidity">function assertLe(uint256 left, uint256 right, string memory err) internal;
</code></pre>
<pre><code class="language-solidity">function assertLe(int256 left, int256 right) internal;
</code></pre>
<pre><code class="language-solidity">function assertLe(int256 left, int256 right, string memory err) internal;
</code></pre>
<h3 id="描述-125"><a class="header" href="#描述-125">描述</a></h3>
<p>断言 <code>left</code> 小于或等于 <code>right</code>。</p>
<p>可选地包含一个错误消息在回退字符串中。</p>
<h3 id="另请参阅-37"><a class="header" href="#另请参阅-37">另请参阅</a></h3>
<ul>
<li><a href="reference/forge-std/./assertLeDecimal.html"><code>assertLeDecimal</code></a></li>
<li><a href="reference/forge-std/./assertLt.html"><code>assertLt</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="assertledecimal"><a class="header" href="#assertledecimal"><code>assertLeDecimal</code></a></h2>
<h3 id="签名-104"><a class="header" href="#签名-104">签名</a></h3>
<pre><code class="language-solidity">function assertLeDecimal(uint256 left, uint256 right, uint256 decimals) internal
</code></pre>
<pre><code class="language-solidity">function assertLeDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal;
</code></pre>
<pre><code class="language-solidity">function assertLeDecimal(int256 left, int256 right, uint256 decimals) internal;
</code></pre>
<pre><code class="language-solidity">function assertLeDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal;
</code></pre>
<h3 id="描述-126"><a class="header" href="#描述-126">描述</a></h3>
<p>断言 <code>left</code> 小于或等于 <code>right</code>。</p>
<p><code>left</code> 和 <code>right</code> 在回退字符串中以小数格式显示。</p>
<p>可选地在回退字符串中包含错误消息。</p>
<h3 id="另请参阅-38"><a class="header" href="#另请参阅-38">另请参阅</a></h3>
<ul>
<li><a href="reference/forge-std/./assertLe.html"><code>assertLe</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="assertge"><a class="header" href="#assertge"><code>assertGe</code></a></h2>
<h3 id="签名-105"><a class="header" href="#签名-105">签名</a></h3>
<pre><code class="language-solidity">function assertGe(uint256 left, uint256 right) internal;
</code></pre>
<pre><code class="language-solidity">function assertGe(uint256 left, uint256 right, string memory err) internal;
</code></pre>
<pre><code class="language-solidity">function assertGe(int256 left, int256 right) internal;
</code></pre>
<pre><code class="language-solidity">function assertGe(int256 left, int256 right, string memory err) internal;
</code></pre>
<h3 id="描述-127"><a class="header" href="#描述-127">描述</a></h3>
<p>断言 <code>left</code> 大于或等于 <code>right</code>。</p>
<p>可选地包含一个错误消息在回退字符串中。</p>
<h3 id="另请参阅-39"><a class="header" href="#另请参阅-39">另请参阅</a></h3>
<ul>
<li><a href="reference/forge-std/./assertGeDecimal.html"><code>assertGeDecimal</code></a></li>
<li><a href="reference/forge-std/./assertGt.html"><code>assertGt</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="assertgedecimal"><a class="header" href="#assertgedecimal"><code>assertGeDecimal</code></a></h2>
<h3 id="签名-106"><a class="header" href="#签名-106">签名</a></h3>
<pre><code class="language-solidity">function assertGeDecimal(uint256 left, uint256 right, uint256 decimals) internal
</code></pre>
<pre><code class="language-solidity">function assertGeDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal;
</code></pre>
<pre><code class="language-solidity">function assertGeDecimal(int256 left, int256 right, uint256 decimals) internal;
</code></pre>
<pre><code class="language-solidity">function assertGeDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal;
</code></pre>
<h3 id="描述-128"><a class="header" href="#描述-128">描述</a></h3>
<p>断言 <code>left</code> 大于或等于 <code>right</code>。</p>
<p><code>left</code> 和 <code>right</code> 在回退字符串中以小数格式显示。</p>
<p>可选地在回退字符串中包含错误消息。</p>
<h3 id="另请参阅-40"><a class="header" href="#另请参阅-40">另请参阅</a></h3>
<ul>
<li><a href="reference/forge-std/./assertGe.html"><code>assertGe</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="assertapproxeqabs"><a class="header" href="#assertapproxeqabs"><code>assertApproxEqAbs</code></a></h2>
<h3 id="签名-107"><a class="header" href="#签名-107">签名</a></h3>
<pre><code class="language-solidity">function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta) internal;
</code></pre>
<pre><code class="language-solidity">function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta, string memory err) internal;
</code></pre>
<pre><code class="language-solidity">function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta) internal;
</code></pre>
<pre><code class="language-solidity">function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta, string memory err) internal;
</code></pre>
<h3 id="描述-129"><a class="header" href="#描述-129">描述</a></h3>
<p>断言 <code>left</code> 与 <code>right</code> 在绝对值上近似相等，允许的最大差值为 <code>maxDelta</code>。</p>
<p>可选地包含一个错误信息在回滚字符串中。</p>
<h3 id="示例-104"><a class="header" href="#示例-104">示例</a></h3>
<pre><code class="language-solidity">function testFail() external {
    uint256 a = 100;
    uint256 b = 200;

    assertApproxEqAbs(a, b, 90);
}
</code></pre>
<pre><code class="language-ignore">[PASS] testFail() (gas: 23169)
Logs:
  Error: a ~= b not satisfied [uint]
    Expected: 200
      Actual: 100
   Max Delta: 90
       Delta: 100
</code></pre>
<h3 id="参见-17"><a class="header" href="#参见-17">参见</a></h3>
<ul>
<li><a href="reference/forge-std/./assertApproxEqAbsDecimal.html"><code>assertApproxEqAbsDecimal</code></a></li>
<li><a href="reference/forge-std/./assertApproxEqRel.html"><code>assertApproxEqRel</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="assertapproxeqabsdecimal"><a class="header" href="#assertapproxeqabsdecimal"><code>assertApproxEqAbsDecimal</code></a></h2>
<h3 id="签名-108"><a class="header" href="#签名-108">签名</a></h3>
<pre><code class="language-solidity">function assertApproxEqAbsDecimal(uint256 left, uint256 right, uint256 maxDelta, uint256 decimals) internal;
</code></pre>
<pre><code class="language-solidity">function assertApproxEqAbsDecimal(uint256 left, uint256 right, uint256 maxDelta, uint256 decimals, string memory err) internal;
</code></pre>
<pre><code class="language-solidity">function assertApproxEqAbsDecimal(int256 left, int256 right, uint256 maxDelta, uint256 decimals) internal;
</code></pre>
<pre><code class="language-solidity">function assertApproxEqAbsDecimal(int256 left, int256 right, uint256 maxDelta, uint256 decimals, string memory err) internal;
</code></pre>
<h3 id="描述-130"><a class="header" href="#描述-130">描述</a></h3>
<p>断言 <code>left</code> 在绝对值的 delta 范围内近似等于 <code>right</code>。</p>
<p><code>left</code> 和 <code>right</code> 在回退字符串中以小数格式显示。</p>
<p>可选地在回退字符串中包含错误消息。</p>
<h3 id="另请参阅-41"><a class="header" href="#另请参阅-41">另请参阅</a></h3>
<ul>
<li><a href="reference/forge-std/./assertApproxEqAbs.html"><code>assertApproxEqAbs</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="assertapproxeqrel"><a class="header" href="#assertapproxeqrel"><code>assertApproxEqRel</code></a></h2>
<h3 id="签名-109"><a class="header" href="#签名-109">签名</a></h3>
<pre><code class="language-solidity">function assertApproxEqRel(uint256 left, uint256 right, uint256 maxPercentDelta) internal;
</code></pre>
<pre><code class="language-solidity">function assertApproxEqRel(uint256 left, uint256 right, uint256 maxPercentDelta, string memory err) internal;
</code></pre>
<pre><code class="language-solidity">function assertApproxEqRel(int256 left, int256 right, uint256 maxPercentDelta) internal;
</code></pre>
<pre><code class="language-solidity">function assertApproxEqRel(int256 left, int256 right, uint256 maxPercentDelta, string memory err) internal;
</code></pre>
<h3 id="描述-131"><a class="header" href="#描述-131">描述</a></h3>
<p>断言 <code>left</code> 大约等于 <code>right</code>，允许的百分比偏差为 <code>maxPercentDelta</code>，其中 <code>1e18</code> 表示 100%。</p>
<p>可选地包含一个错误信息在回滚字符串中。</p>
<h3 id="示例-105"><a class="header" href="#示例-105">示例</a></h3>
<pre><code class="language-solidity">function testFail () external {
    uint256 a = 100;
    uint256 b = 200;
    assertApproxEqRel(a, b, 0.4e18);
}
</code></pre>
<pre><code class="language-ignore">[PASS] testFail() (gas: 23884)
Logs:
  Error: a ~= b not satisfied [uint]
      Expected: 200
        Actual: 100
   Max % Delta: 0.400000000000000000
       % Delta: 0.500000000000000000
</code></pre>
<h3 id="另请参阅-42"><a class="header" href="#另请参阅-42">另请参阅</a></h3>
<ul>
<li><a href="reference/forge-std/./assertApproxEqRelDecimal.html"><code>assertApproxEqRelDecimal</code></a></li>
<li><a href="reference/forge-std/./assertApproxEqAbs.html"><code>assertApproxEqAbs</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="assertapproxeqreldecimal"><a class="header" href="#assertapproxeqreldecimal"><code>assertApproxEqRelDecimal</code></a></h2>
<h3 id="签名-110"><a class="header" href="#签名-110">签名</a></h3>
<pre><code class="language-solidity">function assertApproxEqRelDecimal(uint256 left, uint256 right, uint256 maxPercentDelta, uint256 decimals) internal;
</code></pre>
<pre><code class="language-solidity">function assertApproxEqRelDecimal(uint256 left, uint256 right, uint256 maxPercentDelta, uint256 decimals, string memory err) internal;
</code></pre>
<pre><code class="language-solidity">function assertApproxEqRelDecimal(int256 left, int256 right, uint256 maxPercentDelta, uint256 decimals) internal;
</code></pre>
<pre><code class="language-solidity">function assertApproxEqRelDecimal(int256 left, int256 right, uint256 maxPercentDelta, uint256 decimals, string memory err) internal;
</code></pre>
<h3 id="描述-132"><a class="header" href="#描述-132">描述</a></h3>
<p>断言 <code>left</code> 大约等于 <code>right</code>，其中 <code>maxPercentDelta</code> 是百分比形式的允许误差，<code>1e18</code> 表示 100%。</p>
<p><code>left</code> 和 <code>right</code> 在回退字符串中以小数格式显示。</p>
<p>可选地在回退字符串中包含错误消息。</p>
<h3 id="另请参阅-43"><a class="header" href="#另请参阅-43">另请参阅</a></h3>
<ul>
<li><a href="reference/forge-std/./assertApproxEqRel.html"><code>assertApproxEqRel</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="标准作弊码"><a class="header" href="#标准作弊码">标准作弊码</a></h2>
<ul>
<li><a href="reference/forge-std/./skip.html"><code>skip</code></a></li>
<li><a href="reference/forge-std/./rewind.html"><code>rewind</code></a></li>
<li><a href="reference/forge-std/./hoax.html"><code>hoax</code></a></li>
<li><a href="reference/forge-std/./startHoax.html"><code>startHoax</code></a></li>
<li><a href="reference/forge-std/./deal.html"><code>deal</code></a></li>
<li><a href="reference/forge-std/./deployCode.html"><code>deployCode</code></a></li>
<li><a href="reference/forge-std/./deployCodeTo.html"><code>deployCodeTo</code></a></li>
<li><a href="reference/forge-std/./bound.html"><code>bound</code></a></li>
<li><a href="reference/forge-std/./change-prank.html"><code>changePrank</code></a></li>
<li><a href="reference/forge-std/./make-addr.html"><code>makeAddr</code></a></li>
<li><a href="reference/forge-std/./make-addr-and-key.html"><code>makeAddrAndKey</code></a></li>
<li><a href="reference/forge-std/./noGasMetering.html"><code>noGasMetering</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="skip-1"><a class="header" href="#skip-1"><code>skip</code></a></h2>
<h3 id="签名-111"><a class="header" href="#签名-111">签名</a></h3>
<pre><code class="language-solidity">function skip(uint256 time) public;
</code></pre>
<h3 id="描述-133"><a class="header" href="#描述-133">描述</a></h3>
<p>将 <code>block.timestamp</code> 向前跳过指定秒数。</p>
<h3 id="示例-106"><a class="header" href="#示例-106">示例</a></h3>
<pre><code class="language-solidity">assertEq(block.timestamp, 0);
skip(3600);
assertEq(block.timestamp, 3600);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="rewind"><a class="header" href="#rewind"><code>rewind</code></a></h2>
<h3 id="签名-112"><a class="header" href="#签名-112">签名</a></h3>
<pre><code class="language-solidity">function rewind(uint256 time) public;
</code></pre>
<h3 id="描述-134"><a class="header" href="#描述-134">描述</a></h3>
<p>将 <code>block.timestamp</code> 回退指定的秒数。</p>
<h3 id="示例-107"><a class="header" href="#示例-107">示例</a></h3>
<pre><code class="language-solidity">assertEq(block.timestamp, 3600);
rewind(3600);
assertEq(block.timestamp, 0);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="hoax"><a class="header" href="#hoax"><code>hoax</code></a></h2>
<h3 id="签名-113"><a class="header" href="#签名-113">签名</a></h3>
<pre><code class="language-solidity">function hoax(address who) public;
</code></pre>
<pre><code class="language-solidity">function hoax(address who, uint256 give) public;
</code></pre>
<pre><code class="language-solidity">function hoax(address who, address origin) public;
</code></pre>
<pre><code class="language-solidity">function hoax(address who, address origin, uint256 give) public;
</code></pre>
<h3 id="描述-135"><a class="header" href="#描述-135">描述</a></h3>
<p>设置一个从拥有一些以太币的地址发起的<a href="reference/forge-std/../../cheatcodes/prank.html"><code>prank</code></a>。</p>
<p>如果没有指定余额，它将被设置为 2^128 wei。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="starthoax"><a class="header" href="#starthoax"><code>startHoax</code></a></h2>
<h3 id="签名-114"><a class="header" href="#签名-114">签名</a></h3>
<pre><code class="language-solidity">function startHoax(address who) public;
</code></pre>
<pre><code class="language-solidity">function startHoax(address who, uint256 give) public;
</code></pre>
<pre><code class="language-solidity">function startHoax(address who, address origin) public;
</code></pre>
<pre><code class="language-solidity">function startHoax(address who, address origin, uint256 give) public;
</code></pre>
<h3 id="描述-136"><a class="header" href="#描述-136">描述</a></h3>
<p>从一个有以太币的地址开始一个<a href="reference/forge-std/../../cheatcodes/start-prank.html">永久的 <code>prank</code></a>。</p>
<p>如果没有指定余额，它将被设置为 2^128 wei。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="deal-1"><a class="header" href="#deal-1"><code>deal</code></a></h2>
<h3 id="签名-115"><a class="header" href="#签名-115">签名</a></h3>
<pre><code class="language-solidity">function deal(address to, uint256 give) public;
</code></pre>
<pre><code class="language-solidity">function deal(address token, address to, uint256 give) public;
</code></pre>
<pre><code class="language-solidity">function deal(address token, address to, uint256 give, bool adjust) public;
</code></pre>
<h3 id="描述-137"><a class="header" href="#描述-137">描述</a></h3>
<p>这是 <a href="reference/forge-std/../../cheatcodes/deal.html"><code>deal</code></a> cheatcode 的一个封装，也适用于大多数 ERC-20 代币。</p>
<p>如果使用 <code>deal</code> 的替代签名，则在设置余额后调整代币的总供应量。</p>
<h3 id="示例-108"><a class="header" href="#示例-108">示例</a></h3>
<pre><code class="language-solidity">deal(address(dai), alice, 10000e18);
assertEq(dai.balanceOf(alice), 10000e18);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="deploycode"><a class="header" href="#deploycode"><code>deployCode</code></a></h2>
<h3 id="签名-116"><a class="header" href="#签名-116">签名</a></h3>
<pre><code class="language-solidity">function deployCode(string memory what) public returns (address);
</code></pre>
<pre><code class="language-solidity">function deployCode(string memory what, bytes memory args) public returns (address);
</code></pre>
<pre><code class="language-solidity">function deployCode(string memory what, uint256 val) public returns (address);
</code></pre>
<pre><code class="language-solidity">function deployCode(string memory what, bytes memory args, uint256 val) public returns (address);
</code></pre>
<h3 id="描述-138"><a class="header" href="#描述-138">描述</a></h3>
<p>通过从 artifacts 目录中获取合约字节码来部署合约。</p>
<p>calldata 参数可以是以下形式之一：<code>ContractFile.sol</code>（如果文件名和合约名相同）、<code>ContractFile.sol:ContractName</code>，或者是相对于项目根目录的 artifact 路径。</p>
<p>还可以通过使用 <code>val</code> 参数传递值。如果你需要在构造时发送 ETH，这是必要的。</p>
<h3 id="示例-109"><a class="header" href="#示例-109">示例</a></h3>
<pre><code class="language-solidity">address deployment = deployCode("MyContract.sol", abi.encode(arg1, arg2));
</code></pre>
<h3 id="另请参阅-44"><a class="header" href="#另请参阅-44">另请参阅</a></h3>
<p>Forge 标准库</p>
<ul>
<li><a href="reference/forge-std/./deployCodeTo.html"><code>deployCodeTo</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="deploycodeto"><a class="header" href="#deploycodeto"><code>deployCodeTo</code></a></h2>
<h3 id="签名-117"><a class="header" href="#签名-117">签名</a></h3>
<pre><code class="language-solidity">function deployCodeTo(string memory what, address where) internal virtual;
</code></pre>
<pre><code class="language-solidity">function deployCodeTo(string memory what, bytes memory args, address where) internal virtual;
</code></pre>
<pre><code class="language-solidity">function deployCodeTo(string memory what, bytes memory args, uint256 value, address where) internal virtual;
</code></pre>
<h3 id="描述-139"><a class="header" href="#描述-139">描述</a></h3>
<p>通过从 artifacts 目录中获取合约字节码，伪部署合约到一个任意地址。这可以用于重新创建生产环境。</p>
<p>calldata 参数可以是以下形式之一：<code>ContractFile.sol</code>（如果文件名和合约名相同）、<code>ContractFile.sol:ContractName</code>，或者是相对于项目根目录的 artifact 路径。</p>
<p>还可以通过使用 <code>value</code> 参数传递值。如果你需要在构造时发送 ETH，这是必要的。</p>
<h3 id="示例-110"><a class="header" href="#示例-110">示例</a></h3>
<pre><code class="language-solidity">deployCodeTo("MyContract.sol", abi.encode(arg1, arg2), arbitraryAddr);
</code></pre>
<h3 id="参见-18"><a class="header" href="#参见-18">参见</a></h3>
<p>Forge 标准库</p>
<ul>
<li><a href="reference/forge-std/./deployCode.html"><code>deployCode</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="bound"><a class="header" href="#bound"><code>bound</code></a></h2>
<h3 id="签名-118"><a class="header" href="#签名-118">签名</a></h3>
<pre><code class="language-solidity">function bound(uint256 x, uint256 min, uint256 max) public returns (uint256 result);
</code></pre>
<h3 id="描述-140"><a class="header" href="#描述-140">描述</a></h3>
<p>一个用于将模糊测试输入包装到特定范围的数学函数。</p>
<p>在某些情况下，您可以使用它来代替 <code>assume</code> 作弊码以获得更好的性能。更多信息请阅读<a href="reference/forge-std/../../cheatcodes/assume.html">这里</a>。</p>
<h3 id="示例-111"><a class="header" href="#示例-111">示例</a></h3>
<pre><code class="language-solidity">input = bound(input, 99, 101);
</code></pre>
<p>对于输入 <code>0</code>，返回 <code>99</code>。
<br>
对于输入 <code>1</code>，返回 <code>100</code>。
<br>
对于输入 <code>2</code>，返回 <code>101</code>。
<br>
对于输入 <code>3</code>，返回 <code>99</code>。
<br>
依此类推。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="changeprank"><a class="header" href="#changeprank"><code>changePrank</code></a></h2>
<h3 id="状态-1"><a class="header" href="#状态-1">状态</a></h3>
<p><code>changePrank</code> 已被弃用。</p>
<h3 id="签名-119"><a class="header" href="#签名-119">签名</a></h3>
<pre><code class="language-solidity">function changePrank(address who) internal;
</code></pre>
<h3 id="描述-141"><a class="header" href="#描述-141">描述</a></h3>
<p>停止当前的恶作剧（prank）并使用 <code>stopPrank</code>，然后将地址传递给 <code>startPrank</code>。</p>
<p>这对于在 <code>setUp</code> 函数中启动全局恶作剧并在某些测试中停用它非常有用。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="makeaddr"><a class="header" href="#makeaddr"><code>makeAddr</code></a></h2>
<h3 id="签名-120"><a class="header" href="#签名-120">签名</a></h3>
<pre><code class="language-solidity">function makeAddr(string memory name) internal returns(address addr);
</code></pre>
<h3 id="描述-142"><a class="header" href="#描述-142">描述</a></h3>
<p>从提供的 <code>name</code> 创建一个地址。</p>
<p>为派生的地址创建一个 <a href="reference/forge-std/../../cheatcodes/label.html"><code>label</code></a>，使用提供的 <code>name</code> 作为标签值。</p>
<h3 id="示例-112"><a class="header" href="#示例-112">示例</a></h3>
<pre><code class="language-solidity">address alice = makeAddr("alice");
emit log_address(alice); // 0x328809bc894f92807417d2dad6b7c998c1afdac6
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="makeaddrandkey"><a class="header" href="#makeaddrandkey"><code>makeAddrAndKey</code></a></h2>
<h3 id="签名-121"><a class="header" href="#签名-121">签名</a></h3>
<pre><code class="language-solidity">function makeAddrAndKey(string memory name) internal returns(address addr, uint256 privateKey);
</code></pre>
<h3 id="描述-143"><a class="header" href="#描述-143">描述</a></h3>
<p>从提供的 <code>name</code> 创建一个地址和私钥。</p>
<p>为派生的地址创建一个 <a href="reference/forge-std/../../cheatcodes/label.html"><code>label</code></a>，使用提供的 <code>name</code> 作为标签值。</p>
<h3 id="示例-113"><a class="header" href="#示例-113">示例</a></h3>
<pre><code class="language-solidity">(address alice, uint256 key) = makeAddrAndKey("alice");
emit log_address(alice); // 0x328809bc894f92807417d2dad6b7c998c1afdac6
emit log_uint(key); // 70564938991660933374592024341600875602376452319261984317470407481576058979585
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="nogasmetering"><a class="header" href="#nogasmetering"><code>noGasMetering</code></a></h2>
<h3 id="签名-122"><a class="header" href="#签名-122">签名</a></h3>
<pre><code class="language-solidity">modifier noGasMetering();
</code></pre>
<h3 id="描述-144"><a class="header" href="#描述-144">描述</a></h3>
<p>一个函数修饰器，用于关闭函数的 gas 计量。</p>
<p>注意，调用这个 cheatcode 会有一些 gas 消耗，所以你会看到一些 gas 使用（尽管很小）。</p>
<h3 id="示例-114"><a class="header" href="#示例-114">示例</a></h3>
<pre><code class="language-solidity">function addInLoop() internal returns (uint256) {
    uint256 b;
    for (uint256 i; i &lt; 10000; i++) {
        b + i;
    }
    return b;
}

function addInLoopNoGas() internal noGasMetering returns (uint256) {
    return addInLoop();
}

function testFunc() external {
  uint256 gas_start = gasleft();
  addInLoop();
  uint256 gas_used = gas_start - gasleft();

  uint256 gas_start_no_metering = gasleft();
  addInLoopNoGas();
  uint256 gas_used_no_metering = gas_start_no_metering - gasleft();

  emit log_named_uint("Gas Metering", gas_used);
  emit log_named_uint("No Gas Metering", gas_used_no_metering);
}
</code></pre>
<pre><code class="language-ignore">[PASS] testFunc() (gas: 1887191)
Logs:
  Gas Metering: 1880082
  No Gas Metering: 3024
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="assumenotprecompile"><a class="header" href="#assumenotprecompile"><code>assumeNotPrecompile</code></a></h2>
<h3 id="签名-123"><a class="header" href="#签名-123">签名</a></h3>
<pre><code class="language-solidity">function assumeNotPrecompile(address addr) public;
</code></pre>
<pre><code class="language-solidity">function assumeNotPrecompile(address addr, uint256 chainid) public;
</code></pre>
<h3 id="描述-145"><a class="header" href="#描述-145">描述</a></h3>
<p>使用 <a href="reference/forge-std/../../cheatcodes/assume.html"><code>assume</code></a> 从模糊测试中过滤预编译地址。</p>
<p>可选地，可以指定一个 <code>chainid</code> 来过滤相应链上的已知预编译。</p>
<h3 id="注册表"><a class="header" href="#注册表">注册表</a></h3>
<p>这些是 <code>assumeNotPrecompile</code> 函数已知的所有预编译地址。</p>
<div class="table-wrapper"><table><thead><tr><th>链 ID</th><th>地址</th><th>名称</th></tr></thead><tbody>
<tr><td>ALL</td><td><code>0x01</code></td><td>ECRecover</td></tr>
<tr><td>ALL</td><td><code>0x02</code></td><td>SHA-256</td></tr>
<tr><td>ALL</td><td><code>0x03</code></td><td>RIPEMD-160</td></tr>
<tr><td>ALL</td><td><code>0x04</code></td><td>Identity</td></tr>
<tr><td>ALL</td><td><code>0x05</code></td><td>ModExp</td></tr>
<tr><td>ALL</td><td><code>0x06</code></td><td>ECAdd</td></tr>
<tr><td>ALL</td><td><code>0x07</code></td><td>ECMul</td></tr>
<tr><td>ALL</td><td><code>0x08</code></td><td>ECPairing</td></tr>
<tr><td>ALL</td><td><code>0x09</code></td><td>Blake2F</td></tr>
<tr><td>ALL</td><td><code>0x0a</code></td><td>PointEvaluation</td></tr>
<tr><td>10, 420</td><td><code>0x4200000000000000000000000000000000000016</code></td><td>L2ToL1MessagePasser</td></tr>
<tr><td>10, 420</td><td><code>0x4200000000000000000000000000000000000002</code></td><td>DeployerWhitelist</td></tr>
<tr><td>10, 420</td><td><code>0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000</code></td><td>LegacyERC20ETH</td></tr>
<tr><td>10, 420</td><td><code>0x4200000000000000000000000000000000000006</code></td><td>WETH9</td></tr>
<tr><td>10, 420</td><td><code>0x4200000000000000000000000000000000000007</code></td><td>L2CrossDomainMessenger</td></tr>
<tr><td>10, 420</td><td><code>0x4200000000000000000000000000000000000010</code></td><td>L2StandardBridge</td></tr>
<tr><td>10, 420</td><td><code>0x4200000000000000000000000000000000000011</code></td><td>SequencerFeeVault</td></tr>
<tr><td>10, 420</td><td><code>0x4200000000000000000000000000000000000012</code></td><td>OptimismMintableERC20Factory</td></tr>
<tr><td>10, 420</td><td><code>0x4200000000000000000000000000000000000013</code></td><td>L1BlockNumber</td></tr>
<tr><td>10, 420</td><td><code>0x420000000000000000000000000000000000000F</code></td><td>GasPriceOracle</td></tr>
<tr><td>10, 420</td><td><code>0x4200000000000000000000000000000000000015</code></td><td>L1Block</td></tr>
<tr><td>10, 420</td><td><code>0x4200000000000000000000000000000000000042</code></td><td>GovernanceToken</td></tr>
<tr><td>10, 420</td><td><code>0x4200000000000000000000000000000000000000</code></td><td>LegacyMessagePasser</td></tr>
<tr><td>10, 420</td><td><code>0x4200000000000000000000000000000000000014</code></td><td>L2ERC721Bridge</td></tr>
<tr><td>10, 420</td><td><code>0x4200000000000000000000000000000000000017</code></td><td>OptimismMintableERC721Factory</td></tr>
<tr><td>10, 420</td><td><code>0x4200000000000000000000000000000000000018</code></td><td>ProxyAdmin</td></tr>
<tr><td>42161, 421613</td><td><code>0x0000000000000000000000000000000000000064</code></td><td>ArbSys</td></tr>
<tr><td>42161, 421613</td><td><code>0x000000000000000000000000000000000000006E</code></td><td>ArbRetryableTx</td></tr>
<tr><td>42161, 421613</td><td><code>0x000000000000000000000000000000000000006C</code></td><td>ArbGasInfo</td></tr>
<tr><td>42161, 421613</td><td><code>0x0000000000000000000000000000000000000066</code></td><td>ArbAddressTable</td></tr>
<tr><td>42161, 421613</td><td><code>0x000000000000000000000000000000000000006F</code></td><td>ArbStatistics</td></tr>
<tr><td>42161, 421613</td><td><code>0x00000000000000000000000000000000000000C8</code></td><td>NodeInterface</td></tr>
<tr><td>42161, 421613</td><td><code>0x0000000000000000000000000000000000000067</code></td><td>ArbBLS</td></tr>
<tr><td>42161, 421613</td><td><code>0x0000000000000000000000000000000000000065</code></td><td>ArbInfo</td></tr>
<tr><td>42161, 421613</td><td><code>0x000000000000000000000000000000000000006D</code></td><td>ArbAggregator</td></tr>
<tr><td>42161, 421613</td><td><code>0x0000000000000000000000000000000000000068</code></td><td>ArbFunctionTable</td></tr>
<tr><td>433114, 43113</td><td><code>0x0200000000000000000000000000000000000000</code></td><td>ContractDeployerAllowListAddress</td></tr>
<tr><td>433114, 43113</td><td><code>0x0200000000000000000000000000000000000001</code></td><td>ContractNativeMinterAddress</td></tr>
<tr><td>433114, 43113</td><td><code>0x0200000000000000000000000000000000000002</code></td><td>TxAllowListAddress</td></tr>
<tr><td>433114, 43113</td><td><code>0x0200000000000000000000000000000000000003</code></td><td>FeeConfigManagerAddress</td></tr>
<tr><td>ALL</td><td><code>0x4e59b44847b379578588920cA78FbF26c0B4956C</code></td><td>(Foundry) Create2Deployer</td></tr>
<tr><td>ALL</td><td><code>0x7109709ECfa91a80626fF3989D68f67F5b1DD12D</code></td><td>(Foundry) VM</td></tr>
<tr><td>ALL</td><td><code>0x000000000000000000636F6e736F6c652e6c6f67</code></td><td>(Foundry) Console</td></tr>
</tbody></table>
</div>
<h3 id="保留范围"><a class="header" href="#保留范围">保留范围</a></h3>
<p>某些链还包括预编译合约的保留范围。</p>
<div class="table-wrapper"><table><thead><tr><th>链 ID</th><th>起始</th><th>终止</th></tr></thead><tbody>
<tr><td>ALL</td><td><code>0x00</code></td><td><code>0xff</code></td></tr>
<tr><td>433114, 43113</td><td><code>0x0100000000000000000000000000000000000000</code></td><td><code>0x01000000000000000000000000000000000000ff</code></td></tr>
<tr><td>433114, 43113</td><td><code>0x0200000000000000000000000000000000000000</code></td><td><code>0x02000000000000000000000000000000000000ff</code></td></tr>
<tr><td>433114, 43113</td><td><code>0x0300000000000000000000000000000000000000</code></td><td><code>0x03000000000000000000000000000000000000ff</code></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h2 id="assumepayable"><a class="header" href="#assumepayable"><code>assumePayable</code></a></h2>
<h3 id="签名-124"><a class="header" href="#签名-124">签名</a></h3>
<pre><code class="language-solidity">function assumePayable(address addr) public;
</code></pre>
<h3 id="描述-146"><a class="header" href="#描述-146">描述</a></h3>
<p>使用 <a href="reference/forge-std/../../cheatcodes/assume.html"><code>assume</code></a> 过滤拒绝以太币转账的地址。</p>
<p>这会向指定的 <code>addr</code> 地址发起一个没有调用数据的外部调用，并检查调用的成功与否。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="标准错误"><a class="header" href="#标准错误">标准错误</a></h2>
<ul>
<li><a href="reference/forge-std/./assertionError.html"><code>assertionError</code></a></li>
<li><a href="reference/forge-std/./arithmeticError.html"><code>arithmeticError</code></a></li>
<li><a href="reference/forge-std/./divisionError.html"><code>divisionError</code></a></li>
<li><a href="reference/forge-std/./enumConversionError.html"><code>enumConversionError</code></a></li>
<li><a href="reference/forge-std/./encodeStorageError.html"><code>encodeStorageError</code></a></li>
<li><a href="reference/forge-std/./popError.html"><code>popError</code></a></li>
<li><a href="reference/forge-std/./indexOOBError.html"><code>indexOOBError</code></a></li>
<li><a href="reference/forge-std/./memOverflowError.html"><code>memOverflowError</code></a></li>
<li><a href="reference/forge-std/./zeroVarError.html"><code>zeroVarError</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="assertionerror"><a class="header" href="#assertionerror"><code>assertionError</code></a></h2>
<h3 id="签名-125"><a class="header" href="#签名-125">签名</a></h3>
<pre><code class="language-solidity">stdError.assertionError
</code></pre>
<h3 id="描述-147"><a class="header" href="#描述-147">描述</a></h3>
<p>当 <code>assert</code> 失败时，Solidity 的内部错误。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="arithmeticerror"><a class="header" href="#arithmeticerror"><code>arithmeticError</code></a></h2>
<h3 id="签名-126"><a class="header" href="#签名-126">签名</a></h3>
<pre><code class="language-solidity">stdError.arithmeticError
</code></pre>
<h3 id="描述-148"><a class="header" href="#描述-148">描述</a></h3>
<p>当算术操作失败时，Solidity 内部的错误，例如下溢和上溢。</p>
<h3 id="示例-115"><a class="header" href="#示例-115">示例</a></h3>
<p>假设我们有一个基本的保险库合约，可以存储一些代币（<code>wmdToken</code>）：</p>
<pre><code class="language-solidity">contract BasicVault {

    IERC20 public immutable wmdToken;   
    mapping(address =&gt; uint) public balances;

    event Deposited(address indexed from, uint amount);
    event Withdrawal(address indexed from, uint amount);

    constructor(IERC20 wmdToken_){
        wmdToken = wmdToken_;
    }

    function deposit(uint amount) external {    
        balances[msg.sender] += amount;
        bool success = wmdToken.transferFrom(msg.sender, address(this), amount);
        require(success, "存款失败！"); 
        emit Deposited(msg.sender, amount);
    }

    function withdraw(uint amount) external {      
        balances[msg.sender] -= amount;
        bool success = wmdToken.transfer(msg.sender, amount);
        require(success, "取款失败！");
        emit Withdrawal(msg.sender, amount);
    }
}
</code></pre>
<p>我们有一个测试函数，确保用户无法提取超过其存款的代币，如下所示：</p>
<pre><code class="language-solidity">function testUserCannotWithdrawExcessOfDeposit() public {
    vm.prank(user);
    vm.expectRevert(stdError.arithmeticError);
    vault.withdraw(userTokens + 100*10**18);
}
</code></pre>
<ol>
<li>用户在保险库合约中存入了数量为 <code>userTokens</code> 的代币。</li>
<li>用户尝试提取超过其存款数量的代币。</li>
<li>这会导致下溢错误，因为 <code>balances[msg.sender] -= amount;</code> 会计算出一个负值。</li>
</ol>
<p>为了捕获错误“算术上溢/下溢”，我们在预期会导致下溢的函数调用之前插入 <code>vm.expectRevert(stdError.arithmeticError)</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="divisionerror"><a class="header" href="#divisionerror"><code>divisionError</code></a></h2>
<h3 id="签名-127"><a class="header" href="#签名-127">签名</a></h3>
<pre><code class="language-solidity">stdError.divisionError
</code></pre>
<h3 id="描述-149"><a class="header" href="#描述-149">描述</a></h3>
<p>当除法失败时的内部 Solidity 错误，例如除以零。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="enumconversionerror"><a class="header" href="#enumconversionerror"><code>enumConversionError</code></a></h2>
<h3 id="签名-128"><a class="header" href="#签名-128">签名</a></h3>
<pre><code class="language-solidity">stdError.enumConversionError
</code></pre>
<h3 id="描述-150"><a class="header" href="#描述-150">描述</a></h3>
<p>当尝试将一个数字转换为枚举的一个变体时，如果该数字大于枚举中的变体数量（从0开始计数），则会出现内部 Solidity 错误。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="encodestorageerror"><a class="header" href="#encodestorageerror"><code>encodeStorageError</code></a></h2>
<h3 id="签名-129"><a class="header" href="#签名-129">签名</a></h3>
<pre><code class="language-solidity">stdError.encodeStorageError
</code></pre>
<h3 id="描述-151"><a class="header" href="#描述-151">描述</a></h3>
<p>当尝试访问存储中已损坏的数据时，Solidity 内部错误。除非使用汇编，否则数据不会损坏。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="poperror"><a class="header" href="#poperror"><code>popError</code></a></h2>
<h3 id="签名-130"><a class="header" href="#签名-130">签名</a></h3>
<pre><code class="language-solidity">stdError.popError
</code></pre>
<h3 id="描述-152"><a class="header" href="#描述-152">描述</a></h3>
<p>当尝试从空数组中弹出元素时，Solidity 的内部错误。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="indexooberror"><a class="header" href="#indexooberror"><code>indexOOBError</code></a></h2>
<h3 id="签名-131"><a class="header" href="#签名-131">签名</a></h3>
<pre><code class="language-solidity">stdError.indexOOBError
</code></pre>
<h3 id="描述-153"><a class="header" href="#描述-153">描述</a></h3>
<p>当尝试访问数组中越界的元素时，Solidity 内部抛出的错误。</p>
<p>对于外部合约中的空数组，此方法将不起作用。对于这些情况，请使用不带任何参数的 <code>expectRevert</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="memoverflowerror"><a class="header" href="#memoverflowerror"><code>memOverflowError</code></a></h2>
<h3 id="签名-132"><a class="header" href="#签名-132">签名</a></h3>
<pre><code class="language-solidity">stdError.memOverflowError
</code></pre>
<h3 id="描述-154"><a class="header" href="#描述-154">描述</a></h3>
<p>当尝试分配一个包含超过 2^64-1 个项目的动态内存数组时，Solidity 的内部错误。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="zerovarerror"><a class="header" href="#zerovarerror"><code>zeroVarError</code></a></h2>
<h3 id="签名-133"><a class="header" href="#签名-133">签名</a></h3>
<pre><code class="language-solidity">stdError.zeroVarError
</code></pre>
<h3 id="描述-155"><a class="header" href="#描述-155">描述</a></h3>
<p>当尝试通过未初始化的函数指针调用函数时，Solidity 内部抛出的错误。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="std-storage-1"><a class="header" href="#std-storage-1">Std Storage</a></h2>
<p>Std Storage 是一个使操作存储变得简单的库。</p>
<p>要在测试合约中使用 Std Storage，请导入以下内容：</p>
<pre><code class="language-solidity">import {stdStorage, StdStorage} from "forge-std/Test.sol";              
</code></pre>
<p>在测试合约中添加以下行：</p>
<pre><code class="language-solidity">using stdStorage for StdStorage;
</code></pre>
<p>然后，通过 <code>stdstore</code> 实例访问 Std Storage。</p>
<h3 id="函数"><a class="header" href="#函数">函数</a></h3>
<p>查询函数：</p>
<ul>
<li><a href="reference/forge-std/./target.html"><code>target</code></a>: 设置目标合约的地址</li>
<li><a href="reference/forge-std/./sig.html"><code>sig</code></a>: 设置要静态调用的函数的 4 字节选择器</li>
<li><a href="reference/forge-std/./with_key.html"><code>with_key</code></a>: 传递函数的参数（可以多次使用）</li>
<li><a href="reference/forge-std/./depth.html"><code>depth</code></a>: 设置值在 <code>tuple</code> 中的位置（例如在 <code>struct</code> 内部）</li>
</ul>
<p>终止函数：</p>
<ul>
<li><a href="reference/forge-std/./find.html"><code>find</code></a>: 返回槽号</li>
<li><a href="reference/forge-std/./checked_write.html"><code>checked_write</code></a>: 设置要写入存储槽的数据</li>
<li><a href="reference/forge-std/./read.html"><code>read_&lt;type&gt;</code></a>: 以 <code>&lt;type&gt;</code> 类型从存储槽读取值</li>
</ul>
<h3 id="示例-116"><a class="header" href="#示例-116">示例</a></h3>
<p><code>playerToCharacter</code> 跟踪玩家角色的信息。</p>
<pre><code class="language-solidity">// MetaRPG.sol

struct Character {
    string name;
    uint256 level;
}

mapping (address =&gt; Character) public playerToCharacter;
</code></pre>
<p>假设我们要将角色的等级设置为 120。</p>
<pre><code class="language-solidity">// MetaRPG.t.sol

stdstore
    .target(address(metaRpg))
    .sig("playerToCharacter(address)")
    .with_key(address(this))
    .depth(1)
    .checked_write(120);
</code></pre>
<h3 id="限制"><a class="header" href="#限制">限制</a></h3>
<ul>
<li>不支持访问打包槽</li>
</ul>
<h3 id="已知问题-1"><a class="header" href="#已知问题-1">已知问题</a></h3>
<ul>
<li>如果 <code>tuple</code> 包含短于 32 字节的类型，槽可能无法找到</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="target"><a class="header" href="#target"><code>target</code></a></h2>
<h3 id="签名-134"><a class="header" href="#签名-134">签名</a></h3>
<pre><code class="language-solidity">function target(StdStorage storage self, address _target) internal returns (StdStorage storage);
</code></pre>
<h3 id="描述-156"><a class="header" href="#描述-156">描述</a></h3>
<p>设置合约的地址。</p>
<p>默认值：<code>address(0)</code></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="sig"><a class="header" href="#sig"><code>sig</code></a></h2>
<h3 id="签名-135"><a class="header" href="#签名-135">签名</a></h3>
<pre><code class="language-solidity">function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage);
</code></pre>
<pre><code class="language-solidity">function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage);
</code></pre>
<h3 id="描述-157"><a class="header" href="#描述-157">描述</a></h3>
<p>设置静态调用的函数 4 字节选择器。</p>
<p>默认值：<code>hex"00000000"</code></p>
<h3 id="示例-117"><a class="header" href="#示例-117">示例</a></h3>
<pre><code class="language-solidity">uint256 slot = stdstore
    .target(addr)
    .sig(addr.fun.selector)
    .with_key(1)
    .find();
</code></pre>
<pre><code class="language-solidity">uint256 slot = stdstore
    .target(addr)
    .sig("fun(uint256)")
    .with_key(1)
    .find();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="with_key"><a class="header" href="#with_key"><code>with_key</code></a></h2>
<h3 id="签名-136"><a class="header" href="#签名-136">签名</a></h3>
<pre><code class="language-solidity">function with_key(StdStorage storage self, address who) internal returns (StdStorage storage);
</code></pre>
<pre><code class="language-solidity">function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage);
</code></pre>
<pre><code class="language-solidity">function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage);
</code></pre>
<h3 id="描述-158"><a class="header" href="#描述-158">描述</a></h3>
<p>传递一个参数给函数。</p>
<p>可以多次使用以传递多个参数。顺序很重要。</p>
<h3 id="示例-118"><a class="header" href="#示例-118">示例</a></h3>
<pre><code class="language-solidity">uint256 slot = stdstore
    .target(addr)
    .sig("fun(uint256,address)")
    .with_key(1)
    .with_key(address(this))
    .find();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="depth-1"><a class="header" href="#depth-1"><code>depth</code></a></h2>
<h3 id="签名-137"><a class="header" href="#签名-137">签名</a></h3>
<pre><code class="language-solidity">function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage);
</code></pre>
<h3 id="描述-159"><a class="header" href="#描述-159">描述</a></h3>
<p>设置值在 <code>tuple</code>（例如在 <code>struct</code> 内部）中的位置。</p>
<p>默认值：<code>uint256(0)</code></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="checked_write"><a class="header" href="#checked_write"><code>checked_write</code></a></h2>
<h3 id="签名-138"><a class="header" href="#签名-138">签名</a></h3>
<pre><code class="language-solidity">function checked_write(StdStorage storage self, address who) internal;
</code></pre>
<pre><code class="language-solidity">function checked_write(StdStorage storage self, uint256 amt) internal;
</code></pre>
<pre><code class="language-solidity">function checked_write(StdStorage storage self, bool write) internal;
</code></pre>
<pre><code class="language-solidity">function checked_write(StdStorage storage self, bytes32 set) internal;
</code></pre>
<pre><code class="language-solidity">function checked_write_int(StdStorage storage self, int256 val) internal;
</code></pre>
<h3 id="描述-160"><a class="header" href="#描述-160">描述</a></h3>
<p>设置要写入存储槽的数据。</p>
<p>如果操作不成功，则回退并带有消息。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="find"><a class="header" href="#find"><code>find</code></a></h2>
<h3 id="签名-139"><a class="header" href="#签名-139">签名</a></h3>
<pre><code class="language-solidity">function find(StdStorage storage self) internal returns (uint256);
</code></pre>
<h3 id="描述-161"><a class="header" href="#描述-161">描述</a></h3>
<p>根据 <a href="reference/forge-std/../forge-std/target.html"><code>target</code></a>、<a href="reference/forge-std/../forge-std/sig.html"><code>sig</code></a>、<a href="reference/forge-std/../forge-std/with_key.html"><code>with_key</code></a>(s) 和 <a href="reference/forge-std/../forge-std/depth.html"><code>depth</code></a> 查找任意存储槽。</p>
<p>如果查找失败，则会回退并带有相应的消息。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="read"><a class="header" href="#read"><code>read</code></a></h2>
<h3 id="签名-140"><a class="header" href="#签名-140">签名</a></h3>
<pre><code class="language-solidity">function read_bytes32(StdStorage storage self) internal returns (bytes32);
</code></pre>
<pre><code class="language-solidity">function read_bool(StdStorage storage self) internal returns (bool);
</code></pre>
<pre><code class="language-solidity">function read_address(StdStorage storage self) internal returns (address);
</code></pre>
<pre><code class="language-solidity">function read_uint(StdStorage storage self) internal returns (uint256);
</code></pre>
<pre><code class="language-solidity">function read_int(StdStorage storage self) internal returns (int256);
</code></pre>
<h3 id="描述-162"><a class="header" href="#描述-162">描述</a></h3>
<p>从存储槽中读取值，类型为 <code>bytes32</code>、<code>bool</code>、<code>address</code>、<code>uint256</code> 或 <code>int256</code>。</p>
<p>如果读取失败，会抛出带有消息的错误。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="标准数学"><a class="header" href="#标准数学">标准数学</a></h2>
<ul>
<li><a href="reference/forge-std/./abs.html"><code>abs</code></a></li>
<li><a href="reference/forge-std/./delta.html"><code>delta</code></a></li>
<li><a href="reference/forge-std/./percentDelta.html"><code>percentDelta</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="abs"><a class="header" href="#abs"><code>abs</code></a></h2>
<h3 id="签名-141"><a class="header" href="#签名-141">签名</a></h3>
<pre><code class="language-solidity">function abs(int256 a) internal pure returns (uint256)
</code></pre>
<h3 id="描述-163"><a class="header" href="#描述-163">描述</a></h3>
<p>返回一个数字的绝对值。</p>
<h3 id="示例-119"><a class="header" href="#示例-119">示例</a></h3>
<pre><code class="language-solidity">uint256 ten = stdMath.abs(-10);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="delta"><a class="header" href="#delta"><code>delta</code></a></h2>
<h3 id="签名-142"><a class="header" href="#签名-142">签名</a></h3>
<pre><code class="language-solidity">function delta(uint256 a, uint256 b) internal pure returns (uint256)
</code></pre>
<pre><code class="language-solidity">function delta(int256 a, int256 b) internal pure returns (uint256)
</code></pre>
<h3 id="描述-164"><a class="header" href="#描述-164">描述</a></h3>
<p>返回两个数字之间的绝对值差。</p>
<h3 id="示例-120"><a class="header" href="#示例-120">示例</a></h3>
<pre><code class="language-solidity">uint256 four = stdMath.delta(-1, 3);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="percentdelta"><a class="header" href="#percentdelta"><code>percentDelta</code></a></h2>
<h3 id="签名-143"><a class="header" href="#签名-143">签名</a></h3>
<pre><code class="language-solidity">function percentDelta(uint256 a, uint256 b) internal pure returns (uint256)
</code></pre>
<pre><code class="language-solidity">function percentDelta(int256 a, int256 b) internal pure returns (uint256)
</code></pre>
<h3 id="描述-165"><a class="header" href="#描述-165">描述</a></h3>
<p>返回两个数字之间的百分比差异，其中 <code>1e18</code> 表示 100%。
更确切地说，<code>percentDelta(a, b)</code> 计算 <code>abs((a-b) / b) * 1e18</code>。</p>
<h3 id="示例-121"><a class="header" href="#示例-121">示例</a></h3>
<pre><code class="language-solidity">uint256 percent150 = stdMath.percentDelta(uint256(125), 50);
uint256 percent60 = stdMath.percentDelta(uint256(50), 125);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="脚本工具"><a class="header" href="#脚本工具">脚本工具</a></h2>
<ul>
<li><a href="reference/forge-std/./compute-create-address.html"><code>computeCreateAddress</code></a></li>
<li><a href="reference/forge-std/./derive-remember-key.html"><code>deriveRememberKey</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="computecreateaddress"><a class="header" href="#computecreateaddress"><code>computeCreateAddress</code></a></h2>
<h3 id="签名-144"><a class="header" href="#签名-144">签名</a></h3>
<pre><code class="language-solidity">function computeCreateAddress(address deployer, uint256 nonce) internal pure returns (address)
</code></pre>
<h3 id="描述-166"><a class="header" href="#描述-166">描述</a></h3>
<p>计算给定部署者地址和随机数的合约部署地址。这对于预先计算合约将部署的地址非常有用。</p>
<h3 id="示例-122"><a class="header" href="#示例-122">示例</a></h3>
<pre><code class="language-solidity">address governanceAddress = computeCreateAddress(0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266, 1);

// 这个合约需要一个尚未部署的治理合约
Contract contract = new Contract(governanceAddress);
// 现在我们部署它
Governance governance = new Governance(contract);

// 假设 `contract` 有一个 `governance()` 访问器
assertEq(governanceAddress, address(governance)); // [PASS]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="deriverememberkey"><a class="header" href="#deriverememberkey"><code>deriveRememberKey</code></a></h2>
<h3 id="签名-145"><a class="header" href="#签名-145">签名</a></h3>
<pre><code class="language-solidity">function deriveRememberKey(string memory mnemonic, uint32 index) internal returns (address who, uint256 privateKey)
</code></pre>
<h3 id="描述-167"><a class="header" href="#描述-167">描述</a></h3>
<p>从助记词派生一个私钥，并将其存储在 forge 的本地钱包中。返回地址和私钥。</p>
<h3 id="示例-123"><a class="header" href="#示例-123">示例</a></h3>
<p>从测试助记词在路径 <code>m/44'/60'/0'/0/0</code> 中获取私钥和地址。使用它们来签名一些数据并开始广播交易：</p>
<pre><code class="language-solidity">string memory mnemonic = "test test test test test test test test test test test junk";

(address deployer, uint256 privateKey) = deriveRememberKey(mnemonic, 0);

bytes32 hash = keccak256("Signed by deployer");
(uint8 v, bytes32 r, bytes32 s) = vm.sign(privateKey, hash);

vm.startBroadcast(deployer);
...
vm.stopBroadcast();
</code></pre>
<p>从测试助记词在路径 <code>m/44'/60'/0'/0/0</code> 中获取地址以开始广播交易：</p>
<pre><code class="language-solidity">string memory mnemonic = "test test test test test test test test test test test junk";

(address deployer, ) = deriveRememberKey(mnemonic, 0);

vm.startBroadcast(deployer);
...
vm.stopBroadcast();
</code></pre>
<h3 id="另请参阅-45"><a class="header" href="#另请参阅-45">另请参阅</a></h3>
<p>作弊码：</p>
<ul>
<li><a href="reference/forge-std/../../cheatcodes/derive-key.html">deriveKey</a></li>
<li><a href="reference/forge-std/../../cheatcodes/remember-key.html">rememberKey</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="控制台日志"><a class="header" href="#控制台日志">控制台日志</a></h2>
<ul>
<li>类似于 Hardhat 的控制台函数。</li>
<li>您可以在调用和交易中使用它。它适用于视图函数，但不适用于纯函数。</li>
<li>无论调用或交易是失败还是成功，它总是有效。</li>
<li>要使用它，您需要导入它：
<ul>
<li><code>import "forge-std/console.sol";</code></li>
</ul>
</li>
<li>您可以调用 console.log 最多带 4 个参数，参数可以是以下任意类型：
<ul>
<li><code>uint</code></li>
<li><code>string</code></li>
<li><code>bool</code></li>
<li><code>address</code></li>
</ul>
</li>
<li>还有针对上述类型以及 bytes, bytes1… 到 bytes32 的单参数 API：
<ul>
<li><code>console.logInt(int i)</code></li>
<li><code>console.logUint(uint i)</code></li>
<li><code>console.logString(string memory s)</code></li>
<li><code>console.logBool(bool b)</code></li>
<li><code>console.logAddress(address a)</code></li>
<li><code>console.logBytes(bytes memory b)</code></li>
<li><code>console.logBytes1(bytes1 b)</code></li>
<li><code>console.logBytes2(bytes2 b)</code></li>
<li>…</li>
<li><code>console.logBytes32(bytes32 b)</code></li>
</ul>
</li>
<li>console.log 实现了与 Hardhat 的 console.log 相同的格式化选项。
<ul>
<li>示例：<code>console.log("Changing owner from %s to %s", currentOwner, newOwner)</code></li>
</ul>
</li>
<li>console.log 是用标准 Solidity 实现的，并且兼容 Anvil 和 Hardhat 网络。</li>
<li>console.log 调用可以在其他网络中运行，如主网、kovan、ropsten 等。在这些网络中，它们什么都不做，但会花费极少的 gas。</li>
</ul>
<h3 id="consolelogformatargs"><a class="header" href="#consolelogformatargs"><code>console.log(format[,...args])</code></a></h3>
<p><code>console.log()</code> 方法使用第一个参数作为类似 printf 的格式字符串，该字符串可以包含零个或多个格式说明符。每个说明符被相应的参数转换后的值替换。支持的说明符有：</p>
<ul>
<li><code>%s</code>：字符串将用于将所有值转换为人类可读的字符串。<code>uint256</code>、<code>int256</code> 和 <code>bytes</code> 值被转换为其 <code>0x</code> 十六进制编码值。</li>
<li><code>%d</code>：数字将用于将所有值转换为人类可读的字符串。这与 <code>%s</code> 相同。</li>
<li><code>%i</code>：与 <code>%d</code> 工作方式相同。</li>
<li><code>%e</code>：数字的指数表示。适用于 <code>uint256</code> 和 <code>int256</code> 类型。</li>
<li><code>%x</code>：数字的十六进制表示。适用于 <code>uint256</code> 和 <code>int256</code> 类型。</li>
<li><code>%o</code>：对象。具有通用 JavaScript 风格对象格式的对象字符串表示。对于 solidity 类型，这基本上将值的字符串表示用单引号括起来。</li>
<li><code>%%</code>：单个百分号（‘%’）。这不消耗参数。</li>
<li>返回：<code>&lt;string&gt;</code> 格式化后的字符串</li>
</ul>
<p>如果说明符没有对应的参数，则不会被替换：</p>
<pre><code class="language-solidity">console.log("%s:%s", "foo");
// 返回："foo:%s"
</code></pre>
<p>不属于格式字符串的值使用其人类可读的字符串表示进行格式化。</p>
<p>如果传递给 console.log() 方法的参数数量多于说明符数量，额外的参数将按空格分隔连接到返回的字符串中：</p>
<pre><code class="language-solidity">console.log("%s:%s", "foo", "bar", "baz");
// 返回："foo:bar baz"
</code></pre>
<p>如果只传递一个参数给 console.log()，则它将按原样返回，不进行任何格式化：</p>
<pre><code class="language-solidity">console.log("%% %s");
// 返回："%% %s"
</code></pre>
<p>字符串格式说明符（<code>%s</code>）在大多数情况下应使用，除非需要其他格式说明符的特定功能。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="dstest-参考"><a class="header" href="#dstest-参考">DSTest 参考</a></h2>
<p>Dappsys Test（简称 DSTest）提供了基本的日志记录和断言功能。它包含在 Forge 标准库中。</p>
<p>要访问这些功能，请导入 <code>forge-std/Test.sol</code> 并在你的测试合约中继承 <code>Test</code>：</p>
<pre><code class="language-solidity">import "forge-std/Test.sol";

contract ContractTest is Test {
    // ... 测试 ...
}
</code></pre>
<h3 id="日志记录"><a class="header" href="#日志记录">日志记录</a></h3>
<p>以下是所有可用日志记录事件的完整概述。详细描述和示例用法请参见下文。</p>
<pre><code class="language-solidity">event log                    (string);
event logs                   (bytes);

event log_address            (address);
event log_bytes32            (bytes32);
event log_int                (int);
event log_uint               (uint);
event log_bytes              (bytes);
event log_string             (string);

event log_named_address      (string key, address val);
event log_named_bytes32      (string key, bytes32 val);
event log_named_decimal_int  (string key, int val, uint decimals);
event log_named_decimal_uint (string key, uint val, uint decimals);
event log_named_int          (string key, int val);
event log_named_uint         (string key, uint val);
event log_named_bytes        (string key, bytes val);
event log_named_string       (string key, string val);
</code></pre>
<h3 id="日志记录事件"><a class="header" href="#日志记录事件">日志记录事件</a></h3>
<p>本节记录所有日志记录事件并提供使用示例。</p>
<h4 id="log"><a class="header" href="#log"><code>log</code></a></h4>
<pre><code class="language-solidity">event log(string);
</code></pre>
<h5 id="示例-124"><a class="header" href="#示例-124">示例</a></h5>
<pre><code class="language-solidity">emit log("here");
// here
</code></pre>
<br>
<hr />
<h4 id="logs"><a class="header" href="#logs"><code>logs</code></a></h4>
<pre><code class="language-solidity">event logs(bytes);
</code></pre>
<h5 id="示例-125"><a class="header" href="#示例-125">示例</a></h5>
<pre><code class="language-solidity">emit logs(bytes("abcd"));
// 0x6162636400000000000000000000000000000000000000000000000000000000
</code></pre>
<br>
<hr />
<h4 id="log_type"><a class="header" href="#log_type"><code>log_&lt;type&gt;</code></a></h4>
<pre><code class="language-solidity">event log_&lt;type&gt;(&lt;type&gt;);
</code></pre>
<p>其中 <code>&lt;type&gt;</code> 可以是 <code>address</code>, <code>bytes32</code>, <code>int</code>, <code>uint</code>, <code>bytes</code>, <code>string</code></p>
<h5 id="示例-126"><a class="header" href="#示例-126">示例</a></h5>
<pre><code class="language-solidity">uint256 amount = 1 ether;
emit log_uint(amount);
// 1000000000000000000
</code></pre>
<br>
<hr />
<h4 id="log_named_type"><a class="header" href="#log_named_type"><code>log_named_&lt;type&gt;</code></a></h4>
<pre><code class="language-solidity">event log_named_&lt;type&gt;(string key, &lt;type&gt; val);
</code></pre>
<p>其中 <code>&lt;type&gt;</code> 可以是 <code>address</code>, <code>bytes32</code>, <code>int</code>, <code>uint</code>, <code>bytes</code>, <code>string</code></p>
<h5 id="示例-127"><a class="header" href="#示例-127">示例</a></h5>
<pre><code class="language-solidity">uint256 amount = 1 ether;
emit log_named_uint("Amount", amount);
// amount: 1000000000000000000
</code></pre>
<br>
<hr />
<h4 id="log_named_decimal_type"><a class="header" href="#log_named_decimal_type"><code>log_named_decimal_&lt;type&gt;</code></a></h4>
<pre><code class="language-solidity">event log_named_decimal_&lt;type&gt;(string key, &lt;type&gt; val, uint decimals);
</code></pre>
<p>其中 <code>&lt;type&gt;</code> 可以是 <code>int</code>, <code>uint</code></p>
<h5 id="示例-128"><a class="header" href="#示例-128">示例</a></h5>
<pre><code class="language-solidity">uint256 amount = 1 ether;
emit log_named_decimal_uint("Amount", amount, 18);
// amount: 1.000000000000000000
</code></pre>
<h3 id="断言-1"><a class="header" href="#断言-1">断言</a></h3>
<p>以下是所有可用断言函数的完整概述。详细描述和示例用法请参见下文。</p>
<pre><code class="language-solidity">// 断言 `condition` 为真
function assertTrue(bool condition) internal;
function assertTrue(bool condition, string memory err) internal;

// 断言 `a` 等于 `b`
function assertEq(address a, address b) internal;
function assertEq(address a, address b, string memory err) internal;
function assertEq(bytes32 a, bytes32 b) internal;
function assertEq(bytes32 a, bytes32 b, string memory err) internal;
function assertEq(int a, int b) internal;
function assertEq(int a, int b, string memory err) internal;
function assertEq(uint a, uint b) internal;
function assertEq(uint a, uint b, string memory err) internal;
function assertEqDecimal(int a, int b, uint decimals) internal;
function assertEqDecimal(int a, int b, uint decimals, string memory err) internal;
function assertEqDecimal(uint a, uint b, uint decimals) internal;
function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal;
function assertEq(string memory a, string memory b) internal;
function assertEq(string memory a, string memory b, string memory err) internal;
function assertEq32(bytes32 a, bytes32 b) internal;
function assertEq32(bytes32 a, bytes32 b, string memory err) internal;
function assertEq0(bytes memory a, bytes memory b) internal;
function assertEq0(bytes memory a, bytes memory b, string memory err) internal;

// 断言 `a` 大于 `b`
function assertGt(uint a, uint b) internal;
function assertGt(uint a, uint b, string memory err) internal;
function assertGt(int a, int b) internal;
function assertGt(int a, int b, string memory err) internal;
function assertGtDecimal(int a, int b, uint decimals) internal;
function assertGtDecimal(int a, int b, uint decimals, string memory err) internal;
function assertGtDecimal(uint a, uint b, uint decimals) internal;
function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal;

// 断言 `a` 大于或等于 `b`
function assertGe(uint a, uint b) internal;
function assertGe(uint a, uint b, string memory err) internal;
function assertGe(int a, int b) internal;
function assertGe(int a, int b, string memory err) internal;
function assertGeDecimal(int a, int b, uint decimals) internal;
function assertGeDecimal(int a, int b, uint decimals, string memory err) internal;
function assertGeDecimal(uint a, uint b, uint decimals) internal;
function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal;

// 断言 `a` 小于 `b`
function assertLt(uint a, uint b) internal;
function assertLt(uint a, uint b, string memory err) internal;
function assertLt(int a, int b) internal;
function assertLt(int a, int b, string memory err) internal;
function assertLtDecimal(int a, int b, uint decimals) internal;
function assertLtDecimal(int a, int b, uint decimals, string memory err) internal;
function assertLtDecimal(uint a, uint b, uint decimals) internal;
function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal;

// 断言 `a` 小于或等于 `b`
function assertLe(uint a, uint b) internal;
function assertLe(uint a, uint b, string memory err) internal;
function assertLe(int a, int b) internal;
function assertLe(int a, int b, string memory err) internal;
function assertLeDecimal(int a, int b, uint decimals) internal;
function assertLeDecimal(int a, int b, uint decimals, string memory err) internal;
function assertLeDecimal(uint a, uint b, uint decimals) internal;
function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal;

// 断言 `a` 近似等于 `b`，绝对值误差为 `maxDelta`
function assertApproxEqAbs(uint256 a, uint256 b, uint256 maxDelta) internal;
function assertApproxEqAbs(uint256 a, uint256 b, uint256 maxDelta, string memory err) internal;

// 断言 `a` 近似等于 `b`，百分比误差为 `maxPercentDelta`，其中 `1e18` 为 100%
function assertApproxEqRel(uint256 a, uint256 b, uint256 maxPercentDelta) internal;
function assertApproxEqRel(uint256 a, uint256 b, uint256 maxPercentDelta, string memory err) internal;
</code></pre>
<h3 id="断言函数"><a class="header" href="#断言函数">断言函数</a></h3>
<p>本节记录所有断言函数并提供使用示例。</p>
<h4 id="asserttrue-1"><a class="header" href="#asserttrue-1"><code>assertTrue</code></a></h4>
<pre><code class="language-solidity">function assertTrue(bool condition) internal;
</code></pre>
<p>断言 <code>condition</code> 为真。</p>
<h5 id="示例-129"><a class="header" href="#示例-129">示例</a></h5>
<pre><code class="language-solidity">bool success = contract.fun();
assertTrue(success);
</code></pre>
<br>
<hr />
<h4 id="asserteq-1"><a class="header" href="#asserteq-1"><code>assertEq</code></a></h4>
<pre><code class="language-solidity">function assertEq(&lt;type&gt; a, &lt;type&gt; b) internal;
</code></pre>
<p>其中 <code>&lt;type&gt;</code> 可以是 <code>address</code>, <code>bytes32</code>, <code>int</code>, <code>uint</code></p>
<p>断言 <code>a</code> 等于 <code>b</code>。</p>
<h5 id="示例-130"><a class="header" href="#示例-130">示例</a></h5>
<pre><code class="language-solidity">uint256 a = 1 ether;
uint256 b = 1e18 wei;
assertEq(a, b);
</code></pre>
<br>
<hr />
<h4 id="asserteqdecimal-1"><a class="header" href="#asserteqdecimal-1"><code>assertEqDecimal</code></a></h4>
<pre><code class="language-solidity">function assertEqDecimal(&lt;type&gt; a, &lt;type&gt; b, uint decimals) internal;
</code></pre>
<p>其中 <code>&lt;type&gt;</code> 可以是 <code>int</code>, <code>uint</code></p>
<p>断言 <code>a</code> 等于 <code>b</code>。</p>
<h5 id="示例-131"><a class="header" href="#示例-131">示例</a></h5>
<pre><code class="language-solidity">uint256 a = 1 ether;
uint256 b = 1e18 wei;
assertEqDecimal(a, b, 18);
</code></pre>
<br>
<hr />
<h4 id="asserteq32"><a class="header" href="#asserteq32"><code>assertEq32</code></a></h4>
<pre><code class="language-solidity">function assertEq32(bytes32 a, bytes32 b) internal;
</code></pre>
<p>断言 <code>a</code> 等于 <code>b</code>。</p>
<h5 id="示例-132"><a class="header" href="#示例-132">示例</a></h5>
<pre><code class="language-solidity">assertEq(bytes32("abcd"), 0x6162636400000000000000000000000000000000000000000000000000000000);
</code></pre>
<br>
<hr />
<h4 id="asserteq0"><a class="header" href="#asserteq0"><code>assertEq0</code></a></h4>
<pre><code class="language-solidity">function assertEq0(bytes a, bytes b) internal;
</code></pre>
<p>断言 <code>a</code> 等于 <code>b</code>。</p>
<h5 id="示例-133"><a class="header" href="#示例-133">示例</a></h5>
<pre><code class="language-solidity">string memory name1 = "Alice";
string memory name2 = "Bob";
assertEq0(bytes(name1), bytes(name2)); // [FAIL]
</code></pre>
<br>
<hr />
<h4 id="assertgt-1"><a class="header" href="#assertgt-1"><code>assertGt</code></a></h4>
<pre><code class="language-solidity">function assertGt(&lt;type&gt; a, &lt;type&gt; b) internal;
</code></pre>
<p>其中 <code>&lt;type&gt;</code> 可以是 <code>int</code>, <code>uint</code></p>
<p>断言 <code>a</code> 大于 <code>b</code>。</p>
<h5 id="示例-134"><a class="header" href="#示例-134">示例</a></h5>
<pre><code class="language-solidity">uint256 a = 2 ether;
uint256 b = 1e18 wei;
assertGt(a, b);
</code></pre>
<br>
<hr />
<h4 id="assertgtdecimal-1"><a class="header" href="#assertgtdecimal-1"><code>assertGtDecimal</code></a></h4>
<pre><code class="language-solidity">function assertGtDecimal(&lt;type&gt; a, &lt;type&gt; b, uint decimals) internal;
</code></pre>
<p>其中 <code>&lt;type&gt;</code> 可以是 <code>int</code>, <code>uint</code></p>
<p>断言 <code>a</code> 大于 <code>b</code>。</p>
<h5 id="示例-135"><a class="header" href="#示例-135">示例</a></h5>
<pre><code class="language-solidity">uint256 a = 2 ether;
uint256 b = 1e18 wei;
assertGtDecimal(a, b, 18);
</code></pre>
<br>
<hr />
<h4 id="assertge-1"><a class="header" href="#assertge-1"><code>assertGe</code></a></h4>
<pre><code class="language-solidity">function assertGe(&lt;type&gt; a, &lt;type&gt; b) internal;
</code></pre>
<p>其中 <code>&lt;type&gt;</code> 可以是 <code>int</code>, <code>uint</code></p>
<p>断言 <code>a</code> 大于或等于 <code>b</code>。</p>
<h5 id="示例-136"><a class="header" href="#示例-136">示例</a></h5>
<pre><code class="language-solidity">uint256 a = 1 ether;
uint256 b = 1e18 wei;
assertGe(a, b);
</code></pre>
<br>
<hr />
<h4 id="assertgedecimal-1"><a class="header" href="#assertgedecimal-1"><code>assertGeDecimal</code></a></h4>
<pre><code class="language-solidity">function assertGeDecimal(&lt;type&gt; a, &lt;type&gt; b, uint decimals) internal;
</code></pre>
<p>其中 <code>&lt;type&gt;</code> 可以是 <code>int</code>, <code>uint</code></p>
<p>断言 <code>a</code> 大于或等于 <code>b</code>。</p>
<h5 id="示例-137"><a class="header" href="#示例-137">示例</a></h5>
<pre><code class="language-solidity">uint256 a = 1 ether;
uint256 b = 1e18 wei;
assertGeDecimal(a, b, 18);
</code></pre>
<br>
<hr />
<h4 id="assertlt-1"><a class="header" href="#assertlt-1"><code>assertLt</code></a></h4>
<pre><code class="language-solidity">function assertLt(&lt;type&gt; a, &lt;type&gt; b) internal;
</code></pre>
<p>其中 <code>&lt;type&gt;</code> 可以是 <code>int</code>, <code>uint</code></p>
<p>断言 <code>a</code> 小于 <code>b</code>。</p>
<h5 id="示例-138"><a class="header" href="#示例-138">示例</a></h5>
<pre><code class="language-solidity">uint256 a = 1 ether;
uint256 b = 2e18 wei;
assertLt(a, b);
</code></pre>
<br>
<hr />
<h4 id="assertltdecimal-1"><a class="header" href="#assertltdecimal-1"><code>assertLtDecimal</code></a></h4>
<pre><code class="language-solidity">function assertLtDecimal(&lt;type&gt; a, &lt;type&gt; b, uint decimals) internal;
</code></pre>
<p>其中 <code>&lt;type&gt;</code> 可以是 <code>int</code>, <code>uint</code></p>
<p>断言 <code>a</code> 小于 <code>b</code>。</p>
<h5 id="示例-139"><a class="header" href="#示例-139">示例</a></h5>
<pre><code class="language-solidity">uint256 a = 1 ether;
uint256 b = 2e18 wei;
assertLtDecimal(a, b, 18);
</code></pre>
<br>
<hr />
<h4 id="assertle-1"><a class="header" href="#assertle-1"><code>assertLe</code></a></h4>
<pre><code class="language-solidity">function assertLe(&lt;type&gt; a, &lt;type&gt; b) internal;
</code></pre>
<p>其中 <code>&lt;type&gt;</code> 可以是 <code>int</code>, <code>uint</code></p>
<p>断言 <code>a</code> 小于或等于 <code>b</code>。</p>
<h5 id="示例-140"><a class="header" href="#示例-140">示例</a></h5>
<pre><code class="language-solidity">uint256 a = 1 ether;
uint256 b = 1e18 wei;
assertLe(a, b);
</code></pre>
<br>
<hr />
<h4 id="assertledecimal-1"><a class="header" href="#assertledecimal-1"><code>assertLeDecimal</code></a></h4>
<pre><code class="language-solidity">function assertLeDecimal(&lt;type&gt; a, &lt;type&gt; b, uint decimals) internal;
</code></pre>
<p>其中 <code>&lt;type&gt;</code> 可以是 <code>int</code>, <code>uint</code></p>
<p>断言 <code>a</code> 小于或等于 <code>b</code>。</p>
<h5 id="示例-141"><a class="header" href="#示例-141">示例</a></h5>
<pre><code class="language-solidity">uint256 a = 1 ether;
uint256 b = 1e18 wei;
assertLeDecimal(a, b, 18);
</code></pre>
<br>
<hr />
<h4 id="assertapproxeqabs-1"><a class="header" href="#assertapproxeqabs-1"><code>assertApproxEqAbs</code></a></h4>
<pre><code class="language-solidity">function assertApproxEqAbs(&lt;type&gt; a, &lt;type&gt; b, uint256 maxDelta) internal;
</code></pre>
<p>其中 <code>&lt;type&gt;</code> 可以是 <code>int</code>, <code>uint</code></p>
<p>断言 <code>a</code> 近似等于 <code>b</code>，绝对值误差为 <code>maxDelta</code>。</p>
<h5 id="示例-142"><a class="header" href="#示例-142">示例</a></h5>
<pre><code class="language-solidity">function testFail () external {
    uint256 a = 100;
    uint256 b = 200;

    assertApproxEqAbs(a, b, 90);
}
</code></pre>
<br>
<hr />
<h4 id="assertapproxeqrel-1"><a class="header" href="#assertapproxeqrel-1"><code>assertApproxEqRel</code></a></h4>
<pre><code class="language-solidity">function assertApproxEqRel(&lt;type&gt; a, &lt;type&gt; b, uint256 maxPercentDelta) internal;
</code></pre>
<p>其中 <code>&lt;type&gt;</code> 可以是 <code>int</code>, <code>uint</code></p>
<p>断言 <code>a</code> 近似等于 <code>b</code>，百分比误差为 <code>maxPercentDelta</code>，其中 <code>1e18</code> 为 100%。</p>
<h5 id="示例-143"><a class="header" href="#示例-143">示例</a></h5>
<pre><code class="language-solidity">function testFail () external {
    uint256 a = 100;
    uint256 b = 200;
    assertApproxEqRel(a, b, 0.4e18);
}
</code></pre>
<br>
<blockquote>
<p>ℹ️ <strong>信息</strong></p>
<p>你可以通过提供额外的参数 <code>string err</code> 为上述函数传递自定义错误消息。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="杂项"><a class="header" href="#杂项">杂项</a></h2>
<ul>
<li><a href="misc/./struct-encoding.html">结构体编码</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="结构体编码"><a class="header" href="#结构体编码">结构体编码</a></h2>
<p>结构体是用户定义的类型，可以组合多个变量：</p>
<pre><code class="language-solidity">struct MyStruct {
    address addr;
    uint256 amount;
}
</code></pre>
<p>只有新的 <a href="https://docs.soliditylang.org/zh/latest/layout-of-source-files.html#abi-coder-pragma" title="" target="_blank">ABI 编码器 v2</a> 才能编码和解码任意嵌套的数组和结构体。自 Solidity 0.8.0 起，它默认激活，在此之前需要通过 <code>pragma experimental ABIEncoderV2</code> 激活。</p>
<p>Solidity 结构体映射到 ABI 类型 “tuple”。有关 Solidity 类型如何映射到 ABI 类型的更多信息，请参阅 Solidity 文档中的 <a href="https://docs.soliditylang.org/zh/latest/abi-spec.html#mapping-solidity-to-abi-types" title="" target="_blank">Mapping Solidity to ABI types</a>。</p>
<p>因此，结构体作为元组进行编码和解码。所以我们定义的结构体 <code>MyStruct</code> 在 ABI 中映射为元组 <code>(address,uint256)</code>。</p>
<p>让我们看看这在合约中是如何工作的：</p>
<pre><code class="language-solidity">pragma solidity =0.8.15;

contract Test {
    struct MyStruct {
        address addr;
        uint256 amount;
    }
    function f(MyStruct memory t) public pure {}
}
</code></pre>
<p>该合约中函数 <code>f</code> 的 ABI 是：</p>
<pre><code class="language-json">{
	"inputs": [
		{
			"components": [
				{
					"internalType": "address",
					"name": "addr",
					"type": "address"
				},
				{
					"internalType": "uint256",
					"name": "amount",
					"type": "uint256"
				}
			],
			"internalType": "struct Test.MyStruct",
			"name": "t",
			"type": "tuple"
		}
	],
	"name": "f",
	"outputs": [],
	"stateMutability": "pure",
	"type": "function"
}
</code></pre>
<p>这表示：函数 <code>f</code> 接受一个类型为 <code>tuple</code> 的输入，包含两个类型分别为 <code>address</code> 和 <code>uint256</code> 的组件。</p>
<p><strong>嵌套结构体编码：</strong>
以下是一个更复杂的嵌套结构体示例：</p>
<pre><code class="language-solidity">pragma solidity 0.8.21;

contract Test {
    struct nestedStruct {
        address addr;
        uint256 amount;
    }

    struct MyStruct {
        string nestedStructName;
        uint256 nestedStructCount;
        nestedStruct _nestedStruct;
    }

    function f(MyStruct memory t) public pure {}
}
</code></pre>
<p>该合约中函数 <code>f</code> 的 ABI 是：</p>
<pre><code class="language-json">{
    "inputs": [
        {
            "name": "t",
            "type": "tuple",
            "internalType": "struct Test.MyStruct",
            "components": [
                {
                    "name": "nestedStructName",
                    "type": "string",
                    "internalType": "string"
                },
                {
                    "name": "nestedStructCount",
                    "type": "uint256",
                    "internalType": "uint256"
                },
                {
                    "name": "_nestedStruct",
                    "type": "tuple",
                    "internalType": "struct Test.nestedStruct",
                    "components": [
                        {
                            "name": "addr",
                            "type": "address",
                            "internalType": "address"
                        },
                        {
                            "name": "amount",
                            "type": "uint256",
                            "internalType": "uint256"
                        }
                    ]
                }
            ]
        }
    ],
    "name": "f",
    "outputs": [],
    "stateMutability": "pure",
    "type": "function"
}
</code></pre>
<p>这表示：函数 <code>f</code> 接受一个类型为元组的输入，包含三个组件：一个字符串、一个 uint256 和一个表示嵌套结构体的元组，该元组包含类型为 address 的 addr 和类型为 uint256 的 amount。</p>
<p>要编码 <code>MyStruct</code> 并将其作为参数传递给函数 <code>f</code>：</p>
<pre><code class="language-bash">cast abi-encode "f((string,uint256,(address,uint256)))" "(example,1,(0x...,1))"
</code></pre>
<p>要部署一个接受 <code>MyStruct</code> 作为参数的合约：</p>
<pre><code class="language-bash">forge create src/Test.sol:Test --constructor-args "(example,1,(0x...,1))"
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="src/static/solidity.min.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
